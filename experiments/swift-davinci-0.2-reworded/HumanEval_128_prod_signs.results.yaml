language: swift
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let sum = arr.map { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n\
    \            prod *= 1\n        } else if num < 0 {\n            prod *= -1\n\
    \        } else {\n            prod *= 0\n        }\n        sum += abs(num)\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpv2a8g4vh/tmpv2a8g4vh.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84e08acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84e05a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84e05a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84e05a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv2a8g4vh                        0x000055d0e18b4815 <unavailable> + 6165

    5    libc.so.6                          0x00002b84e0a98460 __libc_start_main +
    245

    6    tmpv2a8g4vh                        0x000055d0e18b4219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num < 0 {\n         \
    \   prod *= -1\n        } else if num > 0 {\n            prod *= 1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjp8b7ms7/tmpjp8b7ms7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad12209dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad121d94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad121d94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad121d937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjp8b7ms7                        0x00005616e09b88a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ad122289460 __libc_start_main +
    245

    6    tmpjp8b7ms7                        0x00005616e09b82a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjp8b7ms7/tmpjp8b7ms7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad12209dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad121d94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad121d94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad121d937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjp8b7ms7                        0x00005616e09b88a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ad122289460 __libc_start_main +
    245

    6    tmpjp8b7ms7                        0x00005616e09b82a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let prod = signs.reduce(1,\
    \ *)\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcgvfe9s6/tmpcgvfe9s6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12953bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12950b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12950b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12950b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgvfe9s6                        0x0000563c9a4738a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b12955a7460 __libc_start_main +
    245

    6    tmpcgvfe9s6                        0x0000563c9a4732a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += abs(num)\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n\
    \            prod *= 1\n        } else if num < 0 {\n            prod *= -1\n\
    \        } else {\n            prod *= 0\n        }\n        sum += abs(num)\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n \
    \           sum += i\n            prod *= 1\n        } else if i < 0 {\n     \
    \       sum += abs(i)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpn12dpp_v/tmpn12dpp_v.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6427375c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b642706cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b642706c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b642706b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn12dpp_v                        0x00005637432c5815 <unavailable> + 6165

    5    libc.so.6                          0x00002b6427561460 __libc_start_main +
    245

    6    tmpn12dpp_v                        0x00005637432c5219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let prod = sign.reduce(1, *)\n\
    \    let sum = arr.map { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num == 0 {\n         \
    \   continue\n        }\n        sum += abs(num)\n        prod *= num > 0 ? 1\
    \ : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpub08mwoz/tmpub08mwoz.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f1f5c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f1f2c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f1f2c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f1f2bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpub08mwoz                        0x0000562dc4fe4815 <unavailable> + 6165

    5    libc.so.6                          0x00002b4f1f7b5460 __libc_start_main +
    245

    6    tmpub08mwoz                        0x0000562dc4fe4219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for n in arr {\n        if n > 0 {\n            prod\
    \ *= 1\n        } else if n < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(n)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes\
    \ = arr.map { abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n     \
    \   if num != 0 {\n            prod *= num / abs(num)\n        }\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpq4evu4ej/tmpq4evu4ej.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae297d1cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae297a13b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae297a13988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae297a127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq4evu4ej                        0x0000561a0569e8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ae297f08460 __libc_start_main +
    245

    6    tmpq4evu4ej                        0x0000561a0569e2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp06hip5bh/tmp06hip5bh.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafcc05ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafcbd51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafcbd51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafcbd507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06hip5bh                        0x000056133fe9b815 <unavailable> + 6165

    5    libc.so.6                          0x00002aafcc246460 __libc_start_main +
    245

    6    tmp06hip5bh                        0x000056133fe9b219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n\
    \        prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb9msdtuq/tmpb9msdtuq.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6aefedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6aefbd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6aefbd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6aefbd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9msdtuq                        0x000055db4f0c28a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b6af00cb460 __libc_start_main +
    245

    6    tmpb9msdtuq                        0x000055db4f0c22a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let sum = arr.map { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        if\
    \ i != 0 {\n            prod *= i > 0 ? 1 : -1\n        }\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5sind56s/tmp5sind56s.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba623c9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba623996b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba623996988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6239957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5sind56s                        0x0000558dfd2b9815 <unavailable> + 6165

    5    libc.so.6                          0x00002ba623e8b460 __libc_start_main +
    245

    6    tmp5sind56s                        0x0000558dfd2b9219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += abs(num)\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpewn89o7k/tmpewn89o7k.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a6c3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a6c0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a6c0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a6c0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewn89o7k                        0x000055ebe4fdd8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b2a6c5c9460 __libc_start_main +
    245

    6    tmpewn89o7k                        0x000055ebe4fdd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num < 0 {\n          \
    \  prod *= -1\n        } else if num > 0 {\n            prod *= 1\n        } else\
    \ {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let product = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return product * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n        } else if num < 0 {\n            prod *= -1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n\
    \        if i != 0 {\n            prod *= i / abs(i)\n        }\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp6y2i83ub/tmp6y2i83ub.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b532a2a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5329f9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5329f9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5329f9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6y2i83ub                        0x0000562f6565b8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b532a491460 __libc_start_main +
    245

    6    tmp6y2i83ub                        0x0000562f6565b2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let signProduct = signs.reduce(1, *)\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i < 0 {\n            prod\
    \ *= -1\n        } else if i > 0 {\n            prod *= 1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let product = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return product * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += -num\n        } else {\n            prod *=\
    \ 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += -num\n        } else {\n            prod *=\
    \ 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n\
    \        prod *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp29nknrvk/tmp29nknrvk.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af459576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af45926db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af45926d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af45926c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29nknrvk                        0x000055fb9d1758a5 <unavailable> + 6309

    5    libc.so.6                          0x00002af459762460 __libc_start_main +
    245

    6    tmp29nknrvk                        0x000055fb9d1752a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sign_prod\
    \ = signs.reduce(1, *)\n    let magnitudes = arr.map { abs($0) }\n    let sum_magnitudes\
    \ = magnitudes.reduce(0, +)\n    return sum_magnitudes * sign_prod\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += -num\n        } else {\n            prod *=\
    \ 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let signProduct = signs.reduce(1, *)\n    let magnitudeSum =\
    \ magnitudes.reduce(0, +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let prod\
    \ = arr.reduce(1) { $0 * $1.signum() }\n    let sum = arr.reduce(0) { $0 + abs($1)\
    \ }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i < 0 {\n            prod\
    \ *= -1\n        } else if i > 0 {\n            prod *= 1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num == 0 ? 1 : num\
    \ > 0 ? 1 : -1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp_gueubss/tmp_gueubss.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b458c28fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b458bf86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b458bf86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b458bf857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_gueubss                        0x000055c0b9c46815 <unavailable> + 6165

    5    libc.so.6                          0x00002b458c47b460 __libc_start_main +
    245

    6    tmp_gueubss                        0x000055c0b9c46219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += -num\n        } else {\n            prod *=\
    \ 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n\
    \        prod *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp29nknrvk/tmp29nknrvk.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af459576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af45926db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af45926d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af45926c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29nknrvk                        0x000055fb9d1758a5 <unavailable> + 6309

    5    libc.so.6                          0x00002af459762460 __libc_start_main +
    245

    6    tmp29nknrvk                        0x000055fb9d1752a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n     \
    \   prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpt6yduazs/tmpt6yduazs.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab51a8a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab51a598b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab51a598988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab51a5977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6yduazs                        0x000056014f66b8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab51aa8d460 __libc_start_main +
    245

    6    tmpt6yduazs                        0x000056014f66b2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n\
    \        if num != 0 {\n            prod *= num / abs(num)\n        }\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpj9895wsu/tmpj9895wsu.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa1cd2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa1ca25b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa1ca25988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa1ca247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj9895wsu                        0x000055d4e62f98a5 <unavailable> + 6309

    5    libc.so.6                          0x00002baa1cf1a460 __libc_start_main +
    245

    6    tmpj9895wsu                        0x000055d4e62f92a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += abs(num)\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpewn89o7k/tmpewn89o7k.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a6c3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a6c0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a6c0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a6c0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewn89o7k                        0x000055ebe4fdd8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b2a6c5c9460 __libc_start_main +
    245

    6    tmpewn89o7k                        0x000055ebe4fdd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n\
    \        if i != 0 {\n            prod *= i > 0 ? 1 : -1\n        }\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpa3_0p5o3/tmpa3_0p5o3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d0cbd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d0c8ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d0c8ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d0c8cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa3_0p5o3                        0x000055590fc17815 <unavailable> + 6165

    5    libc.so.6                          0x00002b3d0cdc3460 __libc_start_main +
    245

    6    tmpa3_0p5o3                        0x000055590fc17219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n\
    \            sum += num\n            prod *= 1\n        } else if num < 0 {\n\
    \            sum += abs(num)\n            prod *= -1\n        }\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmptqnzy9_i/tmptqnzy9_i.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b64ca62ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64ca321b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b64ca321988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b64ca3207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptqnzy9_i                        0x000056400af2c815 <unavailable> + 6165

    5    libc.so.6                          0x00002b64ca816460 __libc_start_main +
    245

    6    tmptqnzy9_i                        0x000056400af2c219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += -num\n        } else {\n            prod *=\
    \ 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign\
    \ = arr.reduce(1) { $0 * ($1 > 0 ? 1 : ($1 < 0 ? -1 : 0)) }\n    let sum = arr.reduce(0)\
    \ { $0 + abs($1) }\n    return sign * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0t7s2u_f/tmp0t7s2u_f.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbea092c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbe9d89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbe9d89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbe9d887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0t7s2u_f                        0x0000557326864649 <unavailable> + 5705

    5    libc.so.6                          0x00002adbea27e460 __libc_start_main +
    245

    6    tmp0t7s2u_f                        0x00005573268641d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n\
    \            prod *= 1\n        } else if num < 0 {\n            prod *= -1\n\
    \        } else {\n            prod *= 0\n        }\n        sum += abs(num)\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjp8b7ms7/tmpjp8b7ms7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad12209dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad121d94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad121d94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad121d937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjp8b7ms7                        0x00005616e09b88a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ad122289460 __libc_start_main +
    245

    6    tmpjp8b7ms7                        0x00005616e09b82a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign\
    \ = arr.reduce(1) { $0 * ($1 > 0 ? 1 : ($1 < 0 ? -1 : 0)) }\n    let mag = arr.reduce(0)\
    \ { $0 + abs($1) }\n    return sign * mag\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n\
    \        prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb9msdtuq/tmpb9msdtuq.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6aefedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6aefbd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6aefbd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6aefbd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9msdtuq                        0x000055db4f0c28a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b6af00cb460 __libc_start_main +
    245

    6    tmpb9msdtuq                        0x000055db4f0c22a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num > 0 ? 1 : (num\
    \ < 0 ? -1 : 0)\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n\
    \        prod *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp29nknrvk/tmp29nknrvk.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af459576c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af45926db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af45926d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af45926c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29nknrvk                        0x000055fb9d1758a5 <unavailable> + 6309

    5    libc.so.6                          0x00002af459762460 __libc_start_main +
    245

    6    tmp29nknrvk                        0x000055fb9d1752a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i < 0 {\n            prod\
    \ *= -1\n        } else if i > 0 {\n            prod *= 1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp06hip5bh/tmp06hip5bh.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafcc05ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafcbd51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafcbd51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafcbd507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06hip5bh                        0x000056133fe9b815 <unavailable> + 6165

    5    libc.so.6                          0x00002aafcc246460 __libc_start_main +
    245

    6    tmp06hip5bh                        0x000056133fe9b219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpn12dpp_v/tmpn12dpp_v.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6427375c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b642706cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b642706c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b642706b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn12dpp_v                        0x00005637432c5815 <unavailable> + 6165

    5    libc.so.6                          0x00002b6427561460 __libc_start_main +
    245

    6    tmpn12dpp_v                        0x00005637432c5219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for i in arr {\n        if i == 0 {\n\
    \            continue\n        }\n        prod *= i > 0 ? 1 : -1\n        sum\
    \ += abs(i)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmptdaq06yj/tmptdaq06yj.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf4f719c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf4f410b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf4f410988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf4f40f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptdaq06yj                        0x000055f677660815 <unavailable> + 6165

    5    libc.so.6                          0x00002aaf4f905460 __libc_start_main +
    245

    6    tmptdaq06yj                        0x000055f677660219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 >= 0 ? 1 : -1 }\n    let mags = arr.map { abs($0) }\n    return\
    \ signs.reduce(1, *) * mags.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpc7ijtlvb/tmpc7ijtlvb.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba970529c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba970220b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba970220988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba97021f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc7ijtlvb                        0x000056471067d7d5 <unavailable> + 6101

    5    libc.so.6                          0x00002ba970715460 __libc_start_main +
    245

    6    tmpc7ijtlvb                        0x000056471067d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcgvfe9s6/tmpcgvfe9s6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12953bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12950b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12950b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12950b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgvfe9s6                        0x0000563c9a4738a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b12955a7460 __libc_start_main +
    245

    6    tmpcgvfe9s6                        0x0000563c9a4732a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpewn89o7k/tmpewn89o7k.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a6c3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a6c0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a6c0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a6c0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewn89o7k                        0x000055ebe4fdd8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b2a6c5c9460 __libc_start_main +
    245

    6    tmpewn89o7k                        0x000055ebe4fdd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = sign.reduce(1, *)\n\
    \    let mag = arr.map { abs($0) }\n    let sum = mag.reduce(0, +)\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let sum = arr.map { abs($0) }.reduce(0, +)\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num < 0 {\n         \
    \   prod *= -1\n        } else if num > 0 {\n            prod *= 1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n     \
    \   prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpt6yduazs/tmpt6yduazs.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab51a8a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab51a598b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab51a598988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab51a5977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6yduazs                        0x000056014f66b8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab51aa8d460 __libc_start_main +
    245

    6    tmpt6yduazs                        0x000056014f66b2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for n in arr {\n        prod *= n < 0 ? -1 : n ==\
    \ 0 ? 0 : 1\n        sum += abs(n)\n    }\n    return prod * sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += -i\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += -num\n        } else {\n            prod *=\
    \ 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num == 0 { continue }\n\
    \        sum += abs(num)\n        prod *= num < 0 ? -1 : 1\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpm9su7h23/tmpm9su7h23.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed5279ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed52491b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed52491988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed524907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm9su7h23                        0x0000556c97513815 <unavailable> + 6165

    5    libc.so.6                          0x00002aed52986460 __libc_start_main +
    245

    6    tmpm9su7h23                        0x0000556c97513219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map\
    \ { $0 == 0 ? 0 : abs($0) }.reduce(1, *) * arr.filter { $0 != 0 }.reduce(1, *)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpo1suult3/tmpo1suult3.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3654c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3651bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3651bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3651bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo1suult3                        0x000056505bd4b709 <unavailable> + 5897

    5    libc.so.6                          0x00002ba3656b1460 __libc_start_main +
    245

    6    tmpo1suult3                        0x000056505bd4b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 >= 0 ? 1 : -1 }\n    let mags = arr.map { abs($0) }\n    let\
    \ prod = signs.reduce(1, *)\n    let sum = mags.reduce(0, +)\n    return prod\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpweyfp425/tmpweyfp425.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4835c5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4835952b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4835952988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48359517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpweyfp425                        0x000055585eb347d5 <unavailable> + 6101

    5    libc.so.6                          0x00002b4835e47460 __libc_start_main +
    245

    6    tmpweyfp425                        0x000055585eb341d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        prod *= i > 0 ? 1 : i < 0\
    \ ? -1 : 0\n        sum += abs(i)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpewn89o7k/tmpewn89o7k.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a6c3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a6c0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a6c0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a6c0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewn89o7k                        0x000055ebe4fdd8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b2a6c5c9460 __libc_start_main +
    245

    6    tmpewn89o7k                        0x000055ebe4fdd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += -num\n        } else {\n            prod *=\
    \ 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i == 0 {\n            continue\n\
    \        }\n        prod *= i > 0 ? 1 : -1\n        sum += abs(i)\n    }\n   \
    \ return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp7j4uygcs/tmp7j4uygcs.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b430fb53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b430f84ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b430f84a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b430f8497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7j4uygcs                        0x000055b7ea9e5815 <unavailable> + 6165

    5    libc.so.6                          0x00002b430fd3f460 __libc_start_main +
    245

    6    tmp7j4uygcs                        0x000055b7ea9e5219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += abs(num)\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num == 0 {\n        \
    \    continue\n        }\n        prod *= num > 0 ? 1 : -1\n        sum += abs(num)\n\
    \    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3k9e56si/tmp3k9e56si.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88fc348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88fc03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88fc03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88fc03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3k9e56si                        0x00005564a3ce9815 <unavailable> + 6165

    5    libc.so.6                          0x00002b88fc534460 __libc_start_main +
    245

    6    tmp3k9e56si                        0x00005564a3ce9219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num == 0 ? 1 : num\
    \ > 0 ? 1 : -1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp_gueubss/tmp_gueubss.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b458c28fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b458bf86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b458bf86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b458bf857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_gueubss                        0x000055c0b9c46815 <unavailable> + 6165

    5    libc.so.6                          0x00002b458c47b460 __libc_start_main +
    245

    6    tmp_gueubss                        0x000055c0b9c46219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0t7s2u_f/tmp0t7s2u_f.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbea092c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbe9d89b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbe9d89988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbe9d887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0t7s2u_f                        0x0000557326864649 <unavailable> + 5705

    5    libc.so.6                          0x00002adbea27e460 __libc_start_main +
    245

    6    tmp0t7s2u_f                        0x00005573268641d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += abs(num)\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpv2a8g4vh/tmpv2a8g4vh.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84e08acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84e05a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84e05a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84e05a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv2a8g4vh                        0x000055d0e18b4815 <unavailable> + 6165

    5    libc.so.6                          0x00002b84e0a98460 __libc_start_main +
    245

    6    tmpv2a8g4vh                        0x000055d0e18b4219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpvz11tykv/tmpvz11tykv.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b809187bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8091572b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8091572988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80915717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvz11tykv                        0x000055ee2a672649 <unavailable> + 5705

    5    libc.so.6                          0x00002b8091a67460 __libc_start_main +
    245

    6    tmpvz11tykv                        0x000055ee2a6721d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmphp5eqvjs/tmphp5eqvjs.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3a40c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3a3dbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae3a3dbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae3a3dbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphp5eqvjs                        0x000055733e4c3815 <unavailable> + 6165

    5    libc.so.6                          0x00002ae3a42b2460 __libc_start_main +
    245

    6    tmphp5eqvjs                        0x000055733e4c3219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcgvfe9s6/tmpcgvfe9s6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12953bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12950b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12950b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12950b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgvfe9s6                        0x0000563c9a4738a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b12955a7460 __libc_start_main +
    245

    6    tmpcgvfe9s6                        0x0000563c9a4732a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num == 0 {\n        \
    \    continue\n        }\n        prod *= num > 0 ? 1 : -1\n        sum += abs(num)\n\
    \    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3k9e56si/tmp3k9e56si.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88fc348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88fc03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88fc03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88fc03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3k9e56si                        0x00005564a3ce9815 <unavailable> + 6165

    5    libc.so.6                          0x00002b88fc534460 __libc_start_main +
    245

    6    tmp3k9e56si                        0x00005564a3ce9219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let sum = arr.reduce(0)\
    \ { $0 + abs($1) }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : ($0 > 0 ? 1 : 0) }\n    let sum = arr.reduce(0) {\
    \ $0 + abs($1) }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcgvfe9s6/tmpcgvfe9s6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12953bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12950b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12950b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12950b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgvfe9s6                        0x0000563c9a4738a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b12955a7460 __libc_start_main +
    245

    6    tmpcgvfe9s6                        0x0000563c9a4732a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n\
    \        prod *= i == 0 ? 1 : i < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcxh59if4/tmpcxh59if4.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3f1b8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3f1882b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3f1882988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3f18817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcxh59if4                        0x0000557335dcf815 <unavailable> + 6165

    5    libc.so.6                          0x00002ab3f1d77460 __libc_start_main +
    245

    6    tmpcxh59if4                        0x0000557335dcf219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i == 0 { continue }\n \
    \       prod *= i > 0 ? 1 : -1\n        sum += abs(i)\n    }\n    return prod\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjjuvhn4y/tmpjjuvhn4y.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f20de6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f20addb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f20add988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f20adc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjjuvhn4y                        0x0000564346f85815 <unavailable> + 6165

    5    libc.so.6                          0x00002b3f20fd2460 __libc_start_main +
    245

    6    tmpjjuvhn4y                        0x0000564346f85219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpnqjd9zer/tmpnqjd9zer.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba01fd65c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba01fa5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba01fa5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba01fa5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnqjd9zer                        0x0000560098aef815 <unavailable> + 6165

    5    libc.so.6                          0x00002ba01ff51460 __libc_start_main +
    245

    6    tmpnqjd9zer                        0x0000560098aef219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var product = 1\n    for num in arr {\n        if num > 0 {\n       \
    \     sum += num\n            product *= 1\n        } else if num < 0 {\n    \
    \        sum += abs(num)\n            product *= -1\n        } else {\n      \
    \      product *= 0\n        }\n    }\n    return sum * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcgvfe9s6/tmpcgvfe9s6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12953bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12950b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12950b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12950b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgvfe9s6                        0x0000563c9a4738a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b12955a7460 __libc_start_main +
    245

    6    tmpcgvfe9s6                        0x0000563c9a4732a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcgvfe9s6/tmpcgvfe9s6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12953bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12950b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12950b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12950b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgvfe9s6                        0x0000563c9a4738a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b12955a7460 __libc_start_main +
    245

    6    tmpcgvfe9s6                        0x0000563c9a4732a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ $0 == 0 ? 0 : abs($0) }\n    let product = signs.reduce(1, *)\n    let sum =\
    \ magnitudes.reduce(0, +)\n    return product * sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpnqjd9zer/tmpnqjd9zer.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba01fd65c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba01fa5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba01fa5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba01fa5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnqjd9zer                        0x0000560098aef815 <unavailable> + 6165

    5    libc.so.6                          0x00002ba01ff51460 __libc_start_main +
    245

    6    tmpnqjd9zer                        0x0000560098aef219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n \
    \           sum += i\n            prod *= 1\n        } else if i < 0 {\n     \
    \       sum += abs(i)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.map { abs($0)\
    \ }.reduce(0, +)\n    let product = signs.reduce(1, *)\n    return sum * product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let mags = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = mags.reduce(0, +)\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n\
    \        prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb9msdtuq/tmpb9msdtuq.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6aefedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6aefbd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6aefbd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6aefbd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9msdtuq                        0x000055db4f0c28a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b6af00cb460 __libc_start_main +
    245

    6    tmpb9msdtuq                        0x000055db4f0c22a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp964aegqy/tmp964aegqy.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5cc6ab8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5cc67afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5cc67af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5cc67ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp964aegqy                        0x0000561e41813649 <unavailable> + 5705

    5    libc.so.6                          0x00002b5cc6ca4460 __libc_start_main +
    245

    6    tmp964aegqy                        0x0000561e418131d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var sum = 0\n    for num in arr {\n\
    \        if num > 0 {\n            prod *= 1\n        } else if num < 0 {\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \      sum += abs(num)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpvu1xt39l/tmpvu1xt39l.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adb1a175c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adb19e6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adb19e6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adb19e6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvu1xt39l                        0x0000559128ac7a5c <unavailable> + 6748

    5    libc.so.6                          0x00002adb1a361460 __libc_start_main +
    245

    6    tmpvu1xt39l                        0x0000559128ac71c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmphp5eqvjs/tmphp5eqvjs.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3a40c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3a3dbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae3a3dbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae3a3dbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphp5eqvjs                        0x000055733e4c3815 <unavailable> + 6165

    5    libc.so.6                          0x00002ae3a42b2460 __libc_start_main +
    245

    6    tmphp5eqvjs                        0x000055733e4c3219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let product = signs.reduce(1,\
    \ *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num < 0 {\n         \
    \   prod *= -1\n        } else if num > 0 {\n            prod *= 1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let signProduct = signs.reduce(1, *)\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpewn89o7k/tmpewn89o7k.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a6c3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a6c0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a6c0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a6c0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewn89o7k                        0x000055ebe4fdd8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b2a6c5c9460 __libc_start_main +
    245

    6    tmpewn89o7k                        0x000055ebe4fdd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        if\
    \ i != 0 {\n            prod *= i / abs(i)\n        }\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppawc_bno/tmppawc_bno.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b477a4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b4749bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b4749b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b4749a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppawc_bno                        0x0000560b7aeeb8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1b47990460 __libc_start_main +
    245

    6    tmppawc_bno                        0x0000560b7aeeb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n \
    \           prod *= 1\n        } else if i < 0 {\n            prod *= -1\n   \
    \     } else {\n            prod *= 0\n        }\n        sum += abs(i)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var prod = 1\n    for i in arr {\n  \
    \      if i > 0 {\n            sum += i\n            prod *= 1\n        } else\
    \ if i < 0 {\n            sum += abs(i)\n            prod *= -1\n        } else\
    \ {\n            prod *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp050ljr_d/tmp050ljr_d.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace9d93bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace9d632b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace9d632988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace9d6317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp050ljr_d                        0x000055ea135bca5c <unavailable> + 6748

    5    libc.so.6                          0x00002ace9db27460 __libc_start_main +
    245

    6    tmp050ljr_d                        0x000055ea135bc1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n        } else if num < 0 {\n            prod *= -1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += abs(num)\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjp8b7ms7/tmpjp8b7ms7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad12209dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad121d94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad121d94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad121d937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjp8b7ms7                        0x00005616e09b88a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ad122289460 __libc_start_main +
    245

    6    tmpjp8b7ms7                        0x00005616e09b82a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjp8b7ms7/tmpjp8b7ms7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad12209dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad121d94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad121d94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad121d937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjp8b7ms7                        0x00005616e09b88a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ad122289460 __libc_start_main +
    245

    6    tmpjp8b7ms7                        0x00005616e09b82a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 >= 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n \
    \   return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjxyjxhrx/tmpjxyjxhrx.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe39408c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe390ffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe390ff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe390fe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjxyjxhrx                        0x00005622543c57d5 <unavailable> + 6101

    5    libc.so.6                          0x00002afe395f4460 __libc_start_main +
    245

    6    tmpjxyjxhrx                        0x00005622543c51d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n\
    \        prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb9msdtuq/tmpb9msdtuq.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6aefedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6aefbd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6aefbd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6aefbd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9msdtuq                        0x000055db4f0c28a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b6af00cb460 __libc_start_main +
    245

    6    tmpb9msdtuq                        0x000055db4f0c22a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes\
    \ = arr.map { abs($0) }\n    let signProduct = signs.reduce(1, *)\n    let magnitudeSum\
    \ = magnitudes.reduce(0, +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        if\
    \ i != 0 {\n            prod *= i > 0 ? 1 : -1\n        }\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5sind56s/tmp5sind56s.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba623c9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba623996b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba623996988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6239957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5sind56s                        0x0000558dfd2b9815 <unavailable> + 6165

    5    libc.so.6                          0x00002ba623e8b460 __libc_start_main +
    245

    6    tmp5sind56s                        0x0000558dfd2b9219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n            sum += num\n        } else if num < 0 {\n         \
    \   prod *= -1\n            sum += abs(num)\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcgvfe9s6/tmpcgvfe9s6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12953bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12950b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12950b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12950b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgvfe9s6                        0x0000563c9a4738a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b12955a7460 __libc_start_main +
    245

    6    tmpcgvfe9s6                        0x0000563c9a4732a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.reduce(0) { $0\
    \ + abs($1) }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sign_prod = signs.reduce(1, *)\n    let mag_sum = magnitudes.reduce(0,\
    \ +)\n    return sign_prod * mag_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpewn89o7k/tmpewn89o7k.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a6c3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a6c0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a6c0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a6c0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewn89o7k                        0x000055ebe4fdd8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b2a6c5c9460 __libc_start_main +
    245

    6    tmpewn89o7k                        0x000055ebe4fdd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824669
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : ($0 > 0 ? 1 : 0) }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num == 0 { continue }\n\
    \        prod *= num > 0 ? 1 : -1\n        sum += abs(num)\n    }\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmptaq0jfvm/tmptaq0jfvm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6f5d2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6f5a23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6f5a23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6f5a227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptaq0jfvm                        0x000055873f764815 <unavailable> + 6165

    5    libc.so.6                          0x00002ba6f5f18460 __libc_start_main +
    245

    6    tmptaq0jfvm                        0x000055873f764219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824670
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824668
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i > 0 ? 1 : (i < 0 ? -1 : 0)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824670
