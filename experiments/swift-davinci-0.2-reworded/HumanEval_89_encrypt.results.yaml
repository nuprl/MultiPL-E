language: swift
name: HumanEval_89_encrypt
results:
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpnxr59zfn/tmpnxr59zfn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bc8db3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bc8aaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bc8aaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bc8aa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxr59zfn                        0x00005565c31c8b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b3bc8f9f460 __libc_start_main +
    245

    6    tmpnxr59zfn                        0x00005565c31c8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let encryptedChar = UnicodeScalar(unicodeEncrypted)!\n\
    \        encryptedString.append(Character(encryptedChar))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpcafw_bx2/tmpcafw_bx2.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa791cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa78ec6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa78ec6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa78ec57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcafw_bx2                        0x000055fa62f26b7e <unavailable> + 7038

    5    libc.so.6                          0x00002afa793bb460 __libc_start_main +
    245

    6    tmpcafw_bx2                        0x000055fa62f26379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = alphabet.firstIndex(of: char)\n        let newCharIndex\
    \ = (charIndex! + 2) % alphabet.count\n        encryptedString.append(alphabet[newCharIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpviv6btkh.swift:18:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.firstIndex(of: char)\n                     \
    \   ^~~~~~~~\n/tmp/tmpviv6btkh.swift:19:47: error: cannot find 'alphabet' in scope\n\
    \        let newCharIndex = (charIndex! + 2) % alphabet.count\n              \
    \                                ^~~~~~~~\n/tmp/tmpviv6btkh.swift:20:32: error:\
    \ cannot find 'alphabet' in scope\n        encryptedString.append(alphabet[newCharIndex])\n\
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        let newAscii = ascii + 2 * 2\n       \
    \ let newChar = Character(UnicodeScalar(newAscii)!)\n        encrypted.append(newChar)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdatp5bdz.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let newCharIndex = charIndex\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n \
    \       encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpewx4hyy4.swift:20:60: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n              \
    \                                             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let asciiValue = char.asciiValue!\n        let newAsciiValue = asciiValue\
    \ + 2 * 2\n        let newChar = Character(UnicodeScalar(newAsciiValue)!)\n  \
    \      encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9581rygp.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAsciiValue)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n             \
    \                                               \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shifted = unicode +\
    \ (2 * 2)\n        let shiftedChar = UnicodeScalar(UInt8(shifted))\n        result.append(Character(shiftedChar!))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2734pjb.swift:21:44: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result.append(Character(shiftedChar!))\n\
    \                                ~~~~~~~~~~~^\n                              \
    \             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        var encryptedUnicode\
    \ = unicode + (2 * 2)\n        if encryptedUnicode > 122 {\n            encryptedUnicode\
    \ = (encryptedUnicode % 122) + 96\n        }\n        let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedLetter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for letter in s {\n     \
    \   let ascii = letter.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n\
    \            let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n \
    \               let diff = newAscii - 122\n                let newAscii = 96 +\
    \ diff\n                encrypted.append(Character(UnicodeScalar(newAscii)!))\n\
    \            } else {\n                encrypted.append(Character(UnicodeScalar(newAscii)!))\n\
    \            }\n        } else {\n            encrypted.append(letter)\n     \
    \   }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4h_gfvl0.swift:24:67: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                encrypted.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                           ~~~~~~~~~~~~~~~~~~~~~~~^\n       \
    \                                                           \n/tmp/tmp4h_gfvl0.swift:26:67:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                encrypted.append(Character(UnicodeScalar(newAscii)!))\n     \
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~^\n            \
    \                                                      \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for character in s {\n        if let index =\
    \ alphabet.firstIndex(of: character) {\n            let newIndex = index.advanced(by:\
    \ 2)\n            let newCharacter = alphabet[newIndex]\n            encryptedString.append(newCharacter)\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpnzgsz8v9.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n        encryptedString.append(encryptedChar)\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppogvysvb.swift:19:71: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                      \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ newUnicode = unicode + (2 * 2)\n        let newCharacter = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpeibkxncs/tmpeibkxncs.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10b5656c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10b534db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10b534d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10b534c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeibkxncs                        0x000055a1bd226b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b10b5842460 __libc_start_main +
    245

    6    tmpeibkxncs                        0x000055a1bd226379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue! - 97\n        let newIndex = (index + 4)\
    \ % 26\n        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n     \
    \   encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpavm0lw2x.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1o4ltgm1.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2 * 2\n          \
    \  let newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex\
    \ % alphabet.count)]\n            encryptedString.append(newChar)\n        }\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = UnicodeScalar(encryptedUnicode)!\n\
    \        encryptedString.append(Character(encryptedLetter))\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp50sz07zy/tmp50sz07zy.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c5d30cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c5d003b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c5d003988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c5d0027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp50sz07zy                        0x0000562557c0cb7e <unavailable> + 7038

    5    libc.so.6                          0x00002b3c5d4f8460 __libc_start_main +
    245

    6    tmp50sz07zy                        0x0000562557c0c379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let encryptedCharIndex\
    \ = (charIndex + 2 * 2) % 26\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex\
    \ + 97)!)\n        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa84j8z7y.swift:20:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex\
    \ + 97)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedChar = String(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n        encryptedString += encryptedChar\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0y3v2kr6.swift:19:68: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = String(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                   \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        if newIndex > alphabet.count - 1 {\n            let newIndex\
    \ = newIndex - alphabet.count\n            encryptedString.append(alphabet[newIndex])\n\
    \        } else {\n            encryptedString.append(alphabet[newIndex])\n  \
    \      }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3xuwsjq6.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp3xuwsjq6.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ if newIndex > alphabet.count - 1 {\n                      ^~~~~~~~\n/tmp/tmp3xuwsjq6.swift:21:39:\
    \ error: cannot find 'alphabet' in scope\n            let newIndex = newIndex\
    \ - alphabet.count\n                                      ^~~~~~~~\n/tmp/tmp3xuwsjq6.swift:22:36:\
    \ error: cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n/tmp/tmp3xuwsjq6.swift:24:36: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmplj31s0r7/tmplj31s0r7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1e681fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1e6516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1e6516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1e65157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplj31s0r7                        0x00005627ffb7bd4e <unavailable> + 7502

    5    libc.so.6                          0x00002ad1e6a0b460 __libc_start_main +
    245

    6    tmplj31s0r7                        0x00005627ffb7b549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shifted = unicode +\
    \ (2 * 2)\n        let shiftedChar = UnicodeScalar(UInt8(shifted))\n        result.append(Character(shiftedChar!))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2734pjb.swift:21:44: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result.append(Character(shiftedChar!))\n\
    \                                ~~~~~~~~~~~^\n                              \
    \             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let newCharIndex = (charIndex\
    \ + 2 * 2) % 26\n        let newChar = Character(UnicodeScalar(newCharIndex +\
    \ 97)!)\n        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxe0okevf.swift:20:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let encryptedIndex = (charIndex\
    \ + 2 * 2) % 26\n        let encryptedChar = Character(UnicodeScalar(encryptedIndex\
    \ + 97)!)\n        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwcu69l4x.swift:20:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedIndex\
    \ + 97)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                        \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 2\n            encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2zgy_ynl/tmp2zgy_ynl.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7419217c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7418f0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7418f0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7418f0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2zgy_ynl                        0x000055ead1c376a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b7419403460 __libc_start_main +
    245

    6    tmp2zgy_ynl                        0x000055ead1c372e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2)))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmppfk2qn3j/tmppfk2qn3j.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad419de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad419adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad419adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad419ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppfk2qn3j                        0x000055ec1a956b9e <unavailable> + 7070

    5    libc.so.6                          0x00002ad419fd0460 __libc_start_main +
    245

    6    tmppfk2qn3j                        0x000055ec1a956399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp1f74fmf9/tmp1f74fmf9.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c12ff9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c12cf0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c12cf0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c12cef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1f74fmf9                        0x000055fa2e206307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6c131e5460 __libc_start_main +
    245

    6    tmp1f74fmf9                        0x000055fa2e205f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(c.asciiValue! + 2 * 2))))\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpru2emm2f/tmpru2emm2f.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b263432cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2634023b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2634023988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26340227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpru2emm2f                        0x0000564143e18bee <unavailable> + 7150

    5    libc.so.6                          0x00002b2634518460 __libc_start_main +
    245

    6    tmpru2emm2f                        0x0000564143e183e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(char.asciiValue!) + 2 * 2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphg9d16db.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(char.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    var result = \"\"\n    for character\
    \ in s {\n        let unicode = character.unicodeScalars.first!.value\n      \
    \  let shiftedUnicode = unicode + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp3ia3hz5i/tmp3ia3hz5i.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70d4ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af70d1d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af70d1d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af70d1d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3ia3hz5i                        0x00005610d0640d4e <unavailable> + 7502

    5    libc.so.6                          0x00002af70d6c9460 __libc_start_main +
    245

    6    tmp3ia3hz5i                        0x00005610d0640549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode\
    \ = unicode + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp0fqom853/tmp0fqom853.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c6d41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c6a38b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c6a38988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c6a377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fqom853                        0x0000555ba8513d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b05c6f2d460 __libc_start_main +
    245

    6    tmp0fqom853                        0x0000555ba8513549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let encryptedChar = UnicodeScalar(unicodeEncrypted)\n\
    \        encryptedString.append(Character(encryptedChar!))\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpflok1xw_/tmpflok1xw_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcf888cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcf8583b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcf8583988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcf85827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpflok1xw_                        0x0000558c13224b7e <unavailable> + 7038

    5    libc.so.6                          0x00002adcf8a78460 __libc_start_main +
    245

    6    tmpflok1xw_                        0x0000558c13224379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedCharIndex = charIndex\
    \ + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpev_fryjf.swift:20:72: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  \
    \                                                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let newCharIndex = (charIndex\
    \ + 2 * 2) % 26\n        let newChar = Character(UnicodeScalar(newCharIndex +\
    \ 97)!)\n        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxe0okevf.swift:20:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ var newChar = char\n        if char == \"z\" {\n            newChar = \"b\"\n\
    \        } else if char == \"y\" {\n            newChar = \"a\"\n        } else\
    \ if char == \" \" {\n            newChar = \" \"\n        } else {\n        \
    \    newChar = Character(UnicodeScalar(Int(String(char))! + 2)!)\n        }\n\
    \        encrypted += String(newChar)\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpl7f8tcbd/tmpl7f8tcbd.swift:26: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002abe39310c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe39007561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abe39007286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abe3900713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abe39006bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpl7f8tcbd                        0x000055dc7b84b2cf <unavailable> + 8911

    6    tmpl7f8tcbd                        0x000055dc7b84a696 <unavailable> + 5782

    7    libc.so.6                          0x00002abe394fc460 __libc_start_main +
    245

    8    tmpl7f8tcbd                        0x000055dc7b84a399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2 * 2\n          \
    \  if newIndex > alphabet.count - 1 {\n                let newIndex = newIndex\
    \ - alphabet.count\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedChar\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpllh8m9te/tmpllh8m9te.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ebea34c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ebe72bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ebe72b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ebe72a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllh8m9te                        0x000056074a6b6d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b5ebec20460 __libc_start_main +
    245

    6    tmpllh8m9te                        0x000056074a6b6549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted\
    \ += String(alphabet[newIndex])\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmptr45nmd3/tmptr45nmd3.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5083e29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5083b20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5083b20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5083b1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptr45nmd3                        0x000056362432f6d7 <unavailable> + 5847

    5    libc.so.6                          0x00002b5084015460 __libc_start_main +
    245

    6    tmptr45nmd3                        0x000056362432f319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmplj31s0r7/tmplj31s0r7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1e681fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1e6516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1e6516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1e65157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplj31s0r7                        0x00005627ffb7bd4e <unavailable> + 7502

    5    libc.so.6                          0x00002ad1e6a0b460 __libc_start_main +
    245

    6    tmplj31s0r7                        0x00005627ffb7b549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n   \
    \     result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpokrwxz68/tmpokrwxz68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb91cd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb919cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb919cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb919cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokrwxz68                        0x000055e6d4845b7e <unavailable> + 7038

    5    libc.so.6                          0x00002abb91ec2460 __libc_start_main +
    245

    6    tmpokrwxz68                        0x000055e6d4845379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode\
    \ = unicode + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp0fqom853/tmp0fqom853.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c6d41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c6a38b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c6a38988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c6a377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fqom853                        0x0000555ba8513d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b05c6f2d460 __libc_start_main +
    245

    6    tmp0fqom853                        0x0000555ba8513549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2) % 26\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx8kt2mim.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpx8kt2mim.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        var encryptedUnicode\
    \ = unicode + 2 * 2\n        if encryptedUnicode > 122 {\n            encryptedUnicode\
    \ = encryptedUnicode - 26\n        }\n        encryptedString.append(Character(UnicodeScalar(encryptedUnicode)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let shifted = unicode\
    \ + (2 * 2)\n        let char = UnicodeScalar(UInt8(shifted))\n        encrypted.append(Character(char!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphgzeclvi.swift:21:40: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encrypted.append(Character(char!))\n\
    \                                   ~~~~^\n                                  \
    \     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ newUnicode = unicode + (2 * 2)\n        let newCharacter = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpeibkxncs/tmpeibkxncs.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10b5656c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10b534db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10b534d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10b534c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeibkxncs                        0x000055a1bd226b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b10b5842460 __libc_start_main +
    245

    6    tmpeibkxncs                        0x000055a1bd226379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 2\n            encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n        }\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpgq6ntkap/tmpgq6ntkap.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e359a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e3569eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e3569e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e3569d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgq6ntkap                        0x0000558ea8ed86a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b7e35b93460 __libc_start_main +
    245

    6    tmpgq6ntkap                        0x0000558ea8ed82e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = char.asciiValue! - 97\n        let newIndex = (index + 2 * 2) % 26\n\
    \        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n        result.append(newChar)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz5h8ldzx.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        if index == nil {\n\
    \            encryptedString.append(char)\n        } else {\n            let newIndex\
    \ = (index! + 2 * 2) % alphabet.count\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpb3ifwlbs.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpb3ifwlbs.swift:22:47: error: cannot find 'alphabet' in scope\n       \
    \     let newIndex = (index! + 2 * 2) % alphabet.count\n                     \
    \                         ^~~~~~~~\n/tmp/tmpb3ifwlbs.swift:23:36: error: cannot\
    \ find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let newChar = UnicodeScalar(newUnicode)!\n    \
    \    encryptedString.append(Character(newChar))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp8gnt6y62/tmp8gnt6y62.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3b4bf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3b48eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3b48ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3b48e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8gnt6y62                        0x000055c024658b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ac3b4ddf460 __libc_start_main +
    245

    6    tmp8gnt6y62                        0x000055c024658379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encrypted.append(encryptedCharacter)\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpapxh_p8s/tmpapxh_p8s.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8601a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af85fe99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af85fe99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af85fe987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpapxh_p8s                        0x000055709b7b1b7e <unavailable> + 7038

    5    libc.so.6                          0x00002af86038e460 __libc_start_main +
    245

    6    tmpapxh_p8s                        0x000055709b7b1379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        if newIndex > 25 {\n            let newIndex = newIndex - 26\n\
    \            encryptedString.append(alphabet[newIndex])\n        } else {\n  \
    \          encryptedString.append(alphabet[newIndex])\n        }\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqcu2mzt3.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpqcu2mzt3.swift:22:36: error: cannot find 'alphabet' in scope\n       \
    \     encryptedString.append(alphabet[newIndex])\n                           \
    \        ^~~~~~~~\n/tmp/tmpqcu2mzt3.swift:24:36: error: cannot find 'alphabet'\
    \ in scope\n            encryptedString.append(alphabet[newIndex])\n         \
    \                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedCharIndex = charIndex\
    \ + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpev_fryjf.swift:20:72: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  \
    \                                                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let unicodeString = String(unicode,\
    \ radix: 16)\n        let unicodeInt = Int(unicodeString, radix: 16)!\n      \
    \  let newUnicode = unicodeInt + (2 * 2)\n        let newUnicodeString = String(newUnicode,\
    \ radix: 16)\n        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString,\
    \ radix: 16)!)\n        result.append(Character(newUnicodeScalar))\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp83kquwrz.swift:24:33: error: value of optional type 'Unicode.Scalar?'\
    \ must be unwrapped to a value of type 'Unicode.Scalar'\n        result.append(Character(newUnicodeScalar))\n\
    \                                ^\n/tmp/tmp83kquwrz.swift:23:13: note: short-circuit\
    \ using 'guard' to exit this function early if the optional value contains 'nil'\n\
    \        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString, radix: 16)!)\n\
    \            ^\n        guard                                                \
    \                   else { return <#default value#> }\n/tmp/tmp83kquwrz.swift:23:32:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString, radix:\
    \ 16)!)\n                               ^\n                                  \
    \                                              ?? <#default value#>\n/tmp/tmp83kquwrz.swift:23:32:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString, radix:\
    \ 16)!)\n                               ^\n                                  \
    \                                             !\n/tmp/tmp83kquwrz.swift:24:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result.append(Character(newUnicodeScalar))\n                \
    \                ^\n                                                 ?? <#default\
    \ value#>\n/tmp/tmp83kquwrz.swift:24:33: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result.append(Character(newUnicodeScalar))\n\
    \                                ^\n                                         \
    \       !\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        let newAscii = ascii + (2 * 2)\n     \
    \   let newChar = Character(UnicodeScalar(newAscii)!)\n        encrypted.append(newChar)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp99qj20uz.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(c.asciiValue!) + 2 * 2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppws61o25.swift:18:79: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(c.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \  \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n   \
    \         let newChar = ascii + (2 * 2)\n            if newChar > 122 {\n    \
    \            let diff = newChar - 122\n                encrypted.append(Character(UnicodeScalar(97\
    \ + diff - 1)!))\n            } else {\n                encrypted.append(Character(UnicodeScalar(newChar)!))\n\
    \            }\n        } else {\n            encrypted.append(char)\n       \
    \ }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprdni2ral.swift:23:72: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                encrypted.append(Character(UnicodeScalar(97\
    \ + diff - 1)!))\n                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                       \n/tmp/tmprdni2ral.swift:25:66:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                encrypted.append(Character(UnicodeScalar(newChar)!))\n      \
    \                                     ~~~~~~~~~~~~~~~~~~~~~~^\n              \
    \                                                   \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for character in s {\n  \
    \      let unicode = character.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let shiftedCharacter = UnicodeScalar(UInt8(newUnicode))\n\
    \        encrypted.append(Character(shiftedCharacter!))\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgwmfrseh.swift:21:52: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encrypted.append(Character(shiftedCharacter!))\n\
    \                                   ~~~~~~~~~~~~~~~~^\n                      \
    \                             \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encrypted.append(encryptedCharacter)\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmph2q57fx4/tmph2q57fx4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5964617c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b596430eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b596430e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b596430d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph2q57fx4                        0x0000558cf6c95d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b5964803460 __libc_start_main +
    245

    6    tmph2q57fx4                        0x0000558cf6c95549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for letter in s {\n        let\
    \ unicode = letter.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpxqn95uv3/tmpxqn95uv3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21f4303c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21f3ffab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21f3ffa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21f3ff97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxqn95uv3                        0x000055e7a71a0d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b21f44ef460 __libc_start_main +
    245

    6    tmpxqn95uv3                        0x000055e7a71a0549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedCharIndex = charIndex\
    \ + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpev_fryjf.swift:20:72: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  \
    \                                                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let asciiValue = char.asciiValue!\n        let newAsciiValue = asciiValue\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newAsciiValue)!)\n\
    \        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3npi1k4x.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAsciiValue)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n             \
    \                                               \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + 2 * 2\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n     \
    \   result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp58ir0pde/tmp58ir0pde.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e741d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e73ecab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e73eca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e73ec97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp58ir0pde                        0x000055ec0f941b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b9e743bf460 __libc_start_main +
    245

    6    tmp58ir0pde                        0x000055ec0f941379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpoh_txgrl/tmpoh_txgrl.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb0ae40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb0ab37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb0ab37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb0ab367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoh_txgrl                        0x0000562d0e383b7e <unavailable> + 7038

    5    libc.so.6                          0x00002afb0b02c460 __libc_start_main +
    245

    6    tmpoh_txgrl                        0x0000562d0e383379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let letterIndex = letter.asciiValue! - 97\n        let encryptedLetterIndex\
    \ = (letterIndex + 4) % 26\n        let encryptedLetter = Character(UnicodeScalar(encryptedLetterIndex\
    \ + 97)!)\n        encryptedString.append(encryptedLetter)\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7z54flqw.swift:20:81: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedLetter = Character(UnicodeScalar(encryptedLetterIndex\
    \ + 97)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \    \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let newCharIndex = (charIndex\
    \ + 2 * 2) % 26\n        let newChar = Character(UnicodeScalar(newCharIndex +\
    \ 97)!)\n        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxe0okevf.swift:20:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let letterIndex = letter.asciiValue! - 97\n        let encryptedLetterIndex\
    \ = (letterIndex + 2) % 26\n        let encryptedLetter = Character(UnicodeScalar(encryptedLetterIndex\
    \ + 97)!)\n        encryptedString.append(encryptedLetter)\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpe2_8vbgj.swift:20:81: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedLetter = Character(UnicodeScalar(encryptedLetterIndex\
    \ + 97)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \    \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n      \
    \  encryptedString.append(alphabet[newIndex])\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpdsi7vsla/tmpdsi7vsla.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af35cb0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af35c805b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af35c805988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af35c8047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdsi7vsla                        0x000055d9d2902687 <unavailable> + 5767

    5    libc.so.6                          0x00002af35ccfa460 __libc_start_main +
    245

    6    tmpdsi7vsla                        0x000055d9d29022c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let asciiValue = char.asciiValue {\n            let newAsciiValue =\
    \ asciiValue + 2 * 2\n            if newAsciiValue > 122 {\n                let\
    \ diff = newAsciiValue - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encryptedString.append(newChar)\n           \
    \ } else {\n                let newChar = Character(UnicodeScalar(newAsciiValue)!)\n\
    \                encryptedString.append(newChar)\n            }\n        }\n \
    \   }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpr108hfn5.swift:22:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmpr108hfn5.swift:25:69:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAsciiValue)!)\n    \
    \                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n         \
    \                                                           \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let unicode\
    \ = c.unicodeScalars.first!.value\n        let unicode2 = unicode + 2 * 2\n  \
    \      let scalar = UnicodeScalar(unicode2)!\n        let char = Character(scalar)\n\
    \        result += String(char)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpxip6e9dr/tmpxip6e9dr.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acfa7f52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acfa7c49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acfa7c49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acfa7c487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxip6e9dr                        0x0000555f50407bde <unavailable> + 7134

    5    libc.so.6                          0x00002acfa813e460 __libc_start_main +
    245

    6    tmpxip6e9dr                        0x0000555f504073d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n\
    \            let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n \
    \               let diff = newAscii - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encryptedString.append(newChar)\n           \
    \ } else {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                encryptedString.append(newChar)\n            }\n        } else\
    \ {\n            encryptedString.append(char)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8s8j0f9r.swift:23:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmp8s8j0f9r.swift:26:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index + 2\n            if newIndex > alphabet.count\
    \ - 1 {\n                let newIndex = newIndex - alphabet.count\n          \
    \      encryptedString.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz41oz6xl.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2\n    \
    \                       ^\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpb1pubfo8/tmpb1pubfo8.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba40519cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba404e93b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba404e93988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba404e927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb1pubfo8                        0x00005571671e3b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ba405388460 __libc_start_main +
    245

    6    tmpb1pubfo8                        0x00005571671e3379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n      \
    \  encrypted += String(alphabet[newIndex])\n    }\n    return encrypted\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpoq92a118/tmpoq92a118.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb0dfedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb0dce4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb0dce4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb0dce37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoq92a118                        0x000055d34e6b16d7 <unavailable> + 5847

    5    libc.so.6                          0x00002abb0e1d9460 __libc_start_main +
    245

    6    tmpoq92a118                        0x000055d34e6b1319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue! - 97\n        let newIndex = (index + 2 *\
    \ 2) % 26\n        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n  \
    \      encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9c6apol.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ var ascii = char.asciiValue!\n        ascii += 2*2\n        if ascii > 122 {\n\
    \            ascii -= 26\n        }\n        encrypted.append(Character(UnicodeScalar(ascii)!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt9ivjsfc.swift:23:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encrypted.append(Character(UnicodeScalar(ascii)!))\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2 * 2) % 26\n        encryptedString.append(alphabet[newIndex])\n    }\n \
    \   return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfc07hir9.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpfc07hir9.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmplj31s0r7/tmplj31s0r7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1e681fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1e6516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1e6516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1e65157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplj31s0r7                        0x00005627ffb7bd4e <unavailable> + 7502

    5    libc.so.6                          0x00002ad1e6a0b460 __libc_start_main +
    245

    6    tmplj31s0r7                        0x00005627ffb7b549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted\
    \ += String(alphabet[newIndex])\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmptr45nmd3/tmptr45nmd3.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5083e29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5083b20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5083b20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5083b1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptr45nmd3                        0x000056362432f6d7 <unavailable> + 5847

    5    libc.so.6                          0x00002b5084015460 __libc_start_main +
    245

    6    tmptr45nmd3                        0x000056362432f319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n   \
    \     result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpokrwxz68/tmpokrwxz68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb91cd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb919cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb919cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb919cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokrwxz68                        0x000055e6d4845b7e <unavailable> + 7038

    5    libc.so.6                          0x00002abb91ec2460 __libc_start_main +
    245

    6    tmpokrwxz68                        0x000055e6d4845379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let lowercaseS = s.lowercased()\n    var encrypted = \"\"\n    for char in lowercaseS\
    \ {\n        if let index = alphabet.firstIndex(of: char) {\n            let newIndex\
    \ = index + 2\n            if newIndex > 25 {\n                let remainder =\
    \ newIndex - 26\n                encrypted.append(alphabet[remainder])\n     \
    \       } else {\n                encrypted.append(alphabet[newIndex])\n     \
    \       }\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjw1lent1.swift:21:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2\n    \
    \                       ^\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = alphabet.firstIndex(of: char)!\n        let newIndex = (index + 2 *\
    \ 2) % alphabet.count\n        result.append(alphabet[newIndex])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9fwcsiqd.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)!\n                    ^~~~~~~~\n\
    /tmp/tmp9fwcsiqd.swift:19:42: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index + 2 * 2) % alphabet.count\n                          \
    \               ^~~~~~~~\n/tmp/tmp9fwcsiqd.swift:20:23: error: cannot find 'alphabet'\
    \ in scope\n        result.append(alphabet[newIndex])\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encrypted.append(encryptedCharacter)\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpapxh_p8s/tmpapxh_p8s.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8601a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af85fe99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af85fe99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af85fe987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpapxh_p8s                        0x000055709b7b1b7e <unavailable> + 7038

    5    libc.so.6                          0x00002af86038e460 __libc_start_main +
    245

    6    tmpapxh_p8s                        0x000055709b7b1379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        if let index = index {\n            let newIndex = alphabet.index(index,\
    \ offsetBy: 2)\n            encrypted.append(alphabet[newIndex])\n        }\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpomw1a6cy/tmpomw1a6cy.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b201942bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2019122b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2019122988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20191217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpomw1a6cy                        0x0000561602e305e7 <unavailable> + 5607

    5    libc.so.6                          0x00002b2019617460 __libc_start_main +
    245

    6    tmpomw1a6cy                        0x0000561602e30229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       encryptedString += String(Character(UnicodeScalar(UInt8(char.asciiValue!\
    \ + 2 * 2))!))\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpws0_pdzc.swift:18:91: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString += String(Character(UnicodeScalar(UInt8(char.asciiValue!\
    \ + 2 * 2))!))\n                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \              \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ ascii = char.asciiValue!\n        let newAscii = ascii + (2 * 2)\n        result.append(Character(UnicodeScalar(newAscii)!))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8y3o4kte.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 2\n            let\
    \ newLetter = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n\
    \            encryptedString.append(newLetter)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpgg32cyk2/tmpgg32cyk2.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae132c4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae132946b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae132946988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1329457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgg32cyk2                        0x0000563d54f8c6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002ae132e3b460 __libc_start_main +
    245

    6    tmpgg32cyk2                        0x0000563d54f8c2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let newAscii = ascii + 2 * 2\n \
    \       let newChar = Character(UnicodeScalar(newAscii)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbpqp7y_y.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = UnicodeScalar(encryptedUnicode)!\n\
    \        encryptedString.append(Character(encryptedLetter))\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp50sz07zy/tmp50sz07zy.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c5d30cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c5d003b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c5d003988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c5d0027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp50sz07zy                        0x0000562557c0cb7e <unavailable> + 7038

    5    libc.so.6                          0x00002b3c5d4f8460 __libc_start_main +
    245

    6    tmp50sz07zy                        0x0000562557c0c379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for letter in s {\n     \
    \   let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encrypted += encryptedLetter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmphp86uelk/tmphp86uelk.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b36d8987c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b36d867eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b36d867e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b36d867d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphp86uelk                        0x000055ff60117d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b36d8b73460 __libc_start_main +
    245

    6    tmphp86uelk                        0x000055ff60117549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = (index.encodedOffset + 4) % alphabet.count\n\
    \            let newLetter = alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)]\n            encryptedString.append(newLetter)\n        }\n    }\n\
    \    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0qxg1lpb/tmp0qxg1lpb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0069dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b00394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b00394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b003937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0qxg1lpb                        0x00005647b471f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6b00889460 __libc_start_main +
    245

    6    tmp0qxg1lpb                        0x00005647b471ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char).unicodeScalars.map {\n            if $0.value >= 97 && $0.value\
    \ <= 122 {\n                let newValue = $0.value + (2 * 2)\n              \
    \  if newValue > 122 {\n                    return UnicodeScalar(newValue - 26)!\n\
    \                } else {\n                    return UnicodeScalar(newValue)!\n\
    \                }\n            } else {\n                return $0\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpf_9zjnub.swift:22:56: error: cannot convert return expression of\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar') to return type 'String.Element'\
    \ (aka 'Character')\n                    return UnicodeScalar(newValue - 26)!\n\
    \                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp39eqodxo/tmp39eqodxo.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca7370fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca73406b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca73406988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca734057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp39eqodxo                        0x000055ac5e9fc687 <unavailable> + 5767

    5    libc.so.6                          0x00002aca738fb460 __libc_start_main +
    245

    6    tmp39eqodxo                        0x000055ac5e9fc2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let newAscii = ascii + 2 * 2\n \
    \       let newChar = Character(UnicodeScalar(newAscii)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbpqp7y_y.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        if index! + 2 * 2 >\
    \ 25 {\n            encryptedString += alphabet[index! + 2 * 2 - 26]\n       \
    \ } else {\n            encryptedString += alphabet[index! + 2 * 2]\n        }\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkb26tcwn.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpkb26tcwn.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \     encryptedString += alphabet[index! + 2 * 2 - 26]\n                     \
    \          ^~~~~~~~\n/tmp/tmpkb26tcwn.swift:22:32: error: cannot find 'alphabet'\
    \ in scope\n            encryptedString += alphabet[index! + 2 * 2]\n        \
    \                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedCharIndex = charIndex\
    \ + 2 * 2\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpyopnng0d.swift:20:72: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  \
    \                                                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let encryptedChar = UnicodeScalar(unicodeEncrypted)!\n\
    \        encryptedString.append(Character(encryptedChar))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpcafw_bx2/tmpcafw_bx2.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa791cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa78ec6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa78ec6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa78ec57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcafw_bx2                        0x000055fa62f26b7e <unavailable> + 7038

    5    libc.so.6                          0x00002afa793bb460 __libc_start_main +
    245

    6    tmpcafw_bx2                        0x000055fa62f26379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n   \
    \     result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpokrwxz68/tmpokrwxz68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb91cd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb919cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb919cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb919cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokrwxz68                        0x000055e6d4845b7e <unavailable> + 7038

    5    libc.so.6                          0x00002abb91ec2460 __libc_start_main +
    245

    6    tmpokrwxz68                        0x000055e6d4845379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedChar\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpllh8m9te/tmpllh8m9te.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ebea34c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ebe72bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ebe72b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ebe72a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllh8m9te                        0x000056074a6b6d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b5ebec20460 __libc_start_main +
    245

    6    tmpllh8m9te                        0x000056074a6b6549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue!\n        let newIndex = Int(index) + 2 *\
    \ 2\n        let newChar = Character(UnicodeScalar(newIndex)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpmicqq5sq/tmpmicqq5sq.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b042b1aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b042aea5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b042aea5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b042aea47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmicqq5sq                        0x0000561c5b203b8e <unavailable> + 7054

    5    libc.so.6                          0x00002b042b39a460 __libc_start_main +
    245

    6    tmpmicqq5sq                        0x0000561c5b203389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1o4ltgm1.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2_uz508q/tmp2_uz508q.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b667d2c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b667cfc0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b667cfc0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b667cfbf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2_uz508q                        0x000055697b78bd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b667d4b5460 __libc_start_main +
    245

    6    tmp2_uz508q                        0x000055697b78b549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ unicodeEncrypted = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(unicodeEncrypted)!)\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpz1i0m_7u/tmpz1i0m_7u.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5028b9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5028894b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5028894988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50288937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz1i0m_7u                        0x00005566723c5b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b5028d89460 __libc_start_main +
    245

    6    tmpz1i0m_7u                        0x00005566723c5379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let charIndex = char.asciiValue! - 97\n        let encryptedIndex = (charIndex\
    \ + 2 * 2) % 26\n        let encryptedChar = Character(UnicodeScalar(encryptedIndex\
    \ + 97)!)\n        encrypted.append(encryptedChar)\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpug3rzyt6.swift:20:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedIndex\
    \ + 97)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                        \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n      \
    \  encryptedString.append(alphabet[newIndex])\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpdsi7vsla/tmpdsi7vsla.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af35cb0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af35c805b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af35c805988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af35c8047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdsi7vsla                        0x000055d9d2902687 <unavailable> + 5767

    5    libc.so.6                          0x00002af35ccfa460 __libc_start_main +
    245

    6    tmpdsi7vsla                        0x000055d9d29022c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n   \
    \         let newAscii = ascii + (2 * 2)\n            if newAscii > 122 {\n  \
    \              let diff = newAscii - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encrypted.append(newChar)\n            } else\
    \ {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n     \
    \           encrypted.append(newChar)\n            }\n        } else {\n     \
    \       encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpna4477qm.swift:23:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmpna4477qm.swift:26:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for character in s {\n        if let index =\
    \ alphabet.firstIndex(of: character) {\n            let newIndex = index.advanced(by:\
    \ 2)\n            let newIndex2 = newIndex.advanced(by: 2)\n            let newIndex3\
    \ = newIndex2.advanced(by: 2)\n            let newIndex4 = newIndex3.advanced(by:\
    \ 2)\n            let newIndex5 = newIndex4.advanced(by: 2)\n            let newIndex6\
    \ = newIndex5.advanced(by: 2)\n            let newIndex7 = newIndex6.advanced(by:\
    \ 2)\n            let newIndex8 = newIndex7.advanced(by: 2)\n            let newIndex9\
    \ = newIndex8.advanced(by: 2)\n            let newIndex10 = newIndex9.advanced(by:\
    \ 2)\n            let newIndex11 = newIndex10.advanced(by: 2)\n            let\
    \ newIndex12 = newIndex11.advanced(by: 2)\n            let newIndex13 = newIndex12.advanced(by:\
    \ 2)\n            let newIndex14 = newIndex13.advanced(by: 2)\n            let\
    \ newIndex15 = newIndex14.advanced(by: 2)\n            let newIndex16 = newIndex15.advanced(by:\
    \ 2)\n            let newIndex17 = newIndex16.advanced(by: 2)\n            let\
    \ newIndex18 = newIndex17.advanced(by: 2)\n            let newIndex19 = newIndex18.advanced(by:\
    \ 2)\n            let newIndex20 = newIndex19.advanced(by: 2)\n            let\
    \ newIndex21 = newIndex20.advanced(by: 2)\n            let newIndex22 = newIndex21.advanced(by:\
    \ 2)\n            let newIndex23 = newIndex22.advanced(by: 2)\n            let\
    \ newIndex24 = newIndex23.advanced(by: 2)\n            let newIndex25 = newIndex24.advanced(by:\
    \ 2)\n            let newIndex26 = newIndex25.advanced(by\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfgafj3ka.swift:46:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpfgafj3ka.swift:45:49: note: to match this opening '('\n           \
    \ let newIndex26 = newIndex25.advanced(by\n                                  \
    \              ^\n/tmp/tmpfgafj3ka.swift:68:31: error: expected '}' at end of\
    \ brace statement\nassert(encrypt(s: \"a\") == \"e\")\n                      \
    \        ^\n/tmp/tmpfgafj3ka.swift:18:24: note: to match this opening '{'\n  \
    \  for character in s {\n                       ^\n/tmp/tmpfgafj3ka.swift:68:31:\
    \ error: expected '}' at end of brace statement\nassert(encrypt(s: \"a\") == \"\
    e\")\n                              ^\n/tmp/tmpfgafj3ka.swift:15:35: note: to\
    \ match this opening '{'\nfunc encrypt(s: String) -> String {\n              \
    \                    ^\n/tmp/tmpfgafj3ka.swift:20:34: error: value of type 'String.Index'\
    \ has no member 'advanced'\n            let newIndex = index.advanced(by: 2)\n\
    \                           ~~~~~ ^~~~~~~~\n/tmp/tmpfgafj3ka.swift:45:50: error:\
    \ cannot find 'by' in scope\n            let newIndex26 = newIndex25.advanced(by\n\
    \                                                 ^~\n/tmp/tmpfgafj3ka.swift:49:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for letter in s {\n        result\
    \ += String(UnicodeScalar(UInt8(letter.asciiValue! + 2 * 2)))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpleo9capm/tmpleo9capm.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a136f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a133ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a133ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a133eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpleo9capm                        0x0000564aa2a41b9e <unavailable> + 7070

    5    libc.so.6                          0x00002b4a138e1460 __libc_start_main +
    245

    6    tmpleo9capm                        0x0000564aa2a41399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n   \
    \         let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n    \
    \            let diff = newAscii - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encrypted.append(newChar)\n            } else\
    \ {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n     \
    \           encrypted.append(newChar)\n            }\n        } else {\n     \
    \       encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1q82uolc.swift:23:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmp1q82uolc.swift:26:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedLetter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpbgw0wi8d/tmpbgw0wi8d.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b305cf22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b305cc19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b305cc19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b305cc187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbgw0wi8d                        0x0000563e344e5d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b305d10e460 __libc_start_main +
    245

    6    tmpbgw0wi8d                        0x0000563e344e5549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2))!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppynlzjo3.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(char.asciiValue!\
    \ + 2 * 2))!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue!\n        let newIndex = (index - 97 + 2 *\
    \ 2) % 26 + 97\n        let newChar = Character(UnicodeScalar(newIndex)!)\n  \
    \      encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpvl56onxb.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2 * 2\n          \
    \  let newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n\
    \            encryptedString.append(newChar)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a33a63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a3375a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a3375a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a3375a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a33759bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b1a3388dec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b1a33846660 String.subscript.getter
    + 34

    7    tmp5qmz90b_                        0x000056432868d0ef <unavailable> + 8431

    8    tmp5qmz90b_                        0x000056432868c9fd <unavailable> + 6653

    9    libc.so.6                          0x00002b1a33c4f460 __libc_start_main +
    245

    10   tmp5qmz90b_                        0x000056432868c2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpnxr59zfn/tmpnxr59zfn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bc8db3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bc8aaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bc8aaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bc8aa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxr59zfn                        0x00005565c31c8b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b3bc8f9f460 __libc_start_main +
    245

    6    tmpnxr59zfn                        0x00005565c31c8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            encrypted.append(alphabet[alphabet.index(index, offsetBy:\
    \ 2)])\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppdp0zl6e/tmppdp0zl6e.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9d98b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9d95a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9d95a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9d95a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppdp0zl6e                        0x000055c121f695f7 <unavailable> + 5623

    5    libc.so.6                          0x00002ab9d9a9d460 __libc_start_main +
    245

    6    tmppdp0zl6e                        0x000055c121f69239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedChar = charIndex\
    \ + (2 * 2)\n        encryptedString.append(Character(UnicodeScalar(encryptedChar)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9br6rgoj.swift:20:70: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(encryptedChar)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n    \
    \                                                                 \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let encryptedChar = UnicodeScalar(unicodeEncrypted)!\n\
    \        encrypted.append(Character(encryptedChar))\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmps0w594g1/tmps0w594g1.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0aeabf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0aea8edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0aea8ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0aea8ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0w594g1                        0x0000565210876b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b0aeade2460 __libc_start_main +
    245

    6    tmps0w594g1                        0x0000565210876379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index + 2 * 2\n            if newIndex\
    \ < alphabet.count {\n                encrypted.append(alphabet[newIndex])\n \
    \           } else {\n                encrypted.append(alphabet[newIndex - alphabet.count])\n\
    \            }\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpswbsmydo.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = (index.encodedOffset + 2) % alphabet.count\n\
    \            encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n        }\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpr8jwmdkw/tmpr8jwmdkw.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b96f668ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b96f6385b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b96f6385988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96f63847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8jwmdkw                        0x00005563c142f797 <unavailable> + 6039

    5    libc.so.6                          0x00002b96f687a460 __libc_start_main +
    245

    6    tmpr8jwmdkw                        0x00005563c142f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0qxg1lpb/tmp0qxg1lpb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0069dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b00394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b00394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b003937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0qxg1lpb                        0x00005647b471f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6b00889460 __libc_start_main +
    245

    6    tmp0qxg1lpb                        0x00005647b471ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        if\
    \ let index = alphabet.firstIndex(of: char) {\n            let newIndex = (index\
    \ + 2 * 2) % alphabet.count\n            result.append(alphabet[newIndex])\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprgdk6y3y.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmprgdk6y3y.swift:19:46: error: cannot find 'alphabet' in scope\n\
    \            let newIndex = (index + 2 * 2) % alphabet.count\n               \
    \                              ^~~~~~~~\n/tmp/tmprgdk6y3y.swift:20:27: error:\
    \ cannot find 'alphabet' in scope\n            result.append(alphabet[newIndex])\n\
    \                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 4\n            if\
    \ newIndex > 25 {\n                let newIndex = newIndex - 26\n            \
    \    encryptedString.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted\
    \ += String(alphabet[newIndex])\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmptr45nmd3/tmptr45nmd3.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5083e29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5083b20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5083b20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5083b1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptr45nmd3                        0x000056362432f6d7 <unavailable> + 5847

    5    libc.so.6                          0x00002b5084015460 __libc_start_main +
    245

    6    tmptr45nmd3                        0x000056362432f319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.advanced(by: 2)\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwvu0epow.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 4\n        let newChar = alphabet[newIndex % alphabet.count]\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3amhp_t2.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp3amhp_t2.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmp3amhp_t2.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = Int(char.asciiValue!)\n        let encryptedChar = charIndex\
    \ + 2 * 2\n        encryptedString.append(Character(UnicodeScalar(encryptedChar)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpnbqmgg75/tmpnbqmgg75.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b280473ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2804431b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2804431988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28044307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnbqmgg75                        0x00005602fa5e2b8e <unavailable> + 7054

    5    libc.so.6                          0x00002b2804926460 __libc_start_main +
    245

    6    tmpnbqmgg75                        0x00005602fa5e2389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        if let index = index\
    \ {\n            let newIndex = (index + (2 * 2)) % 26\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3abw8idp.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp3abw8idp.swift:21:36: error: cannot find 'alphabet' in scope\n       \
    \     encryptedString.append(alphabet[newIndex])\n                           \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ unicodeEncrypted = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(unicodeEncrypted)!)\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpz1i0m_7u/tmpz1i0m_7u.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5028b9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5028894b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5028894988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50288937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz1i0m_7u                        0x00005566723c5b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b5028d89460 __libc_start_main +
    245

    6    tmpz1i0m_7u                        0x00005566723c5379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 2\n            encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n        }\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpgq6ntkap/tmpgq6ntkap.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e359a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e3569eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e3569e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e3569d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgq6ntkap                        0x0000558ea8ed86a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b7e35b93460 __libc_start_main +
    245

    6    tmpgq6ntkap                        0x0000558ea8ed82e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = alphabet.firstIndex(of: char)\n        let newCharIndex\
    \ = charIndex! + 2 * 2\n        encryptedString.append(alphabet[newCharIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfiehxls6.swift:18:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.firstIndex(of: char)\n                     \
    \   ^~~~~~~~\n/tmp/tmpfiehxls6.swift:20:32: error: cannot find 'alphabet' in scope\n\
    \        encryptedString.append(alphabet[newCharIndex])\n                    \
    \           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result.append(shiftedCharacter)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmph_c8qb3l/tmph_c8qb3l.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4af1a39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4af1730b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4af1730988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4af172f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph_c8qb3l                        0x00005619c26d2d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b4af1c25460 __libc_start_main +
    245

    6    tmph_c8qb3l                        0x00005619c26d2549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = alphabet.firstIndex(of: char)!\n        let newIndex = (index + 2 *\
    \ 2) % alphabet.count\n        result.append(alphabet[newIndex])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9fwcsiqd.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)!\n                    ^~~~~~~~\n\
    /tmp/tmp9fwcsiqd.swift:19:42: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index + 2 * 2) % alphabet.count\n                          \
    \               ^~~~~~~~\n/tmp/tmp9fwcsiqd.swift:20:23: error: cannot find 'alphabet'\
    \ in scope\n        result.append(alphabet[newIndex])\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       encryptedString.append(encrypt(char: char))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpm67jnnin.swift:18:39: error: incorrect argument label in call (have\
    \ 'char:', expected 's:')\n        encryptedString.append(encrypt(char: char))\n\
    \                                      ^~~~~\n                               \
    \        s\n/tmp/tmpm67jnnin.swift:18:46: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n        encryptedString.append(encrypt(char:\
    \ char))\n                                             ^\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmplj31s0r7/tmplj31s0r7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1e681fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1e6516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1e6516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1e65157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplj31s0r7                        0x00005627ffb7bd4e <unavailable> + 7502

    5    libc.so.6                          0x00002ad1e6a0b460 __libc_start_main +
    245

    6    tmplj31s0r7                        0x00005627ffb7b549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for character in s {\n        if let index =\
    \ alphabet.firstIndex(of: character) {\n            let newIndex = index.encodedOffset\
    \ + 2\n            let newCharacter = alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)]\n            encryptedString.append(newCharacter)\n   \
    \     }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp_3v060ir/tmp_3v060ir.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aecff745c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aecff43cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aecff43c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aecff43b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_3v060ir                        0x0000563d8fe906a7 <unavailable> + 5799

    5    libc.so.6                          0x00002aecff931460 __libc_start_main +
    245

    6    tmp_3v060ir                        0x0000563d8fe902e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + (2 * 2)\n        let newChar = alphabet[newIndex % alphabet.count]\n     \
    \   encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqrmds887.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpqrmds887.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpqrmds887.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let encryptedCharIndex\
    \ = (charIndex + 2 * 2) % 26\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex\
    \ + 97)!)\n        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa84j8z7y.swift:20:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex\
    \ + 97)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2) % 26\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx8kt2mim.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpx8kt2mim.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let newAscii = ascii + 2 * 2\n \
    \       let newChar = Character(UnicodeScalar(newAscii)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbpqp7y_y.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(char.asciiValue!) + 2 * 2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphg9d16db.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(char.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = alphabet.firstIndex(of: char)\n        let newIndex =\
    \ (charIndex! + 2) % 26\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpvj97nfac.swift:18:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.firstIndex(of: char)\n                     \
    \   ^~~~~~~~\n/tmp/tmpvj97nfac.swift:20:32: error: cannot find 'alphabet' in scope\n\
    \        encryptedString.append(alphabet[newIndex])\n                        \
    \       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2) % 26\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx8kt2mim.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpx8kt2mim.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0qxg1lpb/tmp0qxg1lpb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0069dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b00394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b00394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b003937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0qxg1lpb                        0x00005647b471f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6b00889460 __libc_start_main +
    245

    6    tmp0qxg1lpb                        0x00005647b471ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpoh_txgrl/tmpoh_txgrl.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb0ae40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb0ab37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb0ab37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb0ab367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoh_txgrl                        0x0000562d0e383b7e <unavailable> + 7038

    5    libc.so.6                          0x00002afb0b02c460 __libc_start_main +
    245

    6    tmpoh_txgrl                        0x0000562d0e383379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        if newIndex >= alphabet.count {\n            let newIndex =\
    \ newIndex - alphabet.count\n            encryptedString.append(alphabet[newIndex])\n\
    \        } else {\n            encryptedString.append(alphabet[newIndex])\n  \
    \      }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2d72ibab.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp2d72ibab.swift:20:24: error: cannot find 'alphabet' in scope\n       \
    \ if newIndex >= alphabet.count {\n                       ^~~~~~~~\n/tmp/tmp2d72ibab.swift:21:39:\
    \ error: cannot find 'alphabet' in scope\n            let newIndex = newIndex\
    \ - alphabet.count\n                                      ^~~~~~~~\n/tmp/tmp2d72ibab.swift:22:36:\
    \ error: cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n/tmp/tmp2d72ibab.swift:24:36: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let asciiValue = char.asciiValue!\n        if asciiValue >= 97 && asciiValue\
    \ <= 122 {\n            let newAsciiValue = asciiValue + (2 * 2)\n           \
    \ if newAsciiValue > 122 {\n                let diff = newAsciiValue - 122\n \
    \               let newChar = Character(UnicodeScalar(97 + diff - 1)!)\n     \
    \           encryptedString.append(newChar)\n            } else {\n          \
    \      let newChar = Character(UnicodeScalar(newAsciiValue)!)\n              \
    \  encryptedString.append(newChar)\n            }\n        } else {\n        \
    \    encryptedString.append(char)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt2507arx.swift:23:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmpt2507arx.swift:26:69:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAsciiValue)!)\n    \
    \                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n         \
    \                                                           \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue! - 97\n        let newIndex = (index + 2 *\
    \ 2) % 26\n        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n  \
    \      encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9c6apol.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let asciiValue = char.asciiValue {\n            let newAsciiValue =\
    \ asciiValue + (2 * 2)\n            if let newChar = UnicodeScalar(newAsciiValue)\
    \ {\n                encryptedString.append(Character(newChar))\n            }\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpyg6b2_yp.swift:20:16: error: initializer for conditional binding\
    \ must have Optional type, not 'UnicodeScalar' (aka 'Unicode.Scalar')\n      \
    \      if let newChar = UnicodeScalar(newAsciiValue) {\n               ^     \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2\n            let\
    \ newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n\
    \            encryptedString.append(newChar)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmprzq8eey0/tmprzq8eey0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada11396c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada1108db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada1108d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada1108c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprzq8eey0                        0x000056387e5ca6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002ada11582460 __libc_start_main +
    245

    6    tmprzq8eey0                        0x000056387e5ca2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + (2 * 2)) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn8ekra5k.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpn8ekra5k.swift:19:45: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + (2 * 2)) % alphabet.count\n                       \
    \                     ^~~~~~~~\n/tmp/tmpn8ekra5k.swift:20:32: error: cannot find\
    \ 'alphabet' in scope\n        encryptedString.append(alphabet[newIndex])\n  \
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       var asciiValue = char.asciiValue!\n        asciiValue += 2 * 2\n     \
    \   encryptedString.append(Character(UnicodeScalar(asciiValue)!))\n    }\n   \
    \ return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdg4xifhw.swift:20:67: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(asciiValue)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~~^\n       \
    \                                                           \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = alphabet.firstIndex(of: char)\n        let newCharIndex\
    \ = charIndex! + 2 * 2\n        let newChar = alphabet[newCharIndex % alphabet.count]\n\
    \        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpya1ch12l.swift:18:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.firstIndex(of: char)\n                     \
    \   ^~~~~~~~\n/tmp/tmpya1ch12l.swift:20:23: error: cannot find 'alphabet' in scope\n\
    \        let newChar = alphabet[newCharIndex % alphabet.count]\n             \
    \         ^~~~~~~~\n/tmp/tmpya1ch12l.swift:20:47: error: cannot find 'alphabet'\
    \ in scope\n        let newChar = alphabet[newCharIndex % alphabet.count]\n  \
    \                                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let ascii = char.asciiValue {\n            let newAscii = ascii + (2\
    \ * 2)\n            if newAscii > 122 {\n                let diff = newAscii -\
    \ 122\n                let newAscii = 96 + diff\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \            } else {\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt1210ewd.swift:23:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n/tmp/tmpt1210ewd.swift:25:73:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let index = alphabet.firstIndex(of: char)\n        if let index = index {\n\
    \            let newIndex = index + 2 * 2\n            if newIndex > 25 {\n  \
    \              let newIndex = newIndex - 26\n                encrypted.append(alphabet[newIndex])\n\
    \            } else {\n                encrypted.append(alphabet[newIndex])\n\
    \            }\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp93zbv00l.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp93zbv00l.swift:23:34: error: cannot find 'alphabet' in scope\n       \
    \         encrypted.append(alphabet[newIndex])\n                             \
    \    ^~~~~~~~\n/tmp/tmp93zbv00l.swift:25:34: error: cannot find 'alphabet' in\
    \ scope\n                encrypted.append(alphabet[newIndex])\n              \
    \                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        if let index = index\
    \ {\n            let newIndex = index + 2 * 2\n            if newIndex >= alphabet.count\
    \ {\n                let newIndex = newIndex - alphabet.count\n              \
    \  encryptedString.append(alphabet[newIndex])\n            } else {\n        \
    \        encryptedString.append(alphabet[newIndex])\n            }\n        }\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qxvg6ez.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp5qxvg6ez.swift:21:28: error: cannot find 'alphabet' in scope\n       \
    \     if newIndex >= alphabet.count {\n                           ^~~~~~~~\n/tmp/tmp5qxvg6ez.swift:22:43:\
    \ error: cannot find 'alphabet' in scope\n                let newIndex = newIndex\
    \ - alphabet.count\n                                          ^~~~~~~~\n/tmp/tmp5qxvg6ez.swift:23:40:\
    \ error: cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[newIndex])\n\
    \                                       ^~~~~~~~\n/tmp/tmp5qxvg6ez.swift:25:40:\
    \ error: cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[newIndex])\n\
    \                                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let newChar = char.unicodeScalars.first!.value + 2 * 2\n        encryptedString.append(Character(UnicodeScalar(newChar)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp69buxzta/tmp69buxzta.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c84cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c81c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c81c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c81c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp69buxzta                        0x0000559accb94b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ba5c86b6460 __libc_start_main +
    245

    6    tmp69buxzta                        0x0000559accb94379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedChar\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpllh8m9te/tmpllh8m9te.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ebea34c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ebe72bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ebe72b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ebe72a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllh8m9te                        0x000056074a6b6d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b5ebec20460 __libc_start_main +
    245

    6    tmpllh8m9te                        0x000056074a6b6549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        if newIndex > alphabet.count - 1 {\n            let index =\
    \ newIndex - alphabet.count\n            encryptedString.append(alphabet[index])\n\
    \        } else {\n            encryptedString.append(alphabet[newIndex])\n  \
    \      }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprh0br_5b.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmprh0br_5b.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ if newIndex > alphabet.count - 1 {\n                      ^~~~~~~~\n/tmp/tmprh0br_5b.swift:21:36:\
    \ error: cannot find 'alphabet' in scope\n            let index = newIndex - alphabet.count\n\
    \                                   ^~~~~~~~\n/tmp/tmprh0br_5b.swift:22:36: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[index])\n\
    \                                   ^~~~~~~~\n/tmp/tmprh0br_5b.swift:24:36: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n        encryptedString.append(encryptedChar)\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppogvysvb.swift:19:71: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                      \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = alphabet.firstIndex(of: char)\n        let encryptedCharIndex\
    \ = (charIndex! + 2 * 2) % 26\n        encryptedString.append(alphabet[encryptedCharIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpklkrybka.swift:18:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.firstIndex(of: char)\n                     \
    \   ^~~~~~~~\n/tmp/tmpklkrybka.swift:20:32: error: cannot find 'alphabet' in scope\n\
    \        encryptedString.append(alphabet[encryptedCharIndex])\n              \
    \                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.advanced(by: 2)\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwvu0epow.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let unicodeString = String(unicode,\
    \ radix: 16)\n        let unicodeInt = Int(unicodeString, radix: 16)!\n      \
    \  let newUnicode = unicodeInt + (2 * 2)\n        let newUnicodeString = String(newUnicode,\
    \ radix: 16)\n        let newUnicodeScalar = UnicodeScalar(UInt32(newUnicodeString,\
    \ radix: 16)!)\n        result.append(Character(newUnicodeScalar))\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc56w0jck.swift:24:33: error: value of optional type 'Unicode.Scalar?'\
    \ must be unwrapped to a value of type 'Unicode.Scalar'\n        result.append(Character(newUnicodeScalar))\n\
    \                                ^\n/tmp/tmpc56w0jck.swift:23:13: note: short-circuit\
    \ using 'guard' to exit this function early if the optional value contains 'nil'\n\
    \        let newUnicodeScalar = UnicodeScalar(UInt32(newUnicodeString, radix:\
    \ 16)!)\n            ^\n        guard                                        \
    \                              else { return <#default value#> }\n/tmp/tmpc56w0jck.swift:23:32:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let newUnicodeScalar = UnicodeScalar(UInt32(newUnicodeString,\
    \ radix: 16)!)\n                               ^\n                           \
    \                                                        ?? <#default value#>\n\
    /tmp/tmpc56w0jck.swift:23:32: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let newUnicodeScalar = UnicodeScalar(UInt32(newUnicodeString,\
    \ radix: 16)!)\n                               ^\n                           \
    \                                                       !\n/tmp/tmpc56w0jck.swift:24:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result.append(Character(newUnicodeScalar))\n                \
    \                ^\n                                                 ?? <#default\
    \ value#>\n/tmp/tmpc56w0jck.swift:24:33: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result.append(Character(newUnicodeScalar))\n\
    \                                ^\n                                         \
    \       !\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0qxg1lpb/tmp0qxg1lpb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0069dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b00394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b00394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b003937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0qxg1lpb                        0x00005647b471f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6b00889460 __libc_start_main +
    245

    6    tmp0qxg1lpb                        0x00005647b471ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let lowercased = s.lowercased()\n    var encrypted = \"\"\n    for char in lowercased\
    \ {\n        if let index = alphabet.firstIndex(of: char) {\n            let newIndex\
    \ = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        } else {\n            encrypted.append(char)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoy279ojf.swift:21:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index + 2 * 2\n            if newIndex\
    \ > alphabet.count - 1 {\n                let newIndex = newIndex - alphabet.count\n\
    \                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc6s2xxa_.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n   \
    \         encrypted.append(Character(UnicodeScalar(ascii + 2)!))\n        } else\
    \ if ascii >= 65 && ascii <= 90 {\n            encrypted.append(Character(UnicodeScalar(ascii\
    \ + 2)!))\n        } else {\n            encrypted.append(char)\n        }\n \
    \   }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmptz7v6yt1.swift:20:64: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            encrypted.append(Character(UnicodeScalar(ascii\
    \ + 2)!))\n                                       ~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                               \n/tmp/tmptz7v6yt1.swift:22:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            encrypted.append(Character(UnicodeScalar(ascii + 2)!))\n        \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                             \n"
  stdout: ''
  timestamp: 1659824754
