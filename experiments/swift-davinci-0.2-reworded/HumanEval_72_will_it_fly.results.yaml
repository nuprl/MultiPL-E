language: swift
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return q.count == 1 ||\
    \ (sum <= w && q == q.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var left = 0\n    var right\
    \ = q.count - 1\n    while left < right {\n        if q[left] != q[right] {\n\
    \            return false\n        }\n        left += 1\n        right -= 1\n\
    \    }\n    return q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var sum = 0\n    for i\
    \ in 0..<q.count {\n        sum += q[i]\n    }\n    if sum > w {\n        return\
    \ false\n    }\n    var left = 0\n    var right = q.count - 1\n    while left\
    \ < right {\n        if q[left] != q[right] {\n            return false\n    \
    \    }\n        left += 1\n        right -= 1\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return is_balanced(q: q)\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpymd7p_38.swift:19:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && sum <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    var sum = 0\n    for i in 0..<q.count\
    \ {\n        sum += q[i]\n    }\n    if sum > w {\n        return false\n    }\n\
    \    var left = 0\n    var right = q.count - 1\n    while left < right {\n   \
    \     if q[left] != q[right] {\n            return false\n        }\n        left\
    \ += 1\n        right -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum <= w {\n       \
    \ let firstHalf = q[0..<q.count/2]\n        let secondHalf = q[q.count/2..<q.count]\n\
    \        let reversedSecondHalf = secondHalf.reversed()\n        return firstHalf\
    \ == reversedSecondHalf\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl5ybhayr.swift:23:29: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n        return firstHalf == reversedSecondHalf\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count == 1 || q.count == 2 && q[0] == q[1] ?\
    \ true : q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum <= w {\n       \
    \ return is_palindrome(q)\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9s4gl_xp.swift:20:16: error: cannot find 'is_palindrome' in scope\n\
    \        return is_palindrome(q)\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var i = 0\n    var j =\
    \ q.count - 1\n    while i < j {\n        if q[i] != q[j] {\n            return\
    \ false\n        }\n        i += 1\n        j -= 1\n    }\n    return q.reduce(0,\
    \ +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    let sum = q.reduce(0, +)\n\
    \    if sum > w {\n        return false\n    }\n    let half = q.count / 2\n \
    \   let firstHalf = q[0..<half]\n    let secondHalf = q[half+1..<q.count]\n  \
    \  return firstHalf == secondHalf.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfvu_sn47.swift:31:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'ArraySlice<Int>' and '[Int]'\n    return firstHalf == secondHalf.reversed()\n\
    \           ~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    var i = 0\n    var j =\
    \ q.count - 1\n    while i < j {\n        if q[i] != q[j] {\n            return\
    \ false\n        }\n        i += 1\n        j -= 1\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    return q == q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    if q.count == 1 {\n  \
    \      return true\n    }\n    var i = 0\n    var j = q.count - 1\n    while i\
    \ < j {\n        if q[i] != q[j] {\n            return false\n        }\n    \
    \    i += 1\n        j -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q.count % 2 == 0 {\n            for i in 0..<q.count/2\
    \ {\n                if q[i] != q[q.count-1-i] {\n                    return false\n\
    \                }\n            }\n            return true\n        } else {\n\
    \            for i in 0..<q.count/2 {\n                if q[i] != q[q.count-1-i]\
    \ {\n                    return false\n                }\n            }\n    \
    \        return true\n        }\n    } else {\n        return false\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return q[0] == q[1]\n    }\n    if q.count % 2 == 0\
    \ {\n        return false\n    }\n    var sum = 0\n    for i in 0..<q.count {\n\
    \        sum += q[i]\n    }\n    if sum > w {\n        return false\n    }\n \
    \   for i in 0..<q.count/2 {\n        if q[i] != q[q.count - 1 - i] {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q.count == 1 {\n            return true\n \
    \       }\n        var i = 0\n        var j = q.count - 1\n        while i < j\
    \ {\n            if q[i] != q[j] {\n                return false\n           \
    \ }\n            i += 1\n            j -= 1\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    var\
    \ sum = 0\n    for i in 0..<q.count {\n        sum += q[i]\n    }\n    if sum\
    \ > w {\n        return false\n    }\n    var i = 0\n    var j = q.count - 1\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false\n    \
    \    }\n        i += 1\n        j -= 1\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.isPalindrome() && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps7l15_0_.swift:18:14: error: value of type '[Int]' has no member\
    \ 'isPalindrome'\n    return q.isPalindrome() && q.reduce(0, +) <= w\n       \
    \    ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var sum = 0\n    for i\
    \ in 0..<q.count {\n        sum += q[i]\n    }\n    if sum > w {\n        return\
    \ false\n    }\n    for i in 0..<q.count/2 {\n        if q[i] != q[q.count-1-i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q.count\
    \ % 2 == 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n    return sum <= w && isBalanced\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6p_62bvq.swift:19:84: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n    let isBalanced = q.count %\
    \ 2 == 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n                                   \
    \                                                ^\n/tmp/tmp6p_62bvq.swift:19:142:\
    \ error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>' to\
    \ expected argument type 'ArraySlice<Int>'\n    let isBalanced = q.count % 2 ==\
    \ 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n                                   \
    \                                                                            \
    \                              ^\n"
  stdout: ''
  timestamp: 1660014095
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return is_balanced(q: q)\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpymd7p_38.swift:19:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && sum <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q.count == 1 {\n            return true\n \
    \       }\n        var i = 0\n        var j = q.count - 1\n        while i < j\
    \ {\n            if q[i] != q[j] {\n                return false\n           \
    \ }\n            i += 1\n            j -= 1\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q == q.reversed() {\n            return true\n\
    \        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    if q == reversed {\n    \
    \    return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpulo41l9l.swift:23:13: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    if q == reversed {\n            ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var sum = 0\n    for i\
    \ in 0..<q.count {\n        sum += q[i]\n    }\n    if sum > w {\n        return\
    \ false\n    }\n    var i = 0\n    var j = q.count - 1\n    while i < j {\n  \
    \      if q[i] != q[j] {\n            return false\n        }\n        i += 1\n\
    \        j -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var left = 0\n    var right\
    \ = q.count - 1\n    while left < right {\n        if q[left] != q[right] {\n\
    \            return false\n        }\n        left += 1\n        right -= 1\n\
    \    }\n    return q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    return q == reversed\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqkxxecjd.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == reversed\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var left = 0\n    var right\
    \ = q.count - 1\n    while left < right {\n        if q[left] != q[right] {\n\
    \            return false\n        }\n        left += 1\n        right -= 1\n\
    \    }\n    return q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    for i in 0..<q.count /\
    \ 2 {\n        if q[i] != q[q.count - i - 1] {\n            return false\n   \
    \     }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    return q == reversed\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqkxxecjd.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == reversed\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var sum = 0\n    for i\
    \ in 0..<q.count {\n        sum += q[i]\n    }\n    if sum > w {\n        return\
    \ false\n    }\n    var i = 0\n    var j = q.count - 1\n    while i < j {\n  \
    \      if q[i] != q[j] {\n            return false\n        }\n        i += 1\n\
    \        j -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        for i in 0..<q.count/2 {\n            if q[i]\
    \ != q[q.count-1-i] {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    if q.count % 2 == 0 {\n   \
    \     return false\n    }\n    var sum = 0\n    for i in 0..<q.count {\n     \
    \   sum += q[i]\n    }\n    if sum > w {\n        return false\n    }\n    for\
    \ i in 0..<q.count/2 {\n        if q[i] != q[q.count-1-i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    if q.count % 2 == 0 {\n   \
    \     return false\n    }\n    var sum = 0\n    for i in 0..<q.count {\n     \
    \   sum += q[i]\n    }\n    if sum > w {\n        return false\n    }\n    var\
    \ left = 0\n    var right = q.count - 1\n    while left < right {\n        if\
    \ q[left] != q[right] {\n            return false\n        }\n        left +=\
    \ 1\n        right -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q.count\
    \ % 2 == 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n    return sum <= w && isBalanced\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6p_62bvq.swift:19:84: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n    let isBalanced = q.count %\
    \ 2 == 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n                                   \
    \                                                ^\n/tmp/tmp6p_62bvq.swift:19:142:\
    \ error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>' to\
    \ expected argument type 'ArraySlice<Int>'\n    let isBalanced = q.count % 2 ==\
    \ 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n                                   \
    \                                                                            \
    \                              ^\n"
  stdout: ''
  timestamp: 1660014095
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return is_palindrome(q)\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1oji6ylt.swift:19:12: error: cannot find 'is_palindrome' in scope\n\
    \    return is_palindrome(q) && sum <= w\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let q_reversed = q.reversed()\n    return q == q_reversed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp87sq7ei6.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == q_reversed\n            \
    \    ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    var i = 0\n    var j = q.count - 1\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false\n    \
    \    }\n        i += 1\n        j -= 1\n    }\n    for i in q {\n        sum +=\
    \ i\n    }\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q.elementsEqual(q.reversed())\n\
    \    return isBalanced && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    for i in 0..<q.count {\n\
    \        if q[i] != reversed[i] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpz7xp1z25.swift:24:29: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[Int]>.Index'\n        if q[i]\
    \ != reversed[i] {\n                            ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q.elementsEqual(q.reversed())\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    var i = 0\n    var j =\
    \ q.count - 1\n    while i < j {\n        if q[i] != q[j] {\n            return\
    \ false\n        }\n        i += 1\n        j -= 1\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    return q == reversed\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqkxxecjd.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == reversed\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w && q == q.reversed() {\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    for i in 0..<q.count {\n\
    \        if q[i] != reversed[i] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpz7xp1z25.swift:24:29: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[Int]>.Index'\n        if q[i]\
    \ != reversed[i] {\n                            ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    for i in 0..<q.count/2\
    \ {\n        if q[i] != q[q.count-1-i] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    return q == reversed\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqkxxecjd.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == reversed\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q == q.reversed() {\n            return true\n\
    \        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    for i in 0..<q.count {\n\
    \        if q[i] != reversed[i] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpz7xp1z25.swift:24:29: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[Int]>.Index'\n        if q[i]\
    \ != reversed[i] {\n                            ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    guard q.count\
    \ % 2 == 0 else { return false }\n    guard q.reduce(0, +) <= w else { return\
    \ false }\n    var i = 0\n    var j = q.count - 1\n    while i < j {\n       \
    \ if q[i] != q[j] {\n            return false\n        }\n        i += 1\n   \
    \     j -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpysxvxscr/tmpysxvxscr.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae290b5dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae290854b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae290854988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2908537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpysxvxscr                        0x00005634c517d4bf <unavailable> + 5311

    5    libc.so.6                          0x00002ae290d49460 __libc_start_main +
    245

    6    tmpysxvxscr                        0x00005634c517d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q == q.reversed() {\n            return true\n\
    \        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    let middle = q.count /\
    \ 2\n    let left = q[0..<middle]\n    let right = q[middle+1..<q.count]\n   \
    \ if left == right.reversed() && left.reduce(0, +) <= w {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpj2gop6eg.swift:27:22: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n    if left == right.reversed()\
    \ && left.reduce(0, +) <= w {\n                     ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    return q == reversed\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqkxxecjd.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == reversed\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    var left = 0\n    var\
    \ right = q.count - 1\n    while left < right {\n        if q[left] != q[right]\
    \ {\n            return false\n        }\n        left += 1\n        right -=\
    \ 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    for i in 0..<q.count/2\
    \ {\n        if q[i] != q[q.count-1-i] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    var q = q\n    while !q.isEmpty {\n\
    \        sum += q.removeFirst()\n        if sum > w {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpr5648acm/tmpr5648acm.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf5b6d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf5b3c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf5b3c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf5b3c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr5648acm                        0x00005650924214fb <unavailable> + 5371

    5    libc.so.6                          0x00002abf5b8bd460 __libc_start_main +
    245

    6    tmpr5648acm                        0x00005650924210a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    if q.count % 2 == 0 {\n   \
    \     return false\n    }\n    var sum = 0\n    for i in 0..<q.count {\n     \
    \   sum += q[i]\n    }\n    if sum > w {\n        return false\n    }\n    var\
    \ left = 0\n    var right = q.count - 1\n    while left < right {\n        if\
    \ q[left] != q[right] {\n            return false\n        }\n        left +=\
    \ 1\n        right -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    if q.count % 2 == 0 {\n   \
    \     return false\n    }\n    var sum = 0\n    for i in 0..<q.count {\n     \
    \   sum += q[i]\n    }\n    if sum > w {\n        return false\n    }\n    var\
    \ left = 0\n    var right = q.count - 1\n    while left < right {\n        if\
    \ q[left] != q[right] {\n            return false\n        }\n        left +=\
    \ 1\n        right -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var left = 0\n    var right\
    \ = q.count - 1\n    while left < right {\n        if q[left] != q[right] {\n\
    \            return false\n        }\n        left += 1\n        right -= 1\n\
    \    }\n    return q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    for i in 0..<q.count/2 {\n        if q[i] != q[q.count-1-i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else {\n        return true\n    }\n\
    \    var sum = 0\n    for i in 0..<q.count {\n        sum += q[i]\n    }\n   \
    \ if sum > w {\n        return false\n    }\n    for i in 0..<q.count/2 {\n  \
    \      if q[i] != q[q.count-1-i] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q == q.reversed() {\n            return true\n\
    \        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        for i in 0..<q.count/2 {\n            if q[i]\
    \ != q[q.count-1-i] {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        if q == q.reversed() {\n            return true\n\
    \        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let reversed = q.reversed()\n    return q == reversed\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqkxxecjd.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == reversed\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    if q.count % 2 == 0 {\n   \
    \     return false\n    }\n    var left = 0\n    var right = q.count - 1\n   \
    \ while left < right {\n        if q[left] != q[right] {\n            return false\n\
    \        }\n        left += 1\n        right -= 1\n    }\n    return q.reduce(0,\
    \ +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    var arr = q\n    arr.reverse()\n\
    \    if arr == q {\n        return true\n    }\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q == q.reversed()\n\
    \    return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && sum(q: q) <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcvs18pgx.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && sum(q: q) <= w\n           ^~~~~~~~~~~\n/tmp/tmpcvs18pgx.swift:18:33:\
    \ error: cannot find 'sum' in scope\n    return is_balanced(q: q) && sum(q: q)\
    \ <= w\n                                ^~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    var sum = 0\n    for i in 0..<q.count\
    \ {\n        sum += q[i]\n    }\n    if sum > w {\n        return false\n    }\n\
    \    var left = 0\n    var right = q.count - 1\n    while left < right {\n   \
    \     if q[left] != q[right] {\n            return false\n        }\n        left\
    \ += 1\n        right -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        return true\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpnxn8kzb8/tmpnxn8kzb8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af95e9bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af95e6b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af95e6b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af95e6b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxn8kzb8                        0x000055631bf9552b <unavailable> + 5419

    5    libc.so.6                          0x00002af95eba7460 __libc_start_main +
    245

    6    tmpnxn8kzb8                        0x000055631bf950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    let half = q.count / 2\n\
    \    let left = q[0..<half]\n    let right = q[half..<q.count]\n    let leftSum\
    \ = left.reduce(0, +)\n    let rightSum = right.reduce(0, +)\n    let isBalanced\
    \ = left == right.reversed()\n    return isBalanced && leftSum + rightSum <= w\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9gef6xwn.swift:29:27: error: binary operator '==' cannot be applied\
    \ to operands of type 'ArraySlice<Int>' and '[Int]'\n    let isBalanced = left\
    \ == right.reversed()\n                     ~~~~ ^  ~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return is_palindrome(q)\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1oji6ylt.swift:19:12: error: cannot find 'is_palindrome' in scope\n\
    \    return is_palindrome(q) && sum <= w\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
