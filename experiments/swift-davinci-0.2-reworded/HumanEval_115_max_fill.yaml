name: HumanEval_115_max_fill
language: swift
prompt: "\n/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n/// 5\n/// Example 3:\n///\
  \ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  func max_fill(grid: [[Int]], capacity: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
  \ 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
  \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], capacity: 9) == 2)"
completions: ["    var grid = grid\n    var count = 0\n    var filled = 0\n    var\
    \ i = 0\n    while i < grid.count {\n        var j = 0\n        while j < grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                filled += 1\n         \
    \       grid[i][j] = 0\n            }\n            j += 1\n        }\n       \
    \ if filled == capacity {\n            filled = 0\n            count += 1\n  \
    \      }\n        i += 1\n    }\n    return count", "    var grid = grid\n   \
    \ var count = 0\n    while true {\n        var isEmpty = true\n        for i in\
    \ 0..<grid.count {\n            for j in 0..<grid[i].count {\n               \
    \ if grid[i][j] == 1 {\n                    isEmpty = false\n                \
    \    grid[i][j] = 0\n                    count += 1\n                }\n     \
    \       }\n        }\n        if isEmpty {\n            break\n        }\n   \
    \     for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n  \
    \              if grid[i][j] == 0 {\n                    grid[i][j] = 1\n    \
    \            }\n            }\n        }\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  var row = 0\n    while row < grid.count {\n        var col = 0\n        while\
    \ col < grid[row].count {\n            if grid[row][col] == 1 {\n            \
    \    count += 1\n                var bucket = capacity\n                while\
    \ bucket > 0 {\n                    if row < grid.count && grid[row][col] == 1\
    \ {\n                        grid[row][col] = 0\n                        bucket\
    \ -= 1\n                    }\n                    row += 1\n                }\n\
    \                row -= 1\n            }\n            col += 1\n        }\n  \
    \      row += 1\n    }\n    return count", "    var grid = grid\n    var count\
    \ = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 1 {\n                count += 1\n               \
    \ fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n\
    \    }\n    return count", "    var grid = grid\n    var count = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                fill(grid: &grid, i: i,\
    \ j: j, capacity: capacity)\n            }\n        }\n    }\n    return count",
  "    var buckets = [Int](repeating: 0, count: grid[0].count)\n    var count = 0\n\
    \    for row in grid {\n        for (i, well) in row.enumerated() {\n        \
    \    if well == 1 {\n                if buckets[i] < capacity {\n            \
    \        buckets[i] += 1\n                    count += 1\n                }\n\
    \            }\n        }\n    }\n    return count", "    var grid = grid\n  \
    \  var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      for k in i..<grid.count {\n                    if grid[k][j] == 1 {\n \
    \                       grid[k][j] = 0\n                    } else {\n       \
    \                 break\n                    }\n                }\n          \
    \  }\n        }\n    }\n    return count", "    var count = 0\n    var max = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max += 1\n            }\n        }\n    }\n    while count <\
    \ max {\n        for row in grid {\n            for cell in row {\n          \
    \      if cell == 1 {\n                    count += 1\n                }\n   \
    \         }\n        }\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \        if !filled {\n            break\n        }\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 0 {\n                    grid[i][j] = 1\n                }\n            }\n\
    \        }\n    }\n    return count", "    var buckets = [Int](repeating: 0, count:\
    \ grid[0].count)\n    var count = 0\n    for row in grid {\n        for (index,\
    \ well) in row.enumerated() {\n            if well == 1 {\n                buckets[index]\
    \ += 1\n            }\n        }\n        count += fill_buckets(buckets: &buckets,\
    \ capacity: capacity)\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n      \
    \          count += 1\n                var k = i\n                while k < grid.count\
    \ && capacity > 0 {\n                    if grid[k][j] == 1 {\n              \
    \          grid[k][j] = 0\n                        capacity -= 1\n           \
    \         }\n                    k += 1\n                }\n            }\n  \
    \      }\n    }\n    return count", "    var grid = grid\n    var count = 0\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                count += 1\n                for k\
    \ in 0..<capacity {\n                    if i+k < grid.count {\n             \
    \           grid[i+k][j] = 0\n                    }\n                }\n     \
    \       }\n        }\n    }\n    return count", "    var max_fill = 0\n    var\
    \ buckets = [Int](repeating: 0, count: grid[0].count)\n    for row in grid {\n\
    \        for (i, well) in row.enumerated() {\n            if well == 1 {\n   \
    \             buckets[i] += 1\n            }\n        }\n        max_fill += fill_buckets(buckets:\
    \ &buckets, capacity: capacity)\n    }\n    return max_fill", "    var grid =\
    \ grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var depth = 0\n    var buckets = 0\n  \
    \  for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                depth += 1\n            }\n        }\n    }\n    buckets = depth\
    \ / capacity\n    if depth % capacity != 0 {\n        buckets += 1\n    }\n  \
    \  return buckets", "    var grid = grid\n    var count = 0\n    while true {\n\
    \        var filled = false\n        for i in 0..<grid.count {\n            for\
    \ j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n           \
    \         filled = true\n                    grid[i][j] = 0\n                \
    \    if i > 0 {\n                        grid[i - 1][j] = min(grid[i - 1][j] +\
    \ 1, capacity)\n                    }\n                    if i < grid.count -\
    \ 1 {\n                        grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n\
    \                    if j < grid[i].count - 1 {\n                        grid[i][j\
    \ + 1] = min(grid[i][j + 1] + 1, capacity)\n                    }\n          \
    \      }\n            }\n        }\n        if !filled {\n            break\n\
    \        }\n        count += 1\n    }\n    return count", "    var result = 0\n\
    \    var currentCapacity = capacity\n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n               \
    \ if currentCapacity == 0 {\n                    currentCapacity = capacity\n\
    \                    result += 1\n                }\n                currentCapacity\
    \ -= 1\n            }\n        }\n    }\n    return result", "    var count =\
    \ 0\n    var max = 0\n    for row in grid {\n        for item in row {\n     \
    \       if item == 1 {\n                count += 1\n            }\n        }\n\
    \        if count > max {\n            max = count\n        }\n        count =\
    \ 0\n    }\n    return max * capacity", "    var grid = grid\n    var count =\
    \ 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n   \
    \         if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var grid = grid\n    var count = 0\n    var i = 0\n   \
    \ while i < grid.count {\n        var j = 0\n        while j < grid[i].count {\n\
    \            if grid[i][j] == 1 {\n                grid[i][j] = 0\n          \
    \      count += 1\n                var k = i + 1\n                while k < grid.count\
    \ && capacity > 0 {\n                    if grid[k][j] == 1 {\n              \
    \          grid[k][j] = 0\n                        capacity -= 1\n           \
    \         }\n                    k += 1\n                }\n            }\n  \
    \          j += 1\n        }\n        i += 1\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    while true {\n        var found = false\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] == 1 {\n                    found = true\n    \
    \                grid[i][j] = 0\n                    count += 1\n            \
    \    }\n            }\n        }\n        if !found {\n            break\n   \
    \     }\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 0 {\n                    grid[i][j] = 1\n\
    \                }\n            }\n        }\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    var row = 0\n    while row < grid.count\
    \ {\n        var col = 0\n        while col < grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                count += 1\n                var bucket\
    \ = capacity\n                while bucket > 0 {\n                    if row <\
    \ grid.count && grid[row][col] == 1 {\n                        grid[row][col]\
    \ = 0\n                        bucket -= 1\n                    }\n          \
    \          row += 1\n                }\n                row -= 1\n           \
    \ }\n            col += 1\n        }\n        row += 1\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    while true {\n        var max = 0\n\
    \        var max_i = 0\n        for i in 0..<grid.count {\n            var sum\
    \ = 0\n            for j in 0..<grid[i].count {\n                sum += grid[i][j]\n\
    \            }\n            if sum > max {\n                max = sum\n      \
    \          max_i = i\n            }\n        }\n        if max == 0 {\n      \
    \      break\n        }\n        for j in 0..<grid[max_i].count {\n          \
    \  if grid[max_i][j] == 1 {\n                grid[max_i][j] = 0\n            \
    \    count += 1\n            }\n        }\n    }\n    return count", "    var\
    \ result = 0\n    for row in grid {\n        var current_capacity = capacity\n\
    \        for well in row {\n            if well == 1 {\n                if current_capacity\
    \ == 0 {\n                    result += 1\n                    current_capacity\
    \ = capacity\n                }\n                current_capacity -= 1\n     \
    \       }\n        }\n    }\n    return result", "    var grid = grid\n    var\
    \ count = 0\n    while !grid.isEmpty {\n        var max = 0\n        var maxIndex\
    \ = 0\n        for i in 0..<grid.count {\n            let sum = grid[i].reduce(0,\
    \ +)\n            if sum > max {\n                max = sum\n                maxIndex\
    \ = i\n            }\n        }\n        if max > capacity {\n            for\
    \ i in 0..<grid[maxIndex].count {\n                if grid[maxIndex][i] == 1 {\n\
    \                    grid[maxIndex][i] = 0\n                    count += 1\n \
    \               }\n            }\n        } else {\n            grid.remove(at:\
    \ maxIndex)\n        }\n    }\n    return count", "    var result = 0\n    var\
    \ grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                result += 1\n         \
    \       grid = fill(grid: grid, i: i, j: j, capacity: capacity)\n            }\n\
    \        }\n    }\n    return result", "    var result = 0\n    var row = 0\n\
    \    var col = 0\n    while row < grid.count {\n        while col < grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                result += 1\n     \
    \           col += capacity\n            } else {\n                col += 1\n\
    \            }\n        }\n        row += 1\n        col = 0\n    }\n    return\
    \ result", "    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        while col < grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                grid[row][col] = 0\n   \
    \             count += 1\n                var i = row\n                while i\
    \ < row + capacity {\n                    if i < grid.count {\n              \
    \          grid[i][col] = 0\n                    }\n                    i += 1\n\
    \                }\n            }\n            col += 1\n        }\n        col\
    \ = 0\n        row += 1\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      for k in 0..<capacity {\n                    if i + k < grid.count {\n\
    \                        grid[i + k][j] = 0\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return count", "    var grid =\
    \ grid\n    var count = 0\n    var max = 0\n    for i in 0..<grid.count {\n  \
    \      for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n      \
    \          count += 1\n            }\n        }\n        if count > max {\n  \
    \          max = count\n        }\n        count = 0\n    }\n    return max *\
    \ capacity", "    var grid = grid\n    var count = 0\n    var row = 0\n    var\
    \ col = 0\n    while row < grid.count {\n        while col < grid[row].count {\n\
    \            if grid[row][col] == 1 {\n                grid[row][col] = 0\n  \
    \              count += 1\n                if row + 1 < grid.count {\n       \
    \             grid[row + 1][col] = 1\n                }\n            }\n     \
    \       col += 1\n        }\n        col = 0\n        row += 1\n    }\n    return\
    \ count", "    var grid = grid\n    var count = 0\n    var row = 0\n    var col\
    \ = 0\n    while row < grid.count {\n        if grid[row][col] == 1 {\n      \
    \      grid[row][col] = 0\n            count += 1\n        }\n        if col ==\
    \ grid[row].count - 1 {\n            row += 1\n            col = 0\n        }\
    \ else {\n            col += 1\n        }\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    while true {\n        var max = 0\n    \
    \    var max_i = 0\n        for i in 0..<grid.count {\n            var sum = 0\n\
    \            for j in 0..<grid[i].count {\n                sum += grid[i][j]\n\
    \            }\n            if sum > max {\n                max = sum\n      \
    \          max_i = i\n            }\n        }\n        if max == 0 {\n      \
    \      break\n        }\n        for j in 0..<grid[max_i].count {\n          \
    \  if grid[max_i][j] == 1 {\n                grid[max_i][j] = 0\n            \
    \    count += 1\n            }\n        }\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j\
    \ in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                count\
    \ += 1\n                fill(grid: &grid, capacity: capacity, i: i, j: j)\n  \
    \          }\n        }\n    }\n    return count", "    var count = 0\n    var\
    \ grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, capacity: capacity, i: i, j: j)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var count = 0\n    var grid = grid\n    for row in grid\
    \ {\n        for col in row {\n            if col == 1 {\n                count\
    \ += 1\n            }\n        }\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var count = 0\n    var grid = grid\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                if\
    \ i + 1 < grid.count {\n                    grid[i + 1][j] = 1\n             \
    \   }\n            }\n        }\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    var row = 0\n    var col = 0\n    while row < grid.count\
    \ {\n        while col < grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                grid[row][col] = 0\n                count += 1\n        \
    \        if capacity > 1 {\n                    for i in row..<row+capacity {\n\
    \                        if i < grid.count {\n                            for\
    \ j in col..<col+capacity {\n                                if j < grid[i].count\
    \ {\n                                    grid[i][j] = 0\n                    \
    \            }\n                            }\n                        }\n   \
    \                 }\n                }\n            }\n            col += 1\n\
    \        }\n        col = 0\n        row += 1\n    }\n    return count", "   \
    \ var result = 0\n    var max_well = 0\n    for row in grid {\n        max_well\
    \ = max(max_well, row.reduce(0, +))\n    }\n    var current_fill = 0\n    while\
    \ current_fill < max_well {\n        for row in grid {\n            var current_row_fill\
    \ = 0\n            for well in row {\n                if well == 1 {\n       \
    \             current_row_fill += 1\n                } else {\n              \
    \      if current_row_fill > 0 {\n                        result += 1\n      \
    \                  current_row_fill = 0\n                    }\n             \
    \   }\n            }\n            if current_row_fill > 0 {\n                result\
    \ += 1\n            }\n        }\n        current_fill += capacity\n    }\n  \
    \  return result", "    var result = 0\n    var max = 0\n    var min = 0\n   \
    \ for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n          \
    \  if grid[i][j] == 1 {\n                max += 1\n            }\n        }\n\
    \    }\n    while min <= max {\n        let mid = (min + max) / 2\n        if\
    \ is_possible(grid: grid, capacity: capacity, mid) {\n            result = mid\n\
    \            min = mid + 1\n        } else {\n            max = mid - 1\n    \
    \    }\n    }\n    return result", "    var count = 0\n    var grid = grid\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var grid = grid\n    var count = 0\n    while true {\n\
    \        var isEmpty = true\n        for i in 0..<grid.count {\n            for\
    \ j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n           \
    \         isEmpty = false\n                    grid[i][j] = 0\n              \
    \      count += 1\n                }\n            }\n        }\n        if isEmpty\
    \ {\n            break\n        }\n        for i in 0..<grid.count {\n       \
    \     for j in 0..<grid[i].count {\n                if grid[i][j] == 0 {\n   \
    \                 grid[i][j] = 1\n                }\n            }\n        }\n\
    \    }\n    return count", "    var result = 0\n    var max_row = 0\n    var max_col\
    \ = 0\n    for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n\
    \    }\n    for col in 0..<grid[0].count {\n        max_col = max(max_col, grid.map{\
    \ $0[col] }.reduce(0, +))\n    }\n    result = max(max_row, max_col)\n    return\
    \ result", "    var grid = grid\n    var count = 0\n    var i = 0\n    while i\
    \ < grid.count {\n        var j = 0\n        while j < grid[i].count {\n     \
    \       if grid[i][j] == 1 {\n                grid[i][j] = 0\n               \
    \ count += 1\n                var k = i + 1\n                while k < grid.count\
    \ && capacity > 0 {\n                    if grid[k][j] == 1 {\n              \
    \          grid[k][j] = 0\n                        capacity -= 1\n           \
    \         }\n                    k += 1\n                }\n            }\n  \
    \          j += 1\n        }\n        i += 1\n    }\n    return count", "    var\
    \ max_fill = 0\n    for row in grid {\n        max_fill += row.reduce(0, +)\n\
    \    }\n    return max_fill / capacity", "    var grid = grid\n    var count =\
    \ 0\n    while true {\n        var allZero = true\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    allZero = false\n                    grid[i][j] = 0\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \        if allZero {\n            break\n        }\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 0 {\n                    grid[i][j] = 1\n                }\n            }\n\
    \        }\n    }\n    return count", "    var grid = grid\n    var count = 0\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                count += 1\n                for k\
    \ in 0..<capacity {\n                    if i + k < grid.count {\n           \
    \             grid[i + k][j] = 0\n                    }\n                }\n \
    \           }\n        }\n    }\n    return count", "    var result = 0\n    for\
    \ i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if\
    \ grid[i][j] == 1 {\n                result += 1\n            }\n        }\n \
    \   }\n    return result * capacity", "    var grid = grid\n    var count = 0\n\
    \    while !grid.isEmpty {\n        var row = grid.removeFirst()\n        while\
    \ !row.isEmpty {\n            let bucket = row.removeFirst()\n            if bucket\
    \ == 1 {\n                count += 1\n            }\n        }\n    }\n    return\
    \ count", "    var result = 0\n    let rowCount = grid.count\n    let columnCount\
    \ = grid[0].count\n    for i in 0..<rowCount {\n        for j in 0..<columnCount\
    \ {\n            if grid[i][j] == 1 {\n                result += capacity\n  \
    \          }\n        }\n    }\n    return result", "    var grid = grid\n   \
    \ var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      grid[i][j] = 0\n                var k = i\n                while k > 0\
    \ && grid[k - 1][j] == 1 {\n                    grid[k - 1][j] = 0\n         \
    \           k -= 1\n                }\n            }\n        }\n    }\n    return\
    \ count", "    var result = 0\n    var max_height = 0\n    for row in grid {\n\
    \        max_height = max(max_height, row.reduce(0, +))\n    }\n    for height\
    \ in 1...max_height {\n        for row in grid {\n            var row_result =\
    \ 0\n            for well in row {\n                if well >= height {\n    \
    \                row_result += 1\n                }\n            }\n         \
    \   result += row_result / capacity\n            if row_result % capacity != 0\
    \ {\n                result += 1\n            }\n        }\n    }\n    return\
    \ result", "    var grid = grid\n    var count = 0\n    while true {\n       \
    \ var isEmpty = true\n        for i in 0..<grid.count {\n            if grid[i].contains(1)\
    \ {\n                isEmpty = false\n                for j in 0..<grid[i].count\
    \ {\n                    if grid[i][j] == 1 {\n                        grid[i][j]\
    \ = 0\n                        if i + 1 < grid.count {\n                     \
    \       grid[i + 1][j] = 1\n                        }\n                    }\n\
    \                }\n            }\n        }\n        if isEmpty {\n         \
    \   break\n        }\n        count += 1\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n      \
    \          count += 1\n                if i > 0 && grid[i - 1][j] == 1 {\n   \
    \                 grid[i - 1][j] = 0\n                    count += 1\n       \
    \         }\n                if j > 0 && grid[i][j - 1] == 1 {\n             \
    \       grid[i][j - 1] = 0\n                    count += 1\n                }\n\
    \            }\n        }\n    }\n    return count", "    var grid = grid\n  \
    \  var count = 0\n    while true {\n        var is_full = true\n        for i\
    \ in 0..<grid.count {\n            for j in 0..<grid[i].count {\n            \
    \    if grid[i][j] == 1 {\n                    grid[i][j] = 0\n              \
    \      count += 1\n                    is_full = false\n                }\n  \
    \          }\n        }\n        if is_full {\n            break\n        }\n\
    \    }\n    return count", "    // your code here\n    return 0", "    // your\
    \ code here\n    return 0", "    var grid = grid\n    var count = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                for k in i..<grid.count\
    \ {\n                    if grid[k][j] == 1 {\n                        grid[k][j]\
    \ = 0\n                    } else {\n                        break\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ count", "    var count = 0\n    var grid = grid\n    var wells = grid.map {\
    \ $0.reduce(0, +) }\n    while wells.reduce(0, +) > 0 {\n        for i in 0..<wells.count\
    \ {\n            if wells[i] > 0 {\n                wells[i] -= capacity\n   \
    \             count += 1\n            }\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                grid[i][j] = 0\n                if i + 1 < grid.count\
    \ {\n                    grid[i + 1][j] = 0\n                }\n            }\n\
    \        }\n    }\n    return count", "    var buckets = [Int](repeating: 0, count:\
    \ grid[0].count)\n    var count = 0\n    for row in grid {\n        for (index,\
    \ value) in row.enumerated() {\n            if value == 1 {\n                buckets[index]\
    \ += 1\n            }\n        }\n        for (index, value) in buckets.enumerated()\
    \ {\n            if value > capacity {\n                buckets[index] = capacity\n\
    \                count += 1\n            }\n        }\n    }\n    return count",
  '    return 0', "    var max_fill = 0\n    for row in grid {\n        for column\
    \ in row {\n            if column == 1 {\n                max_fill += 1\n    \
    \        }\n        }\n    }\n    return max_fill / capacity", "    var grid =\
    \ grid\n    var count = 0\n    var i = 0\n    while i < grid.count {\n       \
    \ var j = 0\n        while j < grid[i].count {\n            if grid[i][j] == 1\
    \ {\n                count += 1\n                var k = i\n                while\
    \ k < grid.count && k < i + capacity {\n                    grid[k][j] = 0\n \
    \                   k += 1\n                }\n            }\n            j +=\
    \ 1\n        }\n        i += 1\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    var i = 0\n    while i < grid.count {\n        var j =\
    \ 0\n        while j < grid[i].count {\n            if grid[i][j] == 1 {\n   \
    \             count += 1\n                var k = 0\n                while k <\
    \ capacity {\n                    if i + k < grid.count {\n                  \
    \      grid[i + k][j] = 0\n                    }\n                    k += 1\n\
    \                }\n            }\n            j += 1\n        }\n        i +=\
    \ 1\n    }\n    return count", "    var result = 0\n    var max = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                max += 1\n            }\n        }\n    }\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                result += 1\n                var k = i\n           \
    \     var l = j\n                while k < grid.count && l < grid[i].count {\n\
    \                    if grid[k][l] == 1 {\n                        grid[k][l]\
    \ = 0\n                        max -= 1\n                    }\n             \
    \       if max == 0 {\n                        return result\n               \
    \     }\n                    k += 1\n                    l += 1\n            \
    \    }\n            }\n        }\n    }\n    return result", "    var result =\
    \ 0\n    var grid = grid\n    var row = 0\n    while row < grid.count {\n    \
    \    var col = 0\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                result += 1\n                var bucket = capacity\n\
    \                while bucket > 0 {\n                    if row > 0 && grid[row\
    \ - 1][col] == 1 {\n                        grid[row - 1][col] = 0\n         \
    \               bucket -= 1\n                    }\n                    if row\
    \ < grid.count - 1 && grid[row + 1][col] == 1 {\n                        grid[row\
    \ + 1][col] = 0\n                        bucket -= 1\n                    }\n\
    \                    if col > 0 && grid[row][col - 1] == 1 {\n               \
    \         grid[row][col - 1] = 0\n                        bucket -= 1\n      \
    \              }\n                    if col < grid[row].count - 1 && grid[row][col\
    \ + 1] == 1 {\n                        grid[row][col + 1] = 0\n              \
    \          bucket -= 1\n                    }\n                }\n           \
    \ }\n            col += 1\n        }\n        row += 1\n    }\n    return result",
  "    let rows = grid.count\n    let cols = grid[0].count\n    var grid = grid\n\
    \    var count = 0\n    for _ in 0..<rows {\n        for j in 0..<cols {\n   \
    \         if grid[0][j] == 1 {\n                count += 1\n                grid[0][j]\
    \ = 0\n                for i in 1..<rows {\n                    if grid[i][j]\
    \ == 1 {\n                        grid[i][j] = 0\n                        break\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count", "    var max_fill = 0\n    var current_fill = 0\n    for row\
    \ in grid {\n        for well in row {\n            if well == 1 {\n         \
    \       current_fill += 1\n            }\n        }\n        if current_fill >\
    \ capacity {\n            max_fill += capacity\n        } else {\n           \
    \ max_fill += current_fill\n        }\n        current_fill = 0\n    }\n    return\
    \ max_fill", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                let row = i\n                let\
    \ col = j\n                var row_count = 0\n                var col_count =\
    \ 0\n                while row_count < capacity && row + row_count < grid.count\
    \ {\n                    if grid[row + row_count][col] == 1 {\n              \
    \          grid[row + row_count][col] = 0\n                    }\n           \
    \         row_count += 1\n                }\n                while col_count <\
    \ capacity && col + col_count < grid[i].count {\n                    if grid[row][col\
    \ + col_count] == 1 {\n                        grid[row][col + col_count] = 0\n\
    \                    }\n                    col_count += 1\n                }\n\
    \            }\n        }\n    }\n    return count", "    var result = 0\n   \
    \ for row in grid {\n        var current_capacity = capacity\n        for well\
    \ in row {\n            if well == 1 {\n                if current_capacity >\
    \ 0 {\n                    current_capacity -= 1\n                } else {\n \
    \                   result += 1\n                    current_capacity = capacity\
    \ - 1\n                }\n            }\n        }\n    }\n    return result",
  "    var count = 0\n    var grid = grid\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                grid = fill(grid: grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count", "    var result\
    \ = 0\n    var max_row = 0\n    var max_col = 0\n    var max_sum = 0\n    for\
    \ row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n        for\
    \ (index, col) in row.enumerated() {\n            max_col = max(max_col, col)\n\
    \            max_sum = max(max_sum, grid.reduce(0, { $0 + $1[index] }))\n    \
    \    }\n    }\n    result = max(max_row, max_col, max_sum)\n    return result",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                fill(grid: &grid, capacity: capacity, i: i,\
    \ j: j)\n            }\n        }\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    while !grid.isEmpty {\n        let max = grid.map { $0.max()\
    \ ?? 0 }.max() ?? 0\n        if max == 0 {\n            break\n        }\n   \
    \     grid = grid.map { $0.map { $0 - max } }\n        count += 1\n    }\n   \
    \ return count", "    var result = 0\n    var max_row = 0\n    var max_col = 0\n\
    \    var max_value = 0\n    for row in grid {\n        for col in row {\n    \
    \        if col > max_value {\n                max_value = col\n             \
    \   max_row = grid.firstIndex(of: row)!\n                max_col = row.firstIndex(of:\
    \ col)!\n            }\n        }\n    }\n    while max_value > 0 {\n        for\
    \ row in grid {\n            for col in row {\n                if col > 0 {\n\
    \                    result += 1\n                }\n            }\n        }\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] > 0 {\n                    grid[i][j] -= 1\n  \
    \              }\n            }\n        }\n        max_value = 0\n        for\
    \ row in grid {\n            for col in row {\n                if col > max_value\
    \ {\n                    max_value = col\n                    max_row = grid.firstIndex(of:\
    \ row)!\n                    max_col = row.firstIndex(of: col)!\n            \
    \    }\n            }\n        }\n    }\n    return result", "    var result =\
    \ 0\n    for i in 0..<grid.count {\n        var sum = 0\n        for j in 0..<grid[i].count\
    \ {\n            sum += grid[i][j]\n        }\n        result += sum / capacity\n\
    \        if sum % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result", "    var grid = grid\n    var count = 0\n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            if grid[row][col] ==\
    \ 1 {\n                count += 1\n                fill(grid: &grid, row: row,\
    \ col: col, capacity: capacity)\n            }\n        }\n    }\n    return count",
  "    var total = 0\n    for row in grid {\n        var row_total = 0\n        for\
    \ well in row {\n            if well == 1 {\n                row_total += 1\n\
    \            }\n        }\n        total += row_total / capacity\n        if row_total\
    \ % capacity != 0 {\n            total += 1\n        }\n    }\n    return total",
  "    var count = 0\n    var grid = grid\n    var buckets = [Int](repeating: 0, count:\
    \ grid[0].count)\n    while true {\n        var filled = false\n        for i\
    \ in 0..<grid.count {\n            for j in 0..<grid[i].count {\n            \
    \    if grid[i][j] == 1 {\n                    filled = true\n               \
    \     if buckets[j] < capacity {\n                        buckets[j] += 1\n  \
    \                      grid[i][j] = 0\n                    }\n               \
    \ }\n            }\n        }\n        if !filled {\n            break\n     \
    \   }\n        count += 1\n    }\n    return count", "    var count = 0\n    for\
    \ row in grid {\n        var bucket = capacity\n        for well in row {\n  \
    \          if well == 1 {\n                bucket -= 1\n            }\n      \
    \      if bucket == 0 {\n                count += 1\n                bucket =\
    \ capacity\n            }\n        }\n        if bucket < capacity {\n       \
    \     count += 1\n        }\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      for k in 0..<capacity {\n                    if i + k < grid.count {\n\
    \                        grid[i + k][j] = 0\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return count", "    var grid =\
    \ grid\n    var count = 0\n    var row = 0\n    var col = 0\n    while row < grid.count\
    \ {\n        if grid[row][col] == 1 {\n            grid[row][col] = 0\n      \
    \      count += 1\n        }\n        row += 1\n        if row == grid.count {\n\
    \            row = 0\n            col += 1\n            if col == grid[0].count\
    \ {\n                break\n            }\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                fill(grid: &grid, i: i, j: j, capacity: capacity)\n\
    \            }\n        }\n    }\n    return count", "    var grid = grid\n  \
    \  var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, capacity: capacity, i: i, j: j)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    while !grid.isEmpty {\n        var row = grid.removeFirst()\n\
    \        while !row.isEmpty {\n            let max = row.max()!\n            if\
    \ max > capacity {\n                row = row.map { $0 - capacity }\n        \
    \    } else {\n                row = row.map { $0 - max }\n            }\n   \
    \         count += 1\n        }\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    var i = 0\n    while i < grid.count {\n        var j =\
    \ 0\n        while j < grid[i].count {\n            if grid[i][j] == 1 {\n   \
    \             count += 1\n                var k = i\n                while k <\
    \ grid.count && k < i + capacity {\n                    grid[k][j] = 0\n     \
    \               k += 1\n                }\n            }\n            j += 1\n\
    \        }\n        i += 1\n    }\n    return count", "    var grid = grid\n \
    \   var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var result = 0\n    var max_height = 0\n\
    \    for row in grid {\n        var height = 0\n        for column in row {\n\
    \            if column == 1 {\n                height += 1\n            }\n  \
    \      }\n        max_height = max(max_height, height)\n    }\n    for row in\
    \ grid {\n        var height = 0\n        for column in row {\n            if\
    \ column == 1 {\n                height += 1\n            }\n        }\n     \
    \   if height < max_height {\n            result += max_height - height\n    \
    \    }\n    }\n    return result", "    var count = 0\n    var grid = grid\n \
    \   var i = 0\n    while i < grid.count {\n        var j = 0\n        while j\
    \ < grid[i].count {\n            if grid[i][j] == 1 {\n                count +=\
    \ 1\n                var k = i\n                while k < grid.count && k < i\
    \ + capacity {\n                    grid[k][j] = 0\n                    k += 1\n\
    \                }\n            }\n            j += 1\n        }\n        i +=\
    \ 1\n    }\n    return count", "    var grid = grid\n    var count = 0\n    for\
    \ i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if\
    \ grid[i][j] == 1 {\n                grid[i][j] = 0\n                count +=\
    \ 1\n                var k = i\n                while k < grid.count && capacity\
    \ > 0 {\n                    if grid[k][j] == 1 {\n                        grid[k][j]\
    \ = 0\n                        capacity -= 1\n                    }\n        \
    \            k += 1\n                }\n            }\n        }\n    }\n    return\
    \ count", "    var count = 0\n    for i in 0..<grid.count {\n        var sum =\
    \ 0\n        for j in 0..<grid[i].count {\n            sum += grid[i][j]\n   \
    \     }\n        if sum > capacity {\n            count += sum - capacity\n  \
    \      }\n    }\n    return count", "    var water = 0\n    var count = 0\n  \
    \  for row in grid {\n        for col in row {\n            if col == 1 {\n  \
    \              water += 1\n            }\n        }\n    }\n    while water >\
    \ 0 {\n        for row in grid {\n            for col in row {\n             \
    \   if col == 1 {\n                    water -= capacity\n                   \
    \ count += 1\n                }\n            }\n        }\n    }\n    return count",
  "    var max_fill = 0\n    for row in grid {\n        var bucket = capacity\n  \
    \      for well in row {\n            bucket -= well\n            if bucket <\
    \ 0 {\n                max_fill += 1\n                bucket = capacity - well\n\
    \            }\n        }\n    }\n    return max_fill", "    var result = 0\n\
    \    var max_row = 0\n    var max_col = 0\n    for row in grid {\n        max_row\
    \ = max(max_row, row.reduce(0, +))\n    }\n    for col in 0..<grid[0].count {\n\
    \        var sum = 0\n        for row in 0..<grid.count {\n            sum +=\
    \ grid[row][col]\n        }\n        max_col = max(max_col, sum)\n    }\n    result\
    \ = max(max_row, max_col)\n    return result", "    var grid = grid\n    var count\
    \ = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 1 {\n                count += 1\n               \
    \ grid[i][j] = 0\n                if i + 1 < grid.count {\n                  \
    \  grid[i + 1][j] = 1\n                }\n            }\n        }\n    }\n  \
    \  return count", '    return 0', "    var result = 0\n    var wells = grid\n\
    \    let well_length = wells[0].count\n    var well_index = 0\n    var bucket\
    \ = capacity\n    while well_index < wells.count {\n        var well = wells[well_index]\n\
    \        var water_index = 0\n        while water_index < well.count {\n     \
    \       if well[water_index] == 1 {\n                if bucket == 0 {\n      \
    \              bucket = capacity\n                    result += 1\n          \
    \      }\n                well[water_index] = 0\n                bucket -= 1\n\
    \            }\n            water_index += 1\n        }\n        wells[well_index]\
    \ = well\n        well_index += 1\n    }\n    return result", "    var grid =\
    \ grid\n    var count = 0\n    var row = 0\n    while row < grid.count {\n   \
    \     var column = 0\n        while column < grid[row].count {\n            if\
    \ grid[row][column] == 1 {\n                count += 1\n                var bucket\
    \ = capacity\n                while bucket > 0 {\n                    if row <\
    \ grid.count && grid[row][column] == 1 {\n                        grid[row][column]\
    \ = 0\n                        bucket -= 1\n                    }\n          \
    \          row += 1\n                }\n                row -= 1\n           \
    \ }\n            column += 1\n        }\n        row += 1\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    var row = 0\n    while row < grid.count\
    \ {\n        var col = 0\n        while col < grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                grid[row][col] = 0\n                count\
    \ += 1\n                var bucket = capacity\n                while bucket >\
    \ 0 {\n                    if row + 1 < grid.count && grid[row + 1][col] == 1\
    \ {\n                        grid[row + 1][col] = 0\n                        bucket\
    \ -= 1\n                    } else if col + 1 < grid[row].count && grid[row][col\
    \ + 1] == 1 {\n                        grid[row][col + 1] = 0\n              \
    \          bucket -= 1\n                    } else {\n                       \
    \ break\n                    }\n                }\n            }\n           \
    \ col += 1\n        }\n        row += 1\n    }\n    return count", "    var count\
    \ = 0\n    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      if capacity > 1 {\n                    for k in 1..<capacity {\n      \
    \                  if i + k < grid.count {\n                            grid[i\
    \ + k][j] = 0\n                        }\n                    }\n            \
    \    }\n            }\n        }\n    }\n    return count", "    var count = 0\n\
    \    var grid = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      var k = i\n                while k < grid.count && grid[k][j] == 1 {\n\
    \                    grid[k][j] = 0\n                    k += 1\n            \
    \    }\n            }\n        }\n    }\n    return count", "    var water = 0\n\
    \    var max_water = 0\n    for row in grid {\n        for col in row {\n    \
    \        if col == 1 {\n                water += 1\n            }\n        }\n\
    \        max_water = max(max_water, water)\n        water = 0\n    }\n    return\
    \ max_water / capacity", '    return 0', "    var grid = grid\n    var count =\
    \ 0\n    var i = 0\n    while i < grid.count {\n        var j = 0\n        while\
    \ j < grid[i].count {\n            if grid[i][j] == 1 {\n                var k\
    \ = i\n                while k < grid.count && grid[k][j] == 1 {\n           \
    \         grid[k][j] = 0\n                    k += 1\n                }\n    \
    \            count += 1\n            }\n            j += 1\n        }\n      \
    \  i += 1\n    }\n    return count", "    var grid = grid\n    var count = 0\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                var k = i\n                while k < grid.count && grid[k][j]\
    \ == 0 {\n                    grid[k][j] = 1\n                    k += 1\n   \
    \             }\n            }\n        }\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j\
    \ in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                count\
    \ += 1\n                fill(grid: &grid, i: i, j: j, capacity: capacity)\n  \
    \          }\n        }\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      grid[i][j] = 0\n                if i + 1 < grid.count {\n             \
    \       grid[i + 1][j] = 0\n                }\n            }\n        }\n    }\n\
    \    return count", "    var count = 0\n    for i in 0..<grid.count {\n      \
    \  for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n          \
    \      count += 1\n            }\n        }\n    }\n    return count / capacity\
    \ + (count % capacity > 0 ? 1 : 0)", "    var grid = grid\n    var count = 0\n\
    \    var i = 0\n    while i < grid.count {\n        var j = 0\n        while j\
    \ < grid[i].count {\n            if grid[i][j] == 1 {\n                count +=\
    \ 1\n                var k = i\n                while k < grid.count && k < i\
    \ + capacity {\n                    grid[k][j] = 0\n                    k += 1\n\
    \                }\n            }\n            j += 1\n        }\n        i +=\
    \ 1\n    }\n    return count", "    var result = 0\n    var max_value = 0\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                max_value += 1\n            }\n    \
    \    }\n    }\n    var current_value = 0\n    var i = 0\n    while current_value\
    \ < max_value {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                current_value += 1\n                grid[i][j] = 0\n\
    \            }\n        }\n        result += 1\n        i += 1\n        if i ==\
    \ grid.count {\n            i = 0\n        }\n    }\n    return result", "   \
    \ let rows = grid.count\n    let cols = grid[0].count\n    var count = 0\n   \
    \ var grid = grid\n    for row in 0..<rows {\n        for col in 0..<cols {\n\
    \            if grid[row][col] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, row: row, col: col, capacity: capacity)\n           \
    \ }\n        }\n    }\n    return count", "    var result = 0\n    for row in\
    \ grid {\n        var rowSum = 0\n        for well in row {\n            rowSum\
    \ += well\n        }\n        result += rowSum / capacity\n        if rowSum %\
    \ capacity != 0 {\n            result += 1\n        }\n    }\n    return result",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                fill(grid: &grid, i: i, j: j, capacity: capacity)\n\
    \            }\n        }\n    }\n    return count", "    var count = 0\n    var\
    \ max = 0\n    for row in grid {\n        for item in row {\n            if item\
    \ == 1 {\n                count += 1\n            }\n        }\n        if count\
    \ > max {\n            max = count\n        }\n        count = 0\n    }\n    return\
    \ max * capacity", "    var grid = grid\n    var count = 0\n    while !grid.isEmpty\
    \ {\n        let row = grid.removeFirst()\n        let row_count = row.reduce(0,\
    \ +)\n        if row_count == 0 {\n            continue\n        }\n        count\
    \ += row_count / capacity\n        if row_count % capacity != 0 {\n          \
    \  count += 1\n        }\n    }\n    return count", "    var grid = grid\n   \
    \ var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n      \
    \          count += 1\n                var k = i\n                while k < grid.count\
    \ && capacity > 0 {\n                    if grid[k][j] == 1 {\n              \
    \          grid[k][j] = 0\n                        capacity -= 1\n           \
    \         }\n                    k += 1\n                }\n                capacity\
    \ = capacity + 1\n            }\n        }\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    while true {\n        var found = false\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] == 1 {\n                    found = true\n    \
    \                grid[i][j] = 0\n                    for k in 0..<capacity {\n\
    \                        if i + k < grid.count {\n                           \
    \ grid[i + k][j] = 0\n                        }\n                    }\n     \
    \           }\n            }\n        }\n        if !found {\n            break\n\
    \        }\n        count += 1\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      grid[i][j] = 0\n                var bucket = capacity\n               \
    \ var k = i\n                while bucket > 0 && k < grid.count {\n          \
    \          if grid[k][j] == 1 {\n                        grid[k][j] = 0\n    \
    \                    bucket -= 1\n                    }\n                    k\
    \ += 1\n                }\n            }\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                fill(grid: &grid, i: i, j: j, capacity: capacity)\n\
    \            }\n        }\n    }\n    return count", "    var grid = grid\n  \
    \  var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  var i = 0\n    while i < grid.count {\n        var j = 0\n        while j <\
    \ grid[i].count {\n            if grid[i][j] == 1 {\n                var k = 0\n\
    \                while k < capacity {\n                    if i + k < grid.count\
    \ {\n                        grid[i + k][j] = 0\n                    }\n     \
    \               k += 1\n                }\n                count += 1\n      \
    \      }\n            j += 1\n        }\n        i += 1\n    }\n    return count",
  "    var total = 0\n    for row in grid {\n        total += row.reduce(0, +)\n \
    \   }\n    return total / capacity", "    var grid = grid\n    var count = 0\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, capacity: capacity, i: i, j: j)\n            }\n        }\n    }\n  \
    \  return count", "    var wells = grid\n    var count = 0\n    for i in 0..<wells.count\
    \ {\n        for j in 0..<wells[i].count {\n            if wells[i][j] == 1 {\n\
    \                count += 1\n                wells[i][j] = 0\n               \
    \ var bucket = capacity\n                var k = i\n                while bucket\
    \ > 0 && k < wells.count {\n                    if wells[k][j] == 1 {\n      \
    \                  wells[k][j] = 0\n                        bucket -= 1\n    \
    \                }\n                    k += 1\n                }\n          \
    \  }\n        }\n    }\n    return count", "    var grid = grid\n    var count\
    \ = 0\n    while true {\n        var min = Int.max\n        var min_i = 0\n  \
    \      for i in 0..<grid.count {\n            let row = grid[i]\n            let\
    \ sum = row.reduce(0, +)\n            if sum < min {\n                min = sum\n\
    \                min_i = i\n            }\n        }\n        if min == 0 {\n\
    \            break\n        }\n        for i in 0..<grid[min_i].count {\n    \
    \        if grid[min_i][i] == 1 {\n                grid[min_i][i] = 0\n      \
    \          count += 1\n            }\n        }\n    }\n    return count", " \
    \   var grid = grid\n    var count = 0\n    while true {\n        var max = 0\n\
    \        var max_index = 0\n        for (index, row) in grid.enumerated() {\n\
    \            let sum = row.reduce(0, +)\n            if sum > max {\n        \
    \        max = sum\n                max_index = index\n            }\n       \
    \ }\n        if max == 0 {\n            break\n        }\n        count += 1\n\
    \        for i in 0..<grid[max_index].count {\n            if grid[max_index][i]\
    \ == 1 {\n                grid[max_index][i] = 0\n            } else {\n     \
    \           break\n            }\n        }\n    }\n    return count", "    var\
    \ count = 0\n    for row in grid {\n        var bucket = capacity\n        for\
    \ well in row {\n            if well == 1 {\n                if bucket > 0 {\n\
    \                    bucket -= 1\n                } else {\n                 \
    \   count += 1\n                    bucket = capacity - 1\n                }\n\
    \            }\n        }\n    }\n    return count", "    var grid = grid\n  \
    \  var count = 0\n    for row in grid {\n        for col in row {\n          \
    \  if col == 1 {\n                count += 1\n            }\n        }\n    }\n\
    \    return count / capacity", "    var max_fill = 0\n    for row in grid {\n\
    \        var fill = 0\n        for well in row {\n            fill += well\n \
    \           if fill == capacity {\n                max_fill += 1\n           \
    \     fill = 0\n            }\n        }\n        max_fill += fill\n    }\n  \
    \  return max_fill", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    while true {\n        var filled = false\n  \
    \      for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n \
    \               if grid[i][j] == 1 {\n                    filled = true\n    \
    \                grid[i][j] = 0\n                    if i > 0 {\n            \
    \            grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n            \
    \        }\n                    if i < grid.count - 1 {\n                    \
    \    grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n                    }\n\
    \                    if j > 0 {\n                        grid[i][j - 1] = min(grid[i][j\
    \ - 1] + 1, capacity)\n                    }\n                    if j < grid[i].count\
    \ - 1 {\n                        grid[i][j + 1] = min(grid[i][j + 1] + 1, capacity)\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ !filled {\n            break\n        }\n        count += 1\n    }\n    return\
    \ count", "    var water = 0\n    var count = 0\n    for row in grid {\n     \
    \   for col in row {\n            if col == 1 {\n                water += 1\n\
    \            }\n        }\n    }\n    while water > 0 {\n        count += 1\n\
    \        water -= capacity\n    }\n    return count", "    var grid = grid\n \
    \   var count = 0\n    while !grid.isEmpty {\n        var row = grid.removeFirst()\n\
    \        while !row.isEmpty {\n            let _ = row.removeFirst()\n       \
    \     count += 1\n        }\n    }\n    return count / capacity", "    var grid\
    \ = grid\n    var count = 0\n    while !grid.isEmpty {\n        let max = grid.map\
    \ { $0.reduce(0, +) }.max()!\n        if max == 0 {\n            grid.removeFirst()\n\
    \            continue\n        }\n        let row = grid.firstIndex(where: { $0.reduce(0,\
    \ +) == max })!\n        let col = grid[row].firstIndex(of: 1)!\n        grid[row][col]\
    \ = 0\n        count += 1\n        for i in 0..<grid.count {\n            if grid[i][col]\
    \ == 1 {\n                grid[i][col] = 0\n            }\n        }\n    }\n\
    \    return count", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<grid.count {\n     \
    \               if grid[k][j] == 1 {\n                        grid[k][j] = 0\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    var row = 0\n    var col = 0\n    while row <\
    \ grid.count {\n        if grid[row][col] == 1 {\n            grid[row][col] =\
    \ 0\n            count += 1\n        }\n        if col == grid[row].count - 1\
    \ {\n            row += 1\n            col = 0\n        } else {\n           \
    \ col += 1\n        }\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    var row = 0\n    while row < grid.count {\n        var col =\
    \ 0\n        while col < grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                count += 1\n                var row_ = row\n            \
    \    while row_ < grid.count && grid[row_][col] == 1 {\n                    grid[row_][col]\
    \ = 0\n                    row_ += 1\n                }\n            }\n     \
    \       col += 1\n        }\n        row += 1\n    }\n    return count", "   \
    \ var result = 0\n    var max = 0\n    for row in grid {\n        for column in\
    \ row {\n            if column == 1 {\n                max += 1\n            }\n\
    \        }\n    }\n    var current = 0\n    for row in grid {\n        for column\
    \ in row {\n            if column == 1 {\n                current += 1\n     \
    \       }\n        }\n        if current == max {\n            break\n       \
    \ }\n        result += 1\n        current = 0\n    }\n    return result", "  \
    \  var grid = grid\n    var count = 0\n    while grid.contains(where: { $0.contains(1)\
    \ }) {\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    grid[i][j] = 0\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \    }\n    return count", "    var grid = grid\n    var count = 0\n    while\
    \ true {\n        var is_empty = true\n        for i in 0..<grid.count {\n   \
    \         for j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n\
    \                    is_empty = false\n                    grid[i][j] = 0\n  \
    \                  count += 1\n                }\n            }\n        }\n \
    \       if is_empty {\n            break\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    while true {\n        var filled =\
    \ false\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    filled = true\n\
    \                    grid[i][j] = 0\n                    if i > 0 {\n        \
    \                grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n        \
    \            }\n                    if i < grid.count - 1 {\n                \
    \        grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n                \
    \    }\n                    if j > 0 {\n                        grid[i][j - 1]\
    \ = min(grid[i][j - 1] + 1, capacity)\n                    }\n               \
    \     if j < grid[i].count - 1 {\n                        grid[i][j + 1] = min(grid[i][j\
    \ + 1] + 1, capacity)\n                    }\n                }\n            }\n\
    \        }\n        if !filled {\n            break\n        }\n        count\
    \ += 1\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                var\
    \ k = i\n                while k < grid.count && capacity > 0 {\n            \
    \        if grid[k][j] == 1 {\n                        count += 1\n          \
    \              grid[k][j] = 0\n                        capacity -= 1\n       \
    \             }\n                    k += 1\n                }\n            }\n\
    \        }\n    }\n    return count", "    var grid = grid\n    var count = 0\n\
    \    while !grid.isEmpty {\n        var max = 0\n        var maxIndex = 0\n  \
    \      for i in 0..<grid.count {\n            let sum = grid[i].reduce(0, +)\n\
    \            if sum > max {\n                max = sum\n                maxIndex\
    \ = i\n            }\n        }\n        count += max / capacity\n        if max\
    \ % capacity != 0 {\n            count += 1\n        }\n        grid.remove(at:\
    \ maxIndex)\n    }\n    return count", "    var grid = grid\n    var count = 0\n\
    \    var max = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                max = i\n            }\n\
    \        }\n    }\n    for i in 0...max {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      for k in i..<grid.count {\n                    if grid[k][j] == 1 {\n \
    \                       grid[k][j] = 0\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return count", "    var result = 0\n\
    \    var max_depth = 0\n    for row in grid {\n        max_depth = max(max_depth,\
    \ row.reduce(0, +))\n    }\n    for depth in 0..<max_depth {\n        for row\
    \ in grid {\n            for column in row {\n                if column > depth\
    \ {\n                    result += 1\n                }\n            }\n     \
    \   }\n    }\n    return result", "    var result = 0\n    var max_row = 0\n \
    \   for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n    }\n\
    \    for _ in 0..<max_row {\n        for row in grid {\n            for i in 0..<row.count\
    \ {\n                if row[i] > 0 {\n                    row[i] -= 1\n      \
    \              result += 1\n                }\n            }\n        }\n    }\n\
    \    return result", "    var count = 0\n    var wells = grid\n    var buckets\
    \ = Array(repeating: capacity, count: grid[0].count)\n    while true {\n     \
    \   var is_empty = true\n        for i in 0..<wells.count {\n            for j\
    \ in 0..<wells[i].count {\n                if wells[i][j] == 1 {\n           \
    \         is_empty = false\n                    if buckets[j] > 0 {\n        \
    \                buckets[j] -= 1\n                        wells[i][j] = 0\n  \
    \                  }\n                }\n            }\n        }\n        if\
    \ is_empty {\n            break\n        }\n        count += 1\n    }\n    return\
    \ count", "    var result = 0\n    var max = 0\n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            max += 1\n            }\n        }\n    }\n    var current = 0\n\
    \    while current < max {\n        for i in 0..<grid.count {\n            for\
    \ j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n           \
    \         current += 1\n                    grid[i][j] = 0\n                 \
    \   result += 1\n                }\n            }\n        }\n    }\n    return\
    \ result", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                for k in 0..<capacity {\n       \
    \             if i + k < grid.count {\n                        grid[i + k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count", "    var grid = grid\n    var count = 0\n    for i in\
    \ 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                fill(grid: &grid, i: i,\
    \ j: j, capacity: capacity)\n            }\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    while true {\n        var is_empty\
    \ = true\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    is_empty = false\n\
    \                    grid[i][j] = 0\n                    count += 1\n        \
    \        }\n            }\n        }\n        if is_empty {\n            break\n\
    \        }\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == -1 {\n                    grid[i][j] = 1\n\
    \                }\n            }\n        }\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 0 {\n                    grid[i][j] = -1\n                }\n            }\n\
    \        }\n    }\n    return count", "    var grid = grid\n    var count = 0\n\
    \    while grid.contains(where: { $0.contains(1) }) {\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    grid[i][j] = 0\n                    if i + 1 < grid.count\
    \ && grid[i + 1][j] == 1 {\n                        grid[i + 1][j] = 0\n     \
    \               }\n                    if j + 1 < grid[i].count && grid[i][j +\
    \ 1] == 1 {\n                        grid[i][j + 1] = 0\n                    }\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \    }\n    return count", "    var max_fill = 0\n    for row in grid {\n    \
    \    var fill = 0\n        for well in row {\n            fill += well\n     \
    \       if fill == capacity {\n                max_fill += 1\n               \
    \ fill = 0\n            }\n        }\n        if fill > 0 {\n            max_fill\
    \ += 1\n        }\n    }\n    return max_fill", "    var count = 0\n    var grid\
    \ = grid\n    var capacity = capacity\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     grid[i][j] = 0\n                count += 1\n                capacity -=\
    \ 1\n                if capacity == 0 {\n                    count += 1\n    \
    \                capacity = capacity + 1\n                }\n            }\n \
    \       }\n    }\n    return count", "    let rows = grid.count\n    let cols\
    \ = grid[0].count\n    var max_fill = 0\n    for row in 0..<rows {\n        for\
    \ col in 0..<cols {\n            if grid[row][col] == 1 {\n                max_fill\
    \ += 1\n            }\n        }\n    }\n    return max_fill * capacity", "  \
    \  var count = 0\n    var grid = grid\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                fill(grid: &grid, i: i, j: j, capacity: capacity)\n\
    \            }\n        }\n    }\n    return count", "    var grid = grid\n  \
    \  var count = 0\n    while true {\n        var max = 0\n        var maxIndex\
    \ = 0\n        for i in 0..<grid.count {\n            var sum = 0\n          \
    \  for j in 0..<grid[i].count {\n                sum += grid[i][j]\n         \
    \   }\n            if sum > max {\n                max = sum\n               \
    \ maxIndex = i\n            }\n        }\n        if max == 0 {\n            break\n\
    \        }\n        for i in 0..<grid[maxIndex].count {\n            if grid[maxIndex][i]\
    \ == 1 {\n                grid[maxIndex][i] = 0\n                count += 1\n\
    \            }\n        }\n    }\n    return count", "    var grid = grid\n  \
    \  var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var grid = grid\n    var count = 0\n    var max = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                max = max + 1\n            }\n    \
    \    }\n    }\n    while count < max {\n        for i in 0..<grid.count {\n  \
    \          for j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n\
    \                    grid[i][j] = 0\n                    count = count + 1\n \
    \                   if count == max {\n                        return count\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, capacity: capacity,\
    \ i: i, j: j)\n            }\n        }\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      if i > 0 {\n                    grid[i-1][j] = 1\n                }\n \
    \               if i < grid.count - 1 {\n                    grid[i+1][j] = 1\n\
    \                }\n                if j > 0 {\n                    grid[i][j-1]\
    \ = 1\n                }\n                if j < grid[i].count - 1 {\n       \
    \             grid[i][j+1] = 1\n                }\n            }\n        }\n\
    \    }\n    return count", "    var grid = grid\n    var count = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                fill(grid: &grid, i: i,\
    \ j: j, capacity: capacity)\n            }\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                grid[i][j] = 0\n                for k in i+1..<grid.count\
    \ {\n                    if grid[k][j] == 1 {\n                        grid[k][j]\
    \ = 0\n                        count += 1\n                    }\n           \
    \     }\n            }\n        }\n    }\n    return count", "    var max_fill\
    \ = 0\n    for row in grid {\n        var fill = 0\n        for well in row {\n\
    \            if well == 1 {\n                fill += 1\n            }\n      \
    \  }\n        if fill > max_fill {\n            max_fill = fill\n        }\n \
    \   }\n    return max_fill * capacity", "    var grid = grid\n    var count =\
    \ 0\n    var row = 0\n    var col = 0\n    while row < grid.count {\n        while\
    \ col < grid[row].count {\n            if grid[row][col] == 1 {\n            \
    \    count += 1\n                grid[row][col] = 0\n                for i in\
    \ 0..<capacity {\n                    if col + i < grid[row].count {\n       \
    \                 grid[row][col + i] = 0\n                    }\n            \
    \    }\n            }\n            col += 1\n        }\n        col = 0\n    \
    \    row += 1\n    }\n    return count", "    var grid = grid\n    var count =\
    \ 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n   \
    \         if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                var k = i\n                while k > 0 && grid[k - 1][j]\
    \ == 1 {\n                    grid[k - 1][j] = 0\n                    k -= 1\n\
    \                }\n            }\n        }\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    var row = 0\n    var col = 0\n    while\
    \ row < grid.count {\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                count += 1\n                grid[row][col] = 0\n   \
    \             var i = 1\n                while i <= capacity && row + i < grid.count\
    \ {\n                    grid[row + i][col] = 0\n                    i += 1\n\
    \                }\n            }\n            col += 1\n        }\n        col\
    \ = 0\n        row += 1\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      let row = min(i + capacity, grid.count)\n                let col = min(j\
    \ + capacity, grid[i].count)\n                for k in i..<row {\n           \
    \         for l in j..<col {\n                        grid[k][l] = 0\n       \
    \             }\n                }\n            }\n        }\n    }\n    return\
    \ count", "    var grid = grid\n    var count = 0\n    while true {\n        var\
    \ filled = false\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    filled = true\n\
    \                    grid[i][j] = 0\n                    if i > 0 {\n        \
    \                grid[i - 1][j] = 1\n                    }\n                 \
    \   if i < grid.count - 1 {\n                        grid[i + 1][j] = 1\n    \
    \                }\n                    if j > 0 {\n                        grid[i][j\
    \ - 1] = 1\n                    }\n                    if j < grid[i].count -\
    \ 1 {\n                        grid[i][j + 1] = 1\n                    }\n   \
    \             }\n            }\n        }\n        if filled {\n            count\
    \ += 1\n        } else {\n            break\n        }\n    }\n    return count",
  "    // your code here\n    return 0", "    var count = 0\n    var grid = grid\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                count += 1\n                for k\
    \ in 0..<capacity {\n                    if i + k < grid.count {\n           \
    \             grid[i + k][j] = 0\n                    }\n                }\n \
    \           }\n        }\n    }\n    return count", "    var grid = grid\n   \
    \ var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    var row = 0\n    while row < grid.count {\n \
    \       var col = 0\n        while col < grid[row].count {\n            if grid[row][col]\
    \ == 1 {\n                count += 1\n                var bucket = capacity\n\
    \                while bucket > 0 && row < grid.count {\n                    if\
    \ grid[row][col] == 1 {\n                        grid[row][col] = 0\n        \
    \                bucket -= 1\n                    }\n                    row +=\
    \ 1\n                }\n                row -= 1\n            }\n            col\
    \ += 1\n        }\n        row += 1\n    }\n    return count", "    var grid =\
    \ grid\n    var count = 0\n    while true {\n        var full = true\n       \
    \ for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n      \
    \          if grid[i][j] == 1 {\n                    full = false\n          \
    \          break\n                }\n            }\n        }\n        if full\
    \ {\n            break\n        }\n        for i in 0..<grid.count {\n       \
    \     for j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n   \
    \                 grid[i][j] = 0\n                    if i - 1 >= 0 {\n      \
    \                  grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n      \
    \              }\n                    if i + 1 < grid.count {\n              \
    \          grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n              \
    \      }\n                    if j - 1 >= 0 {\n                        grid[i][j\
    \ - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n          \
    \          if j + 1 < grid[i].count {\n                        grid[i][j + 1]\
    \ = min(grid[i][j + 1] + 1, capacity)\n                    }\n               \
    \ }\n            }\n        }\n        count += 1\n    }\n    return count", " \
    \   let rows = grid.count\n    let cols = grid[0].count\n    var result = 0\n\
    \    var wells = grid\n    for _ in 0..<rows {\n        for col in 0..<cols {\n\
    \            if wells[0][col] == 1 {\n                wells[0][col] = 0\n    \
    \            result += 1\n            }\n        }\n        wells = wells.dropFirst().map\
    \ { $0 }\n    }\n    return result", "    var grid = grid\n    var count = 0\n\
    \    while !grid.isEmpty {\n        var row = grid.removeFirst()\n        while\
    \ !row.isEmpty {\n            var bucket = capacity\n            while bucket\
    \ > 0 && !row.isEmpty {\n                let water = row.removeFirst()\n     \
    \           if water == 1 {\n                    bucket -= 1\n               \
    \ }\n            }\n            count += 1\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    var row = 0\n    while row < grid.count\
    \ {\n        var col = 0\n        while col < grid[row].count {\n            if\
    \ grid[row][col] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, row: row, col: col, capacity: capacity)\n            }\n            col\
    \ += 1\n        }\n        row += 1\n    }\n    return count", "    // TODO: Implement\n\
    \    return 0", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count", "    var grid\
    \ = grid\n    var count = 0\n    while true {\n        var has_water = false\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] == 1 {\n                    has_water = true\n\
    \                    break\n                }\n            }\n            if has_water\
    \ {\n                break\n            }\n        }\n        if !has_water {\n\
    \            break\n        }\n        for i in 0..<grid.count {\n           \
    \ for j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n       \
    \             grid[i][j] = 0\n                    if i > 0 {\n               \
    \         grid[i - 1][j] = 1\n                    }\n                    if i\
    \ < grid.count - 1 {\n                        grid[i + 1][j] = 1\n           \
    \         }\n                    if j > 0 {\n                        grid[i][j\
    \ - 1] = 1\n                    }\n                    if j < grid[i].count -\
    \ 1 {\n                        grid[i][j + 1] = 1\n                    }\n   \
    \             }\n            }\n        }\n        count += 1\n    }\n    return\
    \ count", "    let rows = grid.count\n    let cols = grid[0].count\n    var buckets\
    \ = Array(repeating: 0, count: cols)\n    var count = 0\n    for i in 0..<rows\
    \ {\n        for j in 0..<cols {\n            if grid[i][j] == 1 {\n         \
    \       if buckets[j] < capacity {\n                    buckets[j] += 1\n    \
    \                count += 1\n                }\n            }\n        }\n   \
    \ }\n    return count", "    var water = 0\n    var count = 0\n    for row in\
    \ grid {\n        for cell in row {\n            if cell == 1 {\n            \
    \    water += 1\n            }\n        }\n    }\n    while water > 0 {\n    \
    \    water -= capacity\n        count += 1\n    }\n    return count", "    var\
    \ grid = grid\n    var count = 0\n    while true {\n        var max = 0\n    \
    \    var max_i = 0\n        for i in 0..<grid.count {\n            let sum = grid[i].reduce(0,\
    \ +)\n            if sum > max {\n                max = sum\n                max_i\
    \ = i\n            }\n        }\n        if max == 0 {\n            break\n  \
    \      }\n        for j in 0..<grid[max_i].count {\n            if grid[max_i][j]\
    \ == 1 {\n                grid[max_i][j] = 0\n                count += 1\n   \
    \         }\n        }\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      for k in i..<grid.count {\n                    if grid[k][j] == 1 {\n \
    \                       grid[k][j] = 0\n                    } else {\n       \
    \                 break\n                    }\n                }\n          \
    \  }\n        }\n    }\n    return count", "    let rows = grid.count\n    let\
    \ cols = grid[0].count\n    var maxFill = 0\n    for i in 0..<rows {\n       \
    \ for j in 0..<cols {\n            if grid[i][j] == 1 {\n                maxFill\
    \ += capacity\n            }\n        }\n    }\n    return maxFill", "    var\
    \ grid = grid\n    var count = 0\n    while true {\n        var filled = false\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] == 1 {\n                    filled = true\n   \
    \                 grid[i][j] = 0\n                    if i > 0 {\n           \
    \             grid[i - 1][j] = min(grid[i - 1][j] + 1, capacity)\n           \
    \         }\n                    if i < grid.count - 1 {\n                   \
    \     grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n                   \
    \ }\n                    if j > 0 {\n                        grid[i][j - 1] =\
    \ min(grid[i][j - 1] + 1, capacity)\n                    }\n                 \
    \   if j < grid[i].count - 1 {\n                        grid[i][j + 1] = min(grid[i][j\
    \ + 1] + 1, capacity)\n                    }\n                }\n            }\n\
    \        }\n        if !filled {\n            break\n        }\n        count\
    \ += 1\n    }\n    return count", "    var result = 0\n    var max_water = 0\n\
    \    for row in grid {\n        max_water = 0\n        for well in row {\n   \
    \         if well == 1 {\n                max_water += 1\n            }\n    \
    \    }\n        result += max_water / capacity\n        if max_water % capacity\
    \ != 0 {\n            result += 1\n        }\n    }\n    return result", "   \
    \ var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n               \
    \ grid[i][j] = 0\n                count += 1\n                for k in 0..<capacity\
    \ {\n                    if i + k < grid.count && grid[i + k][j] == 1 {\n    \
    \                    grid[i + k][j] = 0\n                    }\n             \
    \   }\n            }\n        }\n    }\n    return count"]
stop_tokens:
- "\n}"
