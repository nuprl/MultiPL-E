name: HumanEval_49_modp
language: swift
prompt: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p:\
  \ 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
  /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc\
  \ modp(n: Int, p: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101,\
  \ p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
  assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
  \ 31, p: 5) == 3)"
completions: ["    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n   \
    \     return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    } else {\n \
    \       return modp(n: n - 1, p: p) * modp(n: n, p: p) % p\n    }", "    if n\
    \ == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return modp(n:\
    \ n / 2, p: p) * modp(n: n / 2, p: p) % p\n    } else {\n        return modp(n:\
    \ n - 1, p: p) * modp(n: n, p: p) % p\n    }", "    if n == 0 {\n        return\
    \ 1\n    }\n    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n:\
    \ n / 2, p: p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n:\
    \ n, p: p) % p\n    }", "    var result = 1\n    for _ in 0..<n {\n        result\
    \ = (result * 2) % p\n    }\n    return result", "    var result = 1\n    var\
    \ n = n\n    var p = p\n    while n > 0 {\n        if n % 2 == 1 {\n         \
    \   result = (result * p) % 101\n        }\n        n /= 2\n        p = (p * p)\
    \ % 101\n    }\n    return result", "    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result", "    if n == 0\
    \ {\n        return 1\n    }\n    if n % 2 == 0 {\n        let x = modp(n: n /\
    \ 2, p: p)\n        return (x * x) % p\n    }\n    return (modp(n: n - 1, p: p)\
    \ * n) % p", "    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    } else {\n\
    \        return modp(n: n - 1, p: p) * modp(n: n, p: p) % p\n    }", "    if n\
    \ == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let x = modp(n:\
    \ n / 2, p: p)\n        return (x * x) % p\n    }\n    return (n % p) * modp(n:\
    \ n - 1, p: p) % p", "    var result = 1\n    var n = n\n    var p = p\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * p) % 101\n\
    \        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n    return result",
  "    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            result = (result * n) % p\n        }\n        n =\
    \ n / 2\n        p = (p * p) % p\n    }\n    return result", "    var result =\
    \ 1\n    var n = n\n    while n > 0 {\n        if n % 2 == 1 {\n            result\
    \ = (result * 2) % p\n        }\n        n /= 2\n    }\n    return result", " \
    \   var result = 1\n    for _ in 0..<n {\n        result = (result * 2) % p\n\
    \    }\n    return result", "    if n == 0 {\n        return 1\n    }\n    if\
    \ n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x * x) %\
    \ p\n    }\n    return (modp(n: n - 1, p: p) * n) % p", "    if n == 0 {\n   \
    \     return 1\n    }\n    if n % 2 == 0 {\n        let x = modp(n: n / 2, p:\
    \ p)\n        return (x * x) % p\n    }\n    return (n * modp(n: n - 1, p: p))\
    \ % p", "    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            result = (result * n) % p\n        }\n \
    \       n = n / 2\n        n = (n * n) % p\n    }\n    return result", "    if\
    \ n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return modp(n:\
    \ n / 2, p: p) * modp(n: n / 2, p: p) % p\n    } else {\n        return modp(n:\
    \ n - 1, p: p) * modp(n: n, p: p) % p\n    }", "    if n == 0 {\n        return\
    \ 1\n    }\n    if n == 1 {\n        return n % p\n    }\n    if n % 2 == 0 {\n\
    \        let x = modp(n: n / 2, p: p)\n        return (x * x) % p\n    }\n   \
    \ return (n * modp(n: n - 1, p: p)) % p", "    var result = 1\n    var n = n\n\
    \    var p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result\
    \ = (result * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n\
    \    }\n    return result", "    if n == 0 {\n        return 1\n    }\n    if\
    \ n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n\
    \    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p) % p\n  \
    \  }"]
stop_tokens:
- "\n}"
