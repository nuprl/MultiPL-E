language: sh
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n   \
    \ #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n  \
    \  #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n \
    \   #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp0x6plbpt.sh: line 184: syntax error near unexpected token `}''

    /tmp/tmp0x6plbpt.sh: line 184: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"Not implemented\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo \"closest_integer $1\"\n  # echo \"scale=0; $1/1\"\
    \ | bc\n  # echo \"scale=0; $1/1\" | bc -l\n  # echo \"scale=0; $1/1\" | bc -l\
    \ | sed 's/\\..*//'\n  # echo \"scale=0; $1/1\" | bc -l | sed 's/\\..*//' | sed\
    \ 's/-//'\n  # echo \"scale=0; $1/1\" | bc -l | sed 's/\\..*//' | sed 's/-//'\
    \ | sed 's/^0*//'\n  # echo \"scale=0; $1/1\" | bc -l | sed 's/\\..*//' | sed\
    \ 's/-//' | sed 's/^0*//' | sed 's/^$/0/'\n  # echo \"scale=0; $1/1\" | bc -l\
    \ | sed 's/\\..*//' | sed 's/-//' | sed 's/^0*//' | sed 's/^$/0/' | sed 's/^-//'\n\
    \  # echo \"scale=0; $1/1\" | bc -l | sed 's/\\..*//' | sed 's/-//' | sed 's/^0*//'\
    \ | sed 's/^$/0/' | sed 's/^-//' | sed 's/^/-/'\n  # echo \"scale=0; $1/1\" |\
    \ bc -l | sed 's/\\..*//' | sed 's/-//' | sed 's/^0*//' | sed 's/^$/0/' | sed\
    \ 's/^-//' | sed 's/^/-/' | sed 's/^0/-0/'\n  # echo \"scale=0; $1/1\" | bc -l\
    \ | sed 's/\\..*//' | sed 's/-//' | sed 's/^0*//' | sed 's/^$/0/' | sed 's/^-//'\
    \ | sed 's/\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjs8m594r.sh: line 26: syntax error near unexpected token `}''

    /tmp/tmpjs8m594r.sh: line 26: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=$1\n  local int=${num%.*}\n  local dec=${num#*.}\n  if (( dec >= 5 )); then\n\
    \    (( int++ ))\n  fi\n  echo $int\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1#-}\n\
    \  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo\
    \ ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n\
    \  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo\
    \ ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n\
    \  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo\
    \ ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n\
    \  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo\
    \ ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n\
    \  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo\
    \ ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n\
    \  # echo ${1%.*}\n  # echo ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo\
    \ ${1#-}\n  # echo ${1#-}\n  # echo ${1%.*}\n  # echo\n}\n\ncandidate() {\n  \
    \  closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmppr5r5j9v.sh: line 72: syntax error near unexpected token `}''

    /tmp/tmppr5r5j9v.sh: line 72: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1 + 0.5 * sign($1)}'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo $((10#${1#*.}))\n\
    \  # echo $((10#${1#*.} > 5))\n  # echo $((10#${1#*.} < 5))\n  # echo $((10#${1#*.}\
    \ == 5))\n  # echo $((10#${1#*.} > 5))\n  # echo $((10#${1#*.} < 5))\n  # echo\
    \ $((10#${1#*.} == 5))\n  # echo $((10#${1#*.} >= 5))\n  # echo $((10#${1#*.}\
    \ <= 5))\n  # echo $((10#${1#*.} != 5))\n  # echo $((10#${1#*.} > 5))\n  # echo\
    \ $((10#${1#*.} < 5))\n  # echo $((10#${1#*.} == 5))\n  # echo $((10#${1#*.} >=\
    \ 5))\n  # echo $((10#${1#*.} <= 5))\n  # echo $((10#${1#*.} != 5))\n  # echo\
    \ $((10#${1#*.} > 5))\n  # echo $((10#${1#*.} < 5))\n  # echo $((10#${1#*.} ==\
    \ 5))\n  # echo $((10#${1#*.} >= 5))\n  # echo $((10#${1#*.} <= 5))\n  # echo\
    \ $((10#${1#*.} != 5))\n  # echo $((10#${1#*.} > 5))\n  # echo $((10#${1#*.} <\
    \ 5))\n  # echo $((10#${1#*.} == 5))\n  # echo $((10#${1#*.} >= 5))\n  # echo\
    \ $((10#${1#*.} <= 5))\n  # echo $((10#${1#*.} != 5))\n  # echo $((10#${1#*.}\
    \ > 5))\n  # echo $((10#${1#*.} < 5))\n  #\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpmaej1a4u.sh: line 49: syntax error near unexpected token `}''

    /tmp/tmpmaej1a4u.sh: line 49: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  printf \"%.0f\\n\" \"$1\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}'\n \
    \ # echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}'\n  # echo $1 | awk '{printf(\"\
    %d\\n\", $1 - 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}'\n  # echo\
    \ $1 | awk '{printf(\"%d\\n\", $1 - 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\\
    n\", $1 + 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1 - 0.5)}'\n  # echo\
    \ $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\\
    n\", $1 - 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}'\n  # echo\
    \ $1 | awk '{printf(\"%d\\n\", $1 - 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\\
    n\", $1 + 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1 - 0.5)}'\n  # echo\
    \ $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\\
    n\", $1 - 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}'\n  # echo\
    \ $1 | awk '{printf(\"%d\\n\", $1 - 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\\
    n\", $1 + 0.5)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1 - 0.5)}'\n  # echo\
    \ $1 | awk\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpijob2536.sh: line 36: syntax error near unexpected token `}''

    /tmp/tmpijob2536.sh: line 36: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=${1}\n  local int=$(printf \"%.0f\" \"${num}\")\n  local decimal=$(echo\
    \ \"${num} - ${int}\" | bc)\n  if (( $(echo \"${decimal} > 0.5\" | bc -l) ));\
    \ then\n    (( int++ ))\n  elif (( $(echo \"${decimal} < -0.5\" | bc -l) )); then\n\
    \    (( int-- ))\n  fi\n  echo \"${int}\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"Not implemented\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to get the first\
    \ argument passed to the function\n  echo $1\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # your\
    \ code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ $1 | awk '{printf(\"%d\\n\", $1 + 0.5 * sign($1))}'\n}\n\ncandidate() {\n  \
    \  closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n\
    \  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\
    \ ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n\
    \  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo\
    \ ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n\
    \  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\
    \ ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n\
    \  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo\
    \ ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n\
    \  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\
    \ ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n\
    \  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo\
    \ ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_i3bgap2.sh: line 72: syntax error near unexpected token `}''

    /tmp/tmp_i3bgap2.sh: line 72: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n\
    \  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo\
    \ ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n\
    \  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo\
    \ ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n\
    \  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo\
    \ ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n\
    \  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo\
    \ ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n\
    \  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo\
    \ ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n\
    \  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo\
    \ ${1#*.}\n  # echo ${1#*.}\n  # echo ${1#*.}\n  # echo\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbt1wwmu_.sh: line 72: syntax error near unexpected token `}''

    /tmp/tmpbt1wwmu_.sh: line 72: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  if [[ $1 =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n    if [[ $1 =~\
    \ ^-?[0-9]+\\.5$ ]]; then\n      if [[ $1 =~ ^- ]]; then\n        echo $(( $1\
    \ - 1 ))\n      else\n        echo $(( $1 + 1 ))\n      fi\n    else\n      echo\
    \ $(( $1 + 0.5 )) | cut -d. -f1\n    fi\n  else\n    echo $1\n  fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpq6on5s6z.sh: line 20: 14.5 + 1 : syntax error: invalid arithmetic
    operator (error token is ".5 + 1 ")

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local decimal=${number##*.}\n  local integer=${number%.*}\n  if\
    \ [[ $decimal -ge 5 ]]; then\n    ((integer++))\n  fi\n  echo $integer\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo \"0\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo -n \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}${1#*.}\n\
    \  # echo ${1%.*}${1#*.} | bc\n  # echo ${1%.*}${1#*.} | bc | cut -c1\n  # echo\
    \ ${1%.*}${1#*.} | bc | cut -c1-1\n  # echo ${1%.*}${1#*.} | bc | cut -c1-1 |\
    \ sed 's/^0*//'\n  # echo ${1%.*}${1#*.} | bc | cut -c1-1 | sed 's/^0*//' | sed\
    \ 's/^-0*//'\n  # echo ${1%.*}${1#*.} | bc | cut -c1-1 | sed 's/^0*//' | sed 's/^-0*//'\
    \ | sed 's/^$/0/'\n  # echo ${1%.*}${1#*.} | bc | cut -c1-1 | sed 's/^0*//' |\
    \ sed 's/^-0*//' | sed 's/^$/0/' | sed 's/^-//'\n  # echo ${1%.*}${1#*.} | bc\
    \ | cut -c1-1 | sed 's/^0*//' | sed 's/^-0*//' | sed 's/^$/0/' | sed 's/^-//'\
    \ | sed 's/^/0/'\n  # echo ${1%.*}${1#*.} | bc | cut -c1-1 | sed 's/^0*//' | sed\
    \ 's/^-0*//' | sed 's/^$/0/' | sed 's/^-//' | sed 's/^/0/' | sed 's/^-/1/'\n \
    \ # echo ${1%.*}${1#*.} | bc | cut -c1-1 | sed 's/^0*//' | sed 's/^-0*//' | sed\
    \ 's/^$/\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpf9zho046.sh: line 29: syntax error near unexpected token `}''

    /tmp/tmpf9zho046.sh: line 29: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to access the first\
    \ argument to the function\n  # Use return to return a value\n  echo \"Not implemented\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}'\n \
    \ # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\n\
    \  # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' |\
    \ awk '{printf(\"%d\\n\", $1)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}' |\
    \ awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\
    \ | awk '{printf(\"%d\\n\", $1)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}'\
    \ | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\n\
    \  # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' |\
    \ awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\n\
    \  # echo $1 | awk\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpaupreh1y.sh: line 24: syntax error near unexpected token `}''

    /tmp/tmpaupreh1y.sh: line 24: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local decimal=$(echo $number | cut -d. -f2)\n  local integer=$(echo\
    \ $number | cut -d. -f1)\n  if [ \"$decimal\" -gt \"5\" ]; then\n    echo $((integer\
    \ + 1))\n  elif [ \"$decimal\" -lt \"5\" ]; then\n    echo $integer\n  else\n\
    \    if [ \"$integer\" -gt \"0\" ]; then\n      echo $((integer + 1))\n    else\n\
    \      echo $((integer - 1))\n    fi\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}${1#*.}\n\
    \  # echo ${1%.*}${1#*.} | sed 's/^0*//'\n  # echo ${1%.*}${1#*.} | sed 's/^0*//'\
    \ | wc -c\n  # echo ${1%.*}${1#*.} | sed 's/^0*//' | wc -c | sed 's/ //g'\n  #\
    \ echo ${1%.*}${1#*.} | sed 's/^0*//' | wc -c | sed 's/ //g' | sed 's/^0*//'\n\
    \  # echo ${1%.*}${1#*.} | sed 's/^0*//' | wc -c | sed 's/ //g' | sed 's/^0*//'\
    \ | sed 's/^0*//'\n  # echo ${1%.*}${1#*.} | sed 's/^0*//' | wc -c | sed 's/ //g'\
    \ | sed 's/^0*//' | sed 's/^0*//' | sed 's/^0*//'\n  # echo ${1%.*}${1#*.} | sed\
    \ 's/^0*//' | wc -c | sed 's/ //g' | sed 's/^0*//' | sed 's/^0*//' | sed 's/^0*//'\
    \ | sed 's/^0*//'\n  # echo ${1%.*}${1#*.} | sed 's/^0*//' | wc -c | sed 's/ //g'\
    \ | sed 's/^0*//' | sed 's/^0*//' | sed 's/^0*//' | sed 's/^0*//' | sed 's/^0*//'\n\
    \  # echo ${1%.*}${1#*.} | sed 's/^0*//' | wc -c | sed 's/ //g' | sed 's/\n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpmmg8ru7o.sh: line 28: syntax error near unexpected token `}''

    /tmp/tmpmmg8ru7o.sh: line 28: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\"\
    \ | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  #\
    \ echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\"\
    \ | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  #\
    \ echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  #\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpyoc23m48.sh: line 48: syntax error near unexpected token `}''

    /tmp/tmpyoc23m48.sh: line 48: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # your\
    \ code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local integer=$(printf \"%.0f\" $number)\n  local decimal=$(echo\
    \ $number | cut -d'.' -f2)\n  if [ -z $decimal ]; then\n    echo $integer\n  elif\
    \ [ $decimal -gt 0 ]; then\n    echo $((integer + 1))\n  else\n    echo $((integer\
    \ - 1))\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n   \
    \ #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n  \
    \  #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n \
    \   #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp0x6plbpt.sh: line 184: syntax error near unexpected token `}''

    /tmp/tmp0x6plbpt.sh: line 184: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n\
    \  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\
    \ ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n\
    \  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo\
    \ ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n\
    \  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\
    \ ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n\
    \  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo\
    \ ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n\
    \  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\
    \ ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n\
    \  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo\
    \ ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}\n  # echo\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_i3bgap2.sh: line 72: syntax error near unexpected token `}''

    /tmp/tmp_i3bgap2.sh: line 72: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # You can access the input string as $1\n  # You can print\
    \ to standard output using echo\n  # To debug: echo \"Debug messages...\" >&2\n\
    \  #\n  # echo \"14.5\" | awk '{printf(\"%d\\n\",$1)}'\n  # echo \"-14.5\" | awk\
    \ '{printf(\"%d\\n\",$1)}'\n  # echo \"14.5\" | awk '{printf(\"%d\\n\",$1+0.5)}'\n\
    \  # echo \"-14.5\" | awk '{printf(\"%d\\n\",$1-0.5)}'\n  # echo \"14.5\" | awk\
    \ '{printf(\"%d\\n\",$1+0.5); printf(\"%d\\n\",$1-0.5)}'\n  # echo \"-14.5\" |\
    \ awk '{printf(\"%d\\n\",$1+0.5); printf(\"%d\\n\",$1-0.5)}'\n  # echo \"14.5\"\
    \ | awk '{printf(\"%d\\n\",$1+0.5); printf(\"%d\\n\",$1-0.5); printf(\"%d\\n\"\
    ,$1)}'\n  # echo \"-14.5\" | awk '{printf(\"%d\\n\",$1+0.5); printf(\"%d\\n\"\
    ,$1-0.5); printf(\"%d\\n\",$1)}'\n  # echo \"14.5\" | awk '{printf(\"%d\\n\",$1+0.5);\
    \ printf(\"%d\\n\",$1-0.5); printf(\"%d\\n\",$1); printf(\"%d\\n\",$1-1)}'\n \
    \ # echo \"-14.5\" | awk '{printf(\"%d\\n\",$1+0.5); printf(\"%d\\n\",$1-0.5);\
    \ printf(\"%d\\n\",$1); printf(\"%d\\n\",$1-1)}'\n  # echo \"14.5\" | awk '{printf(\"\
    %d\\n\",$1+0.5); printf(\"%d\\n\",\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpv1gu8xfc.sh: line 30: syntax error near unexpected token `}''

    /tmp/tmpv1gu8xfc.sh: line 30: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  #echo \"closest_integer($1)\"\n  #echo \"scale=0; $1/1\" |\
    \ bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo\
    \ \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\"\
    \ | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo\
    \ \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\"\
    \ | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo\
    \ \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\"\
    \ | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo\
    \ \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\"\
    \ | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo\
    \ \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\"\
    \ | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo\
    \ \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpth5oxoxj.sh: line 47: syntax error near unexpected token `}''

    /tmp/tmpth5oxoxj.sh: line 47: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo -n \"Your answer is:\
    \ \"\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # your\
    \ code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to get the first\
    \ argument\n  # Use $2 to get the second argument\n  # Use $# to get the number\
    \ of arguments\n  # Use $@ to get all the arguments\n  # Use $? to get the exit\
    \ status of the last command\n  # Use $$ to get the process ID of the current\
    \ shell\n  # Use $USER to get the username of the current user\n  # Use $HOSTNAME\
    \ to get the hostname of the machine\n  # Use $SECONDS to get the number of seconds\
    \ since the shell was started\n  # Use $RANDOM to get a random number\n  # Use\
    \ $LINENO to get the current line number in the Bash script\n  # Use $0 to get\
    \ the name of the Bash script\n  # Use $FUNCNAME to get the name of the current\
    \ function\n  # Use $DIRSTACK to get an array of the current contents of the directory\
    \ stack\n  # Use $PIPESTATUS to get an array of exit statuses from the processes\
    \ in the most recently executed foreground pipeline\n  # Use $BASH_VERSION to\
    \ get the version of Bash running\n  # Use $BASH_VERSINFO to get an array variable\
    \ whose members hold version information for this instance of Bash\n  # Use $BASH_SOURCE\
    \ to get an array variable whose members are the source filenames where the corresponding\
    \ shell function names in the FUNCNAME array variable are defined\n  # Use $BASH_LINENO\
    \ to get an array variable whose members are the line numbers in source filenames\
    \ where the corresponding shell function names in the FUNCNAME array variable\
    \ are defined\n  # Use $BASH_EXECUTION_STRING to get the original command argument\
    \ string\n  # Use $BASH_REMATCH to get an array variable whose members are assigned\
    \ by the =~ binary operator to the [[ conditional command\n  # Use $BASH_SUBSHELL\
    \ to get the subshell level\n  # Use $BASH_SUBSHELL to get the subshell level\n\
    \  # Use $BASH_SUBSHELL to get the subshell level\n  # Use $BASH_SUBSHELL to get\
    \ the subshell level\n  # Use $BASH_SUBSHELL to get the subshell level\n \n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1y8smxg6.sh: line 43: syntax error near unexpected token `}''

    /tmp/tmp1y8smxg6.sh: line 43: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=$1\n  local int=${num%.*}\n  local dec=${num#*.}\n  if (( dec >= 5 )); then\n\
    \    (( int++ ))\n  fi\n  echo $int\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  #echo \"closest_integer\"\n  #echo $1\n  #echo \"scale=0;\
    \ $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n\
    \  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0;\
    \ $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n\
    \  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0;\
    \ $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n\
    \  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0;\
    \ $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n\
    \  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0;\
    \ $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n\
    \  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0;\
    \ $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n\
    \  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0; $1/1\" | bc\n  #echo \"scale=0\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpa4_yj94p.sh: line 48: syntax error near unexpected token `}''

    /tmp/tmpa4_yj94p.sh: line 48: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    # Use echo to print to stdout\n    echo \"Not implemented\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $1 | awk '{print int($1+0.5)}'\n  # echo\
    \ $1 | awk '{print int($1+0.5)}' | bc\n  echo $1 | awk '{print int($1+0.5)}' |\
    \ bc\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc | awk '{printf \"%d\\n\", $0}'\n  # echo \"scale=0; $1/1\" | bc\
    \ | awk '{printf \"%d\\n\", $0}' | sed 's/^-//'\n  # echo \"scale=0; $1/1\" |\
    \ bc | awk '{printf \"%d\\n\", $0}' | sed 's/^-//' | sed 's/^0//'\n  # echo \"\
    scale=0; $1/1\" | bc | awk '{printf \"%d\\n\", $0}' | sed 's/^-//' | sed 's/^0//'\
    \ | sed 's/^/0/'\n  # echo \"scale=0; $1/1\" | bc | awk '{printf \"%d\\n\", $0}'\
    \ | sed 's/^-//' | sed 's/^0//' | sed 's/^/0/' | sed 's/^/-/'\n  echo \"scale=0;\
    \ $1/1\" | bc | awk '{printf \"%d\\n\", $0}' | sed 's/^-//' | sed 's/^0//' | sed\
    \ 's/^/0/' | sed 's/^/-/'\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  local number=$1\n  local int_number=$(echo $number | cut -d.\
    \ -f1)\n  local decimal_number=$(echo $number | cut -d. -f2)\n  if [ $decimal_number\
    \ -ge 5 ]; then\n    echo $((int_number + 1))\n  else\n    echo $int_number\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5 * sign($1))}'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  #\n  # Hint:\n  #   Use the bash built-in command `bc` to\
    \ do floating point arithmetic\n  #   and the bash built-in command `echo` to\
    \ print the result.\n  #   For example, `echo \"1.2 + 2.3\" | bc` prints 3.5.\n\
    \  #   See the man page of `bc` for more information.\n  #\n  #   You may also\
    \ want to use the bash built-in command `printf` to\n  #   format the output.\n\
    \  #   For example, `printf \"%0.2f\" 3.5` prints 3.50.\n  #   See the man page\
    \ of `printf` for more information.\n  #\n  #   You may also want to use the bash\
    \ built-in command `test` to\n  #   check if a number is positive or negative.\n\
    \  #   For example, `test 3 -gt 0` returns true (0) and `test 3 -lt 0`\n  #  \
    \ returns false (1).\n  #   See the man page of `test` for more information.\n\
    \  #\n  #   You may also want to use the bash built-in command `expr` to\n  #\
    \   do arithmetic.\n  #   For example, `expr 3 + 4` prints 7.\n  #   See the man\
    \ page of `expr` for more information.\n  #\n  #   You may also want to use the\
    \ bash built-in command `seq` to\n  #   generate a sequence of numbers.\n  # \
    \  For example, `seq 1 3` prints 1 2 3.\n  #   See the man page of `seq` for more\
    \ information.\n  #\n  #   You may also want to use the bash built-in command\
    \ `sort` to\n  #   sort a list of numbers.\n  #   For example, `echo \"3 2 1\"\
    \ | sort -n` prints 1 2 3.\n  #   See the man page of `sort` for more information.\n\
    \  #\n  #   You may also want to use the bash built-in command `head` to\n  #\
    \   get the first element of a list.\n  #   For example, `echo \"1 2 3\" | head\
    \ -n 1` prints\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpkcam68mt.sh: line 51: syntax error near unexpected token `}''

    /tmp/tmpkcam68mt.sh: line 51: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo \"$1\" | awk '{printf(\"%d\\n\", $1)}'\n  # echo \"\
    $1\" | awk '{printf(\"%d\\n\", $1+0.5)}'\n  # echo \"$1\" | awk '{printf(\"%d\\\
    n\", $1-0.5)}'\n  # echo \"$1\" | awk '{printf(\"%d\\n\", $1+0.5)}'\n  # echo\
    \ \"$1\" | awk '{printf(\"%d\\n\", $1-0.5)}'\n  # echo \"$1\" | awk '{printf(\"\
    %d\\n\", $1+0.5)}'\n  # echo \"$1\" | awk '{printf(\"%d\\n\", $1-0.5)}'\n  # echo\
    \ \"$1\" | awk '{printf(\"%d\\n\", $1+0.5)}'\n  # echo \"$1\" | awk '{printf(\"\
    %d\\n\", $1-0.5)}'\n  # echo \"$1\" | awk '{printf(\"%d\\n\", $1+0.5)}'\n  # echo\
    \ \"$1\" | awk '{printf(\"%d\\n\", $1-0.5)}'\n  # echo \"$1\" | awk '{printf(\"\
    %d\\n\", $1+0.5)}'\n  # echo \"$1\" | awk '{printf(\"%d\\n\", $1-0.5)}'\n  # echo\
    \ \"$1\" | awk '{printf(\"%d\\n\", $1+0.5)}'\n  # echo \"$1\" | awk '{printf(\"\
    %d\\n\", $1-0.5)}'\n  # echo \"$1\" | awk '{printf(\"%d\\n\", $1+0.5)}'\n  # echo\
    \ \"$1\" | awk '{printf(\"%d\\n\", $1-0.5)}'\n  # echo \"$1\" | awk '{printf(\"\
    %d\\n\", $1+0.5)}'\n  # echo \"$1\" | awk '{printf(\"%d\\n\", $1-0\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_xmgnlmc.sh: line 34: syntax error near unexpected token `}''

    /tmp/tmp_xmgnlmc.sh: line 34: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo \"Not implemented\"\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # $1 is a string\n  # return the closest integer to it\n \
    \ # If the number is equidistant from two integers, round it away from zero.\n\
    \  # Examples\n  # Note:\n  # Rounding away from zero means that if the given\
    \ number is equidistant\n  # from two integers, the one you should return is the\
    \ one that is the\n  # farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n  # return 15 and closest_integer(\"-14.5\") should return -15.\n  #\n\
    \  # $1 is a string\n  # return the closest integer to it\n  # If the number is\
    \ equidistant from two integers, round it away from zero.\n  # Examples\n  # Note:\n\
    \  # Rounding away from zero means that if the given number is equidistant\n \
    \ # from two integers, the one you should return is the one that is the\n  # farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n  # return 15 and closest_integer(\"\
    -14.5\") should return -15.\n  #\n  # $1 is a string\n  # return the closest integer\
    \ to it\n  # If the number is equidistant from two integers, round it away from\
    \ zero.\n  # Examples\n  # Note:\n  # Rounding away from zero means that if the\
    \ given number is equidistant\n  # from two integers, the one you should return\
    \ is the one that is the\n  # farthest from zero. For example closest_integer(\"\
    14.5\") should\n  # return 15 and closest_integer(\"-14.5\") should return -15.\n\
    \  #\n  # $1 is a string\n  # return the closest integer to it\n  # If the number\
    \ is equidistant from two integers, round it away from zero.\n  # Examples\n \
    \ # Note:\n  # Rounding away from zero means that if the given number is equidistant\n\
    \  # from two integers, the one you should return is the one that is the\n  #\
    \ farthest from zero. For example closest_integer(\"14.5\") should\n  # return\
    \ 15 and closest_integer(\"-14.5\") should return -15.\n  #\n  # $1 is a string\n\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpedyzf4_a.sh: line 57: syntax error near unexpected token `}''

    /tmp/tmpedyzf4_a.sh: line 57: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\"\
    \ | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  #\
    \ echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\"\
    \ | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  #\
    \ echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  #\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpyoc23m48.sh: line 48: syntax error near unexpected token `}''

    /tmp/tmpyoc23m48.sh: line 48: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1%.*}${1#*.}\n\
    \  # echo ${1%.*}${1#*.} | sed 's/^-//'\n  # echo ${1%.*}${1#*.} | sed 's/^-//'\
    \ | wc -c\n  # echo ${1%.*}${1#*.} | sed 's/^-//' | wc -c | sed 's/^1//'\n  #\
    \ echo ${1%.*}${1#*.} | sed 's/^-//' | wc -c | sed 's/^1//' | wc -c\n  # echo\
    \ ${1%.*}${1#*.} | sed 's/^-//' | wc -c | sed 's/^1//' | wc -c | sed 's/^1//'\n\
    \  # echo ${1%.*}${1#*.} | sed 's/^-//' | wc -c | sed 's/^1//' | wc -c | sed 's/^1//'\
    \ | sed 's/^1//'\n  # echo ${1%.*}${1#*.} | sed 's/^-//' | wc -c | sed 's/^1//'\
    \ | wc -c | sed 's/^1//' | sed 's/^1//' | sed 's/^1//'\n  # echo ${1%.*}${1#*.}\
    \ | sed 's/^-//' | wc -c | sed 's/^1//' | wc -c | sed 's/^1//' | sed 's/^1//'\
    \ | sed 's/^1//' | sed 's/^1//'\n  # echo ${1%.*}${1#*.} | sed 's/^-//' | wc -c\
    \ | sed 's/^1//' | wc -c | sed 's/^1//' | sed 's/^1//' | sed 's/^1//' | sed 's/^1//'\
    \ |\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpan265_ur.sh: line 28: syntax error near unexpected token `}''

    /tmp/tmpan265_ur.sh: line 28: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to get the first\
    \ argument passed\n  # Use $# to get the number of arguments passed\n  # Use $@\
    \ to get all arguments passed\n  # Use $? to get the exit status of the last command\n\
    \  # Use $$ to get the process ID of the current shell\n  # Use $0 to get the\
    \ name of the shell or shell script\n  # Use $USER to get the username of the\
    \ user running the script\n  # Use $HOSTNAME to get the hostname of the machine\
    \ the script is running on\n  # Use $SECONDS to get the number of seconds since\
    \ the shell was started\n  # Use $RANDOM to get a random number\n  # Use $LINENO\
    \ to get the current line number in the Bash script\n  # Use $DIRSTACK to get\
    \ an array of directory names that the shell has visited\n  # Use $BASH_VERSION\
    \ to get the version of the current instance of Bash\n  # Use $BASH_VERSINFO to\
    \ get an array of version information for the current instance of Bash\n  # Use\
    \ $EUID to get the numeric effective user ID of the current user\n  # Use $UID\
    \ to get the numeric real user ID of the current user\n  # Use $FUNCNAME to get\
    \ the name of the current function or dot script\n  # Use $GROUPS to get an array\
    \ of group IDs that the current user is a member of\n  # Use $HISTFILE to get\
    \ the name of the file in which the command history is saved\n  # Use $HISTFILESIZE\
    \ to get the maximum number of lines contained in the history file\n  # Use $HISTSIZE\
    \ to get the maximum number of commands to remember on the history list\n  # Use\
    \ $HOSTTYPE to get the type of machine Bash is running on\n  # Use $MACHTYPE to\
    \ get a string that fully describes the system type on which Bash is running\n\
    \  # Use $OSTYPE to get a string describing the operating system Bash is running\
    \ on\n  # Use $PIPESTATUS to get an array of exit status values from the processes\
    \ in the most-recently-executed foreground pipeline\n  # Use $SHELLOPTS to get\
    \ a list of enabled shell options\n  # Use $SHLVL to get the\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpgzzcqqre.sh: line 43: syntax error near unexpected token `}''

    /tmp/tmpgzzcqqre.sh: line 43: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"Not implemented\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local int_part=${number%.*}\n  local dec_part=${number#*.}\n  if\
    \ (( dec_part >= 5 )); then\n    (( int_part++ ))\n  fi\n  echo $int_part\n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1 | awk '{printf \"%.0f\\n\", $1}'\n  echo $1 | awk\
    \ '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo \"Not implemented yet\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo \"closest_integer($1)\"\n  # echo \"closest_integer(14.5)\"\
    \n  # echo \"closest_integer(-14.5)\"\n  # echo \"closest_integer(14.4)\"\n  #\
    \ echo \"closest_integer(-14.4)\"\n  # echo \"closest_integer(14.6)\"\n  # echo\
    \ \"closest_integer(-14.6)\"\n  # echo \"closest_integer(14.0)\"\n  # echo \"\
    closest_integer(-14.0)\"\n  # echo \"closest_integer(0.0)\"\n  # echo \"closest_integer(-0.0)\"\
    \n  # echo \"closest_integer(0.1)\"\n  # echo \"closest_integer(-0.1)\"\n  # echo\
    \ \"closest_integer(0.5)\"\n  # echo \"closest_integer(-0.5)\"\n  # echo \"closest_integer(0.6)\"\
    \n  # echo \"closest_integer(-0.6)\"\n  # echo \"closest_integer(0.9)\"\n  # echo\
    \ \"closest_integer(-0.9)\"\n  # echo \"closest_integer(0.99)\"\n  # echo \"closest_integer(-0.99)\"\
    \n  # echo \"closest_integer(1.0)\"\n  # echo \"closest_integer(-1.0)\"\n  # echo\
    \ \"closest_integer(1.1)\"\n  # echo \"closest_integer(-1.1)\"\n  # echo \"closest_integer(1.5)\"\
    \n  # echo \"closest_integer(-1.5)\"\n  # echo \"closest_integer(1.6)\"\n  # echo\
    \ \"closest_integer(-1.6)\"\n  # echo \"closest_integer(1.9)\"\n  # echo \"closest_integer(-1.9)\"\
    \n  # echo \"closest_integer(1.99)\"\n  # echo \"closest_integer(-1.99)\"\n  #\
    \ echo \"closest_integer(2\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpn6qxm6gr.sh: line 49: syntax error near unexpected token `}''

    /tmp/tmpn6qxm6gr.sh: line 49: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    echo \"$1\" | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1#*.}\
    \ | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1#*.} | cut -c 1\n  # echo\
    \ ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n\
    \  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} |\
    \ cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo\
    \ ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n\
    \  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} |\
    \ cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo\
    \ ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n\
    \  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} |\
    \ cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo\
    \ ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n\
    \  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${1%.*} |\
    \ cut -c 1\n  # echo ${1%.*} | cut -c 1\n  # echo ${\n}\n\ncandidate() {\n   \
    \ closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmppv5xfh2h.sh: line 53: syntax error near unexpected token `}''

    /tmp/tmppv5xfh2h.sh: line 53: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1 + 0.5 * sign($1)}'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"scale=0; $1/1\" | bc\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  printf \"%.0f\\n\" \"$1\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo \"Not implemented yet\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1 + 0.5 * sign($1)}'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo \"Not implemented\"\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to get the first\
    \ argument\n  # Use $2 to get the second argument\n  # Use $# to get the number\
    \ of arguments\n  # Use $@ to get all arguments\n  # Use $? to get the exit code\
    \ of the last command\n  # Use $$ to get the process ID of the current shell\n\
    \  # Use $USER to get the username of the current user\n  # Use $HOSTNAME to get\
    \ the hostname of the machine\n  # Use $SECONDS to get the number of seconds since\
    \ the shell was started\n  # Use $RANDOM to get a random number\n  # Use $LINENO\
    \ to get the current line number in the Bash script\n  # Use $0 to get the name\
    \ of the Bash script\n  # Use $FUNCNAME to get the name of the current function\n\
    \  # Use $BASH_VERSION to get the version of Bash running\n  # Use $DIRSTACK to\
    \ get the list of directories in the directory stack\n  # Use $PIPESTATUS to get\
    \ the exit code of the last command in a pipe\n  # Use $MACHTYPE to get the system\
    \ type of the machine Bash is running on\n  # Use $BASH_LINENO to get the current\
    \ line number in the Bash script\n  # Use $BASH_SOURCE to get the name of the\
    \ Bash script\n  # Use $BASH_SUBSHELL to get the subshell level of the current\
    \ process\n  # Use $BASHPID to get the process ID of the current Bash process\n\
    \  # Use $BASH_EXECUTION_STRING to get the string argument passed to the -c option\n\
    \  # Use $BASH_REMATCH to get the array of matched substrings from the last regex\
    \ match\n  # Use $BASH_VERSINFO to get the version information for this instance\
    \ of Bash\n  # Use $BASH_ARGC to get the number of arguments supplied to a function\n\
    \  # Use $BASH_ARGV to get the array of arguments supplied to a function\n  #\
    \ Use $BASH_COMMAND to get the command currently being executed\n  # Use $BASH_ENV\
    \ to get the name of the startup file\n  # Use $BASH_SUBSHELL\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7x9lr0wk.sh: line 45: syntax error near unexpected token `}''

    /tmp/tmp7x9lr0wk.sh: line 45: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $1 | awk '{print int($1+0.5)}'\n  # echo\
    \ $1 | awk '{print int($1+0.5)}' | bc\n  # echo $1 | awk '{print int($1+0.5)}'\
    \ | bc | sed 's/-//g'\n  # echo $1 | awk '{print int($1+0.5)}' | bc | sed 's/-//g'\
    \ | sed 's/^0*//'\n  # echo $1 | awk '{print int($1+0.5)}' | bc | sed 's/-//g'\
    \ | sed 's/^0*//' | sed 's/^-0*//'\n  # echo $1 | awk '{print int($1+0.5)}' |\
    \ bc | sed 's/-//g' | sed 's/^0*//' | sed 's/^-0*//' | sed 's/^-//'\n  # echo\
    \ $1 | awk '{print int($1+0.5)}' | bc | sed 's/-//g' | sed 's/^0*//' | sed 's/^-0*//'\
    \ | sed 's/^-//' | sed 's/^0*//'\n  # echo $1 | awk '{print int($1+0.5)}' | bc\
    \ | sed 's/-//g' | sed 's/^0*//' | sed 's/^-0*//' | sed 's/^-//' | sed 's/^0*//'\
    \ | sed 's/^-0*//'\n  # echo $1 | awk '{print int($1+0.5)}' | bc | sed 's/-//g'\
    \ | sed 's/^0*//' | sed 's/^-0*//' | sed 's/^-//' | sed 's/^0*//' | sed 's/^-0*//'\
    \ | sed 's/^-//'\n  # echo $1 | awk '{print int($1+0.5)}' | bc | sed '\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpezp1ncp8.sh: line 26: syntax error near unexpected token `}''

    /tmp/tmpezp1ncp8.sh: line 26: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    # Use echo to print to stdout\n    echo $1\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use printf to print to\
    \ stderr\n  printf \"Not yet implemented\" 1>&2\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: Not yet implemented
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{print int($1+0.5)}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local floor=$(echo \"$number\" | awk '{print int($1)}')\n  local\
    \ ceil=$(echo \"$number\" | awk '{print int($1)+1}')\n  local diff_floor=$(echo\
    \ \"$number - $floor\" | bc -l)\n  local diff_ceil=$(echo \"$ceil - $number\"\
    \ | bc -l)\n  if [[ \"$diff_floor\" == \"$diff_ceil\" ]]; then\n    if [[ \"$number\"\
    \ -lt 0 ]]; then\n      echo \"$ceil\"\n    else\n      echo \"$floor\"\n    fi\n\
    \  elif [[ \"$diff_floor\" -lt \"$diff_ceil\" ]]; then\n    echo \"$floor\"\n\
    \  else\n    echo \"$ceil\"\n  fi\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpk334bh2o.sh: line 20: [[: 14.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}'\n \
    \ # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\n\
    \  # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' |\
    \ awk '{printf(\"%d\\n\", $1)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}' |\
    \ awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\
    \ | awk '{printf(\"%d\\n\", $1)}'\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}'\
    \ | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\n\
    \  # echo $1 | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' |\
    \ awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"\
    %d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}' | awk '{printf(\"%d\\n\", $1)}'\n\
    \  # echo $1 | awk\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpaupreh1y.sh: line 24: syntax error near unexpected token `}''

    /tmp/tmpaupreh1y.sh: line 24: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  printf\
    \ \"%.0f\\n\" \"$1\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo $1\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  #echo \"Not implemented yet\"\
    \n  #echo $1\n  #echo $1 | awk '{printf(\"%d\\n\", $1)}'\n  #echo $1 | awk '{printf(\"\
    %d\\n\", $1 + 0.5)}'\n  #echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"\
    %d\\n\", $1)}'\n  #echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"\
    %d\\n\", $1 + 0.5)}'\n  #echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"\
    %d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\", $1)}'\n  #echo $1 | awk '{printf(\"\
    %d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\\
    n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\", $1)}'\n  #echo $1 | awk '{printf(\"\
    %d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\\
    n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\"\
    , $1)}'\n  #echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\\
    n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\", $1 + 0.5)}' | awk '{printf(\"%d\\n\"\
    , $1 + 0.5)}' | awk '{printf(\"%d\\n\",\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7gp0gl8p.sh: line 26: syntax error near unexpected token `}''

    /tmp/tmp7gp0gl8p.sh: line 26: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1+0.5}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 0
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  if [[ $1 == *.* ]]; then\n    if [[ $1 == *.*5 ]]; then\n\
    \      if [[ $1 == -* ]]; then\n        echo $(( ${1%.*} - 1 ))\n      else\n\
    \        echo $(( ${1%.*} + 1 ))\n      fi\n    else\n      echo ${1%.*}\n   \
    \ fi\n  else\n    echo $1\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  printf \"%.0f\\n\" \"$1\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $2\n  # echo $3\n  # echo $4\n  # echo\
    \ $5\n  # echo $6\n  # echo $7\n  # echo $8\n  # echo $9\n  # echo ${10}\n  #\
    \ echo ${11}\n  # echo ${12}\n  # echo ${13}\n  # echo ${14}\n  # echo ${15}\n\
    \  # echo ${16}\n  # echo ${17}\n  # echo ${18}\n  # echo ${19}\n  # echo ${20}\n\
    \  # echo ${21}\n  # echo ${22}\n  # echo ${23}\n  # echo ${24}\n  # echo ${25}\n\
    \  # echo ${26}\n  # echo ${27}\n  # echo ${28}\n  # echo ${29}\n  # echo ${30}\n\
    \  # echo ${31}\n  # echo ${32}\n  # echo ${33}\n  # echo ${34}\n  # echo ${35}\n\
    \  # echo ${36}\n  # echo ${37}\n  # echo ${38}\n  # echo ${39}\n  # echo ${40}\n\
    \  # echo ${41}\n  # echo ${42}\n  # echo ${43}\n  # echo ${44}\n  # echo ${45}\n\
    \  # echo ${46}\n  # echo ${47}\n  # echo ${48}\n  # echo ${49}\n  # echo ${50}\n\
    \  # echo ${51}\n  # echo ${52}\n  # echo ${53}\n  # echo ${54}\n  # echo ${55}\n\
    \  # echo ${56}\n  # echo ${57}\n  # echo ${58}\n  # echo ${59}\n  # echo ${60}\n\
    \  # echo ${61}\n  # echo ${62}\n  # echo ${63}\n  # echo ${64}\n  # echo ${65}\n\
    \  # echo ${66}\n  # echo ${67}\n  # echo ${68}\n  # echo ${69}\n  # echo ${70}\n\
    \  # echo ${71}\n  # echo ${72}\n  # echo ${73}\n  #\n}\n\ncandidate() {\n   \
    \ closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp2w1mqpxq.sh: line 89: syntax error near unexpected token `}''

    /tmp/tmp2w1mqpxq.sh: line 89: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  if [[ $1 =~ ^[0-9]+$ ]]; then\n    echo $1\n  elif [[ $1 =~\
    \ ^[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d. -f1\n  elif [[ $1 =~ ^\\-[0-9]+\\\
    .[0-9]+$ ]]; then\n    echo $1 | cut -d. -f1\n  elif [[ $1 =~ ^\\-[0-9]+$ ]];\
    \ then\n    echo $1\n  elif [[ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1\
    \ | cut -d. -f1\n  elif [[ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 |\
    \ cut -d. -f1\n  elif [[ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut\
    \ -d. -f1\n  elif [[ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d.\
    \ -f1\n  elif [[ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d. -f1\n\
    \  elif [[ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d. -f1\n  elif\
    \ [[ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d. -f1\n  elif [[\
    \ $1 =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d. -f1\n  elif [[ $1\
    \ =~ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d. -f1\n  elif [[ $1 =~\
    \ ^\\-[0-9]+\\.[0-9]+$ ]]; then\n    echo\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpo36m94_k.sh: line 43: syntax error near unexpected token `}''

    /tmp/tmpo36m94_k.sh: line 43: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Round the number to the nearest integer\n  # and print it\
    \ to standard output (stdout)\n  # Example:\n  #   echo \"15\"\n  #   echo \"\
    -15\"\n  #   echo \"0\"\n  #   echo \"1\"\n  #   echo \"-1\"\n  #   echo \"14.5\"\
    \n  #   echo \"-14.5\"\n  #   echo \"14.4\"\n  #   echo \"-14.4\"\n  #   echo\
    \ \"14.6\"\n  #   echo \"-14.6\"\n  #   echo \"14.49\"\n  #   echo \"-14.49\"\n\
    \  #   echo \"14.51\"\n  #   echo \"-14.51\"\n  #   echo \"14.500000000000001\"\
    \n  #   echo \"-14.500000000000001\"\n  #   echo \"14.500000000000002\"\n  # \
    \  echo \"-14.500000000000002\"\n  #   echo \"14.500000000000003\"\n  #   echo\
    \ \"-14.500000000000003\"\n  #   echo \"14.500000000000004\"\n  #   echo \"-14.500000000000004\"\
    \n  #   echo \"14.500000000000005\"\n  #   echo \"-14.500000000000005\"\n  # \
    \  echo \"14.500000000000006\"\n  #   echo \"-14.500000000000006\"\n  #   echo\
    \ \"14.500000000000007\"\n  #   echo \"-14.500000000000007\"\n  #   echo \"14.500000000000008\"\
    \n  #   echo \"-14.500000000000008\"\n  #   echo \"14.500000000000009\"\n  # \
    \  echo \"-14.500000000000009\"\n  #   echo \"14.500000000000010\"\n  #   echo\
    \ \"-14.500000000000010\"\n  #   echo \"14.500000000000011\"\n  #   echo \"-14.500000000000011\"\
    \n  #   echo \"14.500000000000012\"\n  #   echo \"-14.500000000000012\"\n  # \
    \  echo \"14.500000000000013\"\n  #   echo \"-14.500000000000013\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmplxp5c3er.sh: line 59: syntax error near unexpected token `}''

    /tmp/tmplxp5c3er.sh: line 59: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\"\
    \ | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  #\
    \ echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\"\
    \ | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  #\
    \ echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0;\
    \ $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n\
    \  # echo \"scale=0; $1/1\" | bc\n  # echo \"scale=0; $1/1\" | bc\n  # echo \"\
    scale=0; $1/1\" | bc\n  #\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpyoc23m48.sh: line 48: syntax error near unexpected token `}''

    /tmp/tmpyoc23m48.sh: line 48: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  #\n  # Hint:\n  #   Use the command `bc` to perform floating\
    \ point arithmetic.\n  #   For example, `bc <<< \"1.0 + 1.0\"` will return 2.0.\n\
    \  #   See the man page for more information.\n  #\n  #   You can use the command\
    \ `awk` to round a number.\n  #   For example, `awk '{print int($1+0.5)}' <<<\
    \ \"14.5\"` will return 15.\n  #   See the man page for more information.\n  #\n\
    \  #   You can use the command `paste` to concatenate strings.\n  #   For example,\
    \ `paste <(echo \"Hello\") <(echo \"World\")` will return \"HelloWorld\".\n  #\
    \   See the man page for more information.\n  #\n  #   You can use the command\
    \ `bc` to perform floating point arithmetic.\n  #   For example, `bc <<< \"1.0\
    \ + 1.0\"` will return 2.0.\n  #   See the man page for more information.\n  #\n\
    \  #   You can use the command `bc` to perform floating point arithmetic.\n  #\
    \   For example, `bc <<< \"1.0 + 1.0\"` will return 2.0.\n  #   See the man page\
    \ for more information.\n  #\n  #   You can use the command `bc` to perform floating\
    \ point arithmetic.\n  #   For example, `bc <<< \"1.0 + 1.0\"` will return 2.0.\n\
    \  #   See the man page for more information.\n  #\n  #   You can use the command\
    \ `bc` to perform floating point arithmetic.\n  #   For example, `bc <<< \"1.0\
    \ + 1.0\"` will return 2.0.\n  #   See the man page for more information.\n  #\n\
    \  #   You can use the command `bc` to perform floating point arithmetic.\n  #\
    \   For example, `bc <<< \"1.0 + 1.0\"` will return 2.0.\n  #   See the man page\
    \ for more information.\n  #\n  #   You can use the command `bc`\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpewsu632e.sh: line 50: syntax error near unexpected token `}''

    /tmp/tmpewsu632e.sh: line 50: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1#*.}\
    \ | cut -c 1\n  # echo ${1#*.} | cut -c 1 | grep -q [^0]\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo \"false\"\n  # echo ${1#*.} | cut\
    \ -c 1 | grep -q [^0] && echo \"true\" || echo\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7urx7jw_.sh: line 34: syntax error near unexpected token `}''

    /tmp/tmp7urx7jw_.sh: line 34: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\",$1)}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1+0.5}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=$1\n  local int=$(printf \"%.0f\" $num)\n  local dec=$(echo $num | cut -d.\
    \ -f2)\n  if [[ $dec -ge 5 ]]; then\n    echo $((int + 1))\n  else\n    echo $int\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local integer=$(printf \"%.0f\" \"$number\")\n  local decimal=$(printf\
    \ \"%.1f\" \"$number\")\n  local decimal_part=$(echo \"$decimal - $integer\" |\
    \ bc)\n  if (( $(echo \"$decimal_part > 0.5\" | bc -l) )); then\n    echo \"$((integer\
    \ + 1))\"\n  elif (( $(echo \"$decimal_part < -0.5\" | bc -l) )); then\n    echo\
    \ \"$((integer - 1))\"\n  else\n    echo \"$integer\"\n  fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to get the first\
    \ argument passed to the function\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # your\
    \ code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n  \
    \  closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  #echo $1\n  if [[ $1 =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n   \
    \ #echo \"is float\"\n    #echo $1 | awk '{printf(\"%d\\n\",$1)}'\n    #echo $1\
    \ | awk '{printf(\"%d\\n\",$1+0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\",$1-0.5)}'\n\
    \    #echo $1 | awk '{printf(\"%d\\n\",$1+0.5)}'\n    #echo $1 | awk '{printf(\"\
    %d\\n\",$1-0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\",$1+0.5)}'\n    #echo\
    \ $1 | awk '{printf(\"%d\\n\",$1-0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\"\
    ,$1+0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\",$1-0.5)}'\n    #echo $1 | awk\
    \ '{printf(\"%d\\n\",$1+0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\",$1-0.5)}'\n\
    \    #echo $1 | awk '{printf(\"%d\\n\",$1+0.5)}'\n    #echo $1 | awk '{printf(\"\
    %d\\n\",$1-0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\",$1+0.5)}'\n    #echo\
    \ $1 | awk '{printf(\"%d\\n\",$1-0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\"\
    ,$1+0.5)}'\n    #echo $1 | awk '{printf(\"%d\\n\",$1-0.5)}'\n    #echo $1 | awk\
    \ '{printf(\"%d\\n\",$1+0.5)}'\n\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpaasy9ld5.sh: line 37: syntax error near unexpected token `}''

    /tmp/tmpaasy9ld5.sh: line 37: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $1 | awk '{printf \"%d\\n\", $1}'\n  #\
    \ echo $1 | awk '{printf \"%d\\n\", $1+0.5}'\n  # echo $1 | awk '{printf \"%d\\\
    n\", $1-0.5}'\n  # echo $1 | awk '{printf \"%d\\n\", $1+0.5}'\n  # echo $1 | awk\
    \ '{printf \"%d\\n\", $1-0.5}'\n  # echo $1 | awk '{printf \"%d\\n\", $1+0.5}'\n\
    \  # echo $1 | awk '{printf \"%d\\n\", $1-0.5}'\n  # echo $1 | awk '{printf \"\
    %d\\n\", $1+0.5}'\n  # echo $1 | awk '{printf \"%d\\n\", $1-0.5}'\n  # echo $1\
    \ | awk '{printf \"%d\\n\", $1+0.5}'\n  # echo $1 | awk '{printf \"%d\\n\", $1-0.5}'\n\
    \  # echo $1 | awk '{printf \"%d\\n\", $1+0.5}'\n  # echo $1 | awk '{printf \"\
    %d\\n\", $1-0.5}'\n  # echo $1 | awk '{printf \"%d\\n\", $1+0.5}'\n  # echo $1\
    \ | awk '{printf \"%d\\n\", $1-0.5}'\n  # echo $1 | awk '{printf \"%d\\n\", $1+0.5}'\n\
    \  # echo $1 | awk '{printf \"%d\\n\", $1-0.5}'\n  # echo $1 | awk '{printf \"\
    %d\\n\", $1+0.5}'\n  # echo $1 | awk '{printf \"%d\\n\", $1-0.5}'\n  # echo $1\
    \ | awk '{printf \"%d\\n\", $1+0.5}'\n  #\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpwvvc16cd.sh: line 37: syntax error near unexpected token `}''

    /tmp/tmpwvvc16cd.sh: line 37: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  printf\
    \ \"%.0f\\n\" \"$1\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=$1\n  local int=$(printf '%.0f' \"$num\")\n  local dec=$(printf '%.1f' \"\
    $num\")\n  local diff=$(echo \"$dec - $int\" | bc)\n  if (( $(echo \"$diff > 0.5\"\
    \ | bc -l) )); then\n    echo \"$((int + 1))\"\n  elif (( $(echo \"$diff < -0.5\"\
    \ | bc -l) )); then\n    echo \"$((int - 1))\"\n  else\n    echo \"$int\"\n  fi\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use printf to print to\
    \ stderr\n  printf \"Not yet implemented\" 1>&2\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: Not yet implemented
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  if [[ $1 =~ ^[0-9]+$ ]]; then\n    echo $1\n\
    \  elif [[ $1 =~ ^[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d '.' -f 1\n \
    \ elif [[ $1 =~ ^-[0-9]+\\.[0-9]+$ ]]; then\n    echo $1 | cut -d '.' -f 1\n \
    \ elif [[ $1 =~ ^-[0-9]+$ ]]; then\n    echo $1\n  elif [[ $1 =~ ^[0-9]+\\.[0-9]+e[0-9]+$\
    \ ]]; then\n    echo $1 | cut -d '.' -f 1\n  elif [[ $1 =~ ^-[0-9]+\\.[0-9]+e[0-9]+$\
    \ ]]; then\n    echo $1 | cut -d '.' -f 1\n  elif [[ $1 =~ ^[0-9]+e[0-9]+$ ]];\
    \ then\n    echo $1 | cut -d '.' -f 1\n  elif [[ $1 =~ ^-[0-9]+e[0-9]+$ ]]; then\n\
    \    echo $1 | cut -d '.' -f 1\n  else\n    echo \"error\"\n  fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Write\
    \ your code here\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n   \
    \ #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n  \
    \  #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n \
    \   #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp0x6plbpt.sh: line 184: syntax error near unexpected token `}''

    /tmp/tmp0x6plbpt.sh: line 184: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1\n}\n\ncandidate() {\n    closest_integer \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use printf to print to\
    \ stderr\n  printf \"Not yet implemented\" 1>&2\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: Not yet implemented
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1+0.5*sign($1))}'\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5 * sign($1))}'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  if [ ${1#*.}\
    \ -gt 0 ]; then\n    echo $(( ${1%.*} + 1 ))\n  else\n    echo ${1%.*}\n  fi\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1 + 0.5}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Your\
    \ code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n  \
    \  closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1+0.5}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local int_number=$(printf \"%.0f\" \"$number\")\n  local decimal_number=$(printf\
    \ \"%.1f\" \"$number\")\n  local decimal_number_int=$(printf \"%.0f\" \"$decimal_number\"\
    )\n  local decimal_number_dec=$(printf \"%.1f\" \"$decimal_number\")\n  local\
    \ decimal_number_dec_int=$(printf \"%.0f\" \"$decimal_number_dec\")\n  local decimal_number_dec_dec=$(printf\
    \ \"%.1f\" \"$decimal_number_dec\")\n  local decimal_number_dec_dec_int=$(printf\
    \ \"%.0f\" \"$decimal_number_dec_dec\")\n  local decimal_number_dec_dec_dec=$(printf\
    \ \"%.1f\" \"$decimal_number_dec_dec\")\n  local decimal_number_dec_dec_dec_int=$(printf\
    \ \"%.0f\" \"$decimal_number_dec_dec_dec\")\n  local decimal_number_dec_dec_dec_dec=$(printf\
    \ \"%.1f\" \"$decimal_number_dec_dec_dec\")\n  local decimal_number_dec_dec_dec_dec_int=$(printf\
    \ \"%.0f\" \"$decimal_number_dec_dec_dec_dec\")\n  local decimal_number_dec_dec_dec_dec_dec=$(printf\
    \ \"%.1f\" \"$decimal_number_dec_dec_dec_dec\")\n  local decimal_number_dec_dec_dec_dec_dec_int=$(printf\
    \ \"%.0f\" \"$decimal_number_dec_dec_dec_dec_dec\")\n  local decimal_number_dec_dec_dec_dec_dec_dec=$(printf\
    \ \"%.1f\" \"$decimal_number_dec_dec_dec_dec_dec\")\n  local decimal_number_dec_dec_dec_dec_dec_dec_int=$(printf\
    \ \"%.0f\" \"$decimal_number_dec_dec_dec_dec_dec_dec\")\n  local decimal_number_dec_dec_dec_dec_dec_dec_dec=$(printf\
    \ \"%.1f\" \"$decimal_number_dec_dec_dec_dec_\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpq0h1snvj.sh: line 43: unexpected EOF while looking for matching
    `"''

    /tmp/tmpq0h1snvj.sh: line 47: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1#*.}\
    \ | cut -c 1\n  # echo ${1#*.} | cut -c 1 | bc\n  # echo ${1#*.} | cut -c 1 |\
    \ bc | grep -q 1\n  # echo ${1#*.} | cut -c 1 | bc | grep -q 1 && echo \"true\"\
    \ || echo \"false\"\n  # echo ${1#*.} | cut -c 1 | bc | grep -q 1 && echo \"${1%.*}\
    \ + 1\" || echo \"${1%.*}\"\n  # echo ${1#*.} | cut -c 1 | bc | grep -q 1 && echo\
    \ \"${1%.*} + 1\" || echo \"${1%.*}\" | bc\n  # echo ${1#*.} | cut -c 1 | bc |\
    \ grep -q 1 && echo \"${1%.*} + 1\" || echo \"${1%.*}\" | bc\n  # echo ${1#*.}\
    \ | cut -c 1 | bc | grep -q 1 && echo \"${1%.*} + 1\" || echo \"${1%.*}\" | bc\n\
    \  # echo ${1#*.} | cut -c 1 | bc | grep -q 1 && echo \"${1%.*} + 1\" || echo\
    \ \"${1%.*}\" | bc\n  # echo ${1#*.} | cut -c 1 | bc | grep -q 1 && echo \"${1%.*}\
    \ + 1\" || echo \"${1%.*}\" | bc\n  # echo ${1#*.} | cut -c 1 | bc | grep -q 1\
    \ && echo \"${1%.*} + 1\" || echo \"${1%.*}\" | bc\n  # echo ${1#*.} | cut -c\
    \ 1 | bc | grep -q 1 && echo \"${1%.*} + 1\" || echo \"${1%.*}\" | bc\n  # echo\
    \ ${1#*.} | cut -c 1 | bc | grep -q 1 && echo \"${1%.*} + 1\" || echo \"${1%.*}\"\
    \ | bc\n  # echo ${1#*.} | cut -c 1 | bc | grep -q 1 && echo\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpoauq0woz.sh: line 32: syntax error near unexpected token `}''

    /tmp/tmpoauq0woz.sh: line 32: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # your\
    \ code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n  \
    \  closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 0
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo \"closest_integer($1)\"\n  if [[ $1 == *.* ]]; then\n\
    \    # echo \"float\"\n    if [[ $1 == *.*5 ]]; then\n      # echo \"5\"\n   \
    \   if [[ $1 == -* ]]; then\n        # echo \"negative\"\n        echo $((${1%.*}\
    \ - 1))\n      else\n        # echo \"positive\"\n        echo $((${1%.*} + 1))\n\
    \      fi\n    else\n      # echo \"not 5\"\n      echo ${1%.*}\n    fi\n  else\n\
    \    # echo \"integer\"\n    echo $1\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if [[\
    \ $1 == *.* ]]; then\n    echo $1 | cut -d. -f1\n  else\n    echo $1\n  fi\n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo \"Not implemented yet\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to access the first\
    \ argument to the function\n  echo \"Not implemented\"\n}\n\ncandidate() {\n \
    \   closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo\
    \ \"$1\" | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 0
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo $1 | awk '{printf(\"%d\\n\", $1)}'\n \
    \ echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5 * ($1 < 0 ? -1 : 1))}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=$1\n  local int=$(printf \"%.0f\" $num)\n  local dec=$(echo $num | cut -d.\
    \ -f2)\n  if [ $dec -gt 0 ]; then\n    if [ $dec -lt 5 ]; then\n      echo $int\n\
    \    else\n      echo $((int + 1))\n    fi\n  else\n    if [ $dec -gt -5 ]; then\n\
    \      echo $int\n    else\n      echo $((int - 1))\n    fi\n  fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{print int($1+0.5)}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  echo $1\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1 + 0.5 * sign($1))}'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: function `sign'' not defined

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo ${1#*.}\
    \ | cut -c 1\n  # echo ${1#*.} | cut -c 1 | grep -E '^[0-9]+$'\n  # echo ${1#*.}\
    \ | cut -c 1 | grep -E '^[0-9]+$' | wc -l\n  # echo ${1#*.} | cut -c 1 | grep\
    \ -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$'\n  # echo ${1#*.} | cut -c 1 | grep\
    \ -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$' | wc -l\n  # echo ${1#*.} | cut -c\
    \ 1 | grep -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$'\n\
    \  # echo ${1#*.} | cut -c 1 | grep -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$'\
    \ | wc -l | grep -E '^[0-9]+$' | wc -l\n  # echo ${1#*.} | cut -c 1 | grep -E\
    \ '^[0-9]+$' | wc -l | grep -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$' | wc -l\
    \ | grep -E '^[0-9]+$'\n  # echo ${1#*.} | cut -c 1 | grep -E '^[0-9]+$' | wc\
    \ -l | grep -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$' | wc -l | grep -E '^[0-9]+$'\
    \ | wc -l\n  # echo ${1#*.} | cut -c 1 |\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpof7bo0qa.sh: line 28: syntax error near unexpected token `}''

    /tmp/tmpof7bo0qa.sh: line 28: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  local number=$1\n  local int_number=${number%.*}\n  local\
    \ decimal_number=${number#*.}\n  local closest_int_number=0\n  if [ $decimal_number\
    \ -lt 5 ]; then\n    closest_int_number=$int_number\n  elif [ $decimal_number\
    \ -gt 5 ]; then\n    closest_int_number=$((int_number + 1))\n  else\n    if [\
    \ $((int_number % 2)) -eq 0 ]; then\n      closest_int_number=$int_number\n  \
    \  else\n      closest_int_number=$((int_number + 1))\n    fi\n  fi\n  echo $closest_int_number\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # echo $1\n  # echo ${1%.*}\n  # echo ${1#*.}\n  # echo $((10#${1#*.}))\n\
    \  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n\
    \  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n\
    \  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n\
    \  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n\
    \  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n\
    \  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n\
    \  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n\
    \  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n\
    \  # echo $((10#${1#*.}>=5))\n  # echo $((10#${1#*.}<5))\n  # echo $((10#${1#*.}>=5))\n\
    \  # echo $((10#${1#*.}<5))\n  # echo $\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpoi4itswj.sh: line 48: syntax error near unexpected token `}''

    /tmp/tmpoi4itswj.sh: line 48: `}''

    '
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf \"%d\\n\", $1}'\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # your\
    \ code here\n  echo \"$1\" | awk '{printf \"%.0f\\n\", $1}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  # Use echo to print to stdout\n  # Use $1 to get the first\
    \ argument passed to the function\n  echo $1\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Write\
    \ your code here\n  echo $1 | awk '{printf(\"%d\\n\", $1)}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660000945
