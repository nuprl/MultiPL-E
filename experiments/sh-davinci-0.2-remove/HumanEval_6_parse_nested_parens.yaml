name: HumanEval_6_parse_nested_parens
language: sh
prompt: "#!/bin/bash\n# Input to this function is a string represented multiple groups\
  \ for nested parentheses separated by spaces.\n# For each of the group, output the\
  \ deepest level of nesting of parentheses.\n# E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n#\n# $1 is a string\nparse_nested_parens()\
  \ {\n"
tests: "}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
  \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
  \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
completions: ["    local str=\"$1\"\n    local max_level=0\n    local level=0\n  \
    \  local i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n        local\
    \ char=${str:$i:1}\n        if [ \"$char\" == \"(\" ]; then\n            level=$((level+1))\n\
    \            if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            level=$((level-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_level", "  local parens_string=\"\
    $1\"\n  local parens_array=($parens_string)\n  local max_depth=0\n  local current_depth=0\n\
    \  for parens in \"${parens_array[@]}\"; do\n    for (( i=0; i<${#parens}; i++\
    \ )); do\n      if [[ \"${parens:$i:1}\" == \"(\" ]]; then\n        ((current_depth++))\n\
    \        if [[ $current_depth -gt $max_depth ]]; then\n          max_depth=$current_depth\n\
    \        fi\n      elif [[ \"${parens:$i:1}\" == \")\" ]]; then\n        ((current_depth--))\n\
    \      fi\n    done\n    current_depth=0\n  done\n  echo $max_depth", "    # Remove\
    \ all non-parentheses characters\n    local str=\"${1//[^()]/}\"\n    # Remove\
    \ all parentheses that are not nested\n    while [[ \"$str\" =~ \\([^()]*\\) ]];\
    \ do\n        str=\"${str//${BASH_REMATCH[0]}/}\"\n    done\n    # Count the number\
    \ of remaining parentheses\n    echo \"${#str}\"", "    # TODO: Implement this\
    \ function\n    # Hint: You can use the following command to get the number of\
    \ left parentheses in a string\n    # echo \"$1\" | grep -o '(' | wc -l\n    #\
    \ Hint: You can use the following command to get the number of right parentheses\
    \ in a string\n    # echo \"$1\" | grep -o ')' | wc -l\n    # Hint: You can use\
    \ the following command to get the number of left parentheses in a string\n  \
    \  # echo \"$1\" | grep -o '(' | wc -l\n    # Hint: You can use the following\
    \ command to get the number of right parentheses in a string\n    # echo \"$1\"\
    \ | grep -o ')' | wc -l\n    # Hint: You can use the following command to get\
    \ the number of left parentheses in a string\n    # echo \"$1\" | grep -o '('\
    \ | wc -l\n    # Hint: You can use the following command to get the number of\
    \ right parentheses in a string\n    # echo \"$1\" | grep -o ')' | wc -l\n   \
    \ # Hint: You can use the following command to get the number of left parentheses\
    \ in a string\n    # echo \"$1\" | grep -o '(' | wc -l\n    # Hint: You can use\
    \ the following command to get the number of right parentheses in a string\n \
    \   # echo \"$1\" | grep -o ')' | wc -l\n    # Hint: You can use the following\
    \ command to get the number of left parentheses in a string\n    # echo \"$1\"\
    \ | grep -o '(' | wc -l\n    # Hint: You can use the following command to get\
    \ the number of right parentheses in a string\n    # echo \"$1\" | grep -o ')'\
    \ | wc -l\n    # Hint: You can use the following command to get the number of\
    \ left parentheses in a string\n    # echo \"$1\" | grep -o '(' | wc -l\n    #\
    \ Hint: You can use the following command to get the number of right parentheses\
    \ in a string\n    # echo \"$1\" | grep -o ')' | wc -l\n    # Hint: You can use\
    \ the following command to get the number of left parentheses in a string\n",
  "    local input=\"$1\"\n    local max_depth=0\n    local depth=0\n    local char\n\
    \    for (( i=0; i<${#input}; i++ )); do\n        char=\"${input:$i:1}\"\n   \
    \     if [[ \"$char\" == \"(\" ]]; then\n            (( depth++ ))\n         \
    \   if (( depth > max_depth )); then\n                max_depth=$depth\n     \
    \       fi\n        elif [[ \"$char\" == \")\" ]]; then\n            (( depth--\
    \ ))\n        fi\n    done\n    echo $max_depth", "    local str=$1\n    local\
    \ max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n    while\
    \ [ $i -lt $len ]; do\n        local char=${str:$i:1}\n        if [ \"$char\"\
    \ == \"(\" ]; then\n            ((level++))\n            if [ $level -gt $max_level\
    \ ]; then\n                max_level=$level\n            fi\n        elif [ \"\
    $char\" == \")\" ]; then\n            ((level--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_level", "    # TODO: Write your code here\n    # Use\
    \ the echo command to output the result\n    # Example:\n    #   echo \"1\"\n\
    \    #   echo \"2\"\n    #   echo \"3\"\n    #   echo \"4\"\n    #   echo \"5\"\
    \n    #   echo \"6\"\n    #   echo \"7\"\n    #   echo \"8\"\n    #   echo \"\
    9\"\n    #   echo \"10\"\n    #   echo \"11\"\n    #   echo \"12\"\n    #   echo\
    \ \"13\"\n    #   echo \"14\"\n    #   echo \"15\"\n    #   echo \"16\"\n    #\
    \   echo \"17\"\n    #   echo \"18\"\n    #   echo \"19\"\n    #   echo \"20\"\
    \n    #   echo \"21\"\n    #   echo \"22\"\n    #   echo \"23\"\n    #   echo\
    \ \"24\"\n    #   echo \"25\"\n    #   echo \"26\"\n    #   echo \"27\"\n    #\
    \   echo \"28\"\n    #   echo \"29\"\n    #   echo \"30\"\n    #   echo \"31\"\
    \n    #   echo \"32\"\n    #   echo \"33\"\n    #   echo \"34\"\n    #   echo\
    \ \"35\"\n    #   echo \"36\"\n    #   echo \"37\"\n    #   echo \"38\"\n    #\
    \   echo \"39\"\n    #   echo \"40\"\n    #   echo \"41\"\n    #   echo \"42\"\
    \n    #   echo \"43\"\n    #   echo \"44\"\n    #   echo \"45\"\n    #   echo\
    \ \"46\"\n    #   echo \"47\"\n    #   echo \"48\"\n    #   echo \"49\"\n    #\
    \   echo \"50\"\n    #   echo \"51\"\n    #   echo \"52\"\n    #   echo \"53\"\
    \n    #   echo \"54\"\n    #   echo \"55\"\n    #   echo \"56\"\n    #   echo\
    \ \"57\"\n    #   echo \"58\"\n    #   echo \"59\"\n    #   echo \"60\"\n    #\
    \   echo \"", "    local str=\"$1\"\n    local max_depth=0\n    local depth=0\n\
    \    local i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n       \
    \ if [ \"${str:$i:1}\" == \"(\" ]; then\n            ((depth++))\n           \
    \ if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n     \
    \       fi\n        elif [ \"${str:$i:1}\" == \")\" ]; then\n            ((depth--))\n\
    \        fi\n        ((i++))\n    done\n    echo $max_depth", "  local str=\"\
    $1\"\n  local max_level=0\n  local level=0\n  local i=0\n  local len=${#str}\n\
    \  for ((i=0; i<len; i++)); do\n    if [[ \"${str:$i:1}\" == \"(\" ]]; then\n\
    \      ((level++))\n      if [[ $level -gt $max_level ]]; then\n        max_level=$level\n\
    \      fi\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n      ((level--))\n\
    \    fi\n  done\n  echo $max_level", "  local str=$1\n  local max_level=0\n  local\
    \ level=0\n  local i=0\n  local len=${#str}\n  while [ $i -lt $len ]; do\n   \
    \ if [ \"${str:$i:1}\" == \"(\" ]; then\n      ((level++))\n      if [ $level\
    \ -gt $max_level ]; then\n        max_level=$level\n      fi\n    elif [ \"${str:$i:1}\"\
    \ == \")\" ]; then\n      ((level--))\n    fi\n    ((i++))\n  done\n  echo $max_level",
  "    local input=$1\n    local max_level=0\n    local level=0\n    local i=0\n \
    \   local len=${#input}\n    local c\n    for ((i=0; i<len; i++)); do\n      \
    \  c=${input:$i:1}\n        if [[ \"$c\" == \"(\" ]]; then\n            ((level++))\n\
    \            if ((level > max_level)); then\n                max_level=$level\n\
    \            fi\n        elif [[ \"$c\" == \")\" ]]; then\n            ((level--))\n\
    \        fi\n    done\n    echo $max_level", "  local str=$1\n  local max_level=0\n\
    \  local level=0\n  local i=0\n  local len=${#str}\n  local char\n\n  while [\
    \ $i -lt $len ]; do\n    char=${str:$i:1}\n    if [ \"$char\" == \"(\" ]; then\n\
    \      level=$((level+1))\n      if [ $level -gt $max_level ]; then\n        max_level=$level\n\
    \      fi\n    elif [ \"$char\" == \")\" ]; then\n      level=$((level-1))\n \
    \   fi\n    i=$((i+1))\n  done\n\n  echo $max_level", "    local str=\"$1\"\n\
    \    local max_depth=0\n    local depth=0\n    local c\n    for ((i=0; i<${#str};\
    \ i++)); do\n        c=${str:$i:1}\n        if [[ \"$c\" == \"(\" ]]; then\n \
    \           ((depth++))\n            if ((depth > max_depth)); then\n        \
    \        max_depth=$depth\n            fi\n        elif [[ \"$c\" == \")\" ]];\
    \ then\n            ((depth--))\n        fi\n    done\n    echo $max_depth", " \
    \   local input=$1\n    local output=''\n    local max_depth=0\n    local depth=0\n\
    \    local i=0\n    local len=${#input}\n    local ch=''\n\n    for ((i=0; i<len;\
    \ i++)); do\n        ch=${input:$i:1}\n        if [[ $ch == '(' ]]; then\n   \
    \         ((depth++))\n            if [[ $depth -gt $max_depth ]]; then\n    \
    \            max_depth=$depth\n            fi\n        elif [[ $ch == ')' ]];\
    \ then\n            ((depth--))\n        fi\n    done\n\n    echo $max_depth",
  "    local str=$1\n    local parens_stack=()\n    local max_nesting=0\n    local\
    \ curr_nesting=0\n    local i=0\n    local len=${#str}\n    local c=''\n\n   \
    \ while [ $i -lt $len ]; do\n        c=${str:$i:1}\n        if [ \"$c\" == \"\
    (\" ]; then\n            parens_stack+=($c)\n            curr_nesting=$((curr_nesting\
    \ + 1))\n            if [ $curr_nesting -gt $max_nesting ]; then\n           \
    \     max_nesting=$curr_nesting\n            fi\n        elif [ \"$c\" == \")\"\
    \ ]; then\n            if [ ${#parens_stack[@]} -eq 0 ]; then\n              \
    \  echo \"Invalid input: $str\"\n                return 1\n            fi\n  \
    \          parens_stack+=($c)\n            curr_nesting=$((curr_nesting - 1))\n\
    \        elif [ \"$c\" == \" \" ]; then\n            if [ ${#parens_stack[@]}\
    \ -ne 0 ]; then\n                echo \"${parens_stack[@]}\"\n               \
    \ parens_stack=()\n                curr_nesting=0\n            fi\n        else\n\
    \            echo \"Invalid input: $str\"\n            return 1\n        fi\n\
    \        i=$((i + 1))\n    done\n\n    if [ ${#parens_stack[@]} -ne 0 ]; then\n\
    \        echo \"${parens_stack[@]}\"\n    fi\n\n    echo $max_nesting", "    #\
    \ TODO: Implement this function\n    echo \"Not implemented\"", "    local str=$1\n\
    \    local max_depth=0\n    local depth=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n        if [ \"$c\"\
    \ == \"(\" ]; then\n            ((depth++))\n            if [ $depth -gt $max_depth\
    \ ]; then\n                max_depth=$depth\n            fi\n        elif [ \"\
    $c\" == \")\" ]; then\n            ((depth--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_depth", "    local input_str=\"$1\"\n    local max_depth=0\n\
    \    local curr_depth=0\n    local i=0\n    local len=${#input_str}\n    while\
    \ [ $i -lt $len ]; do\n        local ch=${input_str:$i:1}\n        if [ \"$ch\"\
    \ == \"(\" ]; then\n            ((curr_depth++))\n            if [ $curr_depth\
    \ -gt $max_depth ]; then\n                max_depth=$curr_depth\n            fi\n\
    \        elif [ \"$ch\" == \")\" ]; then\n            ((curr_depth--))\n     \
    \   fi\n        ((i++))\n    done\n    echo $max_depth", "  local parens_string=\"\
    $1\"\n  local parens_array=($parens_string)\n  for parens in \"${parens_array[@]}\"\
    ; do\n    local parens_length=${#parens}\n    local parens_depth=0\n    local\
    \ max_depth=0\n    for ((i=0; i<parens_length; i++)); do\n      if [[ \"${parens:$i:1}\"\
    \ == \"(\" ]]; then\n        ((parens_depth++))\n        if [[ $parens_depth -gt\
    \ $max_depth ]]; then\n          max_depth=$parens_depth\n        fi\n      elif\
    \ [[ \"${parens:$i:1}\" == \")\" ]]; then\n        ((parens_depth--))\n      fi\n\
    \    done\n    echo $max_depth\n  done", "    # TODO: Write your code here\n \
    \   # Remove this comment when you start working on this function\n    # Hint:\
    \ You may find the following commands useful:\n    #       - awk\n    #      \
    \ - sed\n    #       - grep\n    #       - expr\n    #       - wc\n    #     \
    \  - sort\n    #       - uniq\n    #       - head\n    #       - tail\n    # \
    \      - cut\n    #       - tr\n    #       - bc\n    #       - echo\n    #  \
    \     - printf\n    #       - seq\n    #       - xargs\n    #       - read\n \
    \   #       - cat\n    #       - tac\n    #       - paste\n    #       - tr\n\
    \    #       - sort\n    #       - uniq\n    #       - wc\n    #       - cut\n\
    \    #       - paste\n    #       - bc\n    #       - echo\n    #       - printf\n\
    \    #       - seq\n    #       - xargs\n    #       - read\n    #       - cat\n\
    \    #       - tac\n    #       - paste\n    #       - tr\n    #       - sort\n\
    \    #       - uniq\n    #       - wc\n    #       - cut\n    #       - paste\n\
    \    #       - bc\n    #       - echo\n    #       - printf\n    #       - seq\n\
    \    #       - xargs\n    #       - read\n    #       - cat\n    #       - tac\n\
    \    #       - paste\n    #       - tr\n    #       - sort\n    #       - uniq\n\
    \    #       - wc\n    #       - cut\n    #       - paste\n    #       - bc\n\
    \    #       - echo\n    #       - printf\n    #       - seq\n    #       - xargs\n\
    \    #       - read\n    #       - cat\n    #       - tac\n    #       - paste\n\
    \    #       - tr\n    #       - sort\n    #       - uniq\n    #       - wc\n\
    \    #       - cut\n    #       - paste\n    #       - bc\n    #       - echo\n\
    \    #       - printf\n    #       - seq\n    #       - xargs\n    #", "    local\
    \ str=$1\n    local max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n\
    \    local ch\n\n    while [ $i -lt $len ]; do\n        ch=${str:$i:1}\n     \
    \   if [ \"$ch\" == \"(\" ]; then\n            ((level++))\n            if [ $level\
    \ -gt $max_level ]; then\n                max_level=$level\n            fi\n \
    \       elif [ \"$ch\" == \")\" ]; then\n            ((level--))\n        fi\n\
    \        ((i++))\n    done\n\n    echo $max_level", "    local str=\"$1\"\n  \
    \  local max_depth=0\n    local depth=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n\
    \            ((depth++))\n            if [ $depth -gt $max_depth ]; then\n   \
    \             max_depth=$depth\n            fi\n        elif [ \"${str:$i:1}\"\
    \ == \")\" ]; then\n            ((depth--))\n        fi\n        ((i++))\n   \
    \ done\n    echo $max_depth", "  local input=$1\n  local max_depth=0\n  local\
    \ depth=0\n  local i=0\n  local len=${#input}\n  while [ $i -lt $len ]; do\n \
    \   local char=${input:$i:1}\n    if [ \"$char\" == \"(\" ]; then\n      depth=$((depth+1))\n\
    \      if [ $depth -gt $max_depth ]; then\n        max_depth=$depth\n      fi\n\
    \    elif [ \"$char\" == \")\" ]; then\n      depth=$((depth-1))\n    fi\n   \
    \ i=$((i+1))\n  done\n  echo $max_depth", "    local str=\"$1\"\n    local max=0\n\
    \    local curr=0\n    local i=0\n    local len=${#str}\n    while [ $i -lt $len\
    \ ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n            ((curr++))\n\
    \            ((max=curr>max?curr:max))\n        elif [ \"${str:$i:1}\" == \")\"\
    \ ]; then\n            ((curr--))\n        fi\n        ((i++))\n    done\n   \
    \ echo $max", "    echo \"$1\" | sed 's/ //g' | sed 's/\\(/\\n(/g' | sed 's/\\\
    )/)\\n/g' | sed '/^$/d' | sed 's/^(//' | sed 's/)$//' | sed 's/^\\(([^()]*)\\\
    )$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed\
    \ 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\\
    )$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed\
    \ 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\\
    )$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed\
    \ 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\\
    )$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed\
    \ 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\)$/\\1/' | sed 's/^\\(([^()]*)\\\
    )$/\\1/' | sed 's/^", "    local str=\"$1\"\n    local max_depth=0\n    local\
    \ cur_depth=0\n    local i=0\n    local len=${#str}\n    for ((i=0; i<len; i++));\
    \ do\n        if [[ ${str:$i:1} == \"(\" ]]; then\n            ((cur_depth++))\n\
    \            ((max_depth = cur_depth > max_depth ? cur_depth : max_depth))\n \
    \       elif [[ ${str:$i:1} == \")\" ]]; then\n            ((cur_depth--))\n \
    \       fi\n    done\n    echo $max_depth", "    local str=\"$1\"\n    local max_depth=0\n\
    \    local depth=0\n    local char\n    for (( i=0; i<${#str}; i++ )); do\n  \
    \      char=\"${str:$i:1}\"\n        if [[ \"$char\" == \"(\" ]]; then\n     \
    \       (( depth++ ))\n            (( max_depth = depth > max_depth ? depth :\
    \ max_depth ))\n        elif [[ \"$char\" == \")\" ]]; then\n            (( depth--\
    \ ))\n        fi\n    done\n    echo \"$max_depth\"", "    # TODO: Implement this\
    \ function\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting.\n    # Hint: You can use a stack to keep track of the current level\
    \ of nesting", "    local str=\"$1\"\n    local max_depth=0\n    local depth=0\n\
    \    local i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n       \
    \ if [ \"${str:$i:1}\" == \"(\" ]; then\n            ((depth++))\n           \
    \ if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n     \
    \       fi\n        elif [ \"${str:$i:1}\" == \")\" ]; then\n            ((depth--))\n\
    \        fi\n        ((i++))\n    done\n    echo $max_depth", "    local str=$1\n\
    \    local parens_count=0\n    local max_parens_count=0\n    for (( i=0; i<${#str};\
    \ i++ )); do\n        if [[ ${str:$i:1} == \"(\" ]]; then\n            (( parens_count++\
    \ ))\n            if (( parens_count > max_parens_count )); then\n           \
    \     max_parens_count=$parens_count\n            fi\n        elif [[ ${str:$i:1}\
    \ == \")\" ]]; then\n            (( parens_count-- ))\n        fi\n    done\n\
    \    echo $max_parens_count", "    local input=\"$1\"\n    local max_depth=0\n\
    \    local depth=0\n    local i=0\n    local len=${#input}\n    while [ $i -lt\
    \ $len ]; do\n        if [ \"${input:$i:1}\" == \"(\" ]; then\n            ((depth++))\n\
    \            if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n\
    \            fi\n        elif [ \"${input:$i:1}\" == \")\" ]; then\n         \
    \   ((depth--))\n        fi\n        ((i++))\n    done\n    echo $max_depth",
  "    local str=$1\n    local paren_level=0\n    local max_level=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            ((paren_level++))\n            if [ $paren_level\
    \ -gt $max_level ]; then\n                max_level=$paren_level\n           \
    \ fi\n        elif [ \"${str:$i:1}\" == \")\" ]; then\n            ((paren_level--))\n\
    \        fi\n        ((i++))\n    done\n    echo $max_level", "  local str=$1\n\
    \  local max_level=0\n  local level=0\n  local i=0\n  local len=${#str}\n  while\
    \ [ $i -lt $len ]; do\n    local char=${str:$i:1}\n    if [ \"$char\" == \"(\"\
    \ ]; then\n      ((level++))\n      if [ $level -gt $max_level ]; then\n     \
    \   max_level=$level\n      fi\n    elif [ \"$char\" == \")\" ]; then\n      ((level--))\n\
    \    fi\n    ((i++))\n  done\n  echo $max_level", "    local input=\"$1\"\n  \
    \  local max_depth=0\n    local depth=0\n    local char=''\n    local i=0\n  \
    \  local len=${#input}\n\n    while [ $i -lt $len ]; do\n        char=${input:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            ((depth++))\n          \
    \  if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n    \
    \        fi\n        elif [ \"$char\" == \")\" ]; then\n            ((depth--))\n\
    \        fi\n        ((i++))\n    done\n\n    echo $max_depth", "    # Remove\
    \ all the non-parentheses characters\n    local str=\"${1//[^()]/}\"\n    local\
    \ max_depth=0\n    local depth=0\n    for (( i=0; i<${#str}; i++ )); do\n    \
    \    if [[ \"${str:$i:1}\" == \"(\" ]]; then\n            (( depth++ ))\n    \
    \        if (( depth > max_depth )); then\n                max_depth=$depth\n\
    \            fi\n        elif [[ \"${str:$i:1}\" == \")\" ]]; then\n         \
    \   (( depth-- ))\n        fi\n    done\n    echo $max_depth", "    local str=\"\
    $1\"\n    local max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local ch=${str:$i:1}\n        if [ \"\
    $ch\" == \"(\" ]; then\n            ((level++))\n            if [ $level -gt $max_level\
    \ ]; then\n                max_level=$level\n            fi\n        elif [ \"\
    $ch\" == \")\" ]; then\n            ((level--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_level", "    local str=$1\n    local max_level=0\n  \
    \  local level=0\n    local i=0\n    local len=${#str}\n    while [ $i -lt $len\
    \ ]; do\n        local c=${str:$i:1}\n        if [ \"$c\" == \"(\" ]; then\n \
    \           level=$((level+1))\n            if [ $level -gt $max_level ]; then\n\
    \                max_level=$level\n            fi\n        elif [ \"$c\" == \"\
    )\" ]; then\n            level=$((level-1))\n        fi\n        i=$((i+1))\n\
    \    done\n    echo $max_level", "    local input=\"$1\"\n    local max_depth=0\n\
    \    local curr_depth=0\n    local i\n    for ((i=0; i<${#input}; i++)); do\n\
    \        local c=${input:$i:1}\n        if [[ \"$c\" == \"(\" ]]; then\n     \
    \       ((curr_depth++))\n            if ((curr_depth > max_depth)); then\n  \
    \              max_depth=$curr_depth\n            fi\n        elif [[ \"$c\" ==\
    \ \")\" ]]; then\n            ((curr_depth--))\n        fi\n    done\n    echo\
    \ \"$max_depth\"", "    # TODO: Implement this function\n    # Hint: Use a stack\
    \ to keep track of the nesting level\n    # Hint: Use a variable to keep track\
    \ of the maximum nesting level\n    # Hint: Use a variable to keep track of the\
    \ current nesting level\n    # Hint: Use a variable to keep track of the current\
    \ index of the string\n    # Hint: Use a variable to keep track of the current\
    \ character\n    # Hint: Use a variable to keep track of the current group\n \
    \   # Hint: Use a variable to keep track of the current group index\n    # Hint:\
    \ Use a variable to keep track of the current group length\n    # Hint: Use a\
    \ variable to keep track of the current group maximum nesting level\n    # Hint:\
    \ Use a variable to keep track of the current group current nesting level\n  \
    \  # Hint: Use a variable to keep track of the current group current index\n \
    \   # Hint: Use a variable to keep track of the current group current character\n\
    \    # Hint: Use a variable to keep track of the current group current stack\n\
    \    # Hint: Use a variable to keep track of the current group current stack size\n\
    \    # Hint: Use a variable to keep track of the current group current stack top\n\
    \    # Hint: Use a variable to keep track of the current group current stack top\
    \ value\n    # Hint: Use a variable to keep track of the current group current\
    \ stack top value index\n    # Hint: Use a variable to keep track of the current\
    \ group current stack top value nesting level\n    # Hint: Use a variable to keep\
    \ track of the current group current stack top value current index\n    # Hint:\
    \ Use a variable to keep track of the current group current stack top value current\
    \ character\n    # Hint: Use a variable to keep track of the current group current\
    \ stack top value current stack\n    # Hint: Use a variable to keep track of the\
    \ current group current stack top value current stack size\n    # Hint: Use a\
    \ variable to keep track of the current group current stack top value current\
    \ stack top\n    # Hint: Use a variable to keep track of the current group current\
    \ stack top value current stack top value\n    # Hint: Use a variable to keep\
    \ track of the current group current stack top value current stack top value index\n\
    \    # Hint: Use a variable to keep track of the", "    local str=\"$1\"\n   \
    \ local max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local ch=\"${str:$i:1}\"\n        if [\
    \ \"$ch\" == \"(\" ]; then\n            ((level++))\n            if [ $level -gt\
    \ $max_level ]; then\n                max_level=$level\n            fi\n     \
    \   elif [ \"$ch\" == \")\" ]; then\n            ((level--))\n        fi\n   \
    \     ((i++))\n    done\n    echo $max_level", "    local parens=$1\n    local\
    \ max_depth=0\n    local depth=0\n    local i=0\n    local len=${#parens}\n  \
    \  for ((i=0; i<len; i++)); do\n        if [[ ${parens:$i:1} == \"(\" ]]; then\n\
    \            ((depth++))\n            if ((depth > max_depth)); then\n       \
    \         max_depth=$depth\n            fi\n        elif [[ ${parens:$i:1} ==\
    \ \")\" ]]; then\n            ((depth--))\n        fi\n    done\n    echo $max_depth",
  "    local str=\"$1\"\n    local max_depth=0\n    local depth=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            ((depth++))\n            if [ $depth -gt $max_depth\
    \ ]; then\n                max_depth=$depth\n            fi\n        elif [ \"\
    ${str:$i:1}\" == \")\" ]; then\n            ((depth--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_depth", "    local parens=$1\n    local max_depth=0\n\
    \    local depth=0\n    local char\n    for (( i=0; i<${#parens}; i++ )); do\n\
    \        char=${parens:$i:1}\n        if [[ $char == \"(\" ]]; then\n        \
    \    (( depth++ ))\n            if (( depth > max_depth )); then\n           \
    \     max_depth=$depth\n            fi\n        elif [[ $char == \")\" ]]; then\n\
    \            (( depth-- ))\n        fi\n    done\n    echo $max_depth", "    local\
    \ str=$1\n    local max_depth=0\n    local depth=0\n    local len=${#str}\n  \
    \  local i=0\n    while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            depth=$((depth+1))\n   \
    \         if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            depth=$((depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_depth", "    local input=$1\n\
    \    local parens_count=0\n    local max_parens_count=0\n    local i=0\n    local\
    \ len=${#input}\n    local char=''\n    local output=''\n\n    for ((i=0; i<len;\
    \ i++)); do\n        char=${input:$i:1}\n        if [[ $char == '(' ]]; then\n\
    \            ((parens_count++))\n            if [[ $parens_count -gt $max_parens_count\
    \ ]]; then\n                max_parens_count=$parens_count\n            fi\n \
    \       elif [[ $char == ')' ]]; then\n            ((parens_count--))\n      \
    \  fi\n    done\n\n    echo $max_parens_count", "    local str=$1\n    local max_depth=0\n\
    \    local depth=0\n    local i=0\n    local len=${#str}\n    while [ $i -lt $len\
    \ ]; do\n        local c=${str:$i:1}\n        if [ \"$c\" == \"(\" ]; then\n \
    \           ((depth++))\n            if [ $depth -gt $max_depth ]; then\n    \
    \            max_depth=$depth\n            fi\n        elif [ \"$c\" == \")\"\
    \ ]; then\n            ((depth--))\n        fi\n        ((i++))\n    done\n  \
    \  echo $max_depth", "  local str=\"$1\"\n  local max_depth=0\n  local depth=0\n\
    \  local i=0\n  local len=${#str}\n  while [ $i -lt $len ]; do\n    local char=${str:$i:1}\n\
    \    if [ \"$char\" == \"(\" ]; then\n      ((depth++))\n      if [ $depth -gt\
    \ $max_depth ]; then\n        max_depth=$depth\n      fi\n    elif [ \"$char\"\
    \ == \")\" ]; then\n      ((depth--))\n    fi\n    ((i++))\n  done\n  echo $max_depth",
  "    # TODO: Write your code here\n    # Please use the echo command to output the\
    \ answer, something like:\n    # echo \"answer\"\n    #\n    # Note that you can\
    \ use the following command to convert the string to an array\n    # arr=($1)\n\
    \    #\n    # Note that you can use the following command to convert the string\
    \ to an array\n    arr=($1)\n    #\n    # Note that you can use the following\
    \ command to convert the string to an array\n    arr=($1)\n    #\n    # Note that\
    \ you can use the following command to convert the string to an array\n    arr=($1)\n\
    \    #\n    # Note that you can use the following command to convert the string\
    \ to an array\n    arr=($1)\n    #\n    # Note that you can use the following\
    \ command to convert the string to an array\n    arr=($1)\n    #\n    # Note that\
    \ you can use the following command to convert the string to an array\n    arr=($1)\n\
    \    #\n    # Note that you can use the following command to convert the string\
    \ to an array\n    arr=($1)\n    #\n    # Note that you can use the following\
    \ command to convert the string to an array\n    arr=($1)\n    #\n    # Note that\
    \ you can use the following command to convert the string to an array\n    arr=($1)\n\
    \    #\n    # Note that you can use the following command to convert the string\
    \ to an array\n    arr=($1)\n    #\n    # Note that you can use the following\
    \ command to convert the string to an array\n    arr=($1)\n    #\n    # Note that\
    \ you can use the following command to convert the string to an array\n    arr=($1)\n\
    \    #\n    # Note that you can use the following command to convert the string\
    \ to an array\n    arr=($1)\n    #\n    # Note that you can use the following\
    \ command to convert the string to an array\n    arr=($1)\n    #\n    # Note that\
    \ you can use the following command to convert the string to an array\n    arr=($1)\n\
    \    #\n    # Note that you can use the following command to convert the string\
    \ to an array\n    arr=($1)\n   ", "  local input=\"$1\"\n  local max_depth=0\n\
    \  local current_depth=0\n  local i=0\n  local len=${#input}\n  while [ $i -lt\
    \ $len ]; do\n    local c=${input:$i:1}\n    if [ \"$c\" == \"(\" ]; then\n  \
    \    ((current_depth++))\n      if [ $current_depth -gt $max_depth ]; then\n \
    \       max_depth=$current_depth\n      fi\n    elif [ \"$c\" == \")\" ]; then\n\
    \      ((current_depth--))\n    fi\n    ((i++))\n  done\n  echo $max_depth", " \
    \   local str=\"$1\"\n    local max_depth=0\n    local depth=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            ((depth++))\n            if [ $depth -gt $max_depth\
    \ ]; then\n                max_depth=$depth\n            fi\n        elif [ \"\
    ${str:$i:1}\" == \")\" ]; then\n            ((depth--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_depth", "    # TODO: Implement this function\n    # Hint:\
    \ You can use the following command to get the number of left parentheses:\n \
    \   # echo \"$1\" | grep -o '(' | wc -l\n    #\n    # Hint: You can use the following\
    \ command to get the number of right parentheses:\n    # echo \"$1\" | grep -o\
    \ ')' | wc -l\n    #\n    # Hint: You can use the following command to get the\
    \ number of left parentheses that are not\n    #       matched by a right parentheses:\n\
    \    # echo \"$1\" | grep -o '(' | grep -v ')' | wc -l\n    #\n    # Hint: You\
    \ can use the following command to get the number of right parentheses that are\
    \ not\n    #       matched by a left parentheses:\n    # echo \"$1\" | grep -o\
    \ ')' | grep -v '(' | wc -l\n    #\n    # Hint: You can use the following command\
    \ to get the number of left parentheses that are not\n    #       matched by a\
    \ right parentheses:\n    # echo \"$1\" | grep -o '(' | grep -v ')' | wc -l\n\
    \    #\n    # Hint: You can use the following command to get the number of right\
    \ parentheses that are not\n    #       matched by a left parentheses:\n    #\
    \ echo \"$1\" | grep -o ')' | grep -v '(' | wc -l\n    #\n    # Hint: You can\
    \ use the following command to get the number of left parentheses that are not\n\
    \    #       matched by a right parentheses:\n    # echo \"$1\" | grep -o '('\
    \ | grep -v ')' | wc -l\n    #\n    # Hint: You can use the following command\
    \ to get the number of right parentheses that are not\n    #       matched by\
    \ a left parentheses:\n    # echo \"$1\" | grep -o ')' | grep -v '(' | wc -l\n\
    \    #\n    # Hint: You can use the following command to get the number of left\
    \ parentheses that are not\n    #       matched by a right parentheses:\n    #\
    \ echo \"$1\" | grep -o '(' | grep -v ')' | wc -l\n    #\n    # Hint: You can",
  "    # TODO: Fill in this function\n    # Hint: You may want to use the `sed` command\n\
    \    # Hint: You may want to use the `grep` command\n    # Hint: You may want\
    \ to use the `wc` command\n    # Hint: You may want to use the `sort` command\n\
    \    # Hint: You may want to use the `uniq` command\n    # Hint: You may want\
    \ to use the `tr` command\n    # Hint: You may want to use the `cut` command\n\
    \    # Hint: You may want to use the `head` command\n    # Hint: You may want\
    \ to use the `tail` command\n    # Hint: You may want to use the `rev` command\n\
    \    # Hint: You may want to use the `tr` command\n    # Hint: You may want to\
    \ use the `rev` command\n    # Hint: You may want to use the `rev` command\n \
    \   # Hint: You may want to use the `rev` command\n    # Hint: You may want to\
    \ use the `rev` command\n    # Hint: You may want to use the `rev` command\n \
    \   # Hint: You may want to use the `rev` command\n    # Hint: You may want to\
    \ use the `rev` command\n    # Hint: You may want to use the `rev` command\n \
    \   # Hint: You may want to use the `rev` command\n    # Hint: You may want to\
    \ use the `rev` command\n    # Hint: You may want to use the `rev` command\n \
    \   # Hint: You may want to use the `rev` command\n    # Hint: You may want to\
    \ use the `rev` command\n    # Hint: You may want to use the `rev` command\n \
    \   # Hint: You may want to use the `rev` command\n    # Hint: You may want to\
    \ use the `rev` command\n    # Hint: You may want to use the `rev` command\n \
    \   # Hint: You may want to use the `rev` command\n    # Hint: You may want to\
    \ use the `rev` command\n    # Hint: You may want to use the `rev` command\n \
    \   #", "    local input=$1\n    local max_depth=0\n    local current_depth=0\n\
    \    local char\n    for ((i=0; i<${#input}; i++)); do\n        char=${input:$i:1}\n\
    \        if [[ $char == \"(\" ]]; then\n            ((current_depth++))\n    \
    \        if ((current_depth > max_depth)); then\n                max_depth=$current_depth\n\
    \            fi\n        elif [[ $char == \")\" ]]; then\n            ((current_depth--))\n\
    \        fi\n    done\n    echo $max_depth", "    # TODO: Write your code here\n\
    \    # Remove this comment and the next line when you are done.\n    echo \"Not\
    \ implemented\"", "    local input=$1\n    local max_depth=0\n    local depth=0\n\
    \    local i=0\n    local len=${#input}\n    local c=''\n\n    while [ $i -lt\
    \ $len ]; do\n        c=${input:$i:1}\n        if [ \"$c\" == \"(\" ]; then\n\
    \            ((depth++))\n            if [ $depth -gt $max_depth ]; then\n   \
    \             max_depth=$depth\n            fi\n        elif [ \"$c\" == \")\"\
    \ ]; then\n            ((depth--))\n        fi\n        ((i++))\n    done\n\n\
    \    echo $max_depth", "    local input=$1\n    local max_depth=0\n    local current_depth=0\n\
    \    local char\n    for (( i=0; i<${#input}; i++ )); do\n        char=${input:$i:1}\n\
    \        if [[ $char == \"(\" ]]; then\n            ((current_depth++))\n    \
    \        if ((current_depth > max_depth)); then\n                max_depth=$current_depth\n\
    \            fi\n        elif [[ $char == \")\" ]]; then\n            ((current_depth--))\n\
    \        fi\n    done\n    echo $max_depth", "  local str=\"$1\"\n  local max_depth=0\n\
    \  local depth=0\n  local i=0\n  local len=${#str}\n  while [ $i -lt $len ]; do\n\
    \    local c=${str:$i:1}\n    if [ \"$c\" == \"(\" ]; then\n      ((depth++))\n\
    \      if [ $depth -gt $max_depth ]; then\n        max_depth=$depth\n      fi\n\
    \    elif [ \"$c\" == \")\" ]; then\n      ((depth--))\n    fi\n    ((i++))\n\
    \  done\n  echo $max_depth", "    # TODO: Implement this function\n    # Hint:\
    \ Use a stack to keep track of the current level of nesting.\n    #       Use\
    \ a variable to keep track of the maximum level of nesting.\n    #       Use a\
    \ variable to keep track of the current level of nesting.\n    #       Use a variable\
    \ to keep track of the current character.\n    #       Use a variable to keep\
    \ track of the current group.\n    #       Use a variable to keep track of the\
    \ current group.\n    #       Use a variable to keep track of the current group.\n\
    \    #       Use a variable to keep track of the current group.\n    #       Use\
    \ a variable to keep track of the current group.\n    #       Use a variable to\
    \ keep track of the current group.\n    #       Use a variable to keep track of\
    \ the current group.\n    #       Use a variable to keep track of the current\
    \ group.\n    #       Use a variable to keep track of the current group.\n   \
    \ #       Use a variable to keep track of the current group.\n    #       Use\
    \ a variable to keep track of the current group.\n    #       Use a variable to\
    \ keep track of the current group.\n    #       Use a variable to keep track of\
    \ the current group.\n    #       Use a variable to keep track of the current\
    \ group.\n    #       Use a variable to keep track of the current group.\n   \
    \ #       Use a variable to keep track of the current group.\n    #       Use\
    \ a variable to keep track of the current group.\n    #       Use a variable to\
    \ keep track of the current group.\n    #       Use a variable to keep track of\
    \ the current group.\n    #       Use a variable to keep track of the current\
    \ group.\n    #       Use a variable to keep track of the current group.\n   \
    \ #       Use a variable to keep track of the current group.\n    #       Use\
    \ a variable to keep track of the current group.\n    #       Use a variable to\
    \ keep track of the current group.\n    #       Use a variable to keep track of\
    \ the current group.\n    #       Use a variable to keep track of the current\
    \ group.\n    #       Use a variable to keep track of the current group.\n   \
    \ #       Use a variable to keep track of the current group.\n    #       Use\
    \ a variable to keep track of the current group.", "    local str=$1\n    local\
    \ max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n    local\
    \ c=''\n\n    for ((i=0; i<len; i++)); do\n        c=${str:$i:1}\n        if [[\
    \ $c == '(' ]]; then\n            ((level++))\n            if [[ $level -gt $max_level\
    \ ]]; then\n                max_level=$level\n            fi\n        elif [[\
    \ $c == ')' ]]; then\n            ((level--))\n        fi\n    done\n\n    echo\
    \ $max_level", "    # Remove all non-parentheses characters\n    local parens_only=$(echo\
    \ \"$1\" | tr -d -c '()')\n    # Remove all parentheses that are not part of a\
    \ group\n    local parens_only=$(echo \"$parens_only\" | sed 's/[^()]//g')\n \
    \   # Remove all parentheses that are not part of a group\n    local parens_only=$(echo\
    \ \"$parens_only\" | sed 's/[^()]//g')\n    # Replace all parentheses with a space\n\
    \    local parens_only=$(echo \"$parens_only\" | tr -d -c '() ')\n    # Remove\
    \ all spaces\n    local parens_only=$(echo \"$parens_only\" | tr -d -c '()')\n\
    \    # Remove all parentheses that are not part of a group\n    local parens_only=$(echo\
    \ \"$parens_only\" | sed 's/[^()]//g')\n    # Remove all parentheses that are\
    \ not part of a group\n    local parens_only=$(echo \"$parens_only\" | sed 's/[^()]//g')\n\
    \    # Replace all parentheses with a space\n    local parens_only=$(echo \"$parens_only\"\
    \ | tr -d -c '() ')\n    # Remove all spaces\n    local parens_only=$(echo \"\
    $parens_only\" | tr -d -c '()')\n    # Remove all parentheses that are not part\
    \ of a group\n    local parens_only=$(echo \"$parens_only\" | sed 's/[^()]//g')\n\
    \    # Remove all parentheses that are not part of a group\n    local parens_only=$(echo\
    \ \"$parens_only\" | sed 's/[^()]//g')\n    # Replace all parentheses with a space\n\
    \    local parens_only=$(echo \"$parens_only\" | tr -d -c '() ')\n    # Remove\
    \ all spaces\n    local parens_only=$(echo \"$parens_only\" | tr -d -c '()')\n\
    \    # Remove all parentheses that are not part of a group\n    local parens_only=$(",
  "    # TODO: Write your code here\n    # Remove this comment when you're done.\n\
    \    # You may need to add additional variables.\n    local input=$1\n    local\
    \ max_level=0\n    local level=0\n    local i=0\n    local len=${#input}\n   \
    \ local c\n    local output=''\n\n    while [ $i -lt $len ]; do\n        c=${input:$i:1}\n\
    \        if [ \"$c\" == \"(\" ]; then\n            level=$((level+1))\n      \
    \      if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            level=$((level-1))\n\
    \        fi\n        i=$((i+1))\n    done\n\n    echo $max_level", "    local\
    \ str=$1\n    local max_depth=0\n    local cur_depth=0\n    local i=0\n    local\
    \ len=${#str}\n    for (( i=0; i<len; i++ )); do\n        local ch=${str:$i:1}\n\
    \        if [[ \"$ch\" == \"(\" ]]; then\n            (( cur_depth++ ))\n    \
    \        if (( cur_depth > max_depth )); then\n                max_depth=$cur_depth\n\
    \            fi\n        elif [[ \"$ch\" == \")\" ]]; then\n            (( cur_depth--\
    \ ))\n        fi\n    done\n    echo $max_depth", "    local str=\"$1\"\n    local\
    \ max_level=0\n    local level=0\n    local c\n    for ((i=0; i<${#str}; i++));\
    \ do\n        c=${str:$i:1}\n        if [[ \"$c\" == \"(\" ]]; then\n        \
    \    ((level++))\n            if ((level > max_level)); then\n               \
    \ max_level=$level\n            fi\n        elif [[ \"$c\" == \")\" ]]; then\n\
    \            ((level--))\n        fi\n    done\n    echo $max_level", "    local\
    \ str=\"$1\"\n    local max_level=0\n    local level=0\n    local i=0\n    local\
    \ len=${#str}\n    while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            ((level++))\n          \
    \  if [ $level -gt $max_level ]; then\n                max_level=$level\n    \
    \        fi\n        elif [ \"$char\" == \")\" ]; then\n            ((level--))\n\
    \        fi\n        ((i++))\n    done\n    echo $max_level", "    # Remove all\
    \ non-parentheses characters\n    local str=\"${1//[^()]/}\"\n    # Remove all\
    \ parentheses that are not nested\n    while [[ \"$str\" =~ \\([^()]*\\) ]]; do\n\
    \        str=\"${str//${BASH_REMATCH[0]}/}\"\n    done\n    # Count the number\
    \ of remaining parentheses\n    echo \"${#str}\"", "  local str=\"$1\"\n  local\
    \ max_depth=0\n  local depth=0\n  local i=0\n  local len=${#str}\n  local c=''\n\
    \  while [ $i -lt $len ]; do\n    c=${str:$i:1}\n    if [ \"$c\" == \"(\" ]; then\n\
    \      ((depth++))\n      if [ $depth -gt $max_depth ]; then\n        max_depth=$depth\n\
    \      fi\n    elif [ \"$c\" == \")\" ]; then\n      ((depth--))\n    fi\n   \
    \ ((i++))\n  done\n  echo $max_depth", "  local str=\"$1\"\n  local max_depth=0\n\
    \  local curr_depth=0\n  local i=0\n  local len=${#str}\n  local char=''\n\n \
    \ while [ $i -lt $len ]; do\n    char=${str:$i:1}\n    if [ \"$char\" == \"(\"\
    \ ]; then\n      ((curr_depth++))\n      if [ $curr_depth -gt $max_depth ]; then\n\
    \        max_depth=$curr_depth\n      fi\n    elif [ \"$char\" == \")\" ]; then\n\
    \      ((curr_depth--))\n    fi\n    ((i++))\n  done\n\n  echo $max_depth", " \
    \   local str=\"$1\"\n    local max_level=0\n    local level=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n\
    \        if [ \"$c\" == \"(\" ]; then\n            ((level++))\n            if\
    \ [ $level -gt $max_level ]; then\n                max_level=$level\n        \
    \    fi\n        elif [ \"$c\" == \")\" ]; then\n            ((level--))\n   \
    \     fi\n        ((i++))\n    done\n    echo $max_level", "  local str=$1\n \
    \ local max_depth=0\n  local depth=0\n  local i=0\n  local len=${#str}\n  while\
    \ [ $i -lt $len ]; do\n    local char=${str:$i:1}\n    if [ \"$char\" == \"(\"\
    \ ]; then\n      ((depth++))\n      if [ $depth -gt $max_depth ]; then\n     \
    \   max_depth=$depth\n      fi\n    elif [ \"$char\" == \")\" ]; then\n      ((depth--))\n\
    \    fi\n    ((i++))\n  done\n  echo $max_depth", "    local str=$1\n    local\
    \ max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n    for\
    \ ((i=0; i<len; i++)); do\n        if [[ ${str:$i:1} == \"(\" ]]; then\n     \
    \       level=$((level+1))\n            if [[ $level -gt $max_level ]]; then\n\
    \                max_level=$level\n            fi\n        elif [[ ${str:$i:1}\
    \ == \")\" ]]; then\n            level=$((level-1))\n        fi\n    done\n  \
    \  echo $max_level", "    local str=\"$1\"\n    local max_depth=0\n    local cur_depth=0\n\
    \    local i=0\n    local len=${#str}\n    for ((i=0; i<len; i++)); do\n     \
    \   if [[ ${str:$i:1} == \"(\" ]]; then\n            ((cur_depth++))\n       \
    \     if ((cur_depth > max_depth)); then\n                max_depth=$cur_depth\n\
    \            fi\n        elif [[ ${str:$i:1} == \")\" ]]; then\n            ((cur_depth--))\n\
    \        fi\n    done\n    echo $max_depth", "    local str=$1\n    local max_depth=0\n\
    \    local depth=0\n    for (( i=0; i<${#str}; i++ )); do\n        if [[ ${str:$i:1}\
    \ == \"(\" ]]; then\n            (( depth++ ))\n            if (( depth > max_depth\
    \ )); then\n                max_depth=$depth\n            fi\n        elif [[\
    \ ${str:$i:1} == \")\" ]]; then\n            (( depth-- ))\n        fi\n    done\n\
    \    echo $max_depth", "    local str=$1\n    local max_level=0\n    local level=0\n\
    \    local i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n       \
    \ local c=${str:$i:1}\n        if [ \"$c\" == \"(\" ]; then\n            level=$((level+1))\n\
    \            if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            level=$((level-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_level", "    local str=\"\
    $1\"\n    local max_depth=0\n    local depth=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n\
    \            ((depth++))\n            if [ $depth -gt $max_depth ]; then\n   \
    \             max_depth=$depth\n            fi\n        elif [ \"${str:$i:1}\"\
    \ == \")\" ]; then\n            ((depth--))\n        fi\n        ((i++))\n   \
    \ done\n    echo $max_depth", "    local input_string=\"$1\"\n    local max_nesting=0\n\
    \    local current_nesting=0\n    local char\n    for (( i=0; i<${#input_string};\
    \ i++ )); do\n        char=\"${input_string:$i:1}\"\n        if [[ \"$char\" ==\
    \ \"(\" ]]; then\n            (( current_nesting++ ))\n            if (( current_nesting\
    \ > max_nesting )); then\n                max_nesting=$current_nesting\n     \
    \       fi\n        elif [[ \"$char\" == \")\" ]]; then\n            (( current_nesting--\
    \ ))\n        fi\n    done\n    echo \"$max_nesting\"", "    # TODO: Write your\
    \ code here\n    # Remove this comment and the next line when you are done.\n\
    \    echo \"Not implemented\"", "    # TODO: Implement this function.\n    # Hint:\
    \ You may want to use a stack to keep track of the current level of nesting.\n\
    \    # Hint: You may want to use a variable to keep track of the maximum level\
    \ of nesting.\n    # Hint: You may want to use a variable to keep track of the\
    \ current level of nesting.\n    # Hint: You may want to use a variable to keep\
    \ track of the current group.\n    # Hint: You may want to use a variable to keep\
    \ track of the maximum level of nesting for the current group.\n    # Hint: You\
    \ may want to use a variable to keep track of the current level of nesting for\
    \ the current group.\n    # Hint: You may want to use a variable to keep track\
    \ of the maximum level of nesting for all groups.\n    # Hint: You may want to\
    \ use a variable to keep track of the maximum level of nesting for all groups.\n\
    \    # Hint: You may want to use a variable to keep track of the maximum level\
    \ of nesting for all groups.\n    # Hint: You may want to use a variable to keep\
    \ track of the maximum level of nesting for all groups.\n    # Hint: You may want\
    \ to use a variable to keep track of the maximum level of nesting for all groups.\n\
    \    # Hint: You may want to use a variable to keep track of the maximum level\
    \ of nesting for all groups.\n    # Hint: You may want to use a variable to keep\
    \ track of the maximum level of nesting for all groups.\n    # Hint: You may want\
    \ to use a variable to keep track of the maximum level of nesting for all groups.\n\
    \    # Hint: You may want to use a variable to keep track of the maximum level\
    \ of nesting for all groups.\n    # Hint: You may want to use a variable to keep\
    \ track of the maximum level of nesting for all groups.\n    # Hint: You may want\
    \ to use a variable to keep track of the maximum level of nesting for all groups.\n\
    \    # Hint: You may want to use a variable to keep track of the maximum level\
    \ of nesting for all groups.\n    # Hint: You may want to use a variable to keep\
    \ track of the maximum level of nesting for all groups.\n    # Hint: You may want\
    \ to use a variable to keep track of the maximum level", "    local input=$1\n\
    \    local max_depth=0\n    local depth=0\n    local i=0\n    local len=${#input}\n\
    \    while [ $i -lt $len ]; do\n        local char=${input:$i:1}\n        if [\
    \ \"$char\" == \"(\" ]; then\n            depth=$((depth+1))\n            if [\
    \ $depth -gt $max_depth ]; then\n                max_depth=$depth\n          \
    \  fi\n        elif [ \"$char\" == \")\" ]; then\n            depth=$((depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_depth", "  local str=\"\
    $1\"\n  local max_level=0\n  local level=0\n  local i=0\n  local len=${#str}\n\
    \  while [ $i -lt $len ]; do\n    local char=${str:$i:1}\n    if [ \"$char\" ==\
    \ \"(\" ]; then\n      ((level++))\n      if [ $level -gt $max_level ]; then\n\
    \        max_level=$level\n      fi\n    elif [ \"$char\" == \")\" ]; then\n \
    \     ((level--))\n    fi\n    ((i++))\n  done\n  echo $max_level", "    local\
    \ input=$1\n    local max_depth=0\n    local current_depth=0\n    local i=0\n\
    \    local len=${#input}\n    local c\n\n    while [ $i -lt $len ]; do\n     \
    \   c=${input:$i:1}\n        if [ \"$c\" == \"(\" ]; then\n            ((current_depth++))\n\
    \            if [ $current_depth -gt $max_depth ]; then\n                max_depth=$current_depth\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            ((current_depth--))\n\
    \        fi\n        ((i++))\n    done\n\n    echo $max_depth", "    # Remove\
    \ all non-parentheses characters\n    local parens=$(echo \"$1\" | tr -d -c '()')\n\
    \    # Remove all parentheses that are not nested\n    local nested=$(echo \"\
    $parens\" | sed -e 's/()//g')\n    # Count the number of nested parentheses\n\
    \    local count=$(echo \"$nested\" | wc -c)\n    echo \"$count\"", "    local\
    \ input=$1\n    local parens_count=0\n    local max_parens_count=0\n    local\
    \ parens_count_array=()\n    local max_parens_count_array=()\n    local i=0\n\
    \    local j=0\n    local k=0\n    local l=0\n    local m=0\n    local n=0\n \
    \   local o=0\n    local p=0\n    local q=0\n    local r=0\n    local s=0\n  \
    \  local t=0\n    local u=0\n    local v=0\n    local w=0\n    local x=0\n   \
    \ local y=0\n    local z=0\n    local a=0\n    local b=0\n    local c=0\n    local\
    \ d=0\n    local e=0\n    local f=0\n    local g=0\n    local h=0\n    local i=0\n\
    \    local j=0\n    local k=0\n    local l=0\n    local m=0\n    local n=0\n \
    \   local o=0\n    local p=0\n    local q=0\n    local r=0\n    local s=0\n  \
    \  local t=0\n    local u=0\n    local v=0\n    local w=0\n    local x=0\n   \
    \ local y=0\n    local z=0\n    local a=0\n    local b=0\n    local c=0\n    local\
    \ d=0\n    local e=0\n    local f=0\n    local g=0\n    local h=0\n    local i=0\n\
    \    local j=0\n    local k=0\n    local l=0\n    local m=0\n    local n=0\n \
    \   local o=0\n    local p=0\n    local q=0\n    local r=0\n    local s=0\n  \
    \  local t=0\n    local u=0\n    local v=0\n    local w=0\n    local x=0\n   \
    \ local y=0\n    local z=0\n    local a=0\n    local b=0\n    local c=0\n    local\
    \ d=0\n    local e=0\n    local f=0\n    local g", "    # TODO: Write your code\
    \ here\n    # Please use the following syntax to print your output to standard\
    \ output\n    # echo \"Your_text_here\"\n    echo \"Your_text_here\"", "    local\
    \ input=$1\n    local max_level=0\n    local level=0\n    local i=0\n    local\
    \ len=${#input}\n    while [ $i -lt $len ]; do\n        local c=${input:$i:1}\n\
    \        if [ \"$c\" == \"(\" ]; then\n            ((level++))\n            if\
    \ [ $level -gt $max_level ]; then\n                max_level=$level\n        \
    \    fi\n        elif [ \"$c\" == \")\" ]; then\n            ((level--))\n   \
    \     fi\n        ((i++))\n    done\n    echo $max_level", "    local str=$1\n\
    \    local max_depth=0\n    local depth=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n\
    \            ((depth++))\n            if [ $depth -gt $max_depth ]; then\n   \
    \             max_depth=$depth\n            fi\n        elif [ \"${str:$i:1}\"\
    \ == \")\" ]; then\n            ((depth--))\n        fi\n        ((i++))\n   \
    \ done\n    echo $max_depth", "    local str=$1\n    local max_level=0\n    local\
    \ level=0\n    local c\n    for ((i=0; i<${#str}; i++)); do\n        c=${str:$i:1}\n\
    \        if [[ $c == \"(\" ]]; then\n            ((level++))\n            if ((level\
    \ > max_level)); then\n                max_level=$level\n            fi\n    \
    \    elif [[ $c == \")\" ]]; then\n            ((level--))\n        fi\n    done\n\
    \    echo $max_level", "    # This is the regex to match a group of nested parentheses\n\
    \    local regex=\"\\([^()]*\\)\"\n    local groups=$1\n    local max_level=0\n\
    \    local level=0\n    local group\n    local char\n\n    # Loop through each\
    \ group\n    for group in $groups; do\n        level=0\n        # Loop through\
    \ each character in the group\n        for (( i=0; i<${#group}; i++ )); do\n \
    \           char=${group:$i:1}\n            if [[ $char == \"(\" ]]; then\n  \
    \              (( level++ ))\n            elif [[ $char == \")\" ]]; then\n  \
    \              (( level-- ))\n            fi\n        done\n        # Update the\
    \ maximum level of nesting\n        if [[ $level -gt $max_level ]]; then\n   \
    \         max_level=$level\n        fi\n    done\n    echo $max_level", "    local\
    \ str=\"$1\"\n    local max_nesting=0\n    local current_nesting=0\n    local\
    \ i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n\
    \        if [ \"$c\" == \"(\" ]; then\n            current_nesting=$((current_nesting+1))\n\
    \            if [ $current_nesting -gt $max_nesting ]; then\n                max_nesting=$current_nesting\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            current_nesting=$((current_nesting-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_nesting", "  local -a\
    \ parens_stack\n  local -i parens_stack_top=0\n  local -i max_depth=0\n  local\
    \ -i current_depth=0\n  local -i i=0\n  local -i len=0\n  local -i parens_start=0\n\
    \  local -i parens_end=0\n  local -i parens_start_index=0\n  local -i parens_end_index=0\n\
    \  local -i parens_start_index_stack_top=0\n  local -i parens_end_index_stack_top=0\n\
    \  local -i parens_start_index_stack_top_prev=0\n  local -i parens_end_index_stack_top_prev=0\n\
    \  local -i parens_start_index_stack_top_prev_prev=0\n  local -i parens_end_index_stack_top_prev_prev=0\n\
    \  local -i parens_start_index_stack_top_prev_prev_prev=0\n  local -i parens_end_index_stack_top_prev_prev_prev=0\n\
    \  local -i parens_start_index_stack_top_prev_prev_prev_prev=0\n  local -i parens_end_index_stack_top_prev_prev_prev_prev=0\n\
    \  local -i parens_start_index_stack_top_prev_prev_prev_prev_prev=0\n  local -i\
    \ parens_end_index_stack_top_prev_prev_prev_prev_prev=0\n  local -i parens_start_index_stack_top_prev_prev_prev_prev_prev_prev=0\n\
    \  local -i parens_end_index_stack_top_prev_prev_prev_prev_prev_prev=0\n  local\
    \ -i parens_start_index_stack_top_prev_prev_prev_prev_prev_prev_prev=0\n  local\
    \ -i parens_end_index_stack_top_prev_prev_prev_prev_prev_prev_prev=0", "    local\
    \ string=$1\n    local max_level=0\n    local level=0\n    local i=0\n    local\
    \ len=${#string}\n    while [ $i -lt $len ]; do\n        local char=${string:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            level=$((level+1))\n   \
    \         if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            level=$((level-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_level", "    local input=$1\n\
    \    local max_depth=0\n    local current_depth=0\n    local char\n    for ((i=0;\
    \ i<${#input}; i++)); do\n        char=${input:$i:1}\n        if [[ $char == \"\
    (\" ]]; then\n            ((current_depth++))\n            if ((current_depth\
    \ > max_depth)); then\n                max_depth=$current_depth\n            fi\n\
    \        elif [[ $char == \")\" ]]; then\n            ((current_depth--))\n  \
    \      fi\n    done\n    echo $max_depth", "    local str=\"$1\"\n    local max_depth=0\n\
    \    local depth=0\n    local c\n    for ((i=0; i<${#str}; i++)); do\n       \
    \ c=${str:$i:1}\n        if [[ \"$c\" == \"(\" ]]; then\n            ((depth++))\n\
    \            if ((depth > max_depth)); then\n                max_depth=$depth\n\
    \            fi\n        elif [[ \"$c\" == \")\" ]]; then\n            ((depth--))\n\
    \        fi\n    done\n    echo $max_depth", "    # Split the string into multiple\
    \ groups\n    local groups=($1)\n    local max_depth=0\n    local depth=0\n  \
    \  local group\n    local char\n    for group in \"${groups[@]}\"; do\n      \
    \  depth=0\n        for (( i=0; i<${#group}; i++ )); do\n            char=${group:$i:1}\n\
    \            if [[ $char == \"(\" ]]; then\n                (( depth++ ))\n  \
    \          elif [[ $char == \")\" ]]; then\n                (( depth-- ))\n  \
    \          fi\n        done\n        if [[ $depth -gt $max_depth ]]; then\n  \
    \          max_depth=$depth\n        fi\n    done\n    echo $max_depth", "   \
    \ local input=$1\n    local max_depth=0\n    local curr_depth=0\n    local i=0\n\
    \    local len=${#input}\n    local char\n\n    while [ $i -lt $len ]; do\n  \
    \      char=${input:$i:1}\n        if [ \"$char\" == \"(\" ]; then\n         \
    \   ((curr_depth++))\n            if [ $curr_depth -gt $max_depth ]; then\n  \
    \              max_depth=$curr_depth\n            fi\n        elif [ \"$char\"\
    \ == \")\" ]; then\n            ((curr_depth--))\n        fi\n        ((i++))\n\
    \    done\n\n    echo $max_depth", "  # TODO: Write your code here\n  # Please\
    \ use the echo command to output the answer, e.g.\n  # echo \"answer\"\n  echo\
    \ \"TODO\"", "    local input=$1\n    local output=()\n    local max_level=0\n\
    \    local level=0\n    local i=0\n    local len=${#input}\n    local c\n    local\
    \ group\n\n    while [ $i -lt $len ]; do\n        c=${input:$i:1}\n        if\
    \ [ \"$c\" == \"(\" ]; then\n            level=$((level + 1))\n            if\
    \ [ $level -gt $max_level ]; then\n                max_level=$level\n        \
    \    fi\n        elif [ \"$c\" == \")\" ]; then\n            level=$((level -\
    \ 1))\n        fi\n        i=$((i + 1))\n    done\n\n    echo $max_level", " \
    \ local str=$1\n  local max_depth=0\n  local depth=0\n  local char\n  for (( i=0;\
    \ i<${#str}; i++ )); do\n    char=${str:$i:1}\n    if [[ $char == \"(\" ]]; then\n\
    \      (( depth++ ))\n      (( max_depth = depth > max_depth ? depth : max_depth\
    \ ))\n    elif [[ $char == \")\" ]]; then\n      (( depth-- ))\n    fi\n  done\n\
    \  echo $max_depth", "  local str=\"$1\"\n  local max_depth=0\n  local depth=0\n\
    \  local i=0\n  local len=${#str}\n  while [ $i -lt $len ]; do\n    if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n      ((depth++))\n      if [ $depth -gt $max_depth ]; then\n\
    \        max_depth=$depth\n      fi\n    elif [ \"${str:$i:1}\" == \")\" ]; then\n\
    \      ((depth--))\n    fi\n    ((i++))\n  done\n  echo $max_depth", "  local\
    \ str=\"$1\"\n  local max_depth=0\n  local depth=0\n  local i=0\n  local len=${#str}\n\
    \  local c\n  while [ $i -lt $len ]; do\n    c=${str:$i:1}\n    if [ \"$c\" ==\
    \ \"(\" ]; then\n      ((depth++))\n      if [ $depth -gt $max_depth ]; then\n\
    \        max_depth=$depth\n      fi\n    elif [ \"$c\" == \")\" ]; then\n    \
    \  ((depth--))\n    fi\n    ((i++))\n  done\n  echo $max_depth", "    local str=\"\
    $1\"\n    local max_depth=0\n    local current_depth=0\n    for (( i=0; i<${#str};\
    \ i++ )); do\n        if [[ \"${str:$i:1}\" == \"(\" ]]; then\n            ((\
    \ current_depth++ ))\n            (( max_depth = current_depth > max_depth ? current_depth\
    \ : max_depth ))\n        elif [[ \"${str:$i:1}\" == \")\" ]]; then\n        \
    \    (( current_depth-- ))\n        fi\n    done\n    echo \"$max_depth\"", " \
    \   local str=\"$1\"\n    local max_level=0\n    local level=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            ((level++))\n            if [ $level -gt $max_level\
    \ ]; then\n                max_level=$level\n            fi\n        elif [ \"\
    ${str:$i:1}\" == \")\" ]; then\n            ((level--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_level", "  local str=\"$1\"\n  local max_level=0\n  local\
    \ level=0\n  local i=0\n  local len=${#str}\n  while [ $i -lt $len ]; do\n   \
    \ if [ \"${str:$i:1}\" == \"(\" ]; then\n      ((level++))\n      ((max_level\
    \ = max_level > level ? max_level : level))\n    elif [ \"${str:$i:1}\" == \"\
    )\" ]; then\n      ((level--))\n    fi\n    ((i++))\n  done\n  echo $max_level",
  "    local str=$1\n    local max_level=0\n    local level=0\n    local i=0\n   \
    \ local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            ((level++))\n            if [ $level -gt $max_level\
    \ ]; then\n                max_level=$level\n            fi\n        elif [ \"\
    ${str:$i:1}\" == \")\" ]; then\n            ((level--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_level", "    local str=\"$1\"\n    local max_level=0\n\
    \    local cur_level=0\n    local i=0\n    local len=${#str}\n    for ((i=0; i<len;\
    \ i++)); do\n        if [[ ${str:$i:1} == \"(\" ]]; then\n            ((cur_level++))\n\
    \            if ((cur_level > max_level)); then\n                max_level=$cur_level\n\
    \            fi\n        elif [[ ${str:$i:1} == \")\" ]]; then\n            ((cur_level--))\n\
    \        fi\n    done\n    echo $max_level", "    local str=\"$1\"\n    local\
    \ max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n    while\
    \ [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n       \
    \     ((level++))\n            if [ $level -gt $max_level ]; then\n          \
    \      max_level=$level\n            fi\n        elif [ \"${str:$i:1}\" == \"\
    )\" ]; then\n            ((level--))\n        fi\n        ((i++))\n    done\n\
    \    echo $max_level", "    local str=$1\n    local max_level=0\n    local level=0\n\
    \    local i=0\n    local len=${#str}\n    local ch=''\n\n    while [ $i -lt $len\
    \ ]; do\n        ch=${str:$i:1}\n        if [ \"$ch\" == \"(\" ]; then\n     \
    \       ((level++))\n            if [ $level -gt $max_level ]; then\n        \
    \        max_level=$level\n            fi\n        elif [ \"$ch\" == \")\" ];\
    \ then\n            ((level--))\n        fi\n        ((i++))\n    done\n\n   \
    \ echo $max_level", "    local input=$1\n    local max_depth=0\n    local depth=0\n\
    \    local char\n    for ((i=0; i<${#input}; i++)); do\n        char=${input:$i:1}\n\
    \        if [[ $char == \"(\" ]]; then\n            ((depth++))\n            if\
    \ [[ $depth -gt $max_depth ]]; then\n                max_depth=$depth\n      \
    \      fi\n        elif [[ $char == \")\" ]]; then\n            ((depth--))\n\
    \        fi\n    done\n    echo $max_depth", "    local input_str=$1\n    local\
    \ paren_count=0\n    local max_paren_count=0\n    local i=0\n    local len=${#input_str}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${input_str:$i:1}\" == \"(\" ];\
    \ then\n            ((paren_count++))\n            if [ $paren_count -gt $max_paren_count\
    \ ]; then\n                max_paren_count=$paren_count\n            fi\n    \
    \    elif [ \"${input_str:$i:1}\" == \")\" ]; then\n            ((paren_count--))\n\
    \        fi\n        ((i++))\n    done\n    echo $max_paren_count", "    local\
    \ str=$1\n    local max_depth=0\n    local cur_depth=0\n    local char\n    for\
    \ ((i=0; i<${#str}; i++)); do\n        char=${str:$i:1}\n        if [[ $char ==\
    \ \"(\" ]]; then\n            ((cur_depth++))\n            if ((cur_depth > max_depth));\
    \ then\n                max_depth=$cur_depth\n            fi\n        elif [[\
    \ $char == \")\" ]]; then\n            ((cur_depth--))\n        fi\n    done\n\
    \    echo $max_depth", "    local input=$1\n    local max_depth=0\n    local depth=0\n\
    \    local i=0\n    local len=${#input}\n    while [ $i -lt $len ]; do\n     \
    \   local c=${input:$i:1}\n        if [ \"$c\" == \"(\" ]; then\n            depth=$((depth+1))\n\
    \            if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            depth=$((depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_depth", "    local str=$1\n\
    \    local max_depth=0\n    local cur_depth=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n        if [ \"\
    $char\" == \"(\" ]; then\n            cur_depth=$((cur_depth+1))\n           \
    \ if [ $cur_depth -gt $max_depth ]; then\n                max_depth=$cur_depth\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            cur_depth=$((cur_depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_depth", "  local str=$1\n\
    \  local parens_count=0\n  local max_parens_count=0\n  local parens_count_arr=()\n\
    \  local max_parens_count_arr=()\n  local i=0\n  local j=0\n  local k=0\n  local\
    \ l=0\n  local m=0\n  local n=0\n  local p=0\n  local q=0\n  local r=0\n  local\
    \ s=0\n  local t=0\n  local u=0\n  local v=0\n  local w=0\n  local x=0\n  local\
    \ y=0\n  local z=0\n  local aa=0\n  local bb=0\n  local cc=0\n  local dd=0\n \
    \ local ee=0\n  local ff=0\n  local gg=0\n  local hh=0\n  local ii=0\n  local\
    \ jj=0\n  local kk=0\n  local ll=0\n  local mm=0\n  local nn=0\n  local oo=0\n\
    \  local pp=0\n  local qq=0\n  local rr=0\n  local ss=0\n  local tt=0\n  local\
    \ uu=0\n  local vv=0\n  local ww=0\n  local xx=0\n  local yy=0\n  local zz=0\n\
    \  local aaa=0\n  local bbb=0\n  local ccc=0\n  local ddd=0\n  local eee=0\n \
    \ local fff=0\n  local ggg=0\n  local hhh=0\n  local iii=0\n  local jjj=0\n  local\
    \ kkk=0\n  local lll=0\n  local mmm=0\n  local nnn=0\n  local ooo=0\n  local ppp=0\n\
    \  local qqq=0\n  local rrr=0\n  local sss=0\n  local ttt=0\n  local uuu=0\n \
    \ local vvv=0\n  local www=0\n  local xxx=0\n  local yyy=0\n  local zzz=0\n  local\
    \ aaaa", "  # TODO: Implement this function\n  # Hint: Use awk to parse the string\n\
    \  # Hint: Use a stack to keep track of the current depth\n  # Hint: Use a variable\
    \ to keep track of the maximum depth\n  # Hint: Use a variable to keep track of\
    \ the current depth\n  # Hint: Use a variable to keep track of the current depth\n\
    \  # Hint: Use a variable to keep track of the current depth\n  # Hint: Use a\
    \ variable to keep track of the current depth\n  # Hint: Use a variable to keep\
    \ track of the current depth\n  # Hint: Use a variable to keep track of the current\
    \ depth\n  # Hint: Use a variable to keep track of the current depth\n  # Hint:\
    \ Use a variable to keep track of the current depth\n  # Hint: Use a variable\
    \ to keep track of the current depth\n  # Hint: Use a variable to keep track of\
    \ the current depth\n  # Hint: Use a variable to keep track of the current depth\n\
    \  # Hint: Use a variable to keep track of the current depth\n  # Hint: Use a\
    \ variable to keep track of the current depth\n  # Hint: Use a variable to keep\
    \ track of the current depth\n  # Hint: Use a variable to keep track of the current\
    \ depth\n  # Hint: Use a variable to keep track of the current depth\n  # Hint:\
    \ Use a variable to keep track of the current depth\n  # Hint: Use a variable\
    \ to keep track of the current depth\n  # Hint: Use a variable to keep track of\
    \ the current depth\n  # Hint: Use a variable to keep track of the current depth\n\
    \  # Hint: Use a variable to keep track of the current depth\n  # Hint: Use a\
    \ variable to keep track of the current depth\n  # Hint: Use a variable to keep\
    \ track of the current depth\n  # Hint: Use a variable to keep track of the current\
    \ depth\n  # Hint: Use a variable to keep track of the current depth\n  # Hint:\
    \ Use a variable to keep track of the current depth\n  # Hint: Use a variable\
    \ to keep track of the current depth\n  # Hint: Use a variable to keep track of\
    \ the current depth\n  # Hint: Use a variable to", "    local string=\"$1\"\n\
    \    local max_level=0\n    local level=0\n    local i=0\n    local len=${#string}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${string:$i:1}\" == \"(\" ]; then\n\
    \            ((level++))\n            if [ $level -gt $max_level ]; then\n   \
    \             max_level=$level\n            fi\n        elif [ \"${string:$i:1}\"\
    \ == \")\" ]; then\n            ((level--))\n        fi\n        ((i++))\n   \
    \ done\n    echo $max_level", "    local input=$1\n    local max_depth=0\n   \
    \ local depth=0\n    local i=0\n    local len=${#input}\n    while [ $i -lt $len\
    \ ]; do\n        local char=${input:$i:1}\n        if [ \"$char\" == \"(\" ];\
    \ then\n            depth=$((depth+1))\n            if [ $depth -gt $max_depth\
    \ ]; then\n                max_depth=$depth\n            fi\n        elif [ \"\
    $char\" == \")\" ]; then\n            depth=$((depth-1))\n        fi\n       \
    \ i=$((i+1))\n    done\n    echo $max_depth", "    local str=\"$1\"\n    local\
    \ max_depth=0\n    local current_depth=0\n    local i=0\n    local len=${#str}\n\
    \    local char=''\n\n    while [ $i -lt $len ]; do\n        char=${str:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            current_depth=$((current_depth\
    \ + 1))\n            if [ $current_depth -gt $max_depth ]; then\n            \
    \    max_depth=$current_depth\n            fi\n        elif [ \"$char\" == \"\
    )\" ]; then\n            current_depth=$((current_depth - 1))\n        fi\n  \
    \      i=$((i + 1))\n    done\n\n    echo $max_depth", "    local str=$1\n   \
    \ local max_depth=0\n    local depth=0\n    local char\n\n    for ((i=0; i<${#str};\
    \ i++)); do\n        char=${str:$i:1}\n        if [[ $char == \"(\" ]]; then\n\
    \            ((depth++))\n            if ((depth > max_depth)); then\n       \
    \         max_depth=$depth\n            fi\n        elif [[ $char == \")\" ]];\
    \ then\n            ((depth--))\n        fi\n    done\n\n    echo $max_depth",
  "  local input=$1\n  local max_depth=0\n  local depth=0\n  local char\n  for ((i=0;\
    \ i<${#input}; i++)); do\n    char=${input:$i:1}\n    if [[ \"$char\" == \"(\"\
    \ ]]; then\n      ((depth++))\n      if ((depth > max_depth)); then\n        max_depth=$depth\n\
    \      fi\n    elif [[ \"$char\" == \")\" ]]; then\n      ((depth--))\n    fi\n\
    \  done\n  echo $max_depth", "    local str=\"$1\"\n    local max_level=0\n  \
    \  local level=0\n    local i=0\n    local len=${#str}\n    while [ $i -lt $len\
    \ ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n            level=$((level+1))\n\
    \            if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"${str:$i:1}\" == \")\" ]; then\n           \
    \ level=$((level-1))\n        fi\n        i=$((i+1))\n    done\n    echo $max_level",
  "    local input=$1\n    local max_depth=0\n    local current_depth=0\n    local\
    \ i=0\n    local len=${#input}\n    local char\n\n    while [ $i -lt $len ]; do\n\
    \        char=${input:$i:1}\n        if [ \"$char\" == \"(\" ]; then\n       \
    \     current_depth=$((current_depth + 1))\n            if [ $current_depth -gt\
    \ $max_depth ]; then\n                max_depth=$current_depth\n            fi\n\
    \        elif [ \"$char\" == \")\" ]; then\n            current_depth=$((current_depth\
    \ - 1))\n        fi\n        i=$((i + 1))\n    done\n\n    echo $max_depth", " \
    \ local input_str=$1\n  local paren_count=0\n  local max_paren_count=0\n  local\
    \ i=0\n  local len=${#input_str}\n  for ((i=0; i<len; i++)); do\n    if [[ ${input_str:$i:1}\
    \ == \"(\" ]]; then\n      ((paren_count++))\n      if ((paren_count > max_paren_count));\
    \ then\n        max_paren_count=$paren_count\n      fi\n    elif [[ ${input_str:$i:1}\
    \ == \")\" ]]; then\n      ((paren_count--))\n    fi\n  done\n  echo $max_paren_count",
  "  local input=\"$1\"\n  local max_level=0\n  local level=0\n  local i=0\n  local\
    \ len=${#input}\n  while [ $i -lt $len ]; do\n    local c=${input:$i:1}\n    if\
    \ [ \"$c\" == \"(\" ]; then\n      level=$((level+1))\n      if [ $level -gt $max_level\
    \ ]; then\n        max_level=$level\n      fi\n    elif [ \"$c\" == \")\" ]; then\n\
    \      level=$((level-1))\n    fi\n    i=$((i+1))\n  done\n  echo $max_level",
  "    # TODO: Write your code here\n    # Hint: You can use a stack to solve this\
    \ problem.\n    #       You can use an array to represent a stack.\n    #    \
    \   Use the following command to push an element into the stack: stack+=($elem)\n\
    \    #       Use the following command to pop an element out of the stack: elem=${stack[$((${#stack[@]}-1))]}\
    \ && unset stack[$((${#stack[@]}-1))]\n    #       You can use ${#stack[@]} to\
    \ get the length of the stack\n    #       You can use ${stack[@]} to get all\
    \ elements in the stack\n    #       You can use ${stack[$((${#stack[@]}-1))]}\
    \ to get the top element in the stack\n    #       You can use ${stack[$((${#stack[@]}-2))]}\
    \ to get the second top element in the stack\n    #       You can use ${stack[$((${#stack[@]}-3))]}\
    \ to get the third top element in the stack\n    #       ...\n    #       You\
    \ can use ${stack[0]} to get the bottom element in the stack\n    #       You\
    \ can use ${stack[1]} to get the second bottom element in the stack\n    #   \
    \    You can use ${stack[2]} to get the third bottom element in the stack\n  \
    \  #       ...\n    #       You can use ${stack[$((${#stack[@]}-1))]} to get the\
    \ top element in the stack\n    #       You can use ${stack[$((${#stack[@]}-2))]}\
    \ to get the second top element in the stack\n    #       You can use ${stack[$((${#stack[@]}-3))]}\
    \ to get the third top element in the stack\n    #       ...\n    #       You\
    \ can use ${stack[0]} to get the bottom element in the stack\n    #       You\
    \ can use ${stack[1]} to get the second bottom element in the stack\n    #   \
    \    You can use ${stack[2]} to get the third bottom element in the stack\n  \
    \  #       ...\n    #       You can use ${stack[$((${#stack[@]}-1))", "    local\
    \ str=\"$1\"\n    local max_depth=0\n    local depth=0\n    local i=0\n    local\
    \ len=${#str}\n    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n  \
    \      if [ \"$c\" == \"(\" ]; then\n            ((depth++))\n            if [\
    \ $depth -gt $max_depth ]; then\n                max_depth=$depth\n          \
    \  fi\n        elif [ \"$c\" == \")\" ]; then\n            ((depth--))\n     \
    \   fi\n        ((i++))\n    done\n    echo $max_depth", "    local str=\"$1\"\
    \n    local max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n        if [ \"$c\"\
    \ == \"(\" ]; then\n            level=$((level+1))\n            if [ $level -gt\
    \ $max_level ]; then\n                max_level=$level\n            fi\n     \
    \   elif [ \"$c\" == \")\" ]; then\n            level=$((level-1))\n        fi\n\
    \        i=$((i+1))\n    done\n    echo $max_level", "    # TODO: Implement this\
    \ function.\n    # Hint: You may use the following command to extract the substring\
    \ between two parentheses.\n    #       echo $1 | sed -n 's/.*(\\(.*\\)).*/\\\
    1/p'\n    # Hint: You may use the following command to remove the substring between\
    \ two parentheses.\n    #       echo $1 | sed 's/(.*)//'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may\
    \ use the following command to remove the substring between two parentheses and\
    \ the parentheses.\n    #       echo $1 | sed 's/(.*)//g'\n    # Hint: You may",
  "    local input=$1\n    local max_level=0\n    local level=0\n    local char\n\
    \    for (( i=0; i<${#input}; i++ )); do\n        char=${input:$i:1}\n       \
    \ if [[ $char == \"(\" ]]; then\n            (( level++ ))\n            if [[\
    \ $level -gt $max_level ]]; then\n                max_level=$level\n         \
    \   fi\n        elif [[ $char == \")\" ]]; then\n            (( level-- ))\n \
    \       fi\n    done\n    echo $max_level", "    # TODO: implement this function\n\
    \    # Hint: use the following command to get the number of opening parentheses\
    \ in a string\n    # echo \"$1\" | grep -o \"(\" | wc -l\n    # Hint: use the\
    \ following command to get the number of closing parentheses in a string\n   \
    \ # echo \"$1\" | grep -o \")\" | wc -l\n    # Hint: use the following command\
    \ to get the number of opening parentheses in a string\n    # echo \"$1\" | grep\
    \ -o \"(\" | wc -l\n    # Hint: use the following command to get the number of\
    \ closing parentheses in a string\n    # echo \"$1\" | grep -o \")\" | wc -l\n\
    \    # Hint: use the following command to get the number of opening parentheses\
    \ in a string\n    # echo \"$1\" | grep -o \"(\" | wc -l\n    # Hint: use the\
    \ following command to get the number of closing parentheses in a string\n   \
    \ # echo \"$1\" | grep -o \")\" | wc -l\n    # Hint: use the following command\
    \ to get the number of opening parentheses in a string\n    # echo \"$1\" | grep\
    \ -o \"(\" | wc -l\n    # Hint: use the following command to get the number of\
    \ closing parentheses in a string\n    # echo \"$1\" | grep -o \")\" | wc -l\n\
    \    # Hint: use the following command to get the number of opening parentheses\
    \ in a string\n    # echo \"$1\" | grep -o \"(\" | wc -l\n    # Hint: use the\
    \ following command to get the number of closing parentheses in a string\n   \
    \ # echo \"$1\" | grep -o \")\" | wc -l\n    # Hint: use the following command\
    \ to get the number of opening parentheses in a string\n    # echo \"$1\" | grep\
    \ -o \"(\" | wc -l\n    # Hint: use the following command to get the number of\
    \ closing parentheses in a string\n    # echo \"$1\" | grep -o \")\" | wc -l\n\
    \    # Hint: use the following command to get the number of opening parentheses\
    \ in a string\n    # echo \"$1\" | grep -o \"(\" | wc -l\n    # Hint: use the\
    \ following", "    local str=\"$1\"\n    local max_level=0\n    local level=0\n\
    \    local i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n       \
    \ local char=${str:$i:1}\n        if [ \"$char\" == \"(\" ]; then\n          \
    \  level=$((level+1))\n            if [ $level -gt $max_level ]; then\n      \
    \          max_level=$level\n            fi\n        elif [ \"$char\" == \")\"\
    \ ]; then\n            level=$((level-1))\n        fi\n        i=$((i+1))\n  \
    \  done\n    echo $max_level", "    local input=$1\n    local max_depth=0\n  \
    \  local curr_depth=0\n    local i=0\n    local len=${#input}\n    while [ $i\
    \ -lt $len ]; do\n        if [ \"${input:$i:1}\" == \"(\" ]; then\n          \
    \  curr_depth=$((curr_depth+1))\n            if [ $curr_depth -gt $max_depth ];\
    \ then\n                max_depth=$curr_depth\n            fi\n        elif [\
    \ \"${input:$i:1}\" == \")\" ]; then\n            curr_depth=$((curr_depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_depth", "  local str=\"\
    $1\"\n  local max_level=0\n  local level=0\n  local i=0\n  local len=${#str}\n\
    \  while [ $i -lt $len ]; do\n    local ch=${str:$i:1}\n    if [ \"$ch\" == \"\
    (\" ]; then\n      level=$((level+1))\n      if [ $level -gt $max_level ]; then\n\
    \        max_level=$level\n      fi\n    elif [ \"$ch\" == \")\" ]; then\n   \
    \   level=$((level-1))\n    fi\n    i=$((i+1))\n  done\n  echo $max_level", "\t\
    local str=\"$1\"\n\tlocal max_level=0\n\tlocal cur_level=0\n\tlocal i=0\n\tlocal\
    \ len=${#str}\n\tlocal char=''\n\tfor ((i=0; i<len; i++)); do\n\t\tchar=${str:$i:1}\n\
    \t\tif [[ \"$char\" == \"(\" ]]; then\n\t\t\t((cur_level++))\n\t\t\tif [[ $cur_level\
    \ -gt $max_level ]]; then\n\t\t\t\tmax_level=$cur_level\n\t\t\tfi\n\t\telif [[\
    \ \"$char\" == \")\" ]]; then\n\t\t\t((cur_level--))\n\t\tfi\n\tdone\n\techo $max_level",
  "    local input=$1\n    local max_depth=0\n    local current_depth=0\n    local\
    \ char\n    for (( i=0; i<${#input}; i++ )); do\n        char=${input:$i:1}\n\
    \        if [[ \"$char\" == \"(\" ]]; then\n            (( current_depth++ ))\n\
    \            if (( current_depth > max_depth )); then\n                max_depth=$current_depth\n\
    \            fi\n        elif [[ \"$char\" == \")\" ]]; then\n            (( current_depth--\
    \ ))\n        fi\n    done\n    echo $max_depth", "    local str=$1\n    local\
    \ max_depth=0\n    local cur_depth=0\n    local i=0\n    local len=${#str}\n \
    \   local c\n\n    while [ $i -lt $len ]; do\n        c=${str:$i:1}\n        if\
    \ [ \"$c\" == \"(\" ]; then\n            cur_depth=$((cur_depth + 1))\n      \
    \      if [ $cur_depth -gt $max_depth ]; then\n                max_depth=$cur_depth\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            cur_depth=$((cur_depth\
    \ - 1))\n        fi\n        i=$((i + 1))\n    done\n\n    echo $max_depth", " \
    \ local input=\"$1\"\n  local max_depth=0\n  local depth=0\n  local char\n\n \
    \ for (( i=0; i<${#input}; i++ )); do\n    char=\"${input:$i:1}\"\n    if [[ \"\
    $char\" == \"(\" ]]; then\n      (( depth++ ))\n      if (( depth > max_depth\
    \ )); then\n        max_depth=$depth\n      fi\n    elif [[ \"$char\" == \")\"\
    \ ]]; then\n      (( depth-- ))\n    fi\n  done\n\n  echo \"$max_depth\"", " \
    \   local str=$1\n    local max_level=0\n    local level=0\n    local i=0\n  \
    \  local len=${#str}\n    while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            level=$((level+1))\n   \
    \         if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            level=$((level-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_level", "    local string=\"\
    $1\"\n    local max_depth=0\n    local depth=0\n    local i\n    for ((i=0; i<${#string};\
    \ i++)); do\n        if [[ \"${string:$i:1}\" == \"(\" ]]; then\n            ((depth++))\n\
    \            ((max_depth=depth>max_depth?depth:max_depth))\n        elif [[ \"\
    ${string:$i:1}\" == \")\" ]]; then\n            ((depth--))\n        fi\n    done\n\
    \    echo $max_depth", "    local str=\"$1\"\n    local max_nesting_level=0\n\
    \    local current_nesting_level=0\n    local parens_count=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            ((current_nesting_level++))\n            ((parens_count++))\n\
    \        elif [ \"${str:$i:1}\" == \")\" ]; then\n            ((parens_count--))\n\
    \            if [ $parens_count -eq 0 ]; then\n                ((current_nesting_level--))\n\
    \            fi\n        fi\n        if [ $current_nesting_level -gt $max_nesting_level\
    \ ]; then\n            max_nesting_level=$current_nesting_level\n        fi\n\
    \        ((i++))\n    done\n    echo $max_nesting_level", "    local str=\"$1\"\
    \n    local max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n        if [ \"$c\"\
    \ == \"(\" ]; then\n            level=$((level+1))\n            if [ $level -gt\
    \ $max_level ]; then\n                max_level=$level\n            fi\n     \
    \   elif [ \"$c\" == \")\" ]; then\n            level=$((level-1))\n        fi\n\
    \        i=$((i+1))\n    done\n    echo $max_level", "  local str=\"$1\"\n  local\
    \ max_depth=0\n  local depth=0\n  local i=0\n  local len=${#str}\n  while [ $i\
    \ -lt $len ]; do\n    local c=${str:$i:1}\n    if [ \"$c\" == \"(\" ]; then\n\
    \      ((depth++))\n      if [ $depth -gt $max_depth ]; then\n        max_depth=$depth\n\
    \      fi\n    elif [ \"$c\" == \")\" ]; then\n      ((depth--))\n    fi\n   \
    \ ((i++))\n  done\n  echo $max_depth", "    # TODO: Implement this function\n\
    \    # Hint: Use a stack to keep track of the current level of nesting\n    #\
    \ Hint: Use a variable to keep track of the maximum level of nesting\n    # Hint:\
    \ Use a variable to keep track of the current level of nesting\n    # Hint: Use\
    \ a variable to keep track of the current group\n    # Hint: Use a variable to\
    \ keep track of the current character\n    # Hint: Use a variable to keep track\
    \ of the current index in the string\n    # Hint: Use a variable to keep track\
    \ of the length of the string\n    # Hint: Use a variable to keep track of the\
    \ current character\n    # Hint: Use a variable to keep track of the current index\
    \ in the string\n    # Hint: Use a variable to keep track of the length of the\
    \ string\n    # Hint: Use a variable to keep track of the current character\n\
    \    # Hint: Use a variable to keep track of the current index in the string\n\
    \    # Hint: Use a variable to keep track of the length of the string\n    # Hint:\
    \ Use a variable to keep track of the current character\n    # Hint: Use a variable\
    \ to keep track of the current index in the string\n    # Hint: Use a variable\
    \ to keep track of the length of the string\n    # Hint: Use a variable to keep\
    \ track of the current character\n    # Hint: Use a variable to keep track of\
    \ the current index in the string\n    # Hint: Use a variable to keep track of\
    \ the length of the string\n    # Hint: Use a variable to keep track of the current\
    \ character\n    # Hint: Use a variable to keep track of the current index in\
    \ the string\n    # Hint: Use a variable to keep track of the length of the string\n\
    \    # Hint: Use a variable to keep track of the current character\n    # Hint:\
    \ Use a variable to keep track of the current index in the string\n    # Hint:\
    \ Use a variable to keep track of the length of the string\n    # Hint: Use a\
    \ variable to keep track of the current character\n    # Hint: Use a variable\
    \ to keep track of the current index in the string\n    # Hint: Use a variable\
    \ to keep track of the length of the string\n    # Hint: Use a variable", "  local\
    \ str=\"$1\"\n  local max_depth=0\n  local depth=0\n  local i=0\n  local len=${#str}\n\
    \  while [ $i -lt $len ]; do\n    if [ \"${str:$i:1}\" == \"(\" ]; then\n    \
    \  depth=$((depth+1))\n      if [ $depth -gt $max_depth ]; then\n        max_depth=$depth\n\
    \      fi\n    elif [ \"${str:$i:1}\" == \")\" ]; then\n      depth=$((depth-1))\n\
    \    fi\n    i=$((i+1))\n  done\n  echo $max_depth", "    local string=\"$1\"\n\
    \    local max_depth=0\n    local current_depth=0\n    local i=0\n    local len=${#string}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${string:$i:1}\" == \"(\" ]; then\n\
    \            current_depth=$((current_depth + 1))\n            if [ $current_depth\
    \ -gt $max_depth ]; then\n                max_depth=$current_depth\n         \
    \   fi\n        elif [ \"${string:$i:1}\" == \")\" ]; then\n            current_depth=$((current_depth\
    \ - 1))\n        fi\n        i=$((i + 1))\n    done\n    echo $max_depth", " \
    \   local str=$1\n    local max_level=0\n    local level=0\n    local i=0\n  \
    \  local len=${#str}\n    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n\
    \        if [ \"$c\" == \"(\" ]; then\n            level=$((level+1))\n      \
    \      if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            level=$((level-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_level", "    # TODO:\
    \ Implement this function\n    # Hint: Use the following command to get the deepest\
    \ level of nesting of parentheses in a string:\n    # echo $1 | sed -e 's/[^()]//g'\
    \ | sed -e 's/\\(/\\n/g' | sed -e 's/\\)/\\n/g' | grep -c ''\n    #\n    # Note:\
    \ The above command will not work if the string contains spaces.\n    #      \
    \ You will need to modify it to work with spaces.\n    #\n    # Hint: Use the\
    \ following command to get the deepest level of nesting of parentheses in a string:\n\
    \    # echo $1 | sed -e 's/[^()]//g' | sed -e 's/\\(/\\n/g' | sed -e 's/\\)/\\\
    n/g' | grep -c ''\n    #\n    # Note: The above command will not work if the string\
    \ contains spaces.\n    #       You will need to modify it to work with spaces.\n\
    \    #\n    # Hint: Use the following command to get the deepest level of nesting\
    \ of parentheses in a string:\n    # echo $1 | sed -e 's/[^()]//g' | sed -e 's/\\\
    (/\\n/g' | sed -e 's/\\)/\\n/g' | grep -c ''\n    #\n    # Note: The above command\
    \ will not work if the string contains spaces.\n    #       You will need to modify\
    \ it to work with spaces.\n    #\n    # Hint: Use the following command to get\
    \ the deepest level of nesting of parentheses in a string:\n    # echo $1 | sed\
    \ -e 's/[^()]//g' | sed -e 's/\\(/\\n/g' | sed -e 's/\\)/\\n/g' | grep -c ''\n\
    \    #\n    # Note: The above command will not work if the string contains spaces.\n\
    \    #       You will need to modify it to work with spaces.\n    #\n    # Hint:\
    \ Use the following command to get the deepest level of nesting of parentheses\
    \ in a string:\n    # echo $1 | sed -e 's/[^()]//g'", "    local str=\"$1\"\n\
    \    local max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n        if [ \"$c\"\
    \ == \"(\" ]; then\n            (( level++ ))\n            if [ $level -gt $max_level\
    \ ]; then\n                max_level=$level\n            fi\n        elif [ \"\
    $c\" == \")\" ]; then\n            (( level-- ))\n        fi\n        (( i++ ))\n\
    \    done\n    echo $max_level", "  local str=\"$1\"\n  local max_level=0\n  local\
    \ level=0\n  local i=0\n  local len=${#str}\n  while [ $i -lt $len ]; do\n   \
    \ if [ \"${str:$i:1}\" == \"(\" ]; then\n      ((level++))\n      if [ $level\
    \ -gt $max_level ]; then\n        max_level=$level\n      fi\n    elif [ \"${str:$i:1}\"\
    \ == \")\" ]; then\n      ((level--))\n    fi\n    ((i++))\n  done\n  echo $max_level",
  "  local str=\"$1\"\n  local max_level=0\n  local level=0\n  local i=0\n  local\
    \ len=${#str}\n  for ((i=0; i<len; i++)); do\n    if [[ \"${str:$i:1}\" == \"\
    (\" ]]; then\n      ((level++))\n      if ((level > max_level)); then\n      \
    \  max_level=$level\n      fi\n    elif [[ \"${str:$i:1}\" == \")\" ]]; then\n\
    \      ((level--))\n    fi\n  done\n  echo $max_level", "    local input=$1\n\
    \    local output=\"\"\n    local max_depth=0\n    local depth=0\n    local i=0\n\
    \    local c=\"\"\n\n    while [ $i -lt ${#input} ]; do\n        c=${input:$i:1}\n\
    \        if [ \"$c\" == \"(\" ]; then\n            depth=$((depth+1))\n      \
    \      if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            depth=$((depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n\n    echo $max_depth", "    local\
    \ str=\"$1\"\n    local max_depth=0\n    local depth=0\n    local i=0\n    local\
    \ len=${#str}\n    for ((i=0; i<len; i++)); do\n        if [[ \"${str:$i:1}\"\
    \ == \"(\" ]]; then\n            ((depth++))\n            if ((depth > max_depth));\
    \ then\n                max_depth=$depth\n            fi\n        elif [[ \"${str:$i:1}\"\
    \ == \")\" ]]; then\n            ((depth--))\n        fi\n    done\n    echo $max_depth",
  "  local str=$1\n  local max_depth=0\n  local depth=0\n  local i=0\n  local len=${#str}\n\
    \  local c=''\n\n  while [ $i -lt $len ]; do\n    c=${str:$i:1}\n    if [ \"$c\"\
    \ == \"(\" ]; then\n      ((depth++))\n      if [ $depth -gt $max_depth ]; then\n\
    \        max_depth=$depth\n      fi\n    elif [ \"$c\" == \")\" ]; then\n    \
    \  ((depth--))\n    fi\n    ((i++))\n  done\n\n  echo $max_depth", "    local\
    \ str=\"$1\"\n    local max_depth=0\n    local depth=0\n    local i=0\n    local\
    \ len=${#str}\n    while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            depth=$((depth+1))\n   \
    \         if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            depth=$((depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_depth", "    local input=\"\
    $1\"\n    local max_level=0\n    local level=0\n    local i=0\n    local len=${#input}\n\
    \    while [ $i -lt $len ]; do\n        local char=${input:$i:1}\n        if [\
    \ \"$char\" == \"(\" ]; then\n            ((level++))\n            if [ $level\
    \ -gt $max_level ]; then\n                max_level=$level\n            fi\n \
    \       elif [ \"$char\" == \")\" ]; then\n            ((level--))\n        fi\n\
    \        ((i++))\n    done\n    echo $max_level", "    local str=\"$1\"\n    local\
    \ max_nesting=0\n    local cur_nesting=0\n    local i=0\n    local len=${#str}\n\
    \    local ch\n    while [ $i -lt $len ]; do\n        ch=${str:$i:1}\n       \
    \ if [ \"$ch\" == \"(\" ]; then\n            cur_nesting=$((cur_nesting+1))\n\
    \            if [ $cur_nesting -gt $max_nesting ]; then\n                max_nesting=$cur_nesting\n\
    \            fi\n        elif [ \"$ch\" == \")\" ]; then\n            cur_nesting=$((cur_nesting-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_nesting", "    local\
    \ input=$1\n    local max_depth=0\n    local depth=0\n    local i=0\n    local\
    \ len=${#input}\n    while [ $i -lt $len ]; do\n        local char=${input:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            ((depth++))\n          \
    \  if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n    \
    \        fi\n        elif [ \"$char\" == \")\" ]; then\n            ((depth--))\n\
    \        fi\n        ((i++))\n    done\n    echo $max_depth", "  local str=$1\n\
    \  local max_depth=0\n  local depth=0\n  local i=0\n  local len=${#str}\n  while\
    \ [ $i -lt $len ]; do\n    local ch=${str:$i:1}\n    if [ \"$ch\" == \"(\" ];\
    \ then\n      depth=$((depth+1))\n      if [ $depth -gt $max_depth ]; then\n \
    \       max_depth=$depth\n      fi\n    elif [ \"$ch\" == \")\" ]; then\n    \
    \  depth=$((depth-1))\n    fi\n    i=$((i+1))\n  done\n  echo $max_depth", " \
    \ local str=\"$1\"\n  local max_depth=0\n  local depth=0\n  local i=0\n  local\
    \ len=${#str}\n  while [ $i -lt $len ]; do\n    local c=${str:$i:1}\n    if [\
    \ \"$c\" == \"(\" ]; then\n      ((depth++))\n      if [ $depth -gt $max_depth\
    \ ]; then\n        max_depth=$depth\n      fi\n    elif [ \"$c\" == \")\" ]; then\n\
    \      ((depth--))\n    fi\n    ((i++))\n  done\n  echo $max_depth", "    local\
    \ str=\"$1\"\n    local max_depth=0\n    local cur_depth=0\n    local i=0\n  \
    \  local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            cur_depth=$((cur_depth+1))\n            if [ $cur_depth\
    \ -gt $max_depth ]; then\n                max_depth=$cur_depth\n            fi\n\
    \        elif [ \"${str:$i:1}\" == \")\" ]; then\n            cur_depth=$((cur_depth-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_depth", "    # TODO:\
    \ Implement this function\n    # Hint: Use a stack to keep track of the current\
    \ level of nesting.\n    # Hint: Use a variable to keep track of the maximum level\
    \ of nesting.\n    # Hint: Use a variable to keep track of the current level of\
    \ nesting.\n    # Hint: Use a variable to keep track of the current group.\n \
    \   # Hint: Use a variable to keep track of the maximum level of nesting for the\
    \ current group.\n    # Hint: Use a variable to keep track of the current level\
    \ of nesting for the current group.\n    # Hint: Use a variable to keep track\
    \ of the maximum level of nesting for all groups.\n    # Hint: Use a variable\
    \ to keep track of the current level of nesting for all groups.\n    # Hint: Use\
    \ a variable to keep track of the current character.\n    # Hint: Use a variable\
    \ to keep track of the current character in the current group.\n    # Hint: Use\
    \ a variable to keep track of the current character in the current group.\n  \
    \  # Hint: Use a variable to keep track of the current character in the current\
    \ group.\n    # Hint: Use a variable to keep track of the current character in\
    \ the current group.\n    # Hint: Use a variable to keep track of the current\
    \ character in the current group.\n    # Hint: Use a variable to keep track of\
    \ the current character in the current group.\n    # Hint: Use a variable to keep\
    \ track of the current character in the current group.\n    # Hint: Use a variable\
    \ to keep track of the current character in the current group.\n    # Hint: Use\
    \ a variable to keep track of the current character in the current group.\n  \
    \  # Hint: Use a variable to keep track of the current character in the current\
    \ group.\n    # Hint: Use a variable to keep track of the current character in\
    \ the current group.\n    # Hint: Use a variable to keep track of the current\
    \ character in the current group.\n    # Hint: Use a variable to keep track of\
    \ the current character in the current group.\n    # Hint: Use a variable to keep\
    \ track of the current character in the current group.\n    # Hint: Use a variable\
    \ to keep track of the current character in the current group.\n    # Hint: Use",
  "  local str=\"$1\"\n  local max_level=0\n  local level=0\n  local i=0\n  local\
    \ len=${#str}\n  while [ $i -lt $len ]; do\n    if [ \"${str:$i:1}\" == \"(\"\
    \ ]; then\n      ((level++))\n      if [ $level -gt $max_level ]; then\n     \
    \   max_level=$level\n      fi\n    elif [ \"${str:$i:1}\" == \")\" ]; then\n\
    \      ((level--))\n    fi\n    ((i++))\n  done\n  echo $max_level", "    # TODO:\
    \ Implement this function\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o '(' | wc -l\n    # Hint: Use\
    \ the following command to get the number of closing parentheses\n    # echo $1\
    \ | grep -o ')' | wc -l\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o '(' | wc -l\n    # Hint: Use\
    \ the following command to get the number of closing parentheses\n    # echo $1\
    \ | grep -o ')' | wc -l\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o '(' | wc -l\n    # Hint: Use\
    \ the following command to get the number of closing parentheses\n    # echo $1\
    \ | grep -o ')' | wc -l\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o '(' | wc -l\n    # Hint: Use\
    \ the following command to get the number of closing parentheses\n    # echo $1\
    \ | grep -o ')' | wc -l\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o '(' | wc -l\n    # Hint: Use\
    \ the following command to get the number of closing parentheses\n    # echo $1\
    \ | grep -o ')' | wc -l\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o '(' | wc -l\n    # Hint: Use\
    \ the following command to get the number of closing parentheses\n    # echo $1\
    \ | grep -o ')' | wc -l\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o '(' | wc -l\n    # Hint: Use\
    \ the following command to get the number of closing parentheses\n    # echo $1\
    \ | grep -o ')' | wc -l\n    # Hint: Use the following command to get the number\
    \ of opening parentheses\n    # echo $1 | grep -o", "    local input=$1\n    local\
    \ max_depth=0\n    local depth=0\n    local i=0\n    local len=${#input}\n   \
    \ while [ $i -lt $len ]; do\n        if [ \"${input:$i:1}\" == \"(\" ]; then\n\
    \            depth=$((depth+1))\n            if [ $depth -gt $max_depth ]; then\n\
    \                max_depth=$depth\n            fi\n        elif [ \"${input:$i:1}\"\
    \ == \")\" ]; then\n            depth=$((depth-1))\n        fi\n        i=$((i+1))\n\
    \    done\n    echo $max_depth", "    local input=\"$1\"\n    local max_depth=0\n\
    \    local current_depth=0\n    local i=0\n    local len=${#input}\n    local\
    \ char=''\n    local result=''\n\n    while [ $i -lt $len ]; do\n        char=${input:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            current_depth=$((current_depth\
    \ + 1))\n            if [ $current_depth -gt $max_depth ]; then\n            \
    \    max_depth=$current_depth\n            fi\n        elif [ \"$char\" == \"\
    )\" ]; then\n            current_depth=$((current_depth - 1))\n        fi\n  \
    \      i=$((i + 1))\n    done\n\n    echo $max_depth", "    local str=$1\n   \
    \ local max_level=0\n    local level=0\n    local c\n    for ((i=0; i<${#str};\
    \ i++)); do\n        c=${str:$i:1}\n        if [[ $c == \"(\" ]]; then\n     \
    \       ((level++))\n            if ((level > max_level)); then\n            \
    \    max_level=$level\n            fi\n        elif [[ $c == \")\" ]]; then\n\
    \            ((level--))\n        fi\n    done\n    echo $max_level", "    local\
    \ str=\"$1\"\n    local max_depth=0\n    local depth=0\n    local i=0\n    local\
    \ len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\" ==\
    \ \"(\" ]; then\n            depth=$((depth+1))\n            if [ $depth -gt $max_depth\
    \ ]; then\n                max_depth=$depth\n            fi\n        elif [ \"\
    ${str:$i:1}\" == \")\" ]; then\n            depth=$((depth-1))\n        fi\n \
    \       i=$((i+1))\n    done\n    echo $max_depth", "  local input=$1\n  local\
    \ output=()\n  local max_depth=0\n  local current_depth=0\n  local i=0\n  local\
    \ c=''\n\n  for ((i=0; i<${#input}; i++)); do\n    c=${input:$i:1}\n    if [[\
    \ \"$c\" == \"(\" ]]; then\n      ((current_depth++))\n      if ((current_depth\
    \ > max_depth)); then\n        max_depth=$current_depth\n      fi\n    elif [[\
    \ \"$c\" == \")\" ]]; then\n      ((current_depth--))\n    fi\n  done\n\n  echo\
    \ $max_depth", "    # Write your code here\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n", "  local input=$1\n\
    \  local parens_count=0\n  local max_parens_count=0\n  local max_parens_count_index=0\n\
    \  local parens_count_index=0\n  local i=0\n  local length=${#input}\n  local\
    \ char\n\n  for ((i=0; i<length; i++)); do\n    char=${input:$i:1}\n    if [[\
    \ \"$char\" == \"(\" ]]; then\n      ((parens_count++))\n    elif [[ \"$char\"\
    \ == \")\" ]]; then\n      ((parens_count--))\n    fi\n\n    if [[ \"$parens_count\"\
    \ -gt \"$max_parens_count\" ]]; then\n      max_parens_count=$parens_count\n \
    \     max_parens_count_index=$parens_count_index\n    fi\n\n    if [[ \"$parens_count\"\
    \ -eq 0 ]]; then\n      ((parens_count_index++))\n    fi\n  done\n\n  echo \"\
    $max_parens_count_index $max_parens_count\"", "    local input=$1\n    local output=\"\
    \"\n    local max_depth=0\n    local curr_depth=0\n    local curr_char=\"\"\n\n\
    \    for (( i=0; i<${#input}; i++ )); do\n        curr_char=${input:$i:1}\n  \
    \      if [[ $curr_char == \"(\" ]]; then\n            (( curr_depth++ ))\n  \
    \          if [[ $curr_depth -gt $max_depth ]]; then\n                max_depth=$curr_depth\n\
    \            fi\n        elif [[ $curr_char == \")\" ]]; then\n            ((\
    \ curr_depth-- ))\n        fi\n    done\n\n    echo $max_depth", "  local input=$1\n\
    \  local max_depth=0\n  local depth=0\n  local char\n  for (( i=0; i<${#input};\
    \ i++ )); do\n    char=${input:$i:1}\n    if [[ $char == \"(\" ]]; then\n    \
    \  (( depth++ ))\n      if (( depth > max_depth )); then\n        max_depth=$depth\n\
    \      fi\n    elif [[ $char == \")\" ]]; then\n      (( depth-- ))\n    fi\n\
    \  done\n  echo $max_depth", "    # TODO: Write your code here\n    # Please use\
    \ the echo command to output the answer, something like:\n    # echo \"answer\"\
    \n    echo \"1\"", "  local str=$1\n  local max_depth=0\n  local depth=0\n  local\
    \ i=0\n  local len=${#str}\n  while [ $i -lt $len ]; do\n    local char=${str:$i:1}\n\
    \    if [ \"$char\" == \"(\" ]; then\n      ((depth++))\n      if [ $depth -gt\
    \ $max_depth ]; then\n        max_depth=$depth\n      fi\n    elif [ \"$char\"\
    \ == \")\" ]; then\n      ((depth--))\n    fi\n    ((i++))\n  done\n  echo $max_depth",
  "    local input=$1\n    local output=''\n    local max_depth=0\n    local depth=0\n\
    \    local i=0\n    local len=${#input}\n    for ((i=0; i<len; i++)); do\n   \
    \     local c=${input:$i:1}\n        if [[ $c == '(' ]]; then\n            ((depth++))\n\
    \            if ((depth > max_depth)); then\n                max_depth=$depth\n\
    \            fi\n        elif [[ $c == ')' ]]; then\n            ((depth--))\n\
    \        fi\n    done\n    echo $max_depth", "    local str=\"$1\"\n    local\
    \ max_depth=0\n    local depth=0\n    local i=0\n    local len=${#str}\n    while\
    \ [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\" == \"(\" ]; then\n       \
    \     depth=$((depth+1))\n            if [ $depth -gt $max_depth ]; then\n   \
    \             max_depth=$depth\n            fi\n        elif [ \"${str:$i:1}\"\
    \ == \")\" ]; then\n            depth=$((depth-1))\n        fi\n        i=$((i+1))\n\
    \    done\n    echo $max_depth", "    local input=$1\n    local max_depth=0\n\
    \    local depth=0\n    local paren_count=0\n    local i=0\n    local len=${#input}\n\
    \    local c=''\n\n    for ((i=0; i<len; i++)); do\n        c=${input:$i:1}\n\
    \        if [[ $c == '(' ]]; then\n            ((depth++))\n            ((paren_count++))\n\
    \            if [[ $depth -gt $max_depth ]]; then\n                max_depth=$depth\n\
    \            fi\n        elif [[ $c == ')' ]]; then\n            ((depth--))\n\
    \            ((paren_count--))\n        fi\n    done\n\n    if [[ $paren_count\
    \ -ne 0 ]]; then\n        echo \"Invalid input: $input\"\n        exit 1\n   \
    \ fi\n\n    echo $max_depth", "    local str=$1\n    local max_level=0\n    local\
    \ level=0\n    local i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n\
    \        local c=${str:$i:1}\n        if [ \"$c\" == \"(\" ]; then\n         \
    \   level=$((level+1))\n            if [ $level -gt $max_level ]; then\n     \
    \           max_level=$level\n            fi\n        elif [ \"$c\" == \")\" ];\
    \ then\n            level=$((level-1))\n        fi\n        i=$((i+1))\n    done\n\
    \    echo $max_level", "    local input=$1\n    local parens_stack=()\n    local\
    \ max_depth=0\n    local curr_depth=0\n    local i=0\n    local c=''\n    local\
    \ len=${#input}\n\n    while [ $i -lt $len ]; do\n        c=${input:$i:1}\n  \
    \      if [ \"$c\" == \"(\" ]; then\n            parens_stack+=($c)\n        \
    \    (( curr_depth++ ))\n            (( max_depth = curr_depth > max_depth ? curr_depth\
    \ : max_depth ))\n        elif [ \"$c\" == \")\" ]; then\n            if [ ${#parens_stack[@]}\
    \ -eq 0 ]; then\n                echo \"Invalid input: $input\"\n            \
    \    return 1\n            fi\n            unset parens_stack[${#parens_stack[@]}-1]\n\
    \            (( curr_depth-- ))\n        fi\n        (( i++ ))\n    done\n\n \
    \   if [ ${#parens_stack[@]} -ne 0 ]; then\n        echo \"Invalid input: $input\"\
    \n        return 1\n    fi\n\n    echo $max_depth", "  local input=$1\n  local\
    \ max_depth=0\n  local current_depth=0\n  local i=0\n  local len=${#input}\n \
    \ local c\n  while [ $i -lt $len ]; do\n    c=${input:$i:1}\n    if [ \"$c\" ==\
    \ \"(\" ]; then\n      current_depth=$((current_depth + 1))\n      if [ $current_depth\
    \ -gt $max_depth ]; then\n        max_depth=$current_depth\n      fi\n    elif\
    \ [ \"$c\" == \")\" ]; then\n      current_depth=$((current_depth - 1))\n    fi\n\
    \    i=$((i + 1))\n  done\n  echo $max_depth", "    local str=\"$1\"\n    local\
    \ max_depth=0\n    local cur_depth=0\n    local i=0\n    local len=${#str}\n \
    \   for ((i=0; i<len; i++)); do\n        local char=${str:$i:1}\n        if [[\
    \ \"$char\" == \"(\" ]]; then\n            ((cur_depth++))\n            if ((cur_depth\
    \ > max_depth)); then\n                max_depth=$cur_depth\n            fi\n\
    \        elif [[ \"$char\" == \")\" ]]; then\n            ((cur_depth--))\n  \
    \      fi\n    done\n    echo $max_depth", "    local str=$1\n    local max_depth=0\n\
    \    local depth=0\n    local i=0\n    local len=${#str}\n    while [ $i -lt $len\
    \ ]; do\n        local char=${str:$i:1}\n        if [ \"$char\" == \"(\" ]; then\n\
    \            ((depth++))\n            if [ $depth -gt $max_depth ]; then\n   \
    \             max_depth=$depth\n            fi\n        elif [ \"$char\" == \"\
    )\" ]; then\n            ((depth--))\n        fi\n        ((i++))\n    done\n\
    \    echo $max_depth", "  local str=\"$1\"\n  local max_depth=0\n  local depth=0\n\
    \  local c\n  for ((i=0; i<${#str}; i++)); do\n    c=${str:$i:1}\n    if [[ \"\
    $c\" == \"(\" ]]; then\n      ((depth++))\n      if ((depth > max_depth)); then\n\
    \        max_depth=$depth\n      fi\n    elif [[ \"$c\" == \")\" ]]; then\n  \
    \    ((depth--))\n    fi\n  done\n  echo $max_depth", "    local str=$1\n    local\
    \ max_depth=0\n    local cur_depth=0\n    local i=0\n    local len=${#str}\n \
    \   while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n        if [ \"\
    $char\" == \"(\" ]; then\n            ((cur_depth++))\n            if [ $cur_depth\
    \ -gt $max_depth ]; then\n                max_depth=$cur_depth\n            fi\n\
    \        elif [ \"$char\" == \")\" ]; then\n            ((cur_depth--))\n    \
    \    fi\n        ((i++))\n    done\n    echo $max_depth", "    local str=\"$1\"\
    \n    local max_depth=0\n    local cur_depth=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n        if [ \"\
    $char\" == \"(\" ]; then\n            ((cur_depth++))\n            if [ $cur_depth\
    \ -gt $max_depth ]; then\n                max_depth=$cur_depth\n            fi\n\
    \        elif [ \"$char\" == \")\" ]; then\n            ((cur_depth--))\n    \
    \    fi\n        ((i++))\n    done\n    echo $max_depth", "    local input=$1\n\
    \    local max_depth=0\n    local curr_depth=0\n    local i=0\n    local len=${#input}\n\
    \    local char=''\n\n    while [ $i -lt $len ]; do\n        char=${input:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            ((curr_depth++))\n     \
    \       if [ $curr_depth -gt $max_depth ]; then\n                max_depth=$curr_depth\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            ((curr_depth--))\n\
    \        fi\n        ((i++))\n    done\n\n    echo $max_depth", "    local str=$1\n\
    \    local max_depth=0\n    local depth=0\n    for ((i=0; i<${#str}; i++)); do\n\
    \        if [[ ${str:$i:1} == \"(\" ]]; then\n            ((depth++))\n      \
    \      if ((depth > max_depth)); then\n                max_depth=$depth\n    \
    \        fi\n        elif [[ ${str:$i:1} == \")\" ]]; then\n            ((depth--))\n\
    \        fi\n    done\n    echo $max_depth", "    # Use a stack to keep track\
    \ of the current level of nesting.\n    # When a '(' is encountered, increment\
    \ the stack.\n    # When a ')' is encountered, decrement the stack.\n    # Keep\
    \ track of the maximum level of nesting.\n    local max_level=0\n    local level=0\n\
    \    local str=$1\n    for ((i=0; i<${#str}; i++)); do\n        if [[ ${str:$i:1}\
    \ == \"(\" ]]; then\n            ((level++))\n            if ((level > max_level));\
    \ then\n                max_level=$level\n            fi\n        elif [[ ${str:$i:1}\
    \ == \")\" ]]; then\n            ((level--))\n        fi\n    done\n    echo $max_level",
  "    local str=\"$1\"\n    local max_level=0\n    local level=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n\
    \        if [ \"$c\" == \"(\" ]; then\n            level=$((level+1))\n      \
    \      if [ $level -gt $max_level ]; then\n                max_level=$level\n\
    \            fi\n        elif [ \"$c\" == \")\" ]; then\n            level=$((level-1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $max_level", "    # TODO:\
    \ Fill in this function\n    # Hint: Use a stack to keep track of the current\
    \ level of nesting.\n    # Hint: Use a variable to keep track of the maximum level\
    \ of nesting.\n    # Hint: Use a variable to keep track of the current level of\
    \ nesting.\n    # Hint: Use a variable to keep track of the current character.\n\
    \    # Hint: Use a variable to keep track of the current group.\n    # Hint: Use\
    \ a variable to keep track of the current index.\n    # Hint: Use a variable to\
    \ keep track of the current length.\n    # Hint: Use a variable to keep track\
    \ of the current string.\n    # Hint: Use a variable to keep track of the current\
    \ substring.\n    # Hint: Use a variable to keep track of the current token.\n\
    \    # Hint: Use a variable to keep track of the current word.\n    # Hint: Use\
    \ a variable to keep track of the current line.\n    # Hint: Use a variable to\
    \ keep track of the current file.\n    # Hint: Use a variable to keep track of\
    \ the current directory.\n    # Hint: Use a variable to keep track of the current\
    \ path.\n    # Hint: Use a variable to keep track of the current argument.\n \
    \   # Hint: Use a variable to keep track of the current option.\n    # Hint: Use\
    \ a variable to keep track of the current flag.\n    # Hint: Use a variable to\
    \ keep track of the current command.\n    # Hint: Use a variable to keep track\
    \ of the current process.\n    # Hint: Use a variable to keep track of the current\
    \ job.\n    # Hint: Use a variable to keep track of the current task.\n    # Hint:\
    \ Use a variable to keep track of the current operation.\n    # Hint: Use a variable\
    \ to keep track of the current action.\n    # Hint: Use a variable to keep track\
    \ of the current function.\n    # Hint: Use a variable to keep track of the current\
    \ method.\n    # Hint: Use a variable to keep track of the current function.\n\
    \    # Hint: Use a variable to keep track of the current module.\n    # Hint:\
    \ Use a variable to keep track of the current library.\n   ", "  local str=$1\n\
    \  local max_depth=0\n  local curr_depth=0\n  local i=0\n  local len=${#str}\n\
    \  local c\n\n  while [ $i -lt $len ]; do\n    c=${str:$i:1}\n    if [ \"$c\"\
    \ == \"(\" ]; then\n      ((curr_depth++))\n      if [ $curr_depth -gt $max_depth\
    \ ]; then\n        max_depth=$curr_depth\n      fi\n    elif [ \"$c\" == \")\"\
    \ ]; then\n      ((curr_depth--))\n    fi\n    ((i++))\n  done\n\n  echo $max_depth",
  "    local input=$1\n    local output=\"\"\n    local max_level=0\n    local level=0\n\
    \    local i=0\n    local c=\"\"\n\n    for ((i=0; i<${#input}; i++)); do\n  \
    \      c=${input:$i:1}\n        if [[ \"$c\" == \"(\" ]]; then\n            ((level++))\n\
    \            if [[ $level -gt $max_level ]]; then\n                max_level=$level\n\
    \            fi\n        elif [[ \"$c\" == \")\" ]]; then\n            ((level--))\n\
    \        fi\n    done\n\n    echo $max_level", "    # TODO: Write your code here\n\
    \    # Please use the echo command to output the result, e.g.\n    # echo \"Hello\
    \ world\"\n    #\n    # If you have multiple lines of output, please use the cat\
    \ command, e.g.\n    # cat << EOF\n    # Hello world\n    # EOF\n    #\n    #\
    \ Note that all extra spaces and blank lines will be ignored.\n    # Please make\
    \ sure there are no extra spaces and blank lines at the end of your output.\n\
    \    #\n    # Please do NOT print anything to stdout.\n    #\n    # Your solution\
    \ will be tested against a set of test cases.\n    #\n    # Hint: You may find\
    \ the following commands useful:\n    #       grep, sed, awk, cut, tr, wc, expr,\
    \ bc\n    #\n    # Hint: You may find the following commands useful:\n    #  \
    \     grep, sed, awk, cut, tr, wc, expr, bc\n    #\n    # Hint: You may find the\
    \ following commands useful:\n    #       grep, sed, awk, cut, tr, wc, expr, bc\n\
    \    #\n    # Hint: You may find the following commands useful:\n    #       grep,\
    \ sed, awk, cut, tr, wc, expr, bc\n    #\n    # Hint: You may find the following\
    \ commands useful:\n    #       grep, sed, awk, cut, tr, wc, expr, bc\n    #\n\
    \    # Hint: You may find the following commands useful:\n    #       grep, sed,\
    \ awk, cut, tr, wc, expr, bc\n    #\n    # Hint: You may find the following commands\
    \ useful:\n    #       grep, sed, awk, cut, tr, wc, expr, bc\n    #\n    # Hint:\
    \ You may find the following commands useful:\n    #       grep, sed, awk, cut,\
    \ tr, wc, expr, bc\n    #\n    # Hint: You may find the following commands useful:\n\
    \    #       grep, sed, awk, cut, tr, wc, expr, bc\n    #\n    # Hint: You may\
    \ find the following commands useful:\n    #       grep", "    local input=$1\n\
    \    local parens_stack=()\n    local max_depth=0\n    local curr_depth=0\n  \
    \  local i=0\n    local len=${#input}\n    while [ $i -lt $len ]; do\n       \
    \ local char=${input:$i:1}\n        if [ \"$char\" == \"(\" ]; then\n        \
    \    parens_stack+=(\"$char\")\n            curr_depth=$((curr_depth + 1))\n \
    \           if [ $curr_depth -gt $max_depth ]; then\n                max_depth=$curr_depth\n\
    \            fi\n        elif [ \"$char\" == \")\" ]; then\n            if [ ${#parens_stack[@]}\
    \ -eq 0 ]; then\n                echo \"Error: mismatched parentheses\"\n    \
    \            return 1\n            fi\n            parens_stack=(\"${parens_stack[@]:0:$((${#parens_stack[@]}\
    \ - 1))}\")\n            curr_depth=$((curr_depth - 1))\n        fi\n        i=$((i\
    \ + 1))\n    done\n    if [ ${#parens_stack[@]} -ne 0 ]; then\n        echo \"\
    Error: mismatched parentheses\"\n        return 1\n    fi\n    echo $max_depth",
  "  local str=\"$1\"\n  local max_level=0\n  local level=0\n  local i=0\n  local\
    \ len=${#str}\n  while [ $i -lt $len ]; do\n    local char=${str:$i:1}\n    if\
    \ [ \"$char\" == \"(\" ]; then\n      ((level++))\n      if [ $level -gt $max_level\
    \ ]; then\n        max_level=$level\n      fi\n    elif [ \"$char\" == \")\" ];\
    \ then\n      ((level--))\n    fi\n    ((i++))\n  done\n  echo $max_level", " \
    \   local str=\"$1\"\n    local max_level=0\n    local level=0\n    local i=0\n\
    \    local len=${#str}\n    while [ $i -lt $len ]; do\n        if [ \"${str:$i:1}\"\
    \ == \"(\" ]; then\n            ((level++))\n            if [ $level -gt $max_level\
    \ ]; then\n                max_level=$level\n            fi\n        elif [ \"\
    ${str:$i:1}\" == \")\" ]; then\n            ((level--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_level", "    # Write your code here\n    #\n    #\n \
    \   #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n", "    local str=$1\n    local max_depth=0\n    local depth=0\n    local\
    \ i=0\n    local len=${#str}\n    while [ $i -lt $len ]; do\n        local char=${str:$i:1}\n\
    \        if [ \"$char\" == \"(\" ]; then\n            ((depth++))\n          \
    \  if [ $depth -gt $max_depth ]; then\n                max_depth=$depth\n    \
    \        fi\n        elif [ \"$char\" == \")\" ]; then\n            ((depth--))\n\
    \        fi\n        ((i++))\n    done\n    echo $max_depth", "    local str=$1\n\
    \    local max_level=0\n    local level=0\n    local i=0\n    local len=${#str}\n\
    \    while [ $i -lt $len ]; do\n        local c=${str:$i:1}\n        if [ \"$c\"\
    \ == \"(\" ]; then\n            ((level++))\n            if [ $level -gt $max_level\
    \ ]; then\n                max_level=$level\n            fi\n        elif [ \"\
    $c\" == \")\" ]; then\n            ((level--))\n        fi\n        ((i++))\n\
    \    done\n    echo $max_level", "    local str=$1\n    local max_level=0\n  \
    \  local level=0\n    local i=0\n    local len=${#str}\n    while [ $i -lt $len\
    \ ]; do\n        local char=${str:$i:1}\n        if [ \"$char\" == \"(\" ]; then\n\
    \            ((level++))\n            if [ $level -gt $max_level ]; then\n   \
    \             max_level=$level\n            fi\n        elif [ \"$char\" == \"\
    )\" ]; then\n            ((level--))\n        fi\n        ((i++))\n    done\n\
    \    echo $max_level", "    # TODO: Implement this function\n    # Hint: You may\
    \ find the following useful:\n    #   - expr\n    #   - sed\n    #   - grep\n\
    \    #   - wc\n    #   - sort\n    #   - uniq\n    #   - head\n    #   - tail\n\
    \    #   - tr\n    #   - cut\n    #   - paste\n    #   - bc\n    #   - echo\n\
    \    #   - printf\n    #   - cat\n    #   - sort\n    #   - uniq\n    #   - head\n\
    \    #   - tail\n    #   - tr\n    #   - cut\n    #   - paste\n    #   - bc\n\
    \    #   - echo\n    #   - printf\n    #   - cat\n    #   - sort\n    #   - uniq\n\
    \    #   - head\n    #   - tail\n    #   - tr\n    #   - cut\n    #   - paste\n\
    \    #   - bc\n    #   - echo\n    #   - printf\n    #   - cat\n    #   - sort\n\
    \    #   - uniq\n    #   - head\n    #   - tail\n    #   - tr\n    #   - cut\n\
    \    #   - paste\n    #   - bc\n    #   - echo\n    #   - printf\n    #   - cat\n\
    \    #   - sort\n    #   - uniq\n    #   - head\n    #   - tail\n    #   - tr\n\
    \    #   - cut\n    #   - paste\n    #   - bc\n    #   - echo\n    #   - printf\n\
    \    #   - cat\n    #   - sort\n    #   - uniq\n    #   - head\n    #   - tail\n\
    \    #   - tr\n    #   - cut\n    #   - paste\n    #   - bc\n    #   - echo\n\
    \    #   - printf\n    #   - cat\n    #   - sort\n    #   - uniq\n    #   - head\n\
    \    #   - tail\n    #   - tr\n    #   - cut\n    #   - paste\n    #   - bc\n\
    \    #   - echo\n    #   - printf\n   ", "  local str=\"$1\"\n  local max_depth=0\n\
    \  local depth=0\n  local i=0\n  local len=${#str}\n  for ((i=0; i<len; i++));\
    \ do\n    if [[ \"${str:$i:1}\" == \"(\" ]]; then\n      ((depth++))\n      if\
    \ ((depth > max_depth)); then\n        max_depth=$depth\n      fi\n    elif [[\
    \ \"${str:$i:1}\" == \")\" ]]; then\n      ((depth--))\n    fi\n  done\n  echo\
    \ $max_depth"]
stop_tokens:
- "\n}"
