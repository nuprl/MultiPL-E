name: HumanEval_136_largest_smallest_integers
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Create a function that returns a pair (a, b), where 'a'\
  \ is\n    // the largest of negative integers, and 'b' is the smallest\n    // of\
  \ positive integers in an array array list.\n    // If there is no negative or positive\
  \ integers, return them as null.\n    // Examples:\n    // >>> largestSmallestIntegers((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l,\
  \ (long)7l))))\n    // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))\n\
  \    // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))\n  \
  \  // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))\n\
  \    // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))\n\
  \    // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))\n\
  \    public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long>\
  \ lst) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(largestSmallestIntegers((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l,\
  \ (long)7l)))).equals(Pair.with(Optional.of(Optional.empty()), Optional.of(1l))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)4l, (long)1l, (long)3l, (long)5l, (long)7l, (long)0l)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(1l))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)-2l)))).equals(Pair.with(-2l,\
  \ 1l)));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)4l,\
  \ (long)5l, (long)3l, (long)6l, (long)2l, (long)7l, (long)-7l)))).equals(Pair.with(-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)7l,\
  \ (long)3l, (long)8l, (long)4l, (long)9l, (long)2l, (long)5l, (long)-9l)))).equals(Pair.with(-9l,\
  \ 2l)));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList()))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-1l,\
  \ (long)-3l, (long)-5l, (long)-6l)))).equals(Pair.with(Optional.of(-1l), Optional.of(Optional.empty()))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-1l,\
  \ (long)-3l, (long)-5l, (long)-6l, (long)0l)))).equals(Pair.with(Optional.of(-1l),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-6l,\
  \ (long)-4l, (long)-4l, (long)-3l, (long)1l)))).equals(Pair.with(-3l, 1l)));\n \
  \   assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-6l,\
  \ (long)-4l, (long)-4l, (long)-3l, (long)-100l, (long)1l)))).equals(Pair.with(-3l,\
  \ 1l)));\n    }\n\n}\n"
completions: ["        Optional<Long> largestNegative = Optional.empty();\n      \
    \  Optional<Long> smallestPositive = Optional.empty();\n        for (Long i :\
    \ lst) {\n            if (i < 0) {\n                if (!largestNegative.isPresent()\
    \ || largestNegative.get() < i) {\n                    largestNegative = Optional.of(i);\n\
    \                }\n            } else if (i > 0) {\n                if (!smallestPositive.isPresent()\
    \ || smallestPositive.get() > i) {\n                    smallestPositive = Optional.of(i);\n\
    \                }\n            }\n        }\n        return Pair.with(largestNegative,\
    \ smallestPositive);", "        Optional<Long> max_negative = lst.stream().filter(e\
    \ -> e < 0).max(Comparator.naturalOrder());\n        Optional<Long> min_positive\
    \ = lst.stream().filter(e -> e > 0).min(Comparator.naturalOrder());\n        return\
    \ Pair.with(max_negative, min_positive);", "        Pair<Optional<Long>, Optional<Long>>\
    \ pair = Pair.with(Optional.empty(), Optional.empty());\n        long largestNegative\
    \ = 0;\n        boolean hasNegative = false;\n        long smallestPositive =\
    \ 0;\n        boolean hasPositive = false;\n        for (Long n : lst) {\n   \
    \         if (n < 0) {\n                if (hasNegative) {\n                 \
    \   if (n > largestNegative) {\n                        largestNegative = n;\n\
    \                    }\n                } else {\n                    largestNegative\
    \ = n;\n                    hasNegative = true;\n                }\n         \
    \   } else if (n > 0) {\n                if (hasPositive) {\n                \
    \    if (n < smallestPositive) {\n                        smallestPositive = n;\n\
    \                    }\n                } else {\n                    smallestPositive\
    \ = n;\n                    hasPositive = true;\n                }\n         \
    \   }\n        }\n        if (hasNegative) {\n            pair.setValue0(Optional.of(largestNegative));\n\
    \        }\n        if (hasPositive) {\n            pair.setValue1(Optional.of(smallestPositive));\n\
    \        }\n        return pair;", "        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        if (lst.size() > 0) {\n\
    \            a = Optional.of(lst.stream().filter(x -> x < 0).reduce(Math::max).get());\n\
    \            b = Optional.of(lst.stream().filter(x -> x > 0).reduce(Math::min).get());\n\
    \        }\n        return Pair.with(a, b);", "        Optional<Long> negative\
    \ = lst.stream().filter(x -> x < 0).max(Long::compare);\n        Optional<Long>\
    \ positive = lst.stream().filter(x -> x > 0).min(Long::compare);\n        return\
    \ Pair.with(negative, positive);", '        // write your code here', "      \
    \  //\n        Pair<Optional<Long>, Optional<Long>> pair = new Pair<Optional<Long>,\
    \ Optional<Long>>(Optional.empty(), Optional.empty());\n        if (lst.size()\
    \ > 0) {\n            long largest = lst.get(0);\n            long smallest =\
    \ lst.get(0);\n            for (int i = 0; i < lst.size(); i++) {\n          \
    \      if (lst.get(i) < 0) {\n                    if (lst.get(i) > largest) {\n\
    \                        largest = lst.get(i);\n                    }\n      \
    \          } else {\n                    if (lst.get(i) < smallest) {\n      \
    \                  smallest = lst.get(i);\n                    }\n           \
    \     }\n            }\n            if (largest > 0) {\n                pair =\
    \ new Pair<Optional<Long>, Optional<Long>>(Optional.empty(), Optional.of(smallest));\n\
    \            } else if (smallest < 0) {\n                pair = new Pair<Optional<Long>,\
    \ Optional<Long>>(Optional.of(largest), Optional.empty());\n            } else\
    \ {\n                pair = new Pair<Optional<Long>, Optional<Long>>(Optional.of(largest),\
    \ Optional.of(smallest));\n            }\n        }\n        return pair;", " \
    \       // Your code here!\n        long smallest = Long.MAX_VALUE;\n        long\
    \ largest = Long.MIN_VALUE;\n        boolean any = false;\n        for (long i\
    \ : lst) {\n            if (i > 0) {\n                if (i < smallest) {\n  \
    \                  smallest = i;\n                }\n                any = true;\n\
    \            } else if (i < 0) {\n                if (i > largest) {\n       \
    \             largest = i;\n                }\n                any = true;\n \
    \           }\n        }\n        return Pair.with(any ? Optional.of(largest)\
    \ : Optional.empty(), any ? Optional.of(smallest) : Optional.empty());", "   \
    \     // Your code here\n        return null;", "        Optional<Long> a = lst.stream().reduce((b,\
    \ c) -> b < c ? c : b);\n        Optional<Long> b = lst.stream().reduce((c, d)\
    \ -> c < d ? c : d);\n        return Pair.with(a, b);", "        // Write your\
    \ code here\n        Optional<Long> o = Optional.empty();\n        Optional<Long>\
    \ o1 = Optional.empty();\n        if(lst.size() == 0)\n            return Pair.with(o,\
    \ o1);\n        if(lst.size() == 1 && lst.get(0) == 0)\n            return Pair.with(o,\
    \ o1);\n        for(int i = 0; i < lst.size(); i++){\n            if(lst.get(i)\
    \ > 0){\n                if(o1.isPresent()){\n                    if(lst.get(i)\
    \ < o1.get())\n                        o1 = Optional.of(lst.get(i));\n       \
    \         }\n                else\n                    o1 = Optional.of(lst.get(i));\n\
    \            }\n            else{\n                if(o.isPresent()){\n      \
    \              if(lst.get(i) > o.get())\n                        o = Optional.of(lst.get(i));\n\
    \                }\n                else\n                    o = Optional.of(lst.get(i));\n\
    \            }\n        }\n        return Pair.with(o, o1);", '        return
    null;', "        Optional<Long> largestNegative = Optional.empty();\n        Optional<Long>\
    \ smallestPositive = Optional.empty();\n        for (Long l : lst) {\n       \
    \     if (l >= 0) {\n                if (!smallestPositive.isPresent() || l <\
    \ smallestPositive.get()) {\n                    smallestPositive = Optional.of(l);\n\
    \                }\n            } else {\n                if (!largestNegative.isPresent()\
    \ || l > largestNegative.get()) {\n                    largestNegative = Optional.of(l);\n\
    \                }\n            }\n        }\n        return Pair.with(largestNegative,\
    \ smallestPositive);", "        // Find largest of negative integers in lst.\n\
    \        // Find smallest of positive integers in lst.\n        return null;",
  "        Optional<Long> negative = lst.stream().filter(x -> x < 0).max(Long::compare);\n\
    \        Optional<Long> positive = lst.stream().filter(x -> x > 0).min(Long::compare);\n\
    \        return Pair.with(negative, positive);", "        Optional<Long> largestNegative\
    \ = Optional.empty();\n        Optional<Long> smallestPositive = Optional.empty();\n\
    \        for (Long element : lst) {\n            if (element < 0) {\n        \
    \        if (!largestNegative.isPresent() || largestNegative.get() < element)\
    \ {\n                    largestNegative = Optional.of(element);\n           \
    \     }\n            } else if (element > 0) {\n                if (!smallestPositive.isPresent()\
    \ || smallestPositive.get() > element) {\n                    smallestPositive\
    \ = Optional.of(element);\n                }\n            }\n        }\n     \
    \   return Pair.with(largestNegative, smallestPositive);", "        long max =\
    \ Long.MIN_VALUE;\n        long min = Long.MAX_VALUE;\n        for (Long el: lst)\
    \ {\n            if (el < 0) {\n                max = Math.max(max, el);\n   \
    \         } else if (el > 0) {\n                min = Math.min(min, el);\n   \
    \         }\n        }\n        Optional<Long> maxOp = max == Long.MIN_VALUE ?\
    \ Optional.empty() : Optional.of(max);\n        Optional<Long> minOp = min ==\
    \ Long.MAX_VALUE ? Optional.empty() : Optional.of(min);\n        return Pair.with(maxOp,\
    \ minOp);", '        return null;', "        // This is the correct solution.\n\
    \        if (lst.isEmpty()) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n        List<Long> lst2 = lst.stream().filter(n\
    \ -> n < 0).collect(Collectors.toList());\n        List<Long> lst3 = lst.stream().filter(n\
    \ -> n > 0).collect(Collectors.toList());\n        Optional<Long> a = lst2.isEmpty()\
    \ ? Optional.empty() : Optional.of(Collections.max(lst2));\n        Optional<Long>\
    \ b = lst3.isEmpty() ? Optional.empty() : Optional.of(Collections.min(lst3));\n\
    \        return Pair.with(a, b);", "        Optional<Long> max = lst.stream().filter(x\
    \ -> x < 0).max(Comparator.naturalOrder());\n        Optional<Long> min = lst.stream().filter(x\
    \ -> x > 0).min(Comparator.naturalOrder());\n        return Pair.with(max, min);",
  '        return null;', '        return null;', "        Optional<Long> largestNegativeInteger\
    \ = Optional.empty();\n        Optional<Long> smallestPositiveInteger = Optional.empty();\n\
    \        for (long i : lst) {\n            if (i < 0) {\n                if (!largestNegativeInteger.isPresent()\
    \ || largestNegativeInteger.get() < i) {\n                    largestNegativeInteger\
    \ = Optional.of(i);\n                }\n            } else if (i > 0) {\n    \
    \            if (!smallestPositiveInteger.isPresent() || smallestPositiveInteger.get()\
    \ > i) {\n                    smallestPositiveInteger = Optional.of(i);\n    \
    \            }\n            }\n        }\n        return Pair.with(largestNegativeInteger,\
    \ smallestPositiveInteger);", "        ArrayList<Long> positives = new ArrayList<Long>();\n\
    \        ArrayList<Long> negatives = new ArrayList<Long>();\n        for (Long\
    \ l : lst) {\n            if (l > 0) {\n                positives.add(l);\n  \
    \          } else if (l < 0) {\n                negatives.add(l);\n          \
    \  }\n        }\n        Optional<Long> smallest = positives.stream().min(Comparator.naturalOrder());\n\
    \        Optional<Long> largest = negatives.stream().max(Comparator.naturalOrder());\n\
    \        return Pair.with(largest, smallest);", "        List<Long> c = lst.stream().filter(i\
    \ -> i < 0).collect(Collectors.toList());\n        List<Long> d = lst.stream().filter(i\
    \ -> i > 0).collect(Collectors.toList());\n        return Pair.with(\n       \
    \         Optional.of(c.isEmpty() ? Optional.empty() : Optional.of(c.stream().max(Comparator.naturalOrder()).get())),\n\
    \                Optional.of(d.isEmpty() ? Optional.empty() : Optional.of(d.stream().min(Comparator.naturalOrder()).get()))\n\
    \        );", "        Optional<Long> largestNegativeOptional = lst.stream().filter(n\
    \ -> n < 0).max(Comparator.naturalOrder());\n        Optional<Long> smallestPositiveOptional\
    \ = lst.stream().filter(n -> n > 0).min(Comparator.naturalOrder());\n        return\
    \ Pair.with(largestNegativeOptional, smallestPositiveOptional);", '        return
    null;', "        long max = Long.MIN_VALUE;\n        long min = Long.MAX_VALUE;\n\
    \        Optional<Long> max_val = Optional.empty();\n        Optional<Long> min_val\
    \ = Optional.empty();\n        for (long l : lst) {\n            if (l >= 0 &&\
    \ l < min) {\n                min = l;\n                min_val = Optional.of(l);\n\
    \            }\n            if (l < 0 && l > max) {\n                max = l;\n\
    \                max_val = Optional.of(l);\n            }\n        }\n       \
    \ return Pair.with(max_val, min_val);", '        return new Pair<Optional<Long>,
    Optional<Long>>(Optional.of(Optional.empty()), Optional.of(Optional.empty()));',
  "        Long max = null;\n        Long min = null;\n        for (Long n : lst)\
    \ {\n            if (n < 0 && (max == null || n > max)) {\n                max\
    \ = n;\n            }\n            if (n > 0 && (min == null || n < min)) {\n\
    \                min = n;\n            }\n        }\n        Optional<Long> a\
    \ = max == null ? Optional.empty() : Optional.of(max);\n        Optional<Long>\
    \ b = min == null ? Optional.empty() : Optional.of(min);\n        return Pair.with(a,\
    \ b);", '        return null;', '        // Your code here', "        // write\
    \ your function here\n        return null;", "        // To solve this problem,\
    \ you need to use 'reduce' function from Java's Streams.\n        // The reduce\
    \ function takes a binary operator, and a starting value for\n        // the reduction.\
    \ Note that the starting value is optional, so there is no\n        // need to\
    \ handle the case of an empty list, since the reduce function will\n        //\
    \ just return Optional.empty() if the list is empty.\n        // Take care to\
    \ return the largest negative integers as the first member\n        // of the\
    \ pair, and the smallest positive integers as the second member.\n        // The\
    \ stream() method on ArrayList is what you need to convert the ArrayList\n   \
    \     // to a Stream, and the boxed() method of the Long stream is what you need\n\
    \        // to use to convert the stream of long to a stream of Long.\n      \
    \  // If the list is empty, the reduce function will return an Optional.empty().\n\
    \        // If the list is not empty, the reduce function will return an Optional.of().\n\
    \        // If the list is not empty, but does not contain any negative or positive\n\
    \        // integers, you can return an Optional.empty() for those Optional<Long>\n\
    \        // values.\n        // If you want to only consider negative integers\
    \ for the first member\n        // of the pair, and positive integers for the\
    \ second member of the pair,\n        // you can use the filter() method on the\
    \ Stream. This will allow you to\n        // filter out the elements that you\
    \ don't want to consider. Then, you can\n        // use the max() method of the\
    \ Stream interface to find the largest\n        // negative number. Similarly,\
    \ you can use the min() method to find the\n        // smallest positive number.\n\
    \        // Let's say that you want to only consider values between 1 and 100.\n\
    \        // You would write:\n        // lst.stream().boxed().filter(x -> (x >\
    \ 0 && x < 100)).reduce(Integer::sum)\n        // This would give you the sum\
    \ of the numbers between 1 and 100.\n        // Note that the binary operator\
    \ for the reduce function is also Optional.\n        // This is because it returns\
    \ an Optional value as well.\n        // >>> Optional.of(1).reduce(Optional.of(2),\
    \ (x, y) -> Optional.of(x.get() + y.get()", "        // your code here\n     \
    \   Long min = null;\n        Long max = null;\n        for (Long x : lst) {\n\
    \            if (x > 0) {\n                if (min == null || x < min) {\n   \
    \                 min = x;\n                }\n            } else if (x < 0) {\n\
    \                if (max == null || x > max) {\n                    max = x;\n\
    \                }\n            }\n        }\n        return Pair.with(Optional.ofNullable(max),\
    \ Optional.ofNullable(min));", "        // {{{\n        // your code here\n  \
    \      long min = Long.MAX_VALUE;\n        long max = Long.MIN_VALUE;\n      \
    \  for (long i : lst) {\n            if (i < 0) {\n                max = Math.max(max,\
    \ i);\n            } else if (i > 0) {\n                min = Math.min(min, i);\n\
    \            }\n        }\n        if (min == Long.MAX_VALUE) {\n            min\
    \ = Long.MIN_VALUE;\n        }\n        if (max == Long.MIN_VALUE) {\n       \
    \     max = Long.MAX_VALUE;\n        }\n        return Pair.with(Optional.of(max),\
    \ Optional.of(min));\n        // }}}", "        if (lst.size() == 0) {\n     \
    \       return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        } else {\n            return Pair.with(Optional.of(lst.stream().filter(x\
    \ -> x < 0).max(Comparator.naturalOrder())), Optional.of(lst.stream().filter(x\
    \ -> x > 0).min(Comparator.naturalOrder())));\n        }", "        ArrayList<Long>\
    \ negatives = new ArrayList<Long>();\n        ArrayList<Long> positives = new\
    \ ArrayList<Long>();\n        for (Long i : lst) {\n            if (i < 0) negatives.add(i);\n\
    \            if (i > 0) positives.add(i);\n        }\n        Collections.sort(negatives);\n\
    \        Collections.sort(positives);\n        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        if (negatives.size() >\
    \ 0) a = Optional.of(negatives.get(negatives.size() - 1));\n        if (positives.size()\
    \ > 0) b = Optional.of(positives.get(0));\n        return Pair.with(a, b);", " \
    \       // Remove all those that are not integers\n        lst.removeIf(x -> (x\
    \ > Integer.MAX_VALUE || x < Integer.MIN_VALUE));\n        // remove zero\n  \
    \      lst.removeIf(x -> x == 0);\n        // remove positive numbers\n      \
    \  lst.removeIf(x -> x > 0);\n        // Get the largest number.\n        Optional<Long>\
    \ largestInteger = lst.stream().max(Comparator.comparing(Long::valueOf));\n  \
    \      // remove negative numbers\n        lst.removeIf(x -> x < 0);\n       \
    \ // Get the smallest number.\n        Optional<Long> smallestInteger = lst.stream().min(Comparator.comparing(Long::valueOf));\n\
    \        return Pair.with(largestInteger, smallestInteger);", '        return
    null;', "        Long maxNeg = null;\n        Long minPos = null;\n        for\
    \ (Long a : lst) {\n            if (a < 0) {\n                if (maxNeg == null\
    \ || a > maxNeg) {\n                    maxNeg = a;\n                }\n     \
    \       } else if (a > 0) {\n                if (minPos == null || a < minPos)\
    \ {\n                    minPos = a;\n                }\n            }\n     \
    \   }\n        if (maxNeg == null) {\n            maxNeg = null;\n        }\n\
    \        if (minPos == null) {\n            minPos = null;\n        }\n      \
    \  return Pair.with(Optional.ofNullable(maxNeg), Optional.ofNullable(minPos));",
  "        //**** WRITING CODE HERE ****\n        return null;", "        return Pair.with(lst.stream().reduce((a,\
    \ b) ->\n                                            {\n                     \
    \                           if (a < 0 && b < 0)\n                            \
    \                        return (a > b) ? a : b;\n                           \
    \                     else\n                                                 \
    \   return 0l;\n                                            }),\n            \
    \             lst.stream().reduce((a, b) ->\n                                \
    \            {\n                                                if (a > 0 && b\
    \ > 0)\n                                                    return (a < b) ? a\
    \ : b;\n                                                else\n               \
    \                                     return 0l;\n                           \
    \                 }));", '        throw new UnsupportedOperationException("Implement
    this");', "        Pair<Optional<Long>, Optional<Long>> result = Pair.with(Optional.empty(),\
    \ Optional.empty());\n        Collections.sort(lst);\n        Optional<Long> maxNegativeNumber\
    \ = lst.stream().filter(number -> number < 0).max(Comparator.naturalOrder());\n\
    \        Optional<Long> minPositiveNumber = lst.stream().filter(number -> number\
    \ > 0).min(Comparator.naturalOrder());\n        if (maxNegativeNumber.isPresent())\
    \ {\n            result = Pair.with(maxNegativeNumber, result.getValue1());\n\
    \        }\n        if (minPositiveNumber.isPresent()) {\n            result =\
    \ Pair.with(result.getValue0(), minPositiveNumber);\n        }\n        return\
    \ result;", "        Pair<Optional<Long>, Optional<Long>> answer = new Pair<Optional<Long>,\
    \ Optional<Long>>(Optional.empty(), Optional.empty());\n        Optional<Long>\
    \ big = Optional.empty();\n        Optional<Long> small = Optional.empty();\n\
    \        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) <\
    \ 0) {\n                if (big.isPresent()) {\n                    if (lst.get(i)\
    \ > big.get()) {\n                        big = Optional.of(lst.get(i));\n   \
    \                 }\n                } else {\n                    big = Optional.of(lst.get(i));\n\
    \                }\n            } else if (lst.get(i) > 0) {\n               \
    \ if (small.isPresent()) {\n                    if (lst.get(i) < small.get())\
    \ {\n                        small = Optional.of(lst.get(i));\n              \
    \      }\n                } else {\n                    small = Optional.of(lst.get(i));\n\
    \                }\n            }\n        }\n        return Pair.with(big, small);",
  "        long min_positive_number = Long.MAX_VALUE;\n        long max_negative_number\
    \ = Long.MIN_VALUE;\n        Optional<Long> smallest_integer = Optional.empty();\n\
    \        Optional<Long> largest_integer = Optional.empty();\n        for (long\
    \ i : lst) {\n            if (i > 0) {\n                if (i < min_positive_number)\
    \ {\n                    min_positive_number = i;\n                    smallest_integer\
    \ = Optional.of(i);\n                }\n            } else if (i < 0) {\n    \
    \            if (i > max_negative_number) {\n                    max_negative_number\
    \ = i;\n                    largest_integer = Optional.of(i);\n              \
    \  }\n            }\n        }\n        return Pair.with(largest_integer, smallest_integer);",
  "        Optional<Long> maxNeg = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
    \        Optional<Long> minPos = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(maxNeg, minPos);", "        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        for (long v : lst) {\n\
    \            if (v < 0) {\n                if (!a.isPresent() || a.get() < v)\n\
    \                    a = Optional.of(v);\n            } else if (v > 0) {\n  \
    \              if (!b.isPresent() || b.get() > v)\n                    b = Optional.of(v);\n\
    \            }\n        }\n        return Pair.with(a, b);", '        throw new
    NotImplementedError();', "        Optional<Long> x = Optional.empty();\n     \
    \   Optional<Long> y = Optional.empty();\n        for (Long num : lst) {\n   \
    \         if (num < 0) {\n                if (x.isPresent()) {\n             \
    \       x = Optional.of(Math.max(x.get(), num));\n                } else {\n \
    \                   x = Optional.of(num);\n                }\n            } else\
    \ if (num > 0) {\n                if (y.isPresent()) {\n                    y\
    \ = Optional.of(Math.min(y.get(), num));\n                } else {\n         \
    \           y = Optional.of(num);\n                }\n            }\n        }\n\
    \        return Pair.with(x, y);", '        return Pair.with(Optional.of(lst.stream().filter(i
    -> i < 0).max(Comparator.naturalOrder())), Optional.of(lst.stream().filter(i ->
    i > 0).min(Comparator.naturalOrder())));', "        Optional<Long> max = lst.stream().filter(i\
    \ -> i < 0).max(Comparator.naturalOrder());\n        Optional<Long> min = lst.stream().filter(i\
    \ -> i > 0).min(Comparator.naturalOrder());\n        return Pair.with(max, min);",
  "        ArrayList<Long> positives = new ArrayList<Long>();\n        ArrayList<Long>\
    \ negatives = new ArrayList<Long>();\n        for (Long item : lst) {\n      \
    \      if (item >= 0) {\n                positives.add(item);\n            } else\
    \ {\n                negatives.add(item);\n            }\n        }\n        Collections.sort(positives);\n\
    \        Collections.sort(negatives);\n        Collections.reverse(negatives);\n\
    \        Optional<Long> pos = (positives.size() > 0) ? Optional.of(positives.get(0))\
    \ : Optional.empty();\n        Optional<Long> neg = (negatives.size() > 0) ? Optional.of(negatives.get(0))\
    \ : Optional.empty();\n        return Pair.with(neg, pos);", "        // Insert\
    \ your code here\n        Optional<Long> largest = lst.stream().filter(x -> x\
    \ < 0).max(Comparator.naturalOrder());\n        Optional<Long> smallest = lst.stream().filter(x\
    \ -> x > 0).min(Comparator.naturalOrder());\n        return Pair.with(largest,\
    \ smallest);", '        return Pair.with(lst.stream().filter(x -> x < 0).reduce((x,
    y) -> x > y ? x : y), lst.stream().filter(x -> x > 0).reduce((x, y) -> x < y ?
    x : y));', "        // Your code here\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        Optional<Long> first = Optional.empty();\n\
    \        Optional<Long> second = Optional.empty();\n        for (Long l : lst)\
    \ {\n            if (l < 0) {\n                if (!first.isPresent() || first.get()\
    \ < l)\n                    first = Optional.of(l);\n            } else if (l\
    \ > 0) {\n                if (!second.isPresent() || second.get() > l)\n     \
    \               second = Optional.of(l);\n            }\n        }\n        return\
    \ Pair.with(first, second);", '        return Pair.with(Optional.of(lst.stream().sorted().filter(n
    -> n < 0).findFirst()), Optional.of(lst.stream().sorted().filter(n -> n > 0).findFirst()));',
  "        Optional<Long> a = Optional.empty();\n        Optional<Long> b = Optional.empty();\n\
    \        long max = 0;\n        long min = 0;\n        for (long i : lst) {\n\
    \            if (i > 0) {\n                if (i < min || min == 0) {\n      \
    \              min = i;\n                }\n            } else if (i < 0) {\n\
    \                if (i > max || max == 0) {\n                    max = i;\n  \
    \              }\n            }\n        }\n        if (max != 0) {\n        \
    \    a = Optional.of(max);\n        }\n        if (min != 0) {\n            b\
    \ = Optional.of(min);\n        }\n        return Pair.with(a, b);", "        Optional<Long>\
    \ largestNegative = lst.stream().filter(l -> l < 0).max(Comparator.naturalOrder());\n\
    \        Optional<Long> smallestPositive = lst.stream().filter(l -> l > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(largestNegative, smallestPositive);", "        return\
    \ new Pair<Optional<Long>, Optional<Long>>(\n            new Pair<Optional<Long>,\
    \ Optional<Long>>(Optional.empty(), Optional.empty()).stream().map((i) -> i.filter((v)\
    \ -> v < 0)).max(Long::compare),\n            new Pair<Optional<Long>, Optional<Long>>(Optional.empty(),\
    \ Optional.empty()).stream().map((i) -> i.filter((v) -> v > 0)).min(Long::compare)\n\
    \        );", "        // YOUR CODE HERE\n        long min = 0;\n        long\
    \ max = 0;\n        for (long n : lst) {\n            if (n > 0) {\n         \
    \       if (n < min || min == 0) {\n                    min = n;\n           \
    \     }\n            } else if (n < 0) {\n                if (n > max) {\n   \
    \                 max = n;\n                }\n            }\n        }\n    \
    \    return Pair.with(Optional.of(max), Optional.of(min));", "        Optional<Long>\
    \ neg = Optional.empty();\n        Optional<Long> pos = Optional.empty();\n  \
    \      for (Long i : lst) {\n            if (i < 0) {\n                if (!neg.isPresent()\
    \ || neg.get() < i) {\n                    neg = Optional.of(i);\n           \
    \     }\n            } else if (i > 0) {\n                if (!pos.isPresent()\
    \ || pos.get() > i) {\n                    pos = Optional.of(i);\n           \
    \     }\n            }\n        }\n        return Pair.with(neg, pos);", "   \
    \     ArrayList<Long> positiveLst = new ArrayList<Long>();\n        ArrayList<Long>\
    \ negativeLst = new ArrayList<Long>();\n        for (Long a: lst) {\n        \
    \    if (a >= 0l) {\n                positiveLst.add(a);\n            } else {\n\
    \                negativeLst.add(a);\n            }\n        }\n        Optional<Long>\
    \ smallestPositive = !positiveLst.isEmpty() ? Optional.of(Collections.min(positiveLst))\
    \ : Optional.empty();\n        Optional<Long> largestNegative = !negativeLst.isEmpty()\
    \ ? Optional.of(Collections.max(negativeLst)) : Optional.empty();\n        return\
    \ Pair.with(largestNegative, smallestPositive);", "        // Write your code\
    \ here.\n        return null;", "        // Using Javatuples\n        // return\
    \ Pair.with(Optional.of(lst.stream().sorted().filter(o -> o < 0).findFirst().orElse(null)),\
    \ Optional.of(lst.stream().sorted().filter(o -> o > 0).findFirst().orElse(null)));\n\
    \        // Using Javatuples, where I check if the optional is empty and then\
    \ return null if true.\n        // return Pair.with(Optional.of(lst.stream().sorted().filter(o\
    \ -> o < 0).findFirst().orElse(null)), Optional.of(lst.stream().sorted().filter(o\
    \ -> o > 0).findFirst().orElse(null)));\n        // Using a new tuple class I\
    \ created.\n        return new Tuple<Optional<Long>, Optional<Long>>(Optional.of(lst.stream().sorted().filter(o\
    \ -> o < 0).findFirst().orElse(null)), Optional.of(lst.stream().sorted().filter(o\
    \ -> o > 0).findFirst().orElse(null)));", "        long largestNegativeNumber\
    \ = Long.MIN_VALUE;\n        long smallestPositiveNumber = Long.MAX_VALUE;\n \
    \       for (long num : lst) {\n            if (num > 0 && num < smallestPositiveNumber)\
    \ {\n                smallestPositiveNumber = num;\n            }\n          \
    \  if (num < 0 && num > largestNegativeNumber) {\n                largestNegativeNumber\
    \ = num;\n            }\n        }\n        Optional<Long> largest;\n        Optional<Long>\
    \ smallest;\n        if (largestNegativeNumber == Long.MIN_VALUE) {\n        \
    \    largest = Optional.empty();\n        } else {\n            largest = Optional.of(largestNegativeNumber);\n\
    \        }\n        if (smallestPositiveNumber == Long.MAX_VALUE) {\n        \
    \    smallest = Optional.empty();\n        } else {\n            smallest = Optional.of(smallestPositiveNumber);\n\
    \        }\n        return Pair.with(largest, smallest);", "        Optional<Long>\
    \ largestNegative = Optional.empty();\n        Optional<Long> smallestPositive\
    \ = Optional.empty();\n        for (Long item : lst) {\n            if (item <\
    \ 0) {\n                if (!largestNegative.isPresent() || largestNegative.get()\
    \ < item) {\n                    largestNegative = Optional.of(item);\n      \
    \          }\n            } else if (item > 0) {\n                if (!smallestPositive.isPresent()\
    \ || smallestPositive.get() > item) {\n                    smallestPositive =\
    \ Optional.of(item);\n                }\n            }\n        }\n        return\
    \ Pair.with(largestNegative, smallestPositive);", "        // Write your code\
    \ here\n        // To print results to the standard output you can use System.out.println()\n\
    \        // Example: System.out.println(\"Hello world!\");\n        List<Long>\
    \ l = new ArrayList<>();\n        for (Long i : lst) {\n            if (i > 0)\
    \ {\n                l.add(i);\n            }\n        }\n        Collections.sort(l);\n\
    \        Optional<Long> first = Optional.empty();\n        Optional<Long> second\
    \ = Optional.empty();\n        if (l.size() == 0) {\n            first = Optional.empty();\n\
    \            second = Optional.empty();\n        } else {\n            first =\
    \ Optional.of(l.get(0));\n            second = Optional.of(l.get(l.size() - 1));\n\
    \        }\n        Pair<Optional<Long>, Optional<Long>> result = Pair.with(first,\
    \ second);\n        return result;", "        Optional<Long> largestNegative =\
    \ Optional.empty();\n        Optional<Long> smallestPositive = Optional.empty();\n\
    \        for (Long n : lst) {\n            if (n > 0 && (smallestPositive.isEmpty()\
    \ || n < smallestPositive.get())) {\n                smallestPositive = Optional.of(n);\n\
    \            }\n            if (n < 0 && (largestNegative.isEmpty() || n > largestNegative.get()))\
    \ {\n                largestNegative = Optional.of(n);\n            }\n      \
    \  }\n        return Pair.with(largestNegative, smallestPositive);", "       \
    \ Pair<Optional<Long>, Optional<Long>> min_max_integers = new Pair<Optional<Long>,\
    \ Optional<Long>>(Optional.empty(), Optional.empty());\n        for (Long l :\
    \ lst) {\n            if (l < 0) {\n                if (min_max_integers.getValue0().isPresent())\
    \ {\n                    if (l < min_max_integers.getValue0().get()) {\n     \
    \                   min_max_integers = min_max_integers.setAt0(Optional.of(l));\n\
    \                    }\n                } else {\n                    min_max_integers\
    \ = min_max_integers.setAt0(Optional.of(l));\n                }\n            }\
    \ else if (l > 0) {\n                if (min_max_integers.getValue1().isPresent())\
    \ {\n                    if (l < min_max_integers.getValue1().get()) {\n     \
    \                   min_max_integers = min_max_integers.setAt1(Optional.of(l));\n\
    \                    }\n                } else {\n                    min_max_integers\
    \ = min_max_integers.setAt1(Optional.of(l));\n                }\n            }\n\
    \        }\n        return min_max_integers;", "        long largest = 0;\n  \
    \      long smallest = 0;\n        // Compare the first two items\n        if(lst.size()\
    \ > 1) {\n            if(lst.get(0) > lst.get(1)) {\n                largest =\
    \ lst.get(0);\n                smallest = lst.get(1);\n            } else {\n\
    \                largest = lst.get(1);\n                smallest = lst.get(0);\n\
    \            }\n        }\n        // Iterate over the rest of the list\n    \
    \    for(int i = 2; i < lst.size(); i++) {\n            if(lst.get(i) > largest)\
    \ {\n                largest = lst.get(i);\n            } else if(lst.get(i) <\
    \ smallest) {\n                smallest = lst.get(i);\n            }\n       \
    \ }\n        // If both of them are positive or negative, return them as null\n\
    \        Optional<Long> largestOpt = largest < 0 ? Optional.of(largest) : Optional.empty();\n\
    \        Optional<Long> smallestOpt = smallest > 0 ? Optional.of(smallest) : Optional.empty();\n\
    \        return Pair.with(largestOpt, smallestOpt);", "        Optional<Long>\
    \ neg = lst.stream().filter(l -> l < 0).max(Comparator.naturalOrder());\n    \
    \    Optional<Long> pos = lst.stream().filter(l -> l > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(neg, pos);", "        // Write code to find the largest\
    \ and smallest integers\n        // in an array list, and then return them as\
    \ a pair\n        return null;", "        var r = new Pair<Optional<Long>, Optional<Long>>(Optional.empty(),\
    \ Optional.empty());\n        for (Long n : lst) {\n            var p = (n > 0l)\
    \ ? Optional.of(n) : Optional.empty();\n            var nn = (n < 0l) ? Optional.of(n)\
    \ : Optional.empty();\n            if (r.getValue0().isPresent()) {\n        \
    \        r = new Pair<Optional<Long>, Optional<Long>>(r.getValue0(), p);\n   \
    \         } else {\n                r = new Pair<Optional<Long>, Optional<Long>>(nn,\
    \ r.getValue1());\n            }\n        }\n        return r;", "        Long\
    \ minPositive = null;\n        Long maxNegative = null;\n        for (Long num\
    \ : lst) {\n            if (num < 0) {\n                if (maxNegative == null\
    \ || num > maxNegative) {\n                    maxNegative = num;\n          \
    \      }\n            } else if (num > 0) {\n                if (minPositive ==\
    \ null || num < minPositive) {\n                    minPositive = num;\n     \
    \           }\n            }\n        }\n        Optional<Long> largest = maxNegative\
    \ == null ? Optional.empty() : Optional.of(maxNegative);\n        Optional<Long>\
    \ smallest = minPositive == null ? Optional.empty() : Optional.of(minPositive);\n\
    \        return Pair.with(largest, smallest);", "        return Pair.with(Optional.of(lst.stream().filter(i\
    \ -> i < 0).max(Comparator.naturalOrder())),\n                         Optional.of(lst.stream().filter(i\
    \ -> i > 0).min(Comparator.naturalOrder())));", "        // write your code here\n\
    \        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        // Implement me!\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        Optional<Long> largestNegative =\
    \ lst.stream().filter(n -> n < 0).max(Comparator.naturalOrder());\n        Optional<Long>\
    \ smallestPositive = lst.stream().filter(n -> n > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(largestNegative, smallestPositive);", "        Optional<Long>\
    \ largest = Optional.empty();\n        Optional<Long> smallest = Optional.empty();\n\
    \        for (Long l : lst) {\n            if (l > 0) {\n                if (smallest.isPresent())\
    \ {\n                    if (l < smallest.get()) {\n                        smallest\
    \ = Optional.of(l);\n                    }\n                } else {\n       \
    \             smallest = Optional.of(l);\n                }\n            } else\
    \ if (l < 0) {\n                if (largest.isPresent()) {\n                 \
    \   if (l > largest.get()) {\n                        largest = Optional.of(l);\n\
    \                    }\n                } else {\n                    largest\
    \ = Optional.of(l);\n                }\n            }\n        }\n        return\
    \ Pair.with(largest, smallest);", "        if (lst.size() == 0) {\n          \
    \  return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        return Pair.with(Optional.of(lst.stream().filter(i -> i <\
    \ 0).max(Comparator.naturalOrder())), Optional.of(lst.stream().filter(i -> i >\
    \ 0).min(Comparator.naturalOrder())));", '        return Pair.with(Optional.of(lst.stream().min(Comparator.naturalOrder()).orElse(null)),
    Optional.of(lst.stream().max(Comparator.naturalOrder()).orElse(null)));', "  \
    \      List<Long> list = lst.stream().sorted().collect(Collectors.toList());\n\
    \        if (list.size() == 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        if (list.size() == 1) {\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(list.get(0)));\n\
    \        }\n        if (list.get(0) >= 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(list.get(0)));\n        }\n        if (list.get(list.size() - 1)\
    \ <= 0) {\n            return Pair.with(Optional.of(list.get(list.size() - 1)),\
    \ Optional.of(Optional.empty()));\n        }\n        return Pair.with(Optional.of(list.get(list.size()\
    \ - 1)), Optional.of(list.get(0)));", '        return new Pair<Optional<Long>,
    Optional<Long>>();', "        if (lst.size() == 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        long min = Long.MAX_VALUE;\n\
    \        long max = Long.MIN_VALUE;\n        boolean hasPositive = false;\n  \
    \      boolean hasNegative = false;\n        for (long number : lst) {\n     \
    \       if (number > 0) {\n                hasPositive = true;\n             \
    \   if (number < min) {\n                    min = number;\n                }\n\
    \            } else if (number < 0) {\n                hasNegative = true;\n \
    \               if (number > max) {\n                    max = number;\n     \
    \           }\n            }\n        }\n        return Pair.with(hasNegative\
    \ ? Optional.of(max) : Optional.of(Optional.empty()), hasPositive ? Optional.of(min)\
    \ : Optional.of(Optional.empty()));", "        return new Pair<Optional<Long>,\
    \ Optional<Long>>(\n                Optional.of(lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder())),\n\
    \                Optional.of(lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder()))\n\
    \        );", "        Long negs = lst.stream().filter(x -> x < 0).max(Long::compare).orElse(null);\n\
    \        Long poss = lst.stream().filter(x -> x > 0).min(Long::compare).orElse(null);\n\
    \        return Pair.with(Optional.ofNullable(negs), Optional.ofNullable(poss));",
  '        // Your code here.', "      if (lst.size() > 0) {\n        Optional<Long>\
    \ max = Optional.of(Collections.max(lst));\n        Optional<Long> min = Optional.of(Collections.min(lst));\n\
    \        return Pair.with(max, min);\n      } else {\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n      }", "        return Pair.with(\n    \
    \        Optional.of(\n                lst.stream()\n                .filter(x\
    \ -> x < 0)\n                .max(Comparator.naturalOrder())\n            ),\n\
    \            Optional.of(\n                lst.stream()\n                .filter(x\
    \ -> x > 0)\n                .min(Comparator.naturalOrder())\n            )\n\
    \        );", '        throw new UnsupportedOperationException("Not supported
    yet.");', "        Optional<Long> o1 = Optional.empty();\n        Optional<Long>\
    \ o2 = Optional.empty();\n        Long max = (long) -2147483648;\n        Long\
    \ min = (long) 2147483647;\n        for (Long l : lst) {\n            if (l <\
    \ 0 && l > max) {\n                max = l;\n            }\n            if (l\
    \ > 0 && l < min) {\n                min = l;\n            }\n        }\n    \
    \    if (max > (long) -2147483648) {\n            o1 = Optional.of(max);\n   \
    \     }\n        if (min < (long) 2147483647) {\n            o2 = Optional.of(min);\n\
    \        }\n        return Pair.with(o1, o2);", "        // Replace this with\
    \ your code\n        if (lst.size() == 0)\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        Long a = Long.MIN_VALUE;\n        Long\
    \ b = Long.MAX_VALUE;\n        for (Long i : lst) {\n            if (i < 0 &&\
    \ i > a) {\n                a = i;\n            }\n            if (i > 0 && i\
    \ < b) {\n                b = i;\n            }\n        }\n        return Pair.with(Optional.of(a),\
    \ Optional.of(b));", "        Optional<Long> a = Optional.empty();\n        Optional<Long>\
    \ b = Optional.empty();\n        for (Long l : lst) {\n            if (l > 0 &&\
    \ !b.isPresent()) {\n                b = Optional.of(l);\n            } else if\
    \ (l > 0 && b.isPresent()) {\n                b = Optional.of(Math.min(b.get(),\
    \ l));\n            } else if (l < 0 && !a.isPresent()) {\n                a =\
    \ Optional.of(l);\n            } else if (l < 0 && a.isPresent()) {\n        \
    \        a = Optional.of(Math.max(a.get(), l));\n            }\n        }\n  \
    \      return Pair.with(a, b);", "        Optional<Long> largestNegative = lst.stream().filter(x\
    \ -> x < 0).max(Long::compare);\n        Optional<Long> smallestPositive = lst.stream().filter(x\
    \ -> x > 0).min(Long::compare);\n        return Pair.with(largestNegative, smallestPositive);",
  "        long largestNegative = 0, smallestPositive = 0;\n        Optional<Long>\
    \ largestNegativeOpt = Optional.empty();\n        Optional<Long> smallestPositiveOpt\
    \ = Optional.empty();\n        for (long e : lst) {\n            if (e < 0) {\n\
    \                if (e > largestNegative) {\n                    largestNegative\
    \ = e;\n                    largestNegativeOpt = Optional.of(e);\n           \
    \     }\n            } else if (e > 0) {\n                if (smallestPositiveOpt.isEmpty()\
    \ || e < smallestPositive) {\n                    smallestPositive = e;\n    \
    \                smallestPositiveOpt = Optional.of(e);\n                }\n  \
    \          }\n        }\n        return Pair.with(largestNegativeOpt, smallestPositiveOpt);",
  "        // BEGIN solution\n        Long largest = null;\n        Long smallest\
    \ = null;\n        for (Long l : lst) {\n            if (l < 0) {\n          \
    \      if (largest == null || l > largest) {\n                    largest = l;\n\
    \                }\n            } else if (l > 0) {\n                if (smallest\
    \ == null || l < smallest) {\n                    smallest = l;\n            \
    \    }\n            }\n        }\n        return Pair.with(Optional.ofNullable(largest),\
    \ Optional.ofNullable(smallest));\n        // END solution", "        Pair<Optional<Long>,\
    \ Optional<Long>> result = null;\n        // YOUR CODE HERE\n        return result;",
  "        // # your code\n        Long maxNegative = null;\n        Long minPositive\
    \ = null;\n        for (Long elem : lst) {\n            if (elem < 0 && (maxNegative\
    \ == null || elem > maxNegative)) {\n                maxNegative = elem;\n   \
    \         }\n            if (elem > 0 && (minPositive == null || elem < minPositive))\
    \ {\n                minPositive = elem;\n            }\n        }\n        Optional<Long>\
    \ oMaxNegative = Optional.ofNullable(maxNegative);\n        Optional<Long> oMinPositive\
    \ = Optional.ofNullable(minPositive);\n        return Pair.with(oMaxNegative,\
    \ oMinPositive);", "        Optional<Long> largest = Optional.empty();\n     \
    \   Optional<Long> smallest = Optional.empty();\n        for (Long i : lst) {\n\
    \            if (i < 0) {\n                if (!largest.isPresent() || i > largest.get())\
    \ {\n                    largest = Optional.of(i);\n                }\n      \
    \      } else if (i > 0) {\n                if (!smallest.isPresent() || i < smallest.get())\
    \ {\n                    smallest = Optional.of(i);\n                }\n     \
    \       }\n        }\n        return Pair.with(largest, smallest);", "       \
    \ Optional<Long> maxNegative = lst.stream().filter(v -> v < 0).max(Long::compare);\n\
    \        Optional<Long> minPositive = lst.stream().filter(v -> v > 0).min(Long::compare);\n\
    \        return Pair.with(maxNegative, minPositive);", "        return Pair.with(\n\
    \            Optional.of(lst.stream().filter(n -> n < 0l).max(Comparator.naturalOrder())),\n\
    \            Optional.of(lst.stream().filter(n -> n > 0l).min(Comparator.naturalOrder()))\n\
    \        );", "        // Get the minimum and maximum value of the array list,\n\
    \        // and return it as a pair.\n        return null;", "        // your\
    \ code here\n        Long min_pos = Long.MAX_VALUE;\n        Long max_neg = Long.MIN_VALUE;\n\
    \        for (Long i : lst) {\n            if (i < 0 && i > max_neg) {\n     \
    \           max_neg = i;\n            }\n            if (i > 0 && i < min_pos)\
    \ {\n                min_pos = i;\n            }\n        }\n        return Pair.with(Optional.ofNullable(max_neg),\
    \ Optional.ofNullable(min_pos));", '        return new Pair<Optional<Long>, Optional<Long>>(null,
    null);', "        Optional<Long> minPos = Optional.empty();\n        Optional<Long>\
    \ maxNeg = Optional.empty();\n        for (Long e : lst) {\n            if (e\
    \ > 0) {\n                if (minPos.isPresent()) {\n                    if (e\
    \ < minPos.get()) {\n                        minPos = Optional.of(e);\n      \
    \              }\n                } else {\n                    minPos = Optional.of(e);\n\
    \                }\n            } else if (e < 0) {\n                if (maxNeg.isPresent())\
    \ {\n                    if (e > maxNeg.get()) {\n                        maxNeg\
    \ = Optional.of(e);\n                    }\n                } else {\n       \
    \             maxNeg = Optional.of(e);\n                }\n            }\n   \
    \     }\n        return Pair.with(maxNeg, minPos);", "        Optional<Long> largestOfNegatives\
    \ = Optional.empty();\n        Optional<Long> smallestOfPositives = Optional.empty();\n\
    \        if (lst.size() != 0) {\n            ArrayList<Long> positives = new ArrayList<Long>();\n\
    \            ArrayList<Long> negatives = new ArrayList<Long>();\n            for\
    \ (Long l : lst) {\n                if (l > 0) {\n                    positives.add(l);\n\
    \                } else if (l < 0) {\n                    negatives.add(l);\n\
    \                }\n            }\n            if (positives.size() != 0) {\n\
    \                smallestOfPositives = Optional.of(positives.stream().min(Comparator.naturalOrder()).get());\n\
    \            }\n            if (negatives.size() != 0) {\n                largestOfNegatives\
    \ = Optional.of(negatives.stream().max(Comparator.naturalOrder()).get());\n  \
    \          }\n        }\n        return Pair.with(largestOfNegatives, smallestOfPositives);",
  '        return null;', "        if (lst.size() == 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        long smallest = Long.MAX_VALUE;\n\
    \        long largest = Long.MIN_VALUE;\n        for (long num : lst) {\n    \
    \        if (num < 0) {\n                largest = Math.max(largest, num);\n \
    \           } else if (num > 0) {\n                smallest = Math.min(smallest,\
    \ num);\n            }\n        }\n        if (largest == Long.MIN_VALUE) {\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(smallest));\n\
    \        } else if (smallest == Long.MAX_VALUE) {\n            return Pair.with(Optional.of(largest),\
    \ Optional.of(Optional.empty()));\n        } else {\n            return Pair.with(Optional.of(largest),\
    \ Optional.of(smallest));\n        }", "        if (lst.isEmpty()) return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        long min = Long.MAX_VALUE;\n      \
    \  long max = Long.MIN_VALUE;\n        for (long el: lst) {\n            if (el\
    \ > 0 && el < min) min = el;\n            if (el < 0 && el > max) max = el;\n\
    \        }\n        if (min == Long.MAX_VALUE) return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        if (max == Long.MIN_VALUE) return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(min));\n        return Pair.with(Optional.of(max), Optional.of(min));",
  '        throw new UnsupportedOperationException("implement me!");', '        return
    null;', "        Optional<Long> largestNegativeInteger =\n            lst.stream()\n\
    \                .filter(x -> x < 0)\n                .max(Long::compare);\n \
    \       Optional<Long> smallestPositiveInteger =\n            lst.stream()\n \
    \               .filter(x -> x > 0)\n                .min(Long::compare);\n  \
    \      return Pair.with(largestNegativeInteger, smallestPositiveInteger);", " \
    \       if (lst.isEmpty()) return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        Long smallestPositive = lst.stream().filter(i -> i > 0).sorted().findFirst().orElse(null);\n\
    \        Long largestNegative = lst.stream().filter(i -> i < 0).sorted(Comparator.reverseOrder()).findFirst().orElse(null);\n\
    \        return Pair.with(Optional.of(largestNegative), Optional.of(smallestPositive));",
  "        Optional<Long> smallestPositiveInteger = Optional.empty();\n        Optional<Long>\
    \ largestNegativeInteger = Optional.empty();\n        for (Long i : lst) {\n \
    \           if (i > 0 && (smallestPositiveInteger.isEmpty() || i < smallestPositiveInteger.get()))\
    \ {\n                smallestPositiveInteger = Optional.of(i);\n            }\n\
    \            if (i < 0 && (largestNegativeInteger.isEmpty() || i > largestNegativeInteger.get()))\
    \ {\n                largestNegativeInteger = Optional.of(i);\n            }\n\
    \        }\n        return Pair.with(largestNegativeInteger, smallestPositiveInteger);",
  "        // return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        // return Pair.with(Optional.of(1l), Optional.of(2l));\n        // return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(2l));\n        // return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n \
    \       long largestOfNegativeIntegers = Long.MIN_VALUE;\n        long smallestOfPositiveIntegers\
    \ = Long.MAX_VALUE;\n        for (long x : lst) {\n            if (x < 0) {\n\
    \                largestOfNegativeIntegers = Math.max(largestOfNegativeIntegers,\
    \ x);\n            } else if (x > 0) {\n                smallestOfPositiveIntegers\
    \ = Math.min(smallestOfPositiveIntegers, x);\n            }\n        }\n     \
    \   if (largestOfNegativeIntegers == Long.MIN_VALUE) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(smallestOfPositiveIntegers));\n        } else if (smallestOfPositiveIntegers\
    \ == Long.MAX_VALUE) {\n            return Pair.with(Optional.of(largestOfNegativeIntegers),\
    \ Optional.of(Optional.empty()));\n        } else {\n            return Pair.with(Optional.of(largestOfNegativeIntegers),\
    \ Optional.of(smallestOfPositiveIntegers));\n        }", "        Optional<Long>\
    \ largest = Optional.empty();\n        Optional<Long> smallest = Optional.empty();\n\
    \        for (Long i : lst) {\n            if (i >= 0) {\n                if (smallest.isPresent())\
    \ {\n                    if (i < smallest.get()) {\n                        smallest\
    \ = Optional.of(i);\n                    }\n                } else {\n       \
    \             smallest = Optional.of(i);\n                }\n            } else\
    \ {\n                if (largest.isPresent()) {\n                    if (i > largest.get())\
    \ {\n                        largest = Optional.of(i);\n                    }\n\
    \                } else {\n                    largest = Optional.of(i);\n   \
    \             }\n            }\n        }\n        return Pair.with(largest, smallest);",
  "        // Your code goes here\n        throw new UnsupportedOperationException(\"\
    Method 'largestSmallestIntegers' has not been implemented\");", "        Pair<Optional<Long>,\
    \ Optional<Long>> pair = null;\n        if (lst.size() != 0) {\n            long\
    \ largest = 0;\n            long smallest = 0;\n            boolean hasOneFound\
    \ = false;\n            for (int i = 0; i < lst.size(); i++) {\n             \
    \   if (lst.get(i) < 0) {\n                    if (!hasOneFound) {\n         \
    \               largest = lst.get(i);\n                        hasOneFound = true;\n\
    \                    } else {\n                        if (lst.get(i) > largest)\
    \ {\n                            largest = lst.get(i);\n                     \
    \   }\n                    }\n                } else if (lst.get(i) > 0) {\n \
    \                   if (!hasOneFound) {\n                        smallest = lst.get(i);\n\
    \                        hasOneFound = true;\n                    } else {\n \
    \                       if (lst.get(i) < smallest) {\n                       \
    \     smallest = lst.get(i);\n                        }\n                    }\n\
    \                }\n            }\n            if (hasOneFound) {\n          \
    \      pair = Pair.with(Optional.of(largest), Optional.of(smallest));\n      \
    \      } else {\n                pair = Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n            }\n        } else {\n         \
    \   pair = Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        return pair;", "        // Placeholder, replace with your\
    \ code.\n        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        // Your code here\n        Optional<Long> largestNegativeInteger = lst.stream().filter(n\
    \ -> n < 0).max(Comparator.naturalOrder());\n        Optional<Long> smallestPositiveInteger\
    \ = lst.stream().filter(n -> n > 0).min(Comparator.naturalOrder());\n        return\
    \ Pair.with(largestNegativeInteger, smallestPositiveInteger);", "        long\
    \ maxNeg = 0;\n        long minPos = 0;\n        long maxNegFlag = 0;\n      \
    \  long minPosFlag = 0;\n        for (long x : lst) {\n            if (x >= 0)\
    \ {\n                if (minPosFlag == 0) {\n                    minPos = x;\n\
    \                    minPosFlag = 1;\n                } else if (x < minPos) {\n\
    \                    minPos = x;\n                }\n            } else {\n  \
    \              if (maxNegFlag == 0) {\n                    maxNeg = x;\n     \
    \               maxNegFlag = 1;\n                } else if (x > maxNeg) {\n  \
    \                  maxNeg = x;\n                }\n            }\n        }\n\
    \        if (maxNegFlag == 0) {\n            return Pair.with(Optional.empty(),\
    \ Optional.of(minPos));\n        } else if (minPosFlag == 0) {\n            return\
    \ Pair.with(Optional.of(maxNeg), Optional.empty());\n        } else {\n      \
    \      return Pair.with(Optional.of(maxNeg), Optional.of(minPos));\n        }",
  "        // Your code here.\n        ArrayList<Long> negativeList = new ArrayList<Long>();\n\
    \        ArrayList<Long> positiveList = new ArrayList<Long>();\n        for (int\
    \ i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n         \
    \       negativeList.add(lst.get(i));\n            } else if (lst.get(i) > 0)\
    \ {\n                positiveList.add(lst.get(i));\n            }\n        }\n\
    \        Optional<Long> pos = Optional.empty();\n        Optional<Long> neg =\
    \ Optional.empty();\n        if (positiveList.size() > 0) {\n            pos =\
    \ Optional.of(Collections.min(positiveList));\n        }\n        if (negativeList.size()\
    \ > 0) {\n            neg = Optional.of(Collections.max(negativeList));\n    \
    \    }\n        return Pair.with(neg, pos);", '        return Pair.with(Optional.of(lst.stream().filter(x
    -> x < 0).max(Comparator.naturalOrder())), Optional.of(lst.stream().filter(x ->
    x > 0).min(Comparator.naturalOrder())));', "        // >>> your code goes here\
    \ <<<\n        return null;", '        return null;', "        // Your code here\n\
    \        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        Long largest = Optional.empty();\n        Long smallest = Optional.empty();\n\
    \        for (Long item : lst) {\n            if (item < 0 && (largest == null\
    \ || item > largest)) {\n                largest = item;\n            }\n    \
    \        if (item > 0 && (smallest == null || item < smallest)) {\n          \
    \      smallest = item;\n            }\n        }\n        return Pair.with(Optional.ofNullable(largest),\
    \ Optional.ofNullable(smallest));", '        return null;', "        Optional<Long>\
    \ largestNegative = Optional.empty();\n        Optional<Long> smallestPositive\
    \ = Optional.empty();\n        for (long n : lst) {\n            if (n < 0) {\n\
    \                if (!largestNegative.isPresent() || largestNegative.get() < n)\
    \ {\n                    largestNegative = Optional.of(n);\n                }\n\
    \            } else if (n > 0) {\n                if (!smallestPositive.isPresent()\
    \ || smallestPositive.get() > n) {\n                    smallestPositive = Optional.of(n);\n\
    \                }\n            }\n        }\n        return Pair.with(largestNegative,\
    \ smallestPositive);", "        Optional<Long> largest = lst.stream().max(Comparator.comparing(e->Math.abs(e))).filter(e->e<0).map(e->(Long)e);\n\
    \        Optional<Long> smallest = lst.stream().min(Comparator.comparing(e->Math.abs(e))).filter(e->e>0).map(e->(Long)e);\n\
    \        return Pair.with(largest, smallest);", '        return new Pair<Optional<Long>,
    Optional<Long>>(Optional.of(Optional.empty()), Optional.of(Optional.empty()));',
  "        //Write your code here...\n        long maxNeg = Long.MIN_VALUE;\n    \
    \    long minPos = Long.MAX_VALUE;\n        for (long l : lst) {\n           \
    \ if (l > 0 && l < minPos) {\n                minPos = l;\n            }\n   \
    \         if (l < 0 && l > maxNeg) {\n                maxNeg = l;\n          \
    \  }\n        }\n        Optional<Long> oNeg = Optional.empty();\n        Optional<Long>\
    \ oPos = Optional.empty();\n        if (maxNeg != Long.MIN_VALUE) {\n        \
    \    oNeg = Optional.of(maxNeg);\n        }\n        if (minPos != Long.MAX_VALUE)\
    \ {\n            oPos = Optional.of(minPos);\n        }\n        return Pair.with(oNeg,\
    \ oPos);", "        long larg = 0;\n        long small = 0;\n        boolean large\
    \ = false;\n        boolean smalls = false;\n        for (int i = 0; i < lst.size();\
    \ i++) {\n            if (lst.get(i) > 0) {\n                small = lst.get(i);\n\
    \                smalls = true;\n                break;\n            }\n     \
    \   }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i)\
    \ < 0) {\n                larg = lst.get(i);\n                large = true;\n\
    \                break;\n            }\n        }\n        for (int i = 0; i <\
    \ lst.size(); i++) {\n            if (lst.get(i) > small && lst.get(i) > 0) {\n\
    \                small = lst.get(i);\n            }\n        }\n        for (int\
    \ i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < larg && lst.get(i)\
    \ < 0) {\n                larg = lst.get(i);\n            }\n        }\n     \
    \   if (smalls == false) {\n            small = 0;\n        }\n        if (large\
    \ == false) {\n            larg = 0;\n        }\n        return Pair.with(Optional.of(larg),\
    \ Optional.of(small));", "        Optional<Long> a = Optional.empty();\n     \
    \   Optional<Long> b = Optional.empty();\n        // code goes here.\n       \
    \ return Pair.with(a, b);", '        return null;', "        // Write your code\
    \ here\n        // To print results to the standard output you can use System.out.println()\n\
    \        // Example: System.out.println(\"Hello world!\");\n        long min =\
    \ 0;\n        long max = 0;\n        int flag = 0;\n        boolean first = true;\n\
    \        for (long i : lst) {\n            if (i > 0) {\n                if (first)\
    \ {\n                    min = i;\n                    first = false;\n      \
    \          }\n                else\n                    min = Math.min(min, i);\n\
    \            }\n            else if (i < 0) {\n                if (first) {\n\
    \                    max = i;\n                    first = false;\n          \
    \      }\n                else\n                    max = Math.max(max, i);\n\
    \            }\n        }\n        return Pair.with(Optional.of(max), Optional.of(min));",
  "        Optional<Long> maxNegative = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
    \        Optional<Long> minPositive = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(maxNegative, minPositive);", "        Optional<Long>\
    \ neg = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n    \
    \    Optional<Long> pos = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(neg, pos);", '        return Pair.with(lst.stream().filter(l
    -> l < 0).max(Comparator.naturalOrder()), lst.stream().filter(l -> l > 0).min(Comparator.naturalOrder()));',
  "        // Fill in the implementation of this function so that it passes the tests.\n\
    \        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  '        return Pair.with(lst.stream().filter(l -> l < 0l).reduce((a, b) -> b),
    lst.stream().filter(l -> l > 0l).reduce((a, b) -> a));', "        //We need to\
    \ first find the smallest and largest values.\n        Optional<Long> max = lst.stream().max(Comparator.naturalOrder());\n\
    \        Optional<Long> min = lst.stream().min(Comparator.naturalOrder());\n \
    \       // Now we need to find the first negative value less than the max and\
    \ the first\n        // positive value greater than the min.\n        Optional<Long>\
    \ smallestPositive = lst.stream().filter(i -> i >= 0 && i < min.get()).findFirst();\n\
    \        Optional<Long> largestNegative = lst.stream().filter(i -> i < 0 && i\
    \ > max.get()).findFirst();\n        return Pair.with(largestNegative, smallestPositive);",
  "        // Write your code here\n        Optional<Long> largest = Optional.empty();\n\
    \        Optional<Long> smallest = Optional.empty();\n        for (Long l : lst)\
    \ {\n            if (l > 0 && (!smallest.isPresent() || l < smallest.get())) {\n\
    \                smallest = Optional.of(l);\n            }\n            if (l\
    \ < 0 && (!largest.isPresent() || l > largest.get())) {\n                largest\
    \ = Optional.of(l);\n            }\n        }\n        return Pair.with(largest,\
    \ smallest);", "        Optional<Long> largest = lst.stream().filter(x -> x <\
    \ 0).max(Comparator.naturalOrder());\n        Optional<Long> smallest = lst.stream().filter(x\
    \ -> x > 0).min(Comparator.naturalOrder());\n        return Pair.with(largest,\
    \ smallest);", "        Optional<Long> max = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n\
    \        Optional<Long> min = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(max, min);", "        Optional<Long> negative = Optional.empty();\n\
    \        Optional<Long> positive = Optional.empty();\n        for (Long i : lst)\
    \ {\n            if (i > 0 && (positive.isEmpty() || i < positive.get()))\n  \
    \              positive = Optional.of(i);\n            if (i < 0 && (negative.isEmpty()\
    \ || i > negative.get()))\n                negative = Optional.of(i);\n      \
    \  }\n        return Pair.with(negative, positive);", "        Optional<Long>\
    \ max = lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder());\n    \
    \    Optional<Long> min = lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder());\n\
    \        return Pair.with(max, min);", "      Optional<Long> largestNegativeInteger\
    \ = Optional.empty();\n      Optional<Long> smallestPositiveInteger = Optional.empty();\n\
    \      for (int i = 0; i < lst.size(); i++) {\n        Long currentItem = lst.get(i);\n\
    \        // Check if it is the largest negative integer.\n        if (currentItem\
    \ < 0) {\n          if (largestNegativeInteger.isPresent()) {\n            if\
    \ (currentItem > largestNegativeInteger.get()) {\n              largestNegativeInteger\
    \ = Optional.of(currentItem);\n            }\n          } else {\n           \
    \ largestNegativeInteger = Optional.of(currentItem);\n          }\n        }\n\
    \        // Check if it is the smallest positive integer.\n        if (currentItem\
    \ > 0) {\n          if (smallestPositiveInteger.isPresent()) {\n            if\
    \ (currentItem < smallestPositiveInteger.get()) {\n              smallestPositiveInteger\
    \ = Optional.of(currentItem);\n            }\n          } else {\n           \
    \ smallestPositiveInteger = Optional.of(currentItem);\n          }\n        }\n\
    \      }\n      return Pair.with(largestNegativeInteger, smallestPositiveInteger);",
  "        Optional<Long> a = Optional.empty();\n        Optional<Long> b = Optional.empty();\n\
    \        for (Long x : lst) {\n            if (x > 0) {\n                if (b.isPresent())\
    \ {\n                    if (x < b.get()) {\n                        b = Optional.of(x);\n\
    \                    }\n                } else {\n                    b = Optional.of(x);\n\
    \                }\n            } else if (x < 0) {\n                if (a.isPresent())\
    \ {\n                    if (x > a.get()) {\n                        a = Optional.of(x);\n\
    \                    }\n                } else {\n                    a = Optional.of(x);\n\
    \                }\n            }\n        }\n        return Pair.with(a, b);",
  '        return null;', "        Long max = lst.stream().filter(n -> n < 0).max(Comparator.naturalOrder()).orElse(null);\n\
    \        Long min = lst.stream().filter(n -> n > 0).min(Comparator.naturalOrder()).orElse(null);\n\
    \        Optional<Long> a = Optional.ofNullable(max);\n        Optional<Long>\
    \ b = Optional.ofNullable(min);\n        return Pair.with(a, b);", "        Optional<Long>\
    \ a = Optional.empty();\n        Optional<Long> b = Optional.empty();\n      \
    \  ArrayList<Long> negs = new ArrayList<Long>();\n        ArrayList<Long> poss\
    \ = new ArrayList<Long>();\n        for (Long l : lst) {\n            if (l <\
    \ 0) {\n                negs.add(l);\n            } else if (l > 0) {\n      \
    \          poss.add(l);\n            }\n        }\n        if (negs.size() > 0)\
    \ {\n            a = Optional.of(negs.stream().max(Comparator.naturalOrder()).get());\n\
    \        }\n        if (poss.size() > 0) {\n            b = Optional.of(poss.stream().min(Comparator.naturalOrder()).get());\n\
    \        }\n        return Pair.with(a, b);", '        throw new UnsupportedOperationException("Solution
    not yet implemented");', '        // Your code here!', "        if (lst.isEmpty())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        return Pair.with(Optional.of(lst.stream().min(Comparator.naturalOrder()).get()),\
    \ Optional.of(lst.stream().max(Comparator.naturalOrder()).get()));", "       \
    \ return Pair.with(Optional.of(lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder())),\n\
    \                         Optional.of(lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder())));",
  "        return Pair.with(\n            Optional.of(\n                lst.stream()\n\
    \                .filter(i -> i < 0)\n                .max(Comparator.naturalOrder())\n\
    \            ),\n            Optional.of(\n                lst.stream()\n    \
    \            .filter(i -> i > 0)\n                .min(Comparator.naturalOrder())\n\
    \            )\n        );", '      return Pair.with(Optional.of(Optional.empty()),
    Optional.of(Optional.empty()));', "        if (lst.size() == 0) {\n          \
    \  return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        if (lst.size() == 1) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        long maxNegative = Long.MIN_VALUE;\n\
    \        long minPositive = Long.MAX_VALUE;\n        for (long i : lst) {\n  \
    \          if (i < 0) {\n                if (i > maxNegative) {\n            \
    \        maxNegative = i;\n                }\n            }\n            if (i\
    \ > 0) {\n                if (i < minPositive) {\n                    minPositive\
    \ = i;\n                }\n            }\n        }\n        if (maxNegative ==\
    \ Long.MIN_VALUE) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(minPositive));\n        }\n        if (minPositive == Long.MAX_VALUE)\
    \ {\n            return Pair.with(Optional.of(maxNegative), Optional.of(Optional.empty()));\n\
    \        }\n        return Pair.with(Optional.of(maxNegative), Optional.of(minPositive));",
  "        long largestNegativeInteger = lst.stream().filter(x -> x < 0).sorted().findFirst().orElse((long)0);\n\
    \        long smallestPositiveInteger = lst.stream().filter(x -> x > 0).sorted().findFirst().orElse((long)0);\n\
    \        return Pair.with(Optional.of(largestNegativeInteger), Optional.of(smallestPositiveInteger));",
  "        return lst.stream().reduce(new ArrayList<Long>(), (o, e) -> {\n       \
    \     if (e < 0) {\n                o.add(e);\n            }\n            return\
    \ o;\n        }, (o1, o2) -> {\n            o1.addAll(o2);\n            return\
    \ o1;\n        }).stream().max(Comparator.comparing(Math::abs)).map(i -> Pair.with(Optional.of(i),\
    \ lst.stream().filter(i1 -> i1 > 0).min(Comparator.comparing(Math::abs)))).orElse(Pair.with(Optional.of(Optional.empty()),\
    \ lst.stream().filter(i -> i > 0).min(Comparator.comparing(Math::abs))));", '        //
    Your code here', "        long largest = 0;\n        long smallest = 0;\n    \
    \    boolean smallestPositive = false;\n        boolean largestNegative = false;\n\
    \        for (Long num : lst) {\n            if (num < 0) {\n                largestNegative\
    \ = true;\n                if (num > largest) {\n                    largest =\
    \ num;\n                }\n            } else if (num > 0) {\n               \
    \ smallestPositive = true;\n                if (smallest == 0) {\n           \
    \         smallest = num;\n                } else if (num < smallest) {\n    \
    \                smallest = num;\n                }\n            }\n        }\n\
    \        Optional<Long> largestOpt = Optional.empty();\n        Optional<Long>\
    \ smallestOpt = Optional.empty();\n        if (largestNegative) {\n          \
    \  largestOpt = Optional.of(largest);\n        }\n        if (smallestPositive)\
    \ {\n            smallestOpt = Optional.of(smallest);\n        }\n        return\
    \ Pair.with(largestOpt, smallestOpt);", "        return Pair.with(\n         \
    \   Optional.of(lst.stream().filter(x -> x < 0).max(Comparator.naturalOrder())),\n\
    \            Optional.of(lst.stream().filter(x -> x > 0).min(Comparator.naturalOrder()))\n\
    \        );", "        Optional<Long> largestNegative = lst.stream().filter(x\
    \ -> x < 0l).max(Comparator.naturalOrder());\n        Optional<Long> smallestPositive\
    \ = lst.stream().filter(x -> x > 0l).min(Comparator.naturalOrder());\n       \
    \ return Pair.with(largestNegative, smallestPositive);", "        if (lst.size()\
    \ == 0)\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        Long negativeMaximum = (long)-2e9;\n        Long positiveMinimum = (long)2e9;\n\
    \        for (Long i : lst) {\n            if (i < 0)\n                negativeMaximum\
    \ = Math.max(negativeMaximum, i);\n            if (i > 0)\n                positiveMinimum\
    \ = Math.min(positiveMinimum, i);\n        }\n        if (negativeMaximum == (long)-2e9)\n\
    \            negativeMaximum = null;\n        if (positiveMinimum == (long)2e9)\n\
    \            positiveMinimum = null;\n        return Pair.with(Optional.of(negativeMaximum),\
    \ Optional.of(positiveMinimum));", "        Optional<Long> smallest = Optional.empty();\n\
    \        Optional<Long> largest = Optional.empty();\n        for (Long l : lst)\
    \ {\n            smallest = smallest.isPresent() && smallest.get() < l || l >\
    \ 0 ? smallest : Optional.of(l);\n            largest = largest.isPresent() &&\
    \ largest.get() > l || l < 0 ? largest : Optional.of(l);\n        }\n        return\
    \ Pair.with(largest, smallest);", '        return null;', '        // your code
    here', '        return Pair.with(lst.stream().filter(x -> x.longValue() < 0l).reduce((x,
    y) -> Math.max(x.longValue(), y.longValue())), lst.stream().filter(x -> x.longValue()
    > 0l).reduce((x, y) -> Math.min(x.longValue(), y.longValue())));', "        if\
    \ (lst.size() == 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        long min = Long.MAX_VALUE;\n\
    \        long max = Long.MIN_VALUE;\n        for (long el : lst) {\n         \
    \   if (el < 0) {\n                if (el > max) {\n                    max =\
    \ el;\n                }\n            } else {\n                if (el < min)\
    \ {\n                    min = el;\n                }\n            }\n       \
    \ }\n        Optional<Long> a = Optional.empty();\n        Optional<Long> b =\
    \ Optional.empty();\n        if (max != Long.MIN_VALUE) {\n            a = Optional.of(max);\n\
    \        }\n        if (min != Long.MAX_VALUE) {\n            b = Optional.of(min);\n\
    \        }\n        return Pair.with(a, b);", '        return null;', '        throw
    new UnsupportedOperationException("Not implemented yet");', '        // Your Code
    Here...', "        // Your code here.\n        return null;", "        Optional<Long>\
    \ largestNegative = lst.stream().filter(e -> e < 0).max(Long::compare);\n    \
    \    Optional<Long> smallestPositive = lst.stream().filter(e -> e > 0).min(Long::compare);\n\
    \        return Pair.with(largestNegative, smallestPositive);", "        long\
    \ largestNegative = 0;\n        long smallestPositive = 0;\n        for (Long\
    \ x : lst) {\n            if (x < 0) {\n                if (x > largestNegative)\
    \ {\n                    largestNegative = x;\n                }\n           \
    \ } else if (x > 0) {\n                if (smallestPositive == 0) {\n        \
    \            smallestPositive = x;\n                } else if (x < smallestPositive)\
    \ {\n                    smallestPositive = x;\n                }\n          \
    \  }\n        }\n        if (largestNegative == 0) {\n            return Pair.with(Optional.empty(),\
    \ Optional.of(smallestPositive));\n        } else if (smallestPositive == 0) {\n\
    \            return Pair.with(Optional.of(largestNegative), Optional.empty());\n\
    \        } else {\n            return Pair.with(Optional.of(largestNegative),\
    \ Optional.of(smallestPositive));\n        }", "        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        return Pair.with(a, b);",
  "        Optional<Long> largestNegative = Optional.empty();\n        Optional<Long>\
    \ smallestPositive = Optional.empty();\n        for (Long i : lst) {\n       \
    \     if (i < 0) {\n                if (!largestNegative.isPresent() || largestNegative.get()\
    \ < i) {\n                    largestNegative = Optional.of(i);\n            \
    \    }\n            } else if (i > 0) {\n                if (!smallestPositive.isPresent()\
    \ || smallestPositive.get() > i) {\n                    smallestPositive = Optional.of(i);\n\
    \                }\n            }\n        }\n        return Pair.with(largestNegative,\
    \ smallestPositive);", '        throw new UnsupportedOperationException("Not implemented");',
  "        // Write your code here...\n        return null;", "        // iterate\
    \ through the list and get the largest and smallest\n        // values.\n    \
    \    Optional<Long> largest = Optional.empty();\n        Optional<Long> smallest\
    \ = Optional.empty();\n        for (Long x : lst) {\n            if (largest.isPresent())\
    \ {\n                if (x > largest.get()) {\n                    largest = Optional.of(x);\n\
    \                }\n            } else {\n                largest = Optional.of(x);\n\
    \            }\n            if (smallest.isPresent()) {\n                if (x\
    \ < smallest.get()) {\n                    smallest = Optional.of(x);\n      \
    \          }\n            } else {\n                smallest = Optional.of(x);\n\
    \            }\n        }\n        if (largest.isPresent() && smallest.isPresent())\
    \ {\n            if (largest.get() < 0 && smallest.get() > 0) {\n            \
    \    return Pair.with(largest, smallest);\n            } else {\n            \
    \    return Pair.with(Optional.empty(), Optional.empty());\n            }\n  \
    \      } else {\n            return Pair.with(Optional.empty(), Optional.empty());\n\
    \        }", "        if (lst.size() == 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        Optional<Long> max = lst.stream().reduce(Math::max);\n\
    \        Optional<Long> min = lst.stream().reduce(Math::min);\n        if (max.get()\
    \ < 0 || min.get() > 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        return Pair.with(Optional.of(max.get()),\
    \ Optional.of(min.get()));", "      Optional<Long> max_negative = lst.stream().filter(i\
    \ -> i < 0).max(Long::compare);\n      Optional<Long> min_positive = lst.stream().filter(i\
    \ -> i > 0).min(Long::compare);\n      return Pair.with(max_negative, min_positive);",
  "        // Write code here...\n        long largest = Long.MIN_VALUE;\n       \
    \ long smallest = Long.MAX_VALUE;\n        boolean hasPositive = false;\n    \
    \    boolean hasNegative = false;\n        for (long i : lst) {\n            if\
    \ (i < 0) {\n                hasNegative = true;\n                if (i > largest)\
    \ largest = i;\n            } else if (i > 0) {\n                hasPositive =\
    \ true;\n                if (i < smallest) smallest = i;\n            }\n    \
    \    }\n        if (!hasPositive && !hasNegative) return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        if (!hasPositive) return Pair.with(Optional.of(largest),\
    \ Optional.empty());\n        if (!hasNegative) return Pair.with(Optional.empty(),\
    \ Optional.of(smallest));\n        return Pair.with(Optional.of(largest), Optional.of(smallest));",
  "        // Implement your solution here\n        return null;", "        // Replace\
    \ this with your own code.\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        return Pair.with(\n             \
    \   Optional.of(\n                    lst.stream()\n                       .filter(\n\
    \                            (Long x) -> x <= 0\n                        )\n \
    \                      .max(Comparator.naturalOrder())\n                ),\n \
    \               Optional.of(\n                    lst.stream()\n             \
    \          .filter(\n                            (Long x) -> x >= 0\n        \
    \                )\n                       .min(Comparator.naturalOrder())\n \
    \               )\n            );", "        // Type your code here\n        Long\
    \ max = Long.MIN_VALUE;\n        Long min = Long.MAX_VALUE;\n        for (Long\
    \ l : lst) {\n            if (l < 0) {\n                max = Math.max(max, l);\n\
    \            } else if (l > 0) {\n                min = Math.min(min, l);\n  \
    \          }\n        }\n        return Pair.with(max == Long.MIN_VALUE ? Optional.empty()\
    \ : Optional.of(max), min == Long.MAX_VALUE ? Optional.empty() : Optional.of(min));",
  "        Long largestNegative = null;\n        Long smallestPositive = null;\n \
    \       for (Long l : lst) {\n            if (l < 0) {\n                if (largestNegative\
    \ == null || l > largestNegative) {\n                    largestNegative = l;\n\
    \                }\n            } else if (l > 0) {\n                if (smallestPositive\
    \ == null || l < smallestPositive) {\n                    smallestPositive = l;\n\
    \                }\n            }\n        }\n        return Pair.with(Optional.ofNullable(largestNegative),\
    \ Optional.ofNullable(smallestPositive));", '        return null;', "        Long\
    \ largestNegative = null;\n        Long smallestPositive = null;\n        for\
    \ (Long n : lst) {\n            if (n < 0 && (largestNegative == null || n > largestNegative))\
    \ {\n                largestNegative = n;\n            }\n            if (n >\
    \ 0 && (smallestPositive == null || n < smallestPositive)) {\n               \
    \ smallestPositive = n;\n            }\n        }\n        return Pair.with(Optional.ofNullable(largestNegative),\
    \ Optional.ofNullable(smallestPositive));", "        Long min = lst.stream().filter(x\
    \ -> x > 0).min(Comparator.naturalOrder()).orElse(null);\n        Long max = lst.stream().filter(x\
    \ -> x < 0).max(Comparator.naturalOrder()).orElse(null);\n        return Pair.with(Optional.ofNullable(max),\
    \ Optional.ofNullable(min));", "        Optional<Long> largest = Optional.empty();\n\
    \        Optional<Long> smallest = Optional.empty();\n        if (lst.size() ==\
    \ 0) {\n            return Pair.with(largest, smallest);\n        }\n        for\
    \ (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) > 0) {\n    \
    \            if (smallest.isPresent()) {\n                    if (lst.get(i) <\
    \ smallest.get()) {\n                        smallest = Optional.of(lst.get(i));\n\
    \                    }\n                } else {\n                    smallest\
    \ = Optional.of(lst.get(i));\n                }\n            } else if (lst.get(i)\
    \ < 0) {\n                if (largest.isPresent()) {\n                    if (lst.get(i)\
    \ > largest.get()) {\n                        largest = Optional.of(lst.get(i));\n\
    \                    }\n                } else {\n                    largest\
    \ = Optional.of(lst.get(i));\n                }\n            }\n        }\n  \
    \      return Pair.with(largest, smallest);", "        Optional<Long> largestNegative\
    \ = lst.stream().filter(num -> num < 0l).max(Comparator.naturalOrder());\n   \
    \     Optional<Long> smallestPositive = lst.stream().filter(num -> num > 0l).min(Comparator.naturalOrder());\n\
    \        return Pair.with(largestNegative, smallestPositive);", "        if (lst.isEmpty())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        List<Long> positives = lst.stream().filter(x -> x > 0).collect(Collectors.toList());\n\
    \        List<Long> negatives = lst.stream().filter(x -> x < 0).collect(Collectors.toList());\n\
    \        if (positives.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(0l));\n        }\n        if (negatives.isEmpty()) {\n         \
    \   return Pair.with(Optional.of(0l), Optional.of(positives.get(0)));\n      \
    \  }\n        return Pair.with(Optional.of(negatives.get(negatives.size() - 1)),\
    \ Optional.of(positives.get(0)));", '        return null;']
stop_tokens:
- "\n    }\n"
