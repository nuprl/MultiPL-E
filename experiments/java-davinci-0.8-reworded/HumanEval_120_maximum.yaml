name: HumanEval_120_maximum
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Given an array array list arr of integers and a positive\
  \ integer k, return a sorted array list \n    // of length k with the maximum k\
  \ numbers in arr.\n    // Example 1:\n    // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l,\
  \ (long)-4l, (long)5l))), (3l))\n    // (new ArrayList<Long>(Arrays.asList((long)-4l,\
  \ (long)-3l, (long)5l)))\n    // Example 2:\n    // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l,\
  \ (long)-4l, (long)4l))), (2l))\n    // (new ArrayList<Long>(Arrays.asList((long)4l,\
  \ (long)4l)))\n    // Example 3:\n    // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l,\
  \ (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))\n    //\
  \ (new ArrayList<Long>(Arrays.asList((long)2l)))\n    // Note:\n    // 1. The length\
  \ of the array array list will be in the range of [1, 1000].\n    // 2. The elements\
  \ in the array array list will be in the range of [-1000, 1000].\n    // 3. 0 <=\
  \ k <= len(arr)\n    public static ArrayList<Long> maximum(ArrayList<Long> arr,\
  \ long k) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(maximum((new\
  \ ArrayList<Long>(Arrays.asList((long)-3l, (long)-4l, (long)5l))), (3l)).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)-4l, (long)-3l, (long)5l)))));\n    assert(maximum((new\
  \ ArrayList<Long>(Arrays.asList((long)4l, (long)-4l, (long)4l))), (2l)).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)4l, (long)4l)))));\n    assert(maximum((new\
  \ ArrayList<Long>(Arrays.asList((long)-3l, (long)2l, (long)1l, (long)2l, (long)-1l,\
  \ (long)-2l, (long)1l))), (1l)).equals((new ArrayList<Long>(Arrays.asList((long)2l)))));\n\
  \    assert(maximum((new ArrayList<Long>(Arrays.asList((long)123l, (long)-123l,\
  \ (long)20l, (long)0l, (long)1l, (long)2l, (long)-3l))), (3l)).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)20l, (long)123l)))));\n    assert(maximum((new ArrayList<Long>(Arrays.asList((long)-123l,\
  \ (long)20l, (long)0l, (long)1l, (long)2l, (long)-3l))), (4l)).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
  \ (long)1l, (long)2l, (long)20l)))));\n    assert(maximum((new ArrayList<Long>(Arrays.asList((long)5l,\
  \ (long)15l, (long)0l, (long)3l, (long)-13l, (long)-8l, (long)0l))), (7l)).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)-13l, (long)-8l, (long)0l, (long)0l, (long)3l,\
  \ (long)5l, (long)15l)))));\n    assert(maximum((new ArrayList<Long>(Arrays.asList((long)-1l,\
  \ (long)0l, (long)2l, (long)5l, (long)3l, (long)-10l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)3l,\
  \ (long)5l)))));\n    assert(maximum((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)0l, (long)5l, (long)-7l))), (1l)).equals((new ArrayList<Long>(Arrays.asList((long)5l)))));\n\
  \    assert(maximum((new ArrayList<Long>(Arrays.asList((long)4l, (long)-4l))), (2l)).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)-4l, (long)4l)))));\n    assert(maximum((new\
  \ ArrayList<Long>(Arrays.asList((long)-10l, (long)10l))), (2l)).equals((new ArrayList<Long>(Arrays.asList((long)-10l,\
  \ (long)10l)))));\n    assert(maximum((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)2l, (long)3l, (long)-23l, (long)243l, (long)-400l, (long)0l))), (0l)).equals((new\
  \ ArrayList<Long>(Arrays.asList()))));\n    }\n\n}\n"
completions: ["        ArrayList<Long> sorted = new ArrayList<Long>(arr);\n      \
    \  Collections.sort(sorted);\n        ArrayList<Long> ans = new ArrayList<Long>();\n\
    \        for (int i = sorted.size() - 1; i >= 0; i--) {\n            ans.add(sorted.get(i));\n\
    \            if (ans.size() == k) {\n                break;\n            }\n \
    \       }\n        return ans;", "        List<Long> sorted = arr.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());\n\
    \        return new ArrayList<Long>(sorted.subList(0, (int)k));", "        ArrayList<Long>\
    \ s = new ArrayList<Long>();\n        int i = 0;\n        while (i < k) {\n  \
    \          long t = (long)0l;\n            for (int j = i; j < arr.size(); j++)\
    \ {\n                if (arr.get(j) > t) {\n                    t = arr.get(j);\n\
    \                }\n            }\n            s.add(t);\n            arr.remove(t);\n\
    \            i++;\n        }\n        return s;", "        int n = arr.size();\n\
    \        if (k >= n) {\n            Collections.sort(arr);\n            Collections.reverse(arr);\n\
    \            return arr;\n        }\n        long max = Long.MIN_VALUE;\n    \
    \    for (int i = 0; i < k; i++) {\n            max = Math.max(max, arr.get(i));\n\
    \        }\n        ArrayList<Long> res = new ArrayList<>();\n        for (int\
    \ i = 0; i < k; i++) {\n            if (arr.get(i) == max) {\n               \
    \ res.add(arr.get(i));\n            }\n        }\n        for (int i = k; i <\
    \ n; i++) {\n            if (arr.get(i) > max) {\n                max = arr.get(i);\n\
    \                res.clear();\n                res.add(arr.get(i));\n        \
    \    } else if (arr.get(i) == max) {\n                res.add(arr.get(i));\n \
    \           }\n        }\n        Collections.sort(res);\n        Collections.reverse(res);\n\
    \        return res;", '        return new ArrayList<Long>();', "        // Sort\
    \ array into ascending order\n        Collections.sort(arr);\n        // Return\
    \ array\n        return new ArrayList<Long>(arr.subList((int)(arr.size() - k),\
    \ (int)(arr.size())));", "        ArrayList<Long> ret = new ArrayList<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            if (i >= k) {\n \
    \               long lastVal = ret.get(ret.size() - 1);\n                long\
    \ firstVal = ret.get(0);\n                if (lastVal < arr.get(i)) {\n      \
    \              if (firstVal < arr.get(i)) {\n                        ret.remove(0);\n\
    \                        ret.add(arr.get(i));\n                    }\n       \
    \         }\n            } else {\n                ret.add(arr.get(i));\n    \
    \        }\n        }\n        return ret;", "        //\n        // IMPLEMENTATION\
    \ OF THE INPUT FUNCTIONALITY\n        //\n        ArrayList<Long> result = new\
    \ ArrayList<Long>();\n        ArrayList<Long> temp = new ArrayList<Long>();\n\
    \        result.add((long)0l);\n        result.add((long)0l);\n        result.add((long)0l);\n\
    \        //\n        // IMPLEMENTATION OF THE TARGET FUNCTIONALITY\n        //\n\
    \        int i = 0;\n        while ((i < arr.size())) {\n            if ((i <\
    \ k)) {\n                result.set((i % 3), arr.get(i));\n            } else\
    \ {\n                temp.clear();\n                temp.addAll(result);\n   \
    \             Collections.sort(temp);\n                if ((arr.get(i) > temp.get(0)))\
    \ {\n                    result.set((i % 3), arr.get(i));\n                }\n\
    \            }\n            i = (i + 1);\n        }\n        temp.clear();\n \
    \       temp.addAll(result);\n        Collections.sort(temp);\n        temp.subList(0,\
    \ ((int)((k % 3)))).clear();\n        return temp;", "        // Write your code\
    \ here.\n        return null;", "        // >>> arr[0:k]\n        // (new ArrayList<Long>(Arrays.asList((long)-3l,\
    \ (long)-4l)))\n        // >>> arr[0:k+1]\n        // (new ArrayList<Long>(Arrays.asList((long)-3l,\
    \ (long)-4l, (long)5l)))\n        // >>> arr[0:k+2]\n        // (new ArrayList<Long>(Arrays.asList((long)-3l,\
    \ (long)-4l, (long)5l)))\n        // >>> arr[0:k+3]\n        // (new ArrayList<Long>(Arrays.asList((long)-3l,\
    \ (long)-4l, (long)5l)))\n        // >>> arr[1:k]\n        // (new ArrayList<Long>(Arrays.asList((long)-4l)))\n\
    \        // >>> arr[1:k+1]\n        // (new ArrayList<Long>(Arrays.asList((long)-4l,\
    \ (long)5l)))\n        // >>> arr[1:k+2]\n        // (new ArrayList<Long>(Arrays.asList((long)-4l,\
    \ (long)5l)))\n        // >>> arr[1:k+3]\n        // (new ArrayList<Long>(Arrays.asList((long)-4l,\
    \ (long)5l)))\n        // >>> arr[2:k]\n        // (new ArrayList<Long>(Arrays.asList((long)5l)))\n\
    \        // >>> arr[2:k+1]\n        // (new ArrayList<Long>(Arrays.asList((long)5l)))\n\
    \        // >>> arr[2:k+2]\n        // (new ArrayList<Long>(Arrays.asList((long)5l)))\n\
    \        // >>> arr[2:k+3]\n        // (new ArrayList<Long>(Arrays.asList((long)5l)))\n\
    \        // >>> arr[0:k+1].sort()\n        // (new ArrayList<Long>(Arrays.asList((long)-4l,\
    \ (long)-3l, (long)5l)))\n        // >>> arr[1:k+1].sort()\n", "        ArrayList<Long>\
    \ sortedArr = new ArrayList<Long>(arr);\n        Collections.sort(sortedArr);\n\
    \        Collections.reverse(sortedArr);\n        ArrayList<Long> maxValues =\
    \ new ArrayList<Long>();\n        for (long i = 0; i < k; i++) {\n           \
    \ maxValues.add(sortedArr.get((int)i));\n        }\n        return maxValues;",
  "        ArrayList<Long> a = new ArrayList<Long>();\n        for (int i = 0; i <\
    \ k; i++) {\n            a.add(arr.get(i));\n        }\n        Collections.sort(a);\n\
    \        for (int i = k; i < arr.size(); i++) {\n            Long l = arr.get(i);\n\
    \            if (l >= a.get(0)) {\n                a.remove(0);\n            \
    \    a.add(l);\n                Collections.sort(a);\n            }\n        }\n\
    \        return a;", "        // Iterate through arr, keeping track of the maximum\
    \ element.  Pop the maximum element\n        // and append it to the end of a\
    \ new list.  Continue until the new list is of length k.\n        ArrayList<Long>\
    \ kList = new ArrayList<Long>();\n        int i;\n        for (i = 0; i < k; i++)\
    \ {\n            long maxVal = arr.get(0);\n            int maxIndex = 0;\n  \
    \          for (int j = 0; j < arr.size(); j++) {\n                if (arr.get(j)\
    \ > maxVal) {\n                    maxVal = arr.get(j);\n                    maxIndex\
    \ = j;\n                }\n            }\n            kList.add(maxVal);\n   \
    \         arr.remove(maxIndex);\n        }\n        return kList;", "        ArrayList<Long>\
    \ max = new ArrayList<Long>();\n        // For each element we check if the element\
    \ is bigger than the smallest element in the max\n        //  list, if it is then\
    \ we check if the element is bigger than the next smallest element\n        //\
    \  and keep doing this until we find the position to add it to.\n        // If\
    \ we find the element should be added to the max list then we put it at the right\n\
    \        //  position and remove the smallest element at the end of the list.\n\
    \        // But if we don't find a position for the element then we just add the\
    \ element to the end\n        //  of the list and remove the smallest element\
    \ at the end of the list.\n        for (Long element : arr) {\n            int\
    \ i = 0;\n            while (i < max.size() && max.get(i) < element) {\n     \
    \           i = i + 1;\n            }\n            if (i < max.size()) {\n   \
    \             max.add(i, element);\n            } else {\n                max.add(element);\n\
    \            }\n            if (max.size() > k) {\n                max.remove(max.size()\
    \ - 1);\n            }\n        }\n        return max;", '        return arr.stream().sorted((x,
    y) -> Long.compare(y, x)).limit(k).collect(Collectors.toCollection(ArrayList::new));',
  "        // Implement your solution here.\n        // Good luck!\n        return\
    \ new ArrayList<Long>();", "        if (k > arr.size()) {\n            return\
    \ arr;\n        }\n        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            heap.add(arr.get(i));\n\
    \        }\n        ArrayList<Long> max = new ArrayList<Long>();\n        for\
    \ (int i = 0; i < k; i++) {\n            max.add(heap.poll());\n        }\n  \
    \      return max;", "        Collections.sort(arr);\n        Collections.reverse(arr);\n\
    \        ArrayList<Long> res = new ArrayList<Long>();\n        for (int i = 0;\
    \ i < k; i++) {\n            res.add(arr.get(i));\n        }\n        return res;",
  "        Collections.sort(arr);\n        Collections.reverse(arr);\n        return\
    \ (new ArrayList<Long>(arr.subList(0, (int)k)));", "        int n = arr.size();\n\
    \        if (k > n) {\n            return arr;\n        }\n        if (k == n)\
    \ {\n            Collections.sort(arr);\n            return arr;\n        }\n\
    \        for (int i = 0; i < n - k; i++) {\n            long max = Integer.MIN_VALUE;\n\
    \            int index = -1;\n            for (int j = i; j < n - k + i; j++)\
    \ {\n                if (arr.get(j) > max) {\n                    max = arr.get(j);\n\
    \                    index = j;\n                }\n            }\n          \
    \  Collections.swap(arr, i, index);\n        }\n        return arr;", "      \
    \  // Type your solution here\n        return new ArrayList<Long>();", "     \
    \   ArrayList<Long> res = new ArrayList<Long>();\n        Collections.sort(arr);\n\
    \        Collections.reverse(arr);\n        for (int i = 0; i < k; i++) {\n  \
    \          res.add(arr.get(i));\n        }\n        return res;", "        Collections.sort(arr);\n\
    \        ArrayList<Long> list = new ArrayList<Long>();\n        for (int i = arr.size()\
    \ - 1; i >= 0; i--) {\n            if (list.size() < k) {\n                list.add(arr.get(i));\n\
    \            }\n        }\n        return list;", "        // We are assured that\
    \ k <= len(arr)\n        ArrayList<Long> arr_copy = new ArrayList<Long>(arr);\n\
    \        Collections.sort(arr_copy);\n        Collections.reverse(arr_copy);\n\
    \        return new ArrayList<Long>(arr_copy.subList(0, (int)k));", "        PriorityQueue<Long>\
    \ pq = new PriorityQueue<Long>();\n        for (Long value : arr) {\n        \
    \    pq.add(value);\n            if (pq.size() > k)\n                pq.poll();\n\
    \        }\n        ArrayList<Long> result = new ArrayList<Long>();\n        while\
    \ (!pq.isEmpty()) {\n            result.add(pq.poll());\n        }\n        Collections.reverse(result);\n\
    \        return result;", "        // Your Code Here\n        if (k == 0) {\n\
    \            return new ArrayList<Long>();\n        }\n        if (k >= arr.size())\
    \ {\n            Collections.sort(arr);\n            Collections.reverse(arr);\n\
    \            return arr;\n        }\n        ArrayList<Long> ans = new ArrayList<Long>();\n\
    \        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long\
    \ l : arr) {\n            pq.add(l);\n        }\n        while (k > 0) {\n   \
    \         ans.add(pq.poll());\n            k--;\n        }\n        return ans;",
  "        if (k == 0) {\n            return new ArrayList<Long>();\n        }\n \
    \       PriorityQueue<Long> heap = new PriorityQueue<>();\n        ArrayList<Long>\
    \ ret = new ArrayList<>();\n        for (Long e : arr) {\n            heap.add(e);\n\
    \            if (heap.size() > k) {\n                heap.poll();\n          \
    \  }\n        }\n        for (int i = (int)k - 1; i >= 0; i--) {\n           \
    \ ret.add(heap.poll());\n        }\n        return ret;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        Queue<Long> heap = new PriorityQueue<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            if (heap.size() <\
    \ k) heap.add(arr.get(i));\n            else {\n                long peek = heap.peek();\n\
    \                if (arr.get(i) > peek) {\n                    heap.remove();\n\
    \                    heap.add(arr.get(i));\n                }\n            }\n\
    \        }\n        while (heap.size() > 0) result.add(heap.remove());\n     \
    \   return result;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        return result;", '        throw new UnsupportedOperationException("Answer
    not implemented");', "        PriorityQueue<Long> heap = new PriorityQueue<Long>();\n\
    \        for (Long n : arr) {\n            heap.add(n);\n            if (heap.size()\
    \ > k) {\n                heap.poll();\n            }\n        }\n        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        while (k-- > 0) {\n            res.add(heap.poll());\n\
    \        }\n        Collections.reverse(res);\n        return res;", "       \
    \ LongComparator cmp = new LongComparator(arr);\n        ArrayList<Long> x = new\
    \ ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            x.add(0l);\n\
    \        }\n        return merge(arr, x, 0, arr.size() - 1, 0, k - 1, cmp);",
  "        PriorityQueue<Long> pq = new PriorityQueue<>();\n        ArrayList<Long>\
    \ ret = new ArrayList<>();\n        for (Long l : arr) {\n            pq.add(l);\n\
    \            if (pq.size() > k) pq.poll();\n        }\n        while (pq.size()\
    \ > 0) ret.add(pq.poll());\n        Collections.reverse(ret);\n        return\
    \ ret;", '        return arr.stream().sorted(Collections.reverseOrder()).limit(k).collect(Collectors.toCollection(ArrayList::new));',
  '        throw new RuntimeException("Not implemented.");', "        ArrayList<Long>\
    \ solution = new ArrayList<Long>();\n        // Insert your solution here\n  \
    \      solution.add((long)999);\n        return solution;", '        return arr.stream().sorted(Comparator.reverseOrder()).limit(k).collect(Collectors.toCollection(ArrayList::new));',
  "        //TODO: Write - Your - Code\n        return null;", "        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        // 1. Max heap\n        PriorityQueue<Long>\
    \ pq = new PriorityQueue<Long>(Collections.reverseOrder());\n        for (Long\
    \ i : arr) {\n            pq.add(i);\n        }\n        // 2. Take the first\
    \ k elements from the max heap\n        for (int i = 0; i < k; i++) {\n      \
    \      res.add(pq.poll());\n        }\n        return res;", "        if (k <=\
    \ 0) {\n            return new ArrayList<Long>();\n        }\n        if (k >\
    \ arr.size()) {\n            k = arr.size();\n        }\n        ArrayList<Long>\
    \ f = new ArrayList<Long>();\n        for (long n : arr) {\n            if (f.size()\
    \ < k) {\n                f.add(n);\n            } else {\n                if\
    \ (f.get((int)(k - 1l)) < n) {\n                    f.set((int)(k - 1l), n);\n\
    \                }\n            }\n            Collections.sort(f);\n        }\n\
    \        return f;", "        // return arr.stream().distinct().sorted(Comparator.reverseOrder()).limit(k).collect(Collectors.toCollection(ArrayList::new));\n\
    \        return new ArrayList<Long>(arr.stream().sorted(Comparator.reverseOrder()).limit(k).collect(Collectors.toSet()));",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        Collections.sort(arr);\n\
    \        for (int i = arr.size() - 1; i >= 0; i -= 1) {\n            result.add(arr.get(i));\n\
    \            if (result.size() == k) {\n                break;\n            }\n\
    \        }\n        return result;", "        // Code here\n        return new\
    \ ArrayList<Long>();", "        Collections.sort(arr);\n        Collections.reverse(arr);\n\
    \        ArrayList<Long> ans = new ArrayList<Long>();\n        for (int i = 0;\
    \ i < k; i++) {\n            ans.add(arr.get(i));\n        }\n        return ans;",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        if (arr.size()\
    \ == 0) {\n            return result;\n        }\n        ArrayList<Long> sorted\
    \ = new ArrayList<Long>(arr);\n        Collections.sort(sorted);\n        Collections.reverse(sorted);\n\
    \        long i = 0;\n        while (k > 0) {\n            if (i >= sorted.size())\
    \ {\n                break;\n            }\n            result.add(sorted.get((int)i));\n\
    \            i = i + 1;\n            k = k - 1;\n        }\n        return result;",
  "        // iteratively loop through k elements of the array, collecting the maximum\
    \ element\n        // and removing it from the array\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        while (k > 0) {\n            // loop\
    \ through the array, setting the max element to the first element\n          \
    \  // and the max index to 0\n            long max = arr.get(0);\n           \
    \ int max_index = 0;\n            for (int i = 0; i < arr.size(); i++) {\n   \
    \             // compare the current element to the max element\n            \
    \    if (arr.get(i) > max) {\n                    // if the current element is\
    \ greater than the max element,\n                    // update the max to the\
    \ current element and the max index to the\n                    // current index\n\
    \                    max = arr.get(i);\n                    max_index = i;\n \
    \               }\n            }\n            // add the max element to the result\n\
    \            result.add(max);\n            // remove the max element from the\
    \ array\n            arr.remove(max_index);\n            // decrement k\n    \
    \        k--;\n        }\n        // return the result\n        return result;",
  "        if (k == 0) {\n            return (new ArrayList<Long>());\n        }\n\
    \        if (k == 1) {\n            long maxValue = Long.MIN_VALUE;\n        \
    \    long maxIndex = -1;\n            for (int index = 0; index < arr.size();\
    \ index++) {\n                if (arr.get(index) > maxValue) {\n             \
    \       maxValue = arr.get(index);\n                    maxIndex = index;\n  \
    \              }\n            }\n            ArrayList<Long> result = new ArrayList<Long>();\n\
    \            result.add(maxValue);\n            return result;\n        }\n  \
    \      if (k == arr.size()) {\n            Collections.sort(arr);\n          \
    \  Collections.reverse(arr);\n            return arr;\n        }\n        return\
    \ (new ArrayList<Long>());", "        // null sorting, 1. Return arr if arr is\
    \ null.\n        if (arr == null) {\n            return arr;\n        }\n    \
    \    // null sorting, 2. Return empty array list if arr is empty.\n        if\
    \ (arr.size() == 0) {\n            return new ArrayList<Long>();\n        }\n\
    \        // bounds checking\n        if (k <= 0 || k > arr.size()) {\n       \
    \     throw new IllegalArgumentException(\"k, \" + k + \", must be greater than\
    \ 0 and less than \" + arr.size() + \".\");\n        }\n        ArrayList<Long>\
    \ arrayList = new ArrayList<Long>();\n        // Add the first k elements from\
    \ arr to arrayList.\n        for (int index = 0; index < k; index++) {\n     \
    \       arrayList.add(arr.get(index));\n        }\n        // Check the rest of\
    \ the array for any numbers greater than the current max of arrayList.\n     \
    \   for (int index = (int)k; index < arr.size(); index++) {\n            // Initialize\
    \ max to the first element in arrayList.\n            long max = arrayList.get(0);\n\
    \            // Get the current max.\n            for (int index2 = 0; index2\
    \ < arrayList.size(); index2++) {\n                if (arrayList.get(index2) >\
    \ max) {\n                    max = arrayList.get(index2);\n                }\n\
    \            }\n            // If the current element is greater than the current\
    \ max,\n            // add it to the end of arrayList and remove the smallest\
    \ element in arrayList.\n            if (arr.get(index) > max) {\n           \
    \     arrayList.add(arr.get(index));\n                // Initialize min to the\
    \ first element in arrayList.\n                long min = arrayList.get(0);\n\
    \                // Get the index of the smallest element in arrayList.\n    \
    \            int minIndex = 0;\n                for (int index2 = 0; index2 <\
    \ arrayList.size(); index2++) {\n                    if (arrayList.get(index2)\
    \ < min) {\n                        min = arrayList.get(index2);\n           \
    \             minIndex = index2;\n                    }\n                }\n \
    \               // Remove the smallest element in arrayList.\n               ",
  "        ArrayList<Long> res = new ArrayList<Long>();\n        for (long i = 0;\
    \ i < k; i++) {\n            res.add((long)Integer.MIN_VALUE);\n        }\n  \
    \      for (long i = 0; i < arr.size(); i++) {\n            for (long j = 0; j\
    \ < k; j++) {\n                if (arr.get((int)i) > res.get((int)j)) {\n    \
    \                res.set((int)j, arr.get((int)i));\n                    break;\n\
    \                }\n            }\n        }\n        return res;", "        //\
    \ Given an array array list arr of integers and a positive integer k, return a\
    \ sorted array list \n        // of length k with the maximum k numbers in arr.\n\
    \        return arr;", "        // find the maximum k numbers in arr\n       \
    \ for (int i = 0; i < k; i++) {\n            for (int j = i + 1; j < arr.size();\
    \ j++) {\n                if (arr.get(i) < arr.get(j)) {\n                   \
    \ long t = arr.get(i);\n                    arr.set(i, arr.get(j));\n        \
    \            arr.set(j, t);\n                }\n            }\n        }\n   \
    \     ArrayList<Long> x = new ArrayList<Long>();\n        for (int i = 0; i <\
    \ k; i++) {\n            x.add(arr.get(i));\n        }\n        return x;", " \
    \       ArrayList<Long> copy = new ArrayList<Long>(arr);\n        Collections.sort(copy);\n\
    \        Collections.reverse(copy);\n        return (new ArrayList<Long>(copy.subList(0,\
    \ (int)k)));", "        ArrayList<Long> output = new ArrayList<Long>();\n    \
    \    // Write your code here\n        int i = 0;\n        while (i < k) {\n  \
    \          Long max = Long.MIN_VALUE;\n            int index = -1;\n         \
    \   for (int j = 0; j < arr.size(); j++) {\n                if (arr.get(j) > max)\
    \ {\n                    max = arr.get(j);\n                    index = j;\n \
    \               }\n            }\n            output.add(max);\n            arr.remove(index);\n\
    \            i++;\n        }\n        return output;", '        return (new ArrayList<Long>(Arrays.asList((long)0l)));',
  "        ArrayList<Long> res = new ArrayList<Long>();\n        // If k is zero return\
    \ an empty list.\n        if (k == 0l) return res;\n        // Else if k is equal\
    \ to the number of elements in arr return arr.\n        if (k == arr.size()) return\
    \ arr;\n        // Else we can build the result list by taking the last k elements\
    \ of a sorted version of arr.\n        Collections.sort(arr);\n        for (long\
    \ i = arr.size() - k; i < arr.size(); i++) {\n            res.add(arr.get((int)i));\n\
    \        }\n        return res;", "        long[] ar = new long[arr.size()];\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            ar[i] = arr.get(i);\n\
    \        }\n        Arrays.sort(ar);\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (int i = ar.length - 1; i >= 0 && k > 0; i--) {\n            res.add(ar[i]);\n\
    \            k--;\n        }\n        return res;", "        ArrayList<Long> res\
    \ = new ArrayList<Long>();\n        // sort arr in descending order\n        Collections.sort(arr,\
    \ Collections.reverseOrder());\n        for (int i = 0; i < k; i++) {\n      \
    \      res.add(arr.get(i));\n        }\n        return res;", "        PriorityQueue<Long>\
    \ heap = new PriorityQueue<Long>();\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (long el: arr) {\n            heap.add(el);\n            if (heap.size()\
    \ > k) {\n                heap.poll();\n            }\n        }\n        while\
    \ (!heap.isEmpty()) {\n            res.add(heap.poll());\n        }\n        Collections.reverse(res);\n\
    \        return res;", "        TreeSet<Long> set = new TreeSet<>();\n       \
    \ for (long i : arr) {\n            set.add(i);\n        }\n        ArrayList<Long>\
    \ result = new ArrayList<>();\n        while (!set.isEmpty() && k-- > 0) {\n \
    \           result.add(set.pollLast());\n        }\n        return result;", " \
    \       // As a programmer, I don't want to write comments; but, as a human, I\
    \ want to write comments.\n        // Why?\n        // As a programmer, I want\
    \ my code to be as clear as possible, and I want to be able to \n        // understand\
    \ someone else's code. This typically happens when the code is clear.\n      \
    \  // As a human, I want to tell a story. Why is this code here? Why did I make\
    \ these changes?\n        // What would happen if I changed these things?\n  \
    \      // It's really difficult to balance these two opposing forces, but I guess\
    \ I'll try.\n        // So, first off, why is this method here? Why have this\
    \ method at all?\n        // It's because the problem statement asks for a sorted\
    \ list of length k with the maximum k \n        // numbers in arr.\n        //\
    \ So, here's the strategy:\n        // 1. Create a new array list (max) of length\
    \ k.\n        // 2. Iterate over the numbers in arr.\n        // 3. For each number,\
    \ n, check if n is greater than the first number in max.\n        // 4. If n is\
    \ greater than the first number in max, pop off the first number in max and add\
    \ n\n        //    to the front of max.\n        // 5. Return max.\n        //\
    \ Note: \n        // 1. This is a strategy that I've had to learn over time. In\
    \ the past, I would have been \n        //    tempted to do something like the\
    \ following:\n        //    a. Sort arr.\n        //    b. Return the first k\
    \ elements of arr.\n        //    However, this is not ideal, as sorting an array\
    \ of length n has complexity O(n log n).\n        //    The strategy above has\
    \ complexity O(n k), which is much better.\n        //    It would be nice if\
    \ I had a proof of why this is the case, but I don't. \n        //    I'm writing\
    \ this code on 11/4/20, and it's been many years since I took a class on \n  \
    \      //    algorithms.\n        // 2. The code below is a compact representation\
    \ of this strategy, which is possible because \n        //    of Java's streaming\
    \ capabilities. The strategy above is implemented on line 82 of this \n      \
    \  //", "        Collections.sort(arr);\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (int i = arr.size() - 1; i >= arr.size() - k; i--) {\n          \
    \  res.add(arr.get(i));\n        }\n        return res;", "        ArrayList<Long>\
    \ sorted = new ArrayList<Long>(arr);\n        Collections.sort(sorted);\n    \
    \    Collections.reverse(sorted);\n        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        for (int i = 0; i < k; i++) {\n            output.add(sorted.get(i));\n\
    \        }\n        return output;", '        return new ArrayList<Long>();',
  "        ArrayList<Long> myarr = new ArrayList<Long>();\n        arr.stream().sorted(Comparator.reverseOrder()).limit(k).forEach(t\
    \ -> myarr.add(t));\n        return myarr;", "        // curr_max = the maximum\
    \ in arr.\n        // curr_index = the index of curr_max in arr.\n        long\
    \ curr_max;\n        int curr_index;\n        // prev_max = the maximum in arr\
    \ before curr_max.\n        // prev_index = the index of prev_max in arr.\n  \
    \      long prev_max;\n        int prev_index;\n        // prev_prev_max = the\
    \ maximum in arr before prev_max.\n        // prev_prev_index = the index of prev_prev_max\
    \ in arr.\n        long prev_prev_max;\n        int prev_prev_index;\n       \
    \ // Initialize curr_max, curr_index, prev_max, prev_index, prev_prev_max, prev_prev_index,\
    \ and\n        // max_arr.\n        curr_max = arr.get(0);\n        curr_index\
    \ = 0;\n        prev_max = 0;\n        prev_index = 0;\n        prev_prev_max\
    \ = 0;\n        prev_prev_index = 0;\n        ArrayList<Long> max_arr = new ArrayList<Long>();\n\
    \        for (int i = 0; i < k; i++) {\n            max_arr.add(0l);\n       \
    \ }\n        // Iterate over the array list arr.\n        for (int i = 0; i <\
    \ arr.size(); i++) {\n            if (arr.get(i) > curr_max) {\n             \
    \   // If an element in arr is greater than curr_max, update\n               \
    \ // curr_max, curr_index, prev_max, prev_index, prev_prev_max,\n            \
    \    // and prev_prev_index.\n                prev_prev_max = prev_max;\n    \
    \            prev_prev_index = prev_index;\n                prev_max = curr_max;\n\
    \                prev_index = curr_index;\n                curr_max = arr.get(i);\n\
    \                curr_index = i;\n            } else if (arr.get(i) > prev_max)\
    \ {\n                // If an element in arr is greater than prev_max, but less\
    \ than\n                // curr_max, update", "        int k1 = (int)k;\n    \
    \    long[] a = arr.stream().mapToLong(i -> i).toArray();\n        long[] a1 =\
    \ new long[k1];\n        for (int i = 0; i < k1; i++) {\n            a1[i] = a[i];\n\
    \        }\n        Arrays.sort(a1);\n        for (int i = k1; i < a.length; i++)\
    \ {\n            if (a[i] > a1[0]) {\n                a1[0] = a[i];\n        \
    \        Arrays.sort(a1);\n            }\n        }\n        return new ArrayList<Long>(Arrays.stream(a1).boxed().collect(Collectors.toList()));",
  "        // Remove all elements that are greater than minimum of arraylist.\n  \
    \      // Repeat this process until k elements have been removed.\n        //\
    \ If k is less than or equal to 0, then return an empty array list.\n        if\
    \ (k <= 0) {\n            return new ArrayList<Long>();\n        }\n        //\
    \ Sort the array list in ascending order.\n        Collections.sort(arr);\n  \
    \      // Helper function that returns the minimum value in an array list.\n \
    \       // Note that this function will return an Integer.MIN_VALUE \n       \
    \ // if the array list is empty.\n        Function1<ArrayList<Long>, Long> listMinimum\
    \ = (ArrayList<Long> l) -> {\n            if (l.size() > 0) {\n              \
    \  return l.stream().reduce(Math::min).get();\n            } else {\n        \
    \        return (long)Integer.MIN_VALUE;\n            }\n        };\n        //\
    \ Remove all elements that are greater than the minimum of the array list,\n \
    \       // until k elements have been removed.\n        for (long i = 0; i < k;\
    \ i++) {\n            arr.removeIf((Long n) -> {\n                return n > listMinimum.apply(arr);\n\
    \            });\n        }\n        // Sort the array list in descending order.\n\
    \        Collections.sort(arr, Collections.reverseOrder());\n        // Return\
    \ the result.\n        return arr;", "        // Write your code here\n      \
    \  return new ArrayList<Long>();", "        long tmp = 0;\n        int len = arr.size();\n\
    \        long i = 0;\n        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        while (i < k) {\n            long max = Long.MIN_VALUE;\n           \
    \ for (long l = 0; l < len; l++) {\n                tmp = arr.get((int)l);\n \
    \               if (tmp > max) {\n                    max = tmp;\n           \
    \     }\n            }\n            output.add(max);\n            arr.remove(max);\n\
    \            i = i + 1;\n        }\n        return output;", "        PriorityQueue<Long>\
    \ pq = new PriorityQueue<Long>();\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (Long i : arr) {\n            pq.add(i);\n            if (pq.size()\
    \ > k) {\n                pq.poll();\n            }\n        }\n        for (Long\
    \ i : pq) {\n            res.add(i);\n        }\n        return res;", '        return
    null;', "        // Missing implementation\n        return null;", "        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        // BEGIN SOLUTION\n        ArrayList<Long>\
    \ sortedArr = new ArrayList<Long>(arr);\n        Collections.sort(sortedArr);\n\
    \        Collections.reverse(sortedArr);\n        for (int i = 0; i < k; i++)\
    \ {\n            res.add(sortedArr.get(i));\n        }\n        // END SOLUTION\n\
    \        return res;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (int i = 0; i < k; i++) {\n            long max = arr.get(0);\n \
    \           int index = 0;\n            for (int j = 0; j < arr.size(); j++) {\n\
    \                if (arr.get(j) > max) {\n                    max = arr.get(j);\n\
    \                    index = j;\n                }\n            }\n          \
    \  result.add(max);\n            arr.remove(index);\n        }\n        return\
    \ result;", '        return arr.stream().sorted((a, b) -> -a.compareTo(b)).limit(k).collect(Collectors.toCollection(ArrayList::new));',
  "        // for each element in arr, add to new_arr only if it's larger than the\
    \ smallest element in new_arr\n        // to implement this, use a priority queue,\
    \ and maintain the size of the queue to be k\n        PriorityQueue<Long> heap\
    \ = new PriorityQueue<>();\n        for (long a : arr) {\n            heap.add(a);\n\
    \            if (heap.size() > k) {\n                heap.poll();\n          \
    \  }\n        }\n        ArrayList<Long> res = new ArrayList<>();\n        while\
    \ (heap.size() > 0) {\n            res.add(heap.poll());\n        }\n        Collections.reverse(res);\n\
    \        return res;", "        ArrayList<Long> rv = new ArrayList<Long>();\n\
    \        LongStream.range(0l, k).forEach(i -> {rv.add(new Long(Long.MIN_VALUE));});\n\
    \        LongStream.range(0l, arr.size()).forEach(i -> {\n            Long val\
    \ = arr.get(i.intValue());\n            if (val > rv.get(rv.size() - 1).longValue())\
    \ {\n                LongStream.range(0l, rv.size()).forEach(j -> {\n        \
    \            if (val > rv.get(j.intValue()).longValue()) {\n                 \
    \       rv.add(j.intValue(), val);\n                        rv.remove(rv.size()\
    \ - 1);\n                        return;\n                    }\n            \
    \    });\n            }\n        });\n        return rv;", '        return arr.stream().sorted((x,
    y) -> -x.compareTo(y)).limit(k).collect(Collectors.toCollection(ArrayList::new));',
  "        // We will use the implementation of Java's PriorityQueue as a min heap.\n\
    \        PriorityQueue<Long> minHeap = new PriorityQueue<Long>();\n        //\
    \ The number of elements to keep in the heap.\n        int keep = (int)k;\n  \
    \      for (int i = 0; i < arr.size(); i++) {\n            // If the heap is not\
    \ full, add the element in the heap.\n            if (minHeap.size() < keep) {\n\
    \                minHeap.add(arr.get(i));\n            } else {\n            \
    \    // If the heap is full and the maximum element in the heap is smaller than\
    \ the \n                // current element, remove the maximum element in the\
    \ heap and add the current element.\n                if (minHeap.peek() < arr.get(i))\
    \ {\n                    minHeap.poll();\n                    minHeap.add(arr.get(i));\n\
    \                }\n            }\n        }\n        // Remove all the elements\
    \ in the heap and put them in the result array list.\n        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        while (!minHeap.isEmpty()) {\n       \
    \     res.add(minHeap.poll());\n        }\n        // Reverse the result array\
    \ list.\n        Collections.reverse(res);\n        return res;", "        //\n\
    \        // BEGIN\n        //\n        return null;\n        //\n        // END\n\
    \        //", "        if (k > arr.size()) {\n            k = arr.size();\n  \
    \      }\n        ArrayList<Long> arr2 = (new ArrayList<Long>(arr.subList(0, (int)k)));\n\
    \        return arr2;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        if (k <= 0) {\n            return result;\n        }\n        if (k ==\
    \ 1) {\n            long max = Long.MIN_VALUE;\n            for (int i = 0; i\
    \ < arr.size(); i++) {\n                long l = arr.get(i);\n               \
    \ if (l > max) {\n                    max = l;\n                }\n          \
    \  }\n            result.add(max);\n            return result;\n        }\n  \
    \      PriorityQueue<Long> q = new PriorityQueue<Long>();\n        for (int i\
    \ = 0; i < arr.size(); i++) {\n            q.add(arr.get(i));\n        }\n   \
    \     for (int i = 0; i < k; i++) {\n            result.add(q.poll());\n     \
    \   }\n        return result;", "        // (new Error((\"For debugging purposes:\
    \ \" + arr.toString()))).printStackTrace();\n        ArrayList<Long> temp = new\
    \ ArrayList<Long>();\n        for (int i = 0; i < k; i++) {\n            temp.add((long)-1000000000l);\n\
    \        }\n        for (int i = 0; i < arr.size(); i++) {\n            long cur\
    \ = arr.get(i);\n            for (int j = 0; j < k; j++) {\n                if\
    \ (cur > temp.get(j)) {\n                    long tempj = temp.get(j);\n     \
    \               temp.set(j, cur);\n                    cur = tempj;\n        \
    \        }\n            }\n        }\n        Collections.sort(temp);\n      \
    \  return temp;", "        ArrayList<Long> ret = new ArrayList<Long>();\n    \
    \    ArrayList<Long> tmp = new ArrayList<Long>();\n        HashMap<Long, Long>\
    \ m = new HashMap<Long, Long>();\n        for (int i = 0; i < arr.size(); i++)\
    \ {\n            Long key = arr.get(i);\n            if (m.containsKey(key)) {\n\
    \                m.put(key, m.get(key) + 1);\n            } else {\n         \
    \       m.put(key, 1l);\n            }\n        }\n        TreeMap<Long, Long>\
    \ tm = new TreeMap<Long, Long>(Collections.reverseOrder());\n        tm.putAll(m);\n\
    \        int idx = 0;\n        while (k > 0) {\n            if (tm.isEmpty())\
    \ {\n                break;\n            }\n            Long key = tm.firstKey();\n\
    \            Long val = tm.get(key);\n            Long count = val;\n        \
    \    while (count > 0) {\n                if (k == 0) {\n                    break;\n\
    \                }\n                ret.add(key);\n                k--;\n    \
    \            count--;\n            }\n            tm.remove(key);\n        }\n\
    \        return ret;", "        if (((long)arr.size()) == k) {\n            Collections.sort(arr);\n\
    \            return arr;\n        }\n        LinkedList<Long> smallNum = new LinkedList<Long>();\n\
    \        ArrayList<Long> largeNum = new ArrayList<Long>();\n        smallNum.add(arr.get((int)0l));\n\
    \        for (long i = (long)1l; i < ((long)arr.size()); i++) {\n            long\
    \ n = arr.get((int)i);\n            while ((((long)smallNum.size()) > (k - (long)1l))\
    \ && (n > smallNum.get((int)0l))) {\n                smallNum.removeFirst();\n\
    \            }\n            if (((long)smallNum.size()) < (k - (long)1l)) {\n\
    \                smallNum.addFirst(n);\n            }\n        }\n        largeNum.addAll(smallNum);\n\
    \        largeNum.addAll(arr);\n        Collections.sort(largeNum);\n        largeNum.subList((int)k,\
    \ (int)largeNum.size()).clear();\n        return largeNum;", "        //BEGIN\
    \ SOLUTION\n        return (new ArrayList<Long>(Arrays.asList(arr.stream().sorted(Comparator.reverseOrder()).limit(k).toArray(Long[]::new))));\n\
    \        //END SOLUTION", "        // Base case: arr.size() < k\n        if (arr.size()\
    \ < k) {\n            return arr;\n        }\n        if (k == 1) {\n        \
    \    return maximumOne(arr);\n        }\n        // Base case: k == 1\n      \
    \  ArrayList<Long> max1 = maximumOne(arr);\n        ArrayList<Long> max2 = maximum(arr,\
    \ k - 1);\n        ArrayList<Long> max = new ArrayList<Long>();\n        for (int\
    \ i = 0; i < k; i++) {\n            Long m1 = max1.get(i);\n            Long m2\
    \ = max2.get(i);\n            max.add(Math.max(m1, m2));\n        }\n        return\
    \ max;", '        throw new RuntimeException("Write your code here");', '        return
    new ArrayList<Long>();', "        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            if (res.size() <\
    \ k) {\n                res.add(arr.get(i));\n            } else {\n         \
    \       Long min = res.get(0);\n                int index = 0;\n             \
    \   for (int j = 1; j < res.size(); j++) {\n                    if (res.get(j)\
    \ < min) {\n                        min = res.get(j);\n                      \
    \  index = j;\n                    }\n                }\n                if (min\
    \ < arr.get(i)) {\n                    res.set(index, arr.get(i));\n         \
    \       }\n            }\n        }\n        Collections.sort(res);\n        Collections.reverse(res);\n\
    \        return res;", "        // Your code here\n        Collections.sort(arr);\n\
    \        int length = arr.size();\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (int i = length - 1; i >= length - k; i--) {\n            result.add(arr.get(i));\n\
    \        }\n        return result;", "        // This is a very optimized version\
    \ of the function maximum from my python version.\n        int size = arr.size();\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        ArrayList<Integer>\
    \ neg_indices = new ArrayList<Integer>();\n        ArrayList<Integer> pos_indices\
    \ = new ArrayList<Integer>();\n        for (int i = 0; i < size; i++) {\n    \
    \        if (arr.get(i) < 0) {\n                neg_indices.add(i);\n        \
    \    } else {\n                pos_indices.add(i);\n            }\n        }\n\
    \        int neg_size = neg_indices.size();\n        int pos_size = pos_indices.size();\n\
    \        int neg_i = neg_size - 1;\n        int pos_i = 0;\n        int i = 0;\n\
    \        while (i < k) {\n            if (pos_i == pos_size) {\n             \
    \   result.add(arr.get(neg_indices.get(neg_i)));\n                neg_i -= 1;\n\
    \            } else if (neg_i == -1) {\n                result.add(arr.get(pos_indices.get(pos_i)));\n\
    \                pos_i += 1;\n            } else {\n                long neg_value\
    \ = arr.get(neg_indices.get(neg_i));\n                long pos_value = arr.get(pos_indices.get(pos_i));\n\
    \                if (pos_value > -neg_value) {\n                    result.add(pos_value);\n\
    \                    pos_i += 1;\n                } else {\n                 \
    \   result.add(neg_value);\n                    neg_i -= 1;\n                }\n\
    \            }\n            i += 1;\n        }\n        return result;", "   \
    \     Collections.sort(arr);\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (int i = (int)(arr.size() - 1); i >= (int)(arr.size() - k); i--)\
    \ {\n            result.add(arr.get(i));\n        }\n        return result;",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        List<Long> arrList\
    \ = arr.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());\n\
    \        for (long i = 0; i < k; i += 1) {\n            result.add(arrList.get((int)i));\n\
    \        }\n        return result;", "        // Your code goes here\n       \
    \ return null;", "        if (k == 0) {\n            return new ArrayList<Long>();\n\
    \        }\n        else if (k == arr.size()) {\n            return maximum(arr);\n\
    \        }\n        else {\n            return maximum(maximum(arr), k);\n   \
    \     }", "        ArrayList<Long> result = new ArrayList<Long>();\n        Collections.sort(arr);\n\
    \        LongStream longStream = arr.stream().skip(arr.size() - k);\n        List<Long>\
    \ list = longStream.boxed().collect(Collectors.toList());\n        Collections.reverse(list);\n\
    \        result.addAll(list);\n        return result;", "        List<Long> sorted\
    \ = arr.stream().sorted().collect(Collectors.toList());\n        Collections.reverse(sorted);\n\
    \        sorted = sorted.subList(0, (int)k);\n        return new ArrayList<Long>(sorted);",
  "        ArrayList<Long> sorted = new ArrayList<Long>(arr);\n        Collections.sort(sorted);\n\
    \        Collections.reverse(sorted);\n        sorted = new ArrayList<Long>(sorted.subList(0,\
    \ (int)k));\n        return sorted;", "        // your code here\n        return\
    \ null;", "        Collections.sort(arr);\n        int length = arr.size();\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i =\
    \ length - 1; i >= length - k; i--) {\n            result.add(arr.get(i));\n \
    \       }\n        return result;", "        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        Collections.sort(arr);\n        for (int i = arr.size() - 1; i >= 0 &&\
    \ k > 0; i--) {\n            res.add(arr.get(i));\n            k--;\n        }\n\
    \        return res;", "        int n = arr.size();\n        PriorityQueue<Long>\
    \ heap = new PriorityQueue<Long>();\n        for (int i = 0; i < n; i++) {\n \
    \           heap.add(arr.get(i));\n            if (heap.size() > k) {\n      \
    \          heap.poll();\n            }\n        }\n        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        while (heap.size() > 0) {\n            result.add(heap.poll());\n\
    \        }\n        Collections.reverse(result);\n        return result;", " \
    \       // your code here\n        return null;", '        return new ArrayList<Long>();',
  "        ArrayList<Long> max_k = new ArrayList<Long>();\n        ArrayList<Long>\
    \ copy = new ArrayList<Long>(arr);\n        Long[] max_l = new Long[(int)k];\n\
    \        // find max k\n        while (k > 0) {\n            long max = -1001;\n\
    \            long index = -1;\n            for (int i = 0; i < copy.size(); i++)\
    \ {\n                if (copy.get(i) > max) {\n                    max = copy.get(i);\n\
    \                    index = i;\n                }\n            }\n          \
    \  if (index != -1) {\n                max_l[(int)k - 1] = max;\n            \
    \    copy.remove((int)index);\n            }\n            k--;\n        }\n  \
    \      // sort max k\n        while (max_l.length > 0) {\n            long max\
    \ = -1001;\n            long index = -1;\n            for (int i = 0; i < max_l.length;\
    \ i++) {\n                if (max_l[i] > max) {\n                    max = max_l[i];\n\
    \                    index = i;\n                }\n            }\n          \
    \  if (index != -1) {\n                max_k.add(max);\n                max_l\
    \ = Arrays.copyOfRange(max_l, 0, (int)index);\n                max_l = Arrays.copyOfRange(max_l,\
    \ (int)index + 1, max_l.length);\n            }\n        }\n        return max_k;",
  "        if (((new Long(arr.size())) < k)) {\n            return arr;\n        }\n\
    \        Collections.sort(arr);\n        return (new ArrayList<Long>(arr.subList(((arr.size())\
    \ - ((int) k)), arr.size())));", "        if (k > arr.size()) {\n            return\
    \ arr;\n        }\n        List<Long> temp = arr.subList(0, (int)k);\n       \
    \ Collections.sort(temp);\n        for (int i = (int)k; i < arr.size(); i++) {\n\
    \            long num = arr.get(i);\n            if (num > temp.get(0)) {\n  \
    \              temp.set(0, num);\n                Collections.sort(temp);\n  \
    \          }\n        }\n        ArrayList<Long> out = new ArrayList<Long>();\n\
    \        for (int i = 0; i < temp.size(); i++) {\n            out.add(temp.get(i));\n\
    \        }\n        return out;", "        // Write your code here\n        return\
    \ arr;", "        // This function is correct. DO NOT CHANGE IT.\n        if (k\
    \ == 0) {\n            return new ArrayList<Long>();\n        }\n        int len\
    \ = arr.size();\n        ArrayList<Long> ret = new ArrayList<Long>();\n      \
    \  Long[] rest = arr.toArray(new Long[len]);\n        Arrays.sort(rest, Collections.reverseOrder());\n\
    \        for (int i = 0; i < k; i++) {\n            ret.add(rest[i]);\n      \
    \  }\n        return ret;", "        // Your code here\n        return null;",
  "        ArrayList<Long> ans = new ArrayList<Long>();\n        Collections.sort(arr);\n\
    \        for (int i = 0; i < k; i++) {\n            ans.add(arr.get(arr.size()\
    \ - 1 - i));\n        }\n        return ans;", "        // your code here\n  \
    \      return null;", "        // your code here\n        return arr;", "    \
    \    Collections.sort(arr);\n        ArrayList<Long> r = new ArrayList<Long>();\n\
    \        for (long i = 0; i < k; i++) {\n            r.add(arr.get((int)(arr.size()\
    \ - 1 - i)));\n        }\n        return r;", '        return new ArrayList<Long>();',
  "        int index = (int)k;\n        Collections.sort(arr);\n        return new\
    \ ArrayList<Long>(arr.subList(arr.size() - index, arr.size()));", "        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        return res;", "        // Type your solution\
    \ here\n        return arr;", "        Collections.sort(arr);\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (int i = arr.size() - 1; i >= arr.size()\
    \ - k; i--) {\n            result.add(arr.get(i));\n        }\n        return\
    \ result;", "        // Implement me!\n        return null;", "        TreeSet<Long>\
    \ set = new TreeSet<>();\n        for (Long e : arr) {\n            set.add(e);\n\
    \            if (set.size() > k) {\n                set.pollFirst();\n       \
    \     }\n        }\n        ArrayList<Long> out = new ArrayList<>(set);\n    \
    \    Collections.reverse(out);\n        return out;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        Collections.sort(arr);\n        Collections.reverse(arr);\n\
    \        return new ArrayList<Long>(arr.subList(0, (int)k));", "        // 3 <=\
    \ k <= arr.size()\n        ArrayList<Long> res = new ArrayList<Long>();\n    \
    \    if(k == 0) return res;\n        if(k == arr.size()) return arr;\n       \
    \ if(k < 3) throw new java.lang.IllegalArgumentException(\"k < 3\");\n       \
    \ return (ArrayList<Long>) Arrays.stream(new Long[][]{\n            (Long[])arr.stream().mapToLong(p\
    \ -> p).toArray(),\n            (Long[])arr.stream().sorted().limit(k).toArray(),\n\
    \            (Long[])arr.stream().sorted(Comparator.reverseOrder()).limit(k).toArray()\n\
    \        }).flatMapToLong(p -> Arrays.stream(p)).distinct().sorted(Comparator.reverseOrder()).limit(k).mapToObj(p\
    \ -> p).collect(Collectors.toList());", "        ArrayList<Long> ret = new ArrayList<Long>();\n\
    \        long i = 0l;\n        long j = arr.size() - 1l;\n        if (k > arr.size())\
    \ {\n            return arr;\n        }\n        for (i = 0l; i < k; i++) {\n\
    \            ret.add(arr.get((int)i));\n        }\n        java.util.Collections.sort(ret);\n\
    \        while (i < arr.size()) {\n            if (arr.get((int)i) > ret.get((int)0))\
    \ {\n                ret.remove((int)0);\n                ret.add(arr.get((int)i));\n\
    \                java.util.Collections.sort(ret);\n            }\n           \
    \ i = i + 1l;\n        }\n        return ret;", "        ArrayList<Long> ans =\
    \ new ArrayList<Long>();\n        return ans;", "        ArrayList<Long> maxs\
    \ = new ArrayList<Long>();\n        PriorityQueue<Long> queue = new PriorityQueue<Long>(Comparator.reverseOrder());\n\
    \        int i = 0;\n        while (i < arr.size()) {\n            queue.add(arr.get(i));\n\
    \            i = i + 1;\n        }\n        while (maxs.size() < k) {\n      \
    \      maxs.add(queue.poll());\n        }\n        return maxs;", "        if\
    \ (arr.size() <= k) {\n            return arr;\n        }\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        // Complete the function.\n       \
    \ // // WRITE YOUR CODE BELOW THIS LINE\n        ArrayList<Long> copy = new ArrayList<Long>(arr);\n\
    \        // // SORT THIS ARRAY\n        Collections.sort(copy);\n        // //\
    \ NEED TO TAKE LAST K ELEMENTS\n        int result_size = (int)k;\n        for\
    \ (int i = copy.size() - 1; i >= copy.size() - result_size; i--) {\n         \
    \   result.add(copy.get(i));\n        }\n        // // WRITE YOUR CODE ABOVE THIS\
    \ LINE\n        return result;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (int\
    \ i = 0; i < arr.size(); i++) {\n            pq.add(arr.get(i));\n        }\n\
    \        for (int i = 0; i < k; i++) {\n            result.add(pq.poll());\n \
    \       }\n        return result;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        // Build the array list with the given values.\n        for (int i =\
    \ 0; i < arr.size(); i++) {\n            long item = arr.get(i);\n           \
    \ result.add(item);\n        }\n        if (k > 0) {\n            // Sort the\
    \ array in ascending order.\n            Collections.sort(result);\n         \
    \   // Remove the elements from the end of the array until the array is of length\
    \ k.\n            while (result.size() > k) {\n                result.remove(result.size()\
    \ - 1);\n            }\n            // Sort the array in descending order.\n \
    \           Collections.sort(result, Collections.reverseOrder());\n        }\n\
    \        return result;", "        // Implementation here...\n        return new\
    \ ArrayList<Long>();", "        ArrayList<Long> temp = new ArrayList<Long>();\n\
    \        if (k < 1) return temp;\n        if (k > arr.size()) return arr;\n  \
    \      while (k > 0) {\n            Long max = arr.get(0);\n            int pos\
    \ = 0;\n            for (int i = 1; i < arr.size(); i++) {\n                if\
    \ (arr.get(i) > max) {\n                    max = arr.get(i);\n              \
    \      pos = i;\n                }\n            }\n            temp.add(max);\n\
    \            arr.remove(pos);\n            k--;\n        }\n        return temp;",
  "        return k > arr.size() ? maximum(arr, arr.size()) : (\n            new ArrayList<Long>(Arrays.asList(arr.stream().sorted((i,\
    \ j) -> (i >= j ? -1 : 1)).limit(k).toArray(Long[]::new)))\n        );", "   \
    \     ArrayList<Long> xs = new ArrayList<Long>();\n        ArrayList<Long> xsp\
    \ = new ArrayList<Long>();\n        ArrayList<Long> ls = new ArrayList<Long>();\n\
    \        ArrayList<Long> rs = new ArrayList<Long>();\n        while (true) {\n\
    \            if (arr.size() < k) {\n                break;\n            }\n  \
    \          if (arr.size() == k) {\n                if (xs.size() == 0) {\n   \
    \                 xs = arr;\n                } else {\n                    if\
    \ (less(arr, xs)) {\n                        xs = arr;\n                    }\n\
    \                }\n                break;\n            }\n            if (xs.size()\
    \ == 0) {\n                int n = arr.size();\n                int hn = n / 2;\n\
    \                for (int i = 0; i < hn; i++) {\n                    ls.add(arr.get(i));\n\
    \                }\n                for (int i = hn; i < n; i++) {\n         \
    \           rs.add(arr.get(i));\n                }\n                xsp = maximum(ls,\
    \ k);\n                ArrayList<Long> xsq = maximum(rs, k);\n               \
    \ if (less(xsp, xsq)) {\n                    xs = xsq;\n                } else\
    \ {\n                    xs = xsp;\n                }\n                break;\n\
    \            }\n            break;\n        }\n        return xs;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        int i = 0;\n        for (i = 0; i <\
    \ k; i++) {\n            int j = i;\n            for (j = i; j < arr.size(); j++)\
    \ {\n                if (arr.get(j) > arr.get(i)) {\n                    Long\
    \ temp = arr.get(i);\n                    arr.set(i, arr.get(j));\n          \
    \          arr.set(j, temp);\n                }\n            }\n            result.add(arr.get(i));\n\
    \        }\n        return result;", "        List<Long> answer = new ArrayList<Long>();\n\
    \        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (int\
    \ i = 0; i < arr.size(); i++) {\n            pq.add(arr.get(i));\n        }\n\
    \        while (k > 0) {\n            answer.add(pq.poll());\n            k--;\n\
    \        }\n        return new ArrayList<Long>(answer);", "        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        return res;", "        assert(k >= 0);\n\
    \        assert(k <= 1000);\n        int arr_size = arr.size();\n        assert(arr_size\
    \ >= 1);\n        assert(arr_size <= 1000);\n        for (int i = 0; i < arr_size;\
    \ i++) {\n            long e = arr.get(i);\n            assert(e >= -1000);\n\
    \            assert(e <= 1000);\n        }\n        // 1 <= k <= arr_size\n  \
    \      if (k > arr_size) {\n            k = arr_size;\n        }\n        ArrayList<Long>\
    \ new_arr = new ArrayList<Long>();\n        if (k > 0) {\n            PriorityQueue<Long>\
    \ max_heap = new PriorityQueue<Long>(Comparator.reverseOrder());\n           \
    \ for (int i = 0; i < arr_size; i++) {\n                max_heap.add(arr.get(i));\n\
    \            }\n            for (int i = 0; i < k; i++) {\n                new_arr.add(max_heap.poll());\n\
    \            }\n        }\n        return new_arr;", "        ArrayList<Long>\
    \ sorted = new ArrayList<Long>(arr);\n        Collections.sort(sorted);\n    \
    \    ArrayList<Long> res = new ArrayList<Long>();\n        for (long i = arr.size()\
    \ - 1; i >= arr.size() - k; i--) {\n            res.add(sorted.get((int)i));\n\
    \        }\n        return res;", "        int range_start = 0;\n        int range_end\
    \ = (int)k;\n        int arr_len = arr.size();\n        int count = (int)k;\n\
    \        if (arr_len > k) {\n            // We have to find the k largest numbers\
    \ in the array.\n            // This is a problem which can be solved using a\
    \ modified quicksort algorithm.\n            while (count < arr_len) {\n     \
    \           long pivot = arr.get(range_start);\n                ArrayList<Long>\
    \ left = new ArrayList<Long>();\n                ArrayList<Long> right = new ArrayList<Long>();\n\
    \                int smaller_count = 0;\n                int larger_count = 0;\n\
    \                // The pivot is the first number in the range of the array we\
    \ are looking at.\n                // We iterate through the array from left to\
    \ right until we reach the end of the range.\n                for (int i = range_start\
    \ + 1; i < range_end; i++) {\n                    if (arr.get(i) <= pivot) {\n\
    \                        left.add(arr.get(i));\n                        smaller_count\
    \ += 1;\n                    } else {\n                        right.add(arr.get(i));\n\
    \                        larger_count += 1;\n                    }\n         \
    \       }\n                // If there are less smaller elements than are required,\
    \ we move the pivot to the left,\n                // and move the end point of\
    \ the range to the left.\n                if (smaller_count < (int)k) {\n    \
    \                range_end -= (smaller_count + 1);\n                    // We\
    \ need to add the right elements onto the end of the range.\n                \
    \    for (int i = 0; i < larger_count; i++) {\n                        arr.set(range_end\
    \ + i, right.get(i));\n                    }\n                    // We need to\
    \ add the pivot onto the end of the range.\n                    arr.set(range_end\
    \ + larger_count, pivot);\n                    count += larger_count;\n      \
    \          } else {\n                    // If there are less larger elements\
    \ than are required, we move the pivot to the right,\n                    // and\
    \ move the start point of the range to the right.\n                    range_start\
    \ += (larger_count + 1);\n                    // We need to", "        if (((arr\
    \ == null) || (arr.size() == 0)) || (k <= 0)) {\n            return arr;\n   \
    \     }\n        ArrayList<Long> result = new ArrayList<Long>();\n        Queue<Long>\
    \ queue = new PriorityQueue<Long>(Collections.reverseOrder());\n        for (Long\
    \ x : arr) {\n            queue.add(x);\n            if (queue.size() > k) {\n\
    \                queue.poll();\n            }\n        }\n        while (!queue.isEmpty())\
    \ {\n            result.add(queue.poll());\n        }\n        return result;",
  "        //return (new ArrayList<Long>(arr.stream().distinct().sorted(Collections.reverseOrder()).limit(k).collect(Collectors.toList())));\n\
    \        ArrayList<Long> res = new ArrayList<Long>();\n        Collections.sort(arr,\
    \ Collections.reverseOrder());\n        for (int i = 0; i < k; i++) {\n      \
    \      res.add(arr.get(i));\n        }\n        return res;", "        Collections.sort(arr);\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i\
    \ = arr.size() - 1; i >= 0; i--) {\n            if (k == 0) {\n              \
    \  break;\n            }\n            result.add(arr.get((int)i));\n         \
    \   k--;\n        }\n        return result;", "        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        return result;", "        // arr = arr.stream().sorted().collect(Collectors.toCollection(ArrayList::new));\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        int length =\
    \ arr.size();\n        if (k > length) {\n            k = length;\n        }\n\
    \        for (int i = 0; i < k; i++) {\n            long maximum = arr.get(0);\n\
    \            int position = 0;\n            for (int j = 0; j < arr.size(); j++)\
    \ {\n                if (arr.get(j) > maximum) {\n                    maximum\
    \ = arr.get(j);\n                    position = j;\n                }\n      \
    \      }\n            result.add(maximum);\n            arr.remove(position);\n\
    \        }\n        return result;", "        int n = arr.size();\n        //\
    \ two heaps, max heap and min heap\n        PriorityQueue<Long> left = new PriorityQueue<Long>(\n\
    \            (long)n, (Comparator<Long>)Collections.reverseOrder());\n       \
    \ PriorityQueue<Long> right = new PriorityQueue<Long>();\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (int i = 0; i < k; i++) {\n   \
    \         left.add(arr.get(i));\n        }\n        for (int i = k; i < n; i++)\
    \ {\n            right.add(arr.get(i));\n        }\n        for (int i = 0; i\
    \ < k; i++) {\n            result.add(left.poll());\n        }\n        return\
    \ result;", "        // Convert array list to array list of tuples\n        ArrayList<Pair<Long,\
    \ Long>> arr_pairs = new ArrayList<Pair<Long, Long>>();\n        for (int i =\
    \ 0; i < arr.size(); i++) {\n            arr_pairs.add(new Pair<Long, Long>(arr.get(i),\
    \ (long)i));\n        }\n        // Sort array list of tuples, descending\n  \
    \      Collections.sort(arr_pairs, new Comparator<Pair<Long, Long>>() {\n    \
    \        @Override\n            public int compare(Pair<Long, Long> pair1, Pair<Long,\
    \ Long> pair2) {\n                if (pair1.getValue0() > pair2.getValue0()) {\n\
    \                    return -1;\n                } else if (pair1.getValue0()\
    \ < pair2.getValue0()) {\n                    return 1;\n                } else\
    \ {\n                    return 0;\n                }\n            }\n       \
    \ });\n        // Truncate length of array list of tuples\n        arr_pairs =\
    \ new ArrayList<Pair<Long, Long>>(arr_pairs.subList(0, (int)k));\n        // Sort\
    \ array list of tuples, ascending\n        Collections.sort(arr_pairs, new Comparator<Pair<Long,\
    \ Long>>() {\n            @Override\n            public int compare(Pair<Long,\
    \ Long> pair1, Pair<Long, Long> pair2) {\n                if (pair1.getValue1()\
    \ < pair2.getValue1()) {\n                    return -1;\n                } else\
    \ if (pair1.getValue1() > pair2.getValue1()) {\n                    return 1;\n\
    \                } else {\n                    return 0;\n                }\n\
    \            }\n        });\n        // Convert array list of tuples to array\
    \ list\n        ArrayList<Long> arr_ordered = new ArrayList<Long>();\n       \
    \ for (int i = 0; i < arr_pairs.size(); i++) {\n            arr_ordered.add(arr_pairs.get(i).getValue0());\n\
    \        }\n        return arr_ordered;", "        ArrayList<Long> result = new\
    \ ArrayList<Long>();\n        int n = arr.size();\n        while (k > 0) {\n \
    \           Long max = Long.MIN_VALUE;\n            int idx = -1;\n          \
    \  for (int i = 0; i < n; i++) {\n                if (arr.get(i) > max) {\n  \
    \                  max = arr.get(i);\n                    idx = i;\n         \
    \       }\n            }\n            arr.set(idx, Long.MIN_VALUE);\n        \
    \    result.add(max);\n            k--;\n        }\n        return result;", " \
    \       if (k == 0) {\n            return new ArrayList<Long>();\n        }\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i =\
    \ 0; i < arr.size(); i++) {\n            if (result.size() == 0) {\n         \
    \       result.add(arr.get(i));\n            } else {\n                for (int\
    \ j = 0; j < result.size(); j++) {\n                    if (arr.get(i) > result.get(j))\
    \ {\n                        result.add(j, arr.get(i));\n                    \
    \    break;\n                    }\n                    if (j == result.size()\
    \ - 1) {\n                        result.add(arr.get(i));\n                  \
    \  }\n                }\n            }\n            if (result.size() > k) {\n\
    \                result.remove(result.size() - 1);\n            }\n        }\n\
    \        return result;", "        ArrayList<Long> ret = new ArrayList<Long>();\n\
    \        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (long\
    \ x : arr) {\n            pq.add(x);\n            if (pq.size() > k) {\n     \
    \           pq.poll();\n            }\n        }\n        while (!pq.isEmpty())\
    \ {\n            ret.add(pq.poll());\n        }\n        Collections.reverse(ret);\n\
    \        return ret;", "        // Write your code here\n        return null;",
  "        long[] vals = new long[arr.size()];\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            vals[i] = arr.get(i);\n        }\n        Arrays.sort(vals);\n\
    \        ArrayList<Long> ret = new ArrayList<Long>();\n        for (int i = arr.size()\
    \ - 1; i >= 0 && k > 0; i--) {\n            ret.add(vals[i]);\n            k--;\n\
    \        }\n        return ret;", '        return arr.stream().sorted(Long::compareTo).collect(Collectors.toCollection(ArrayList::new)).subList(arr.size()
    - (int)k, arr.size());', "        ArrayList<Long> copy = (ArrayList<Long>)arr.clone();\n\
    \        Collections.sort(copy);\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (int i = 0; i < k; i += 1) {\n            res.add(copy.get(copy.size()\
    \ - 1 - i));\n        }\n        return res;", "        // Write your code here\n\
    \        return null;", "        // throw new UnsupportedOperationException(\"\
    Not implemented yet.\");\n        if (arr.size() < k)\n            throw new IllegalArgumentException(\"\
    Not enough elements in the array list!\");\n        final Long[] max = {arr.get(0)};\n\
    \        ArrayList<Long> ans = new ArrayList<Long>();\n        arr.stream().limit(k).forEach((i)\
    \ -> {\n            if (i > max[0]) {\n                max[0] = i;\n         \
    \   }\n        });\n        ans.add(max[0]);\n        if (arr.size() == k)\n \
    \           return ans;\n        arr.subList(k, arr.size()).stream().forEach((i)\
    \ -> {\n            if (i > max[0]) {\n                ans.add(i);\n         \
    \       ans.remove(max[0]);\n                max[0] = i;\n            }\n    \
    \    });\n        return ans;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        return result;", '        return (k >= 1l && k <= arr.size()) ? new ArrayList<Long>(arr.stream().distinct().sorted((x,
    y) -> y.compareTo(x)).limit(k).collect(Collectors.toList())) : new ArrayList<Long>();',
  '        return (new ArrayList<Long>(arr.stream().sorted(Collections.reverseOrder()).limit(k).collect(Collectors.toList())));',
  "        ArrayList<Long> ret = new ArrayList<Long>();\n        for (int i = 0; i\
    \ < k; i++) {\n            ret.add((long)0);\n        }\n        for (int i =\
    \ 0; i < arr.size(); i++) {\n            for (int j = 0; j < k; j++) {\n     \
    \           if (arr.get(i) > ret.get(j)) {\n                    ret.set(j, arr.get(i));\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return ret;", "        // your code here\n        return new ArrayList<Long>();",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        for (long i =\
    \ 0; i < k; i++) {\n            long max = Long.MIN_VALUE;\n            long maxIndex\
    \ = 0;\n            for (long j = 0; j < arr.size(); j++) {\n                if\
    \ (arr.get((int)j) > max) {\n                    max = arr.get((int)j);\n    \
    \                maxIndex = j;\n                }\n            }\n           \
    \ result.add(max);\n            arr.remove((int)maxIndex);\n        }\n      \
    \  return result;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (long i = 0; i < k; i++) {\n            result.add(0l);\n       \
    \ }\n        //...your code...\n        return result;", "        // Your code\
    \ goes here.\n        ArrayList<Long> max = new ArrayList<Long>();\n        for\
    \ (int i = 0; i < k; i++) {\n            max.add(new Long(0));\n        }\n  \
    \      for (int i = 0; i < arr.size(); i++) {\n            for (int j = 0; j <\
    \ k; j++) {\n                if (arr.get(i) > max.get(j)) {\n                \
    \    for (int l = k - 1; l > j; l--) {\n                        max.set(l, max.get(l\
    \ - 1));\n                    }\n                    max.set(j, arr.get(i));\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return max;", "        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        // BEGIN SOLUTION\n        // This is a selection sort algorithm with\
    \ a descending sort order.\n        for (int i = 0; i < k; i++) {\n          \
    \  // This is the index of the largest element in the given range.\n         \
    \   int index = i;\n            for (int j = i + 1; j < arr.size(); j++) {\n \
    \               if (arr.get(j) > arr.get(index)) {\n                    index\
    \ = j;\n                }\n            }\n            // Swap element at index\
    \ with element at i.\n            if (index != i) {\n                long temp\
    \ = arr.get(i);\n                arr.set(i, arr.get(index));\n               \
    \ arr.set(index, temp);\n            }\n        }\n        // Copy k elements\
    \ into output.\n        for (int i = 0; i < k; i++) {\n            output.add(arr.get(i));\n\
    \        }\n        // END SOLUTION\n        return output;", "        // Implement\
    \ your solution here\n        return null;", "        List<Long> xs = arr.stream().sorted(Comparator.reverseOrder()).limit(k).collect(Collectors.toList());\n\
    \        return new ArrayList<Long>(xs);", "        // Since the array array list\
    \ has length at most 1000, we can sort it with a quicksort with complexity O(nlogn).\n\
    \        Collections.sort(arr);\n        // Then we simply reverse the first k\
    \ elements with a for loop.\n        for (int i = 0; i < k / 2; i++) {\n     \
    \       long temp = arr.get(i);\n            arr.set(i, arr.get((int)k - i - 1));\n\
    \            arr.set((int)k - i - 1, temp);\n        }\n        // The runtime\
    \ of this algorithm is therefore O(nlogn).\n        return arr;", "        //\
    \ Write your code here.\n        PriorityQueue<Long> queue = new PriorityQueue<Long>(Comparator.reverseOrder());\n\
    \        for (long i : arr) {\n            queue.add(i);\n        }\n        ArrayList<Long>\
    \ output = new ArrayList<Long>();\n        for (int i = 0; i < k; i++) {\n   \
    \         output.add(queue.poll());\n        }\n        return output;", "   \
    \     ArrayList<Long> result = new ArrayList<Long>();\n        while (k > 0) {\n\
    \            int i = 0;\n            long max = arr.get(0);\n            for (int\
    \ j = 1; j < arr.size(); j++) {\n                if (arr.get(j) > max) {\n   \
    \                 max = arr.get(j);\n                    i = j;\n            \
    \    }\n            }\n            result.add(max);\n            arr.remove(i);\n\
    \            k--;\n        }\n        return result;", "        PriorityQueue<Long>\
    \ que = new PriorityQueue<Long>();\n        for (Long i : arr) {\n           \
    \ que.add(i);\n            if (que.size() > k) {\n                que.poll();\n\
    \            }\n        }\n        ArrayList<Long> ret = new ArrayList<Long>();\n\
    \        while (que.size() > 0) {\n            ret.add(que.poll());\n        }\n\
    \        Collections.reverse(ret);\n        return ret;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        ArrayList<Long> neg = new ArrayList<Long>();\n\
    \        ArrayList<Long> pos = new ArrayList<Long>();\n        for (Long l : arr)\
    \ {\n            if (l < 0l) {\n                neg.add(l);\n            } else\
    \ {\n                pos.add(l);\n            }\n        }\n        for (Long\
    \ l : neg) {\n            boolean wasAdded = false;\n            for (int i =\
    \ 0; i < result.size(); i++) {\n                if (result.get(i) < l) {\n   \
    \                 result.add(i, l);\n                    wasAdded = true;\n  \
    \                  break;\n                }\n            }\n            if (!wasAdded)\
    \ {\n                result.add(l);\n            }\n        }\n        for (Long\
    \ l : pos) {\n            boolean wasAdded = false;\n            for (int i =\
    \ 0; i < result.size(); i++) {\n                if (result.get(i) < l) {\n   \
    \                 result.add(i, l);\n                    wasAdded = true;\n  \
    \                  break;\n                }\n            }\n            if (!wasAdded)\
    \ {\n                result.add(l);\n            }\n        }\n        int num\
    \ = 0;\n        ArrayList<Long> r = new ArrayList<Long>();\n        for (int i\
    \ = result.size() - 1; i >= 0; i--) {\n            if (num == k) {\n         \
    \       break;\n            }\n            r.add(result.get(i));\n           \
    \ num++;\n        }\n        return r;", "        if (arr.size() < k) {\n    \
    \        throw new RuntimeException(\"\");\n        }\n        Collections.sort(arr);\n\
    \        return new ArrayList<Long>(arr.subList((arr.size() - ((int)k)), arr.size()));",
  "        ArrayList<Long> ans = new ArrayList<Long>();\n        PriorityQueue<Long>\
    \ arr_pq = new PriorityQueue<Long>(arr);\n        while (k > 0) {\n          \
    \  ans.add(arr_pq.poll());\n            k--;\n        }\n        return ans;",
  "        ArrayList<Long> ret = new ArrayList<Long>();\n        PriorityQueue<Long>\
    \ pq = new PriorityQueue<Long>();\n        for (long i = 0; i < k; i++) {\n  \
    \          pq.add(arr.get((int)i));\n        }\n        for (long i = k; i < arr.size();\
    \ i++) {\n            pq.add(arr.get((int)i));\n            pq.poll();\n     \
    \   }\n        while (!pq.isEmpty()) {\n            ret.add(pq.poll());\n    \
    \    }\n        Collections.reverse(ret);\n        return ret;", "        ArrayList<Long>\
    \ out = new ArrayList<Long>();\n        for (long i = 0; i < k; i++) {\n     \
    \       out.add(arr.get((int)i));\n        }\n        Collections.sort(out);\n\
    \        for (long i = k; i < arr.size(); i++) {\n            if (arr.get((int)i)\
    \ > out.get(0)) {\n                out.remove(0);\n                out.add(arr.get((int)i));\n\
    \                Collections.sort(out);\n            }\n        }\n        return\
    \ out;", "        ArrayList<Long> result = new ArrayList<Long>();\n        if\
    \ (k == 0 || arr.size() == 0) {\n            return result;\n        }\n     \
    \   if (k >= arr.size()) {\n            for (Long i : arr) {\n               \
    \ result.add(i);\n            }\n            Collections.sort(result);\n     \
    \       Collections.reverse(result);\n            return result;\n        }\n\
    \        PriorityQueue<Long> pq = new PriorityQueue<Long>();\n        for (Long\
    \ i : arr) {\n            pq.add(i);\n        }\n        for (int i = 0; i < k;\
    \ i++) {\n            result.add(pq.poll());\n        }\n        return result;",
  "        int j = 0;\n        for (int i = 0; i < k; i++) {\n            j = find_max(arr,\
    \ j);\n            System.out.println(i);\n            System.out.println(j);\n\
    \            System.out.println(arr);\n            swap(arr, i, j);\n        }\n\
    \        ArrayList<Long> res = new ArrayList<Long>();\n        for (int i = 0;\
    \ i < k; i++) {\n            res.add(arr.get(i));\n        }\n        return res;",
  "        ArrayList<Long> ans = new ArrayList<Long>();\n        for (long i=0l; i<k;\
    \ i++) {\n            ans.add(0l);\n        }\n        for (long i=0l; i<arr.size();\
    \ i++) {\n            long j = 0l;\n            while (j < k && arr.get((int)i)\
    \ <= ans.get((int)j)) {\n                j = j + 1l;\n            }\n        \
    \    if (j < k) {\n                ans.remove((int)j);\n                ans.add((int)j,\
    \ arr.get((int)i));\n            }\n        }\n        Collections.sort(ans);\n\
    \        Collections.reverse(ans);\n        return ans;", "        ArrayList<Long>\
    \ tmp = new ArrayList<Long>();\n        for (Long it : arr) {\n            tmp.add(it);\n\
    \        }\n        ArrayList<Long> ret = new ArrayList<Long>();\n        for\
    \ (int i = 0; i < k; i++) {\n            Long max = (long)0;\n            for\
    \ (Long it : tmp) {\n                if (it > max) {\n                    max\
    \ = it;\n                }\n            }\n            ret.add(max);\n       \
    \     tmp.remove(max);\n        }\n        return ret;", "        ArrayList<Long>\
    \ arr2 = new ArrayList<Long>();\n        for (int i = 0; i < k; i++) {\n     \
    \       arr2.add(arr.get(i));\n        }\n        Collections.sort(arr2);\n  \
    \      for (int i = (int)k; i < arr.size(); i++) {\n            if (arr.get(i)\
    \ > arr2.get(0)) {\n                arr2.remove(0);\n                arr2.add(arr.get(i));\n\
    \                Collections.sort(arr2);\n            }\n        }\n        return\
    \ arr2;", "        //class Key extends Tuple {\n        //    public long key;\n\
    \        //    public Key(long key) {\n        //        super(key);\n       \
    \ //        this.key = key;\n        //    }\n        //}\n        ArrayList<Long>\
    \ out = new ArrayList<Long>();\n        Queue<Long> q = new PriorityQueue<Long>(arr.size(),\
    \ Collections.reverseOrder());\n        for (long x : arr) {\n            q.add(x);\n\
    \        }\n        for (int i = 0; i < k; i++) {\n            out.add(q.poll());\n\
    \        }\n        return out;", '        throw new RuntimeException("Not implemented.");',
  "        ArrayList<Long> newArr = new ArrayList<Long>();\n        PriorityQueue<Long>\
    \ heap = new PriorityQueue<Long>();\n        arr.forEach(el -> heap.add(el));\n\
    \        for (int i = 0; i < k; i++) {\n            newArr.add(heap.poll());\n\
    \        }\n        Collections.reverse(newArr);\n        return newArr;", " \
    \       // Write your code here.\n        return new ArrayList<Long>();", "  \
    \      ArrayList<Long> lst = new ArrayList<Long>();\n        //int i = arr.length;\n\
    \        int i = arr.size();\n        while (i > 0) {\n            if (k > i)\
    \ {\n                k = i;\n            }\n            long max = Long.MIN_VALUE;\n\
    \            for (int j = 0; j < i; j++) {\n                if (arr.get(j) > max)\
    \ {\n                    max = arr.get(j);\n                }\n            }\n\
    \            lst.add(max);\n            arr.remove(arr.indexOf(max));\n      \
    \      i = arr.size();\n        }\n        return lst;", "        // Assume that\
    \ elements in arr are unique.\n        ArrayList<Long> ans = new ArrayList<Long>();\n\
    \        ArrayList<Long> arr1 = new ArrayList<Long>();\n        for (int i = 0;\
    \ i < k; i++) {\n            arr1.add(arr.get(i));\n        }\n        Collections.sort(arr1);\n\
    \        for (int i = k; i < arr.size(); i++) {\n            long e = arr.get(i);\n\
    \            if (e >= arr1.get(0)) {\n                int j = 0;\n           \
    \     while (j < k) {\n                    if (e > arr1.get(j)) {\n          \
    \              arr1.remove(j);\n                        arr1.add(j, e);\n    \
    \                    break;\n                    }\n                    j++;\n\
    \                }\n            }\n        }\n        for (int i = 0; i < k; i++)\
    \ {\n            ans.add(arr1.get(i));\n        }\n        return ans;", "   \
    \     ArrayList<Long> result = new ArrayList<Long>();\n        PriorityQueue<Long>\
    \ pq = new PriorityQueue<Long>();\n        for (Long element : arr) {\n      \
    \      pq.add(element);\n        }\n        for (long i = 0; i < k; i++) {\n \
    \           result.add(pq.poll());\n        }\n        return result;", "    \
    \    // \\begin{problem}[Maximum]\n        // Given an array array list arr of\
    \ integers and a positive integer k, return a sorted array list \n        // of\
    \ length k with the maximum k numbers in arr.\n        // \\end{problem}\n   \
    \     // \\begin{problem}[Note]\n        // \\begin{itemize}\n        // \\item\
    \ The length of the array array list will be in the range of [1, 1000].\n    \
    \    // \\item The elements in the array array list will be in the range of [-1000,\
    \ 1000].\n        // \\item 0 <= k <= len(arr)\n        // \\end{itemize}\n  \
    \      // \\end{problem}\n        // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l,\
    \ (long)-4l, (long)5l))), (3l))\n        // (new ArrayList<Long>(Arrays.asList((long)-4l,\
    \ (long)-3l, (long)5l)))\n        // >>> maximum((new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)-4l, (long)4l))), (2l))\n        // (new ArrayList<Long>(Arrays.asList((long)4l,\
    \ (long)4l)))\n        // >>> maximum((new ArrayList<Long>(Arrays.asList((long)-3l,\
    \ (long)2l, (long)1l, (long)2l, (long)-1l, (long)-2l, (long)1l))), (1l))\n   \
    \     // (new ArrayList<Long>(Arrays.asList((long)2l)))\n        // Assume that\
    \ the input is valid.\n        return new ArrayList<Long>(Arrays.asList(arr.stream().sorted(Comparator.reverseOrder()).limit(k).toArray(Long[]::new)));",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        return result;",
  "        return arr.stream().sorted((x, y) -> {\n            if (x < y) {\n    \
    \            return 1;\n            } else if (x > y) {\n                return\
    \ -1;\n            } else {\n                return 0;\n            }\n      \
    \  }).limit(k).collect(Collectors.toCollection(ArrayList::new));", '        return
    arr.stream().sorted(Comparator.reverseOrder()).limit(k).collect(Collectors.toCollection(ArrayList::new));',
  '        return arr.stream().sorted(Comparator.reverseOrder()).limit(k).collect(Collectors.toCollection(ArrayList::new));',
  "        Collections.sort(arr);\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (int i = arr.size() - 1; i >= arr.size() - k; i--) {\n          \
    \  res.add(arr.get(i));\n        }\n        return res;", "        // throw new\
    \ Exception(\"Not implemented\");\n        for (int i = 0; i < arr.size(); i++)\
    \ {\n            for (int j = i; j < arr.size(); j++) {\n                if (arr.get(i)\
    \ < arr.get(j)) {\n                    long temp = arr.get(i);\n             \
    \       arr.set(i, arr.get(j));\n                    arr.set(j, temp);\n     \
    \           }\n            }\n        }\n        ArrayList<Long> ret = new ArrayList<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            if (i == k) {\n \
    \               break;\n            }\n            ret.add(arr.get(i));\n    \
    \    }\n        return ret;", "        ArrayList<Long> sortedArr = new ArrayList<Long>(arr);\n\
    \        Collections.sort(sortedArr);\n        Collections.reverse(sortedArr);\n\
    \        return (new ArrayList<Long>(sortedArr.subList(0, (int)k)));", "     \
    \   // Build a max heap.\n        PriorityQueue<Long> heap = new PriorityQueue<Long>(Collections.reverseOrder());\n\
    \        for (long x : arr) {\n            heap.add(x);\n        }\n        //\
    \ k items in heap.\n        ArrayList<Long> list = new ArrayList<Long>();\n  \
    \      for (int i = 0; i < k; i++) {\n            list.add(heap.poll());\n   \
    \     }\n        // Return list in reverse.\n        Collections.reverse(list);\n\
    \        return list;", "        ArrayList<Long> sorted = new ArrayList<Long>(arr);\n\
    \        Collections.sort(sorted);\n        Collections.reverse(sorted);\n   \
    \     ArrayList<Long> ret = new ArrayList<Long>();\n        for (int i = 0; i\
    \ < k; i++) {\n            ret.add(sorted.get(i));\n        }\n        return\
    \ ret;", '        return new ArrayList<Long>();', "        // Fill this in.\n\
    \        ArrayList<Long> arr2 = new ArrayList<Long>();\n        for (long i =\
    \ (long)0; i < k; i += (long)1) {\n            long max = (long)-1001;\n     \
    \       for (long j = (long)0; j < arr.size(); j += (long)1) {\n             \
    \   if (arr.get((int)j) > max) {\n                    max = arr.get((int)j);\n\
    \                }\n            }\n            arr2.add(max);\n            arr.remove((Object)max);\n\
    \        }\n        return arr2;"]
stop_tokens:
- "\n    }\n"
