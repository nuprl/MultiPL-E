name: HumanEval_83_starts_one_ends
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Given a positive integer n, return the count of the numbers\
  \ of n-digit\n    // positive integers that start or end with 1.\n    public static\
  \ long startsOneEnds(long n) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(startsOneEnds((1l))\
  \ == (1l));\n    assert(startsOneEnds((2l)) == (18l));\n    assert(startsOneEnds((3l))\
  \ == (180l));\n    assert(startsOneEnds((4l)) == (1800l));\n    assert(startsOneEnds((5l))\
  \ == (18000l));\n    }\n\n}\n"
completions: ["        // Create the set of factors.\n        long[] factors = new\
    \ long[(int)n];\n        for (int i = 0; i < n; i++) {\n            factors[i]\
    \ = (i == 0) ? 9 : 10;\n        }\n        // Using the factors, compute the values\
    \ of the sum.\n        long[] result = new long[(int)n];\n        result[0] =\
    \ 1;\n        for (int i = 1; i < n; i++) {\n            result[i] = result[i\
    \ - 1] * factors[i - 1];\n        }\n        // Remove the number of numbers that\
    \ start and end with 1, because\n        // they have been double counted.\n \
    \       long numSubsequences = (n == 1) ? 0 : result[(int)n - 1] - result[(int)n\
    \ - 2];\n        return result[(int)n - 1] + numSubsequences;", "        long\
    \ sum = 0;\n        if (n == 1) {\n            return 2;\n        }\n        long\
    \ f = (long) Math.pow(10, n - 1);\n        long s = f * 2;\n        while (f <\
    \ s) {\n            sum += f;\n            f *= 10;\n        }\n        return\
    \ sum;", "        long result = 0;\n        if (n <= 2) {\n            if (n ==\
    \ 1) {\n                result = 10;\n            } else {\n                result\
    \ = 21;\n            }\n        } else {\n            result = 10 * startsOneEnds(n\
    \ - 1) - 9 * endsOne(n - 1);\n        }\n        return result;", "        long\
    \ ans = (n - 1) * 9;\n        if (n > 1) {\n            ans += 9;\n        }\n\
    \        return ans;", "        // For n = 1, the answer is 2 (1, 1)\n       \
    \ // For n = 2, the answer is 6 (11, 12, 13, 21, 22, 23)\n        // For n = 3,\
    \ the answer is 26 (111, 112, 113, 121, 122, 123,\n        //                \
    \              211, 212, 213, 221, 222, 223,\n        //                     \
    \         311, 312, 313, 321, 322, 323)\n        // This is a Catalan number problem.\
    \ The answer is counted by the\n        // formula 2*C(n-1, 2n-1)\n        return\
    \ 2*binomial(n-1, 2*n-1);", "        long ans = 0;\n        for (long i = 0; i\
    \ < n; i++) {\n            long a = (long) Math.pow(10, i);\n            long\
    \ b = (long) Math.pow(10, n - i);\n            ans += (a * (b - a)) + a;\n   \
    \     }\n        return ans;", "        // Base case.\n        if (n == 1) return\
    \ 10;\n        // Initialize an array of size 10.\n        long[] arr = new long[10];\n\
    \        // Inititialize the array.\n        Arrays.fill(arr, 1);\n        //\
    \ Iterate over the range [1, n).\n        for (int i = 1; i < n; i++) {\n    \
    \        // Iterate over the range [0, 9].\n            for (int j = 0; j < 10;\
    \ j++) {\n                // Update the count for each number.\n             \
    \   if (j != 0) arr[j] += arr[j - 1];\n            }\n        }\n        // Return\
    \ the count of the number that starts with 1 and ends with 1.\n        return\
    \ arr[9] * 2;", '        return ((long) Math.pow(10, n - 1) - (long) Math.pow(9,
    n - 1)) + ((long) Math.pow(9, n - 1) - (long) Math.pow(8, n - 1));', '        return
    count(n, 1);', "        assert n > 0;\n        if (n == 1) return 10;\n      \
    \  return 10 * numNines(n - 1) + (n - 1) * 9;", '        return n * 9 * (long)
    Math.pow(10, n - 1);', "        if (n == 1) {\n            return 1;\n       \
    \ }\n        return (long) Math.pow(10, n - 1) + (long) Math.pow(10, n - 2) *\
    \ 9;", "        if (n == 1) {\n            return 10;\n        }\n        // Returns\
    \ a number of the form 10^(n-1)*a + b where a is 0...9\n        // and b is 1...9.\n\
    \        // For example, if n = 2, then we have 10x+y where x is 0...9 and\n \
    \       // y is 1...9. \n        // n = 3, then we have 100x+10y+z where x is\
    \ 0...9, y is 0...9, and\n        // z is 1...9.\n        long min =  (long)Math.pow(10,\
    \ n-1);\n        long max = (long)Math.pow(10, n) - 1;\n        // We need the\
    \ following:\n        // 1. those numbers with 1 at the beginning (and thus a\
    \ zero in the \n        // remainder of the number).\n        // 2. those numbers\
    \ with a 0 at the beginning, and a 1 at the end.\n        // 3. those numbers\
    \ with a 1 at the end.\n        // For example, if n = 2:\n        // then we\
    \ need 1, 10, 11, 12... 98, 99.\n        //\n        // If n = 3:\n        //\
    \ then we need 1, 10, 100, 101, 110, 111, 112, 120, 121, 122, 130,\n        //\
    \ 131, 132, ..., 991, 992, 993, 994, 995, 996, 997, 998, 999.\n        //\n  \
    \      // If n = 4:\n        // then we need 1, 10, 100, 1000, 1001, 1010, 1011,\
    \ 1012, ..., 9990,\n        // 9991, 9992, 9993, 9994, 9995, 9996, 9997, 9998,\
    \ 9999.\n        //\n        // The numbers that start with 1 are 1 + (n-1) digits\
    \ which start \n        // with 0. Therefore, n-1 9s for the remaining digits.\n\
    \        // The numbers that end with 1 are 10^(n-1).\n        // The numbers\
    \ that have a 0 before the 1 are (n-1) * 9 * 10^(n-2).\n        // Multiply by\
    \ 2 because the first digit", "        if (n < 1) {\n            return 0;\n \
    \       }\n        if (n == 1) {\n            return 2;\n        }\n        if\
    \ (n == 2) {\n            return 3;\n        }\n        long result = 3;\n   \
    \     for (long i = 3; i <= n; i++) {\n            result = (result * 2) - 1;\n\
    \        }\n        return result;", "        // Base case\n        if (n == 1)\
    \ {\n            return 10;\n        }\n        // Get the count of n-1 digit\
    \ integers that starts with a 1.\n        long cnt = n >= 2 ? (int)Math.pow(10,\
    \ n - 2) : 0;\n        // Add the count of n-1 digit integers that ends with a\
    \ 1.\n        cnt += (int)Math.pow(10, n - 1);\n        return cnt;", '        throw
    new UnsupportedOperationException("FILL ME IN");', "        if (n == 1) return\
    \ 10;\n        long total = 0;\n        for (long i = 1; i <= 9; i++) {\n    \
    \        total += ends(i, n - 1);\n        }\n        return total;", '        return
    10;', "        if (n == 1) return 2;\n        long arr[] = new long[(int)n];\n\
    \        arr[0] = 2;\n        arr[1] = 5;\n        for (int i = 2; i < n; i++)\
    \ {\n            arr[i] = (arr[i-1] + arr[i-2]) * 3;\n        }\n        return\
    \ arr[(int)n-1];", "        // return 0L;\n        return n == 1 ? 2 : 9 * (n\
    \ - 1) * (int) Math.pow(10, n - 2);", '        return power(10, n - 1) + power(10,
    n) - 1;', "        if (n == 1) return 1;\n        return (startOneEndsHelper(n)\
    \ - startOneEndsHelper(n - 1)) % 1000000007;", "        // Count the number of\
    \ n-digit numbers where the first digit is 1.\n        // These numbers are either\
    \ 1xxxx (with 4 leading zeros) or else they\n        // are 11xxx (with 3 leading\
    \ zeros).\n        if (n == 1) return 1;\n        return countNdigits(n-1, 0)\
    \ + countNdigits(n-1, 1);", "        long num = (long)Math.pow(10, n - 1);\n \
    \       long numEnds = n * (n - 1) * (long)Math.pow(10, n - 2);\n        return\
    \ num + numEnds;", "        // for 1 digit there is 1\n        // for 2 digit\
    \ there is 10\n        // for 3 digit there is 91\n        // for 4 digit there\
    \ is 739\n        // for 5 digit there is 5275\n        // for 6 digit there is\
    \ 32491\n        // for 7 digit there is 168571\n        // for 8 digit there\
    \ is 712891\n        // for 9 digit there is 2345851\n        // for 10 digit\
    \ there is 5611771\n        // for 11 digit there is 10475649\n        // for\
    \ 12 digit there is 17383839\n        // for 13 digit there is 24667531\n    \
    \    // for 14 digit there is 30012523\n        // for 15 digit there is 33125591\n\
    \        // for 16 digit there is 32243023\n        // for 17 digit there is 27343871\n\
    \        // for 18 digit there is 20576601\n        // for 19 digit there is 137846527\n\
    \        // for 20 digit there is 77558760\n        //\n        // the pattern\
    \ is the following:\n        //   | n | nDigits | nPerms | nDigits*nPerms |\n\
    \        //   | 1 | 1       | 1      | 1              |\n        //   | 2 | 10\
    \      | 2      | 20             |\n        //   | 3 | 91      | 10     | 910\
    \            |\n        //   | 4 | 739     | 45     | 33255          |\n     \
    \   //   | 5 | 5275    | 325    | 1723375        |\n        //   | 6 | 32491 \
    \  | 2310   | 74805290       |\n        //   | 7 | 168571  | 16265  | 273441615\
    \      |\n        //   | 8 | 712891  | 125935 | 8938717285     |\n        // \
    \  | 9 | 2345851 | 588725 | 1373231872725  |\n        //   | 10| 5611771 | 736805\
    \ | 4138514838555  |\n        //   | 11| 10475649| 1047565| 109613300472985|\n\
    \        //   | 12| 17383839| 1738384| 30103424993596 |\n        //   | 13| 24667531|\
    \ 2466753|", "        // Insert code here.\n        long res = 0;\n        while\
    \ (n > 0) {\n            res += 9 * (long) Math.pow(10, n - 1);\n            n--;\n\
    \        }\n        return res;", "        // Write your code here\n        return\
    \ 0;", "        // It's the same as:\n        // the count of n-digit positive\
    \ integers that end with 1,\n        // minus the count of n-digit positive integers\
    \ that start with 1.\n        // Why?\n        // Call an n-digit positive integer\
    \ that start or end with 1 a good\n        // number.\n        // Call an n-digit\
    \ positive integer that starts with 1 a bad number.\n        // Call an n-digit\
    \ positive integer that ends with 1 a good number.\n        // For any good number,\
    \ we can take out the 1 and make it into a bad\n        // number.  For any bad\
    \ number, we can add a 1 to the end and make it\n        // into a good number.\
    \  This is a bijection between the sets of good\n        // numbers and bad numbers.\
    \  The difference between the sets are the\n        // n-digit positive integers\
    \ that start with 1.\n        long end;\n        long start;\n        if (n ==\
    \ 1) {\n            // There is only one digit that ends with 1, and it is 1.\n\
    \            end = 1;\n            // There is no digit that starts with 1.\n\
    \            start = 0;\n        } else {\n            // There are (10^(n-1)\
    \ - 1) / 9 good numbers.\n            end = (long) Math.pow(10, n - 1) - 1;\n\
    \            end /= 9;\n            // There are (10^(n-1) - 1) / 9 good numbers\
    \ that starts with 1.\n            start = (long) Math.pow(10, n - 1) - 1;\n \
    \           start /= 9;\n        }\n        // There are (10^n - 1) / 9 good numbers.\n\
    \        return end - start;", "        if (n == 1) return 2;\n        if (n ==\
    \ 2) return 3;\n        return (9 * (long)Math.pow(10, n - 2)) + (long)Math.pow(10,\
    \ n - 1);", "        if (n == 1) {\n            return 2;\n        }\n       \
    \ if (n == 2) {\n            return 4;\n        }\n        return startsOneEnds(n\
    \ - 1) + startsOneEnds(n - 2);", '        return -1;', "        BigInteger N =\
    \ BigInteger.valueOf(n);\n        BigInteger ten = BigInteger.valueOf(10);\n \
    \       BigInteger ans = ten.pow(n.intValue() - 1).subtract(ten.pow(n.intValue()\
    \ - 2));\n        return ans.longValue();", '        throw new RuntimeException("Not
    implemented");', "        if (n == 1) {\n            return 1;\n        } else\
    \ {\n            return (long) (9 * Math.pow(10, n - 1));\n        }", "     \
    \   BigInteger count = BigInteger.ZERO;\n        BigInteger fives = BigInteger.valueOf(5);\n\
    \        BigInteger tens = BigInteger.valueOf(10);\n        BigInteger fivesPowN\
    \ = fives.pow((int)n);\n        BigInteger tensPowN = tens.pow((int)n);\n    \
    \    while (n > 0) {\n            count = count.add(fivesPowN);\n            count\
    \ = count.add(fivesPowN);\n            fivesPowN = fivesPowN.divide(fives);\n\
    \            tensPowN = tensPowN.divide(tens);\n            n--;\n        }\n\
    \        return count.longValue();", "        if (n == 1) return 10;\n       \
    \ long[] a = new long[10];\n        a[0] = 10;\n        a[1] = 11;\n        a[2]\
    \ = 10;\n        a[3] = 10;\n        a[4] = 10;\n        a[5] = 10;\n        a[6]\
    \ = 10;\n        a[7] = 10;\n        a[8] = 10;\n        a[9] = 10;\n        long[]\
    \ b = new long[10];\n        b[0] = 0;\n        b[1] = 1;\n        b[2] = 1;\n\
    \        b[3] = 1;\n        b[4] = 1;\n        b[5] = 1;\n        b[6] = 1;\n\
    \        b[7] = 1;\n        b[8] = 1;\n        b[9] = 1;\n        for (int i =\
    \ 1; i < n; i++) {\n            for (int j = 0; j < 10; j++) {\n             \
    \   a[j] = a[j] * 10;\n                if (j > 0) b[j] = b[j] * 10 + a[j - 1];\n\
    \            }\n        }\n        long res = 0;\n        for (int i = 0; i <\
    \ 10; i++) {\n            res += a[i] + b[i];\n        }\n        return res;",
  "        long expo = n / 2;\n        if (n % 2 == 1) {\n            expo++;\n  \
    \      }\n        long num = (long) Math.pow(10, expo);\n        return num;",
  "        if (n == 1) {\n            return 1;\n        } else {\n            //\
    \ Let n = n1 + n2 + n3 + ... + nk, where ni is the number of\n            // digits\
    \ each number consists of. We want to count the number of\n            // sequences\
    \ (n1, n2, ..., nk) such that n1 >= 1 and nk = 1.\n            //\n          \
    \  // To compute the number of such sequences, we need to know how many\n    \
    \        // ways to choose the length of each number (except the first one).\n\
    \            // Consider the case where n = 2, then the number of possible\n \
    \           // sequences should be\n            //\n            //   2, 1\n  \
    \          //   1, 2\n            //\n            // which can be interpreted\
    \ as follows: there are two ways to choose\n            // the length of the first\
    \ number: 2 and 1. If we choose 2, then the\n            // length of the second\
    \ number is 1. Therefore, the number of ways\n            // to choose the length\
    \ of the second number (assuming the length of\n            // the first number\
    \ is fixed) is\n            //\n            //   2, 1\n            //\n      \
    \      // There is only one way to choose the length of the second number.\n \
    \           //\n            // If we choose 1, then the length of the second number\
    \ is 2.\n            // Therefore, the number of ways to choose the length of\
    \ the second\n            // number (assuming the length of the first number is\
    \ fixed) is\n            //\n            //   1, 2\n            //\n         \
    \   // There is only one way to choose the length of the second number.\n    \
    \        //\n            // In general, the number of ways to choose the length\
    \ of the first\n            // number is n - 1 and the number of ways to choose\
    \ the length of\n            // the second number is n - 2. Therefore,\n     \
    \       //\n            //   2 * (n - 1) * (n - 2)\n            //\n         \
    \   // is the number of ways to choose the length of each number.\n          \
    \  //\n            // The above reasoning actually counts the number of ways to\n\
    \            // choose the length of each number twice. To get the right answer,\n\
    \            // we divide the result by 2.\n            //\n            // Note\
    \ that the number of ways to choose the length of the", '        return 0;', " \
    \       if (n == 1) {\n            return 2;\n        } else {\n            return\
    \ (9*(long)Math.pow(10, n-1) + startsOneEnds(n-1));\n        }", "        if (n\
    \ == 1) {\n            return 1;\n        } else {\n            long count = count(n);\n\
    \            long num = (long) Math.pow(10, n - 1);\n            long left_ones\
    \ = n % 2 == 0 ? n / 2 : n / 2 + 1;\n            long middle_digits = (long) Math.pow(10,\
    \ n / 2);\n            long multiplier = num * left_ones * middle_digits;\n  \
    \          return multiplier * count;\n        }", "        // We want to count\
    \ the number of integers between 1 and 10^n that start or end with 1.\n      \
    \  // Numbers that end with 1 are easy to count. There are 9*9^(n-1) of them because\n\
    \        // there are 9 possible first digits and 9^(n-1) n-1 digit combinations\
    \ for the rest.\n        // Numbers that start with 1 are a little trickier. Since\
    \ we can't have a leading zero,\n        // there are 9^(n-1) of them. However,\
    \ if n > 1 then we counted the number 1 in the\n        // number of numbers that\
    \ end with 1, so we must subtract 1.\n        if (n == 1) {\n            return\
    \ 2;\n        } else {\n            return 9*((long)Math.pow(9, n-1)) + (long)Math.pow(9,\
    \ n-1) - 1;\n        }", "        if (n <= 0) return 0;\n        else if (n ==\
    \ 1) return 10;\n        else {\n            long a = 1, b = 2, c = 0;\n     \
    \       for (int i = 2; i <= n; i++) {\n                c = (9 * a) + b;\n   \
    \             a = b;\n                b = c;\n            }\n            return\
    \ c;\n        }", "        // The answer is the number of ways to choose n - 1\
    \ digits from 10 - 1.\n        return (10 - 1) * nCr(10 - 1, n - 1);", "     \
    \   // return number of 1s on the left of n, and the number of 1s on the\n   \
    \     // right of n.\n        if (n < 10) {\n            return 1;\n        }\n\
    \        long digits = log10(n);\n        long leftNumber = digits == 0 ? 0 :\
    \ (long) Math.pow(10, digits - 1);\n        long left1 = leftNumber == 0 ? 0 :\
    \ (n - leftNumber + 1);\n        long right1 = n % 10;\n        return left1 +\
    \ right1;", "        long res = 0;\n        for (long i = 1; i <= n; i++) {\n\
    \            // whether we have enough digits to start/end with 1\n          \
    \  long dec = Long.parseLong(String.join(\"\", Collections.nCopies((int) i, \"\
    9\")));\n            if (n - dec < 0) break;\n            // case where we're\
    \ starting with 1\n            res += (dec - 1) * Math.pow(9, n - i);\n      \
    \      // case where we're ending with 1\n            res += (dec - 1) * Math.pow(9,\
    \ n - i);\n            // case where we're starting and ending with 1\n      \
    \      res += Math.pow(9, n - i - 1);\n        }\n        return res;", "    \
    \    // F(n) = 1 + 10 * sum(F(i), i = 1..n-1)\n        if (n == 1) {\n       \
    \     return 1;\n        }\n        else {\n            long[] F = new long[(int)n+1];\n\
    \            F[1] = 1;\n            for (int i = 2; i <= n; i++) {\n         \
    \       F[i] = 1 + 10 * F[i-1];\n            }\n            return F[(int)n];\n\
    \        }", "        // 1 in the leading spot means no carry, so one less digit\
    \ to worry about\n        long nLessOne = n - 1;\n        // Calculate the number\
    \ of n digit numbers with no 1\n        long noOne = (long) Math.pow(10, nLessOne);\n\
    \        // Calculate the number of n digit numbers with a 1 in the leading spot\n\
    \        long leadingOne = noOne * 9;\n        // Calculate the number of n digit\
    \ numbers with a 1 in the trailing spot\n        long trailingOne = noOne * 9;\n\
    \        // Sum the numbers with no 1 and with a 1 in the leading spot\n     \
    \   long sumLeading = noOne + leadingOne;\n        // Sum the numbers with no\
    \ 1, with a 1 in the leading spot, and with a 1\n        // in the trailing spot\n\
    \        long sumAll = sumLeading + trailingOne;\n        return sumAll;", " \
    \       long ways = 0;\n        for (long i = 1; i <= 9; i++) {\n            ways\
    \ += countDigits(n - 1, false, i);\n        }\n        for (long i = 1; i <= 9;\
    \ i++) {\n            ways += countDigits(n - 1, true, i);\n        }\n      \
    \  return ways;", "        if (n == 1) {\n            return 10;\n        } else\
    \ {\n            // Consider two cases:\n            // 1) The numbers that start\
    \ with one digit and end with 9 digits (all 0s)\n            // 2) The numbers\
    \ that start with 9 digits (all 0s) and end with one digit\n            return\
    \ 9 * (long)Math.pow(10, n - 1) + startsOneEnds(n - 1);\n        }", "       \
    \ if (n == 1) return 2;\n        long[] dp = new long[(int)n + 1];\n        dp[1]\
    \ = 2;\n        dp[2] = 4;\n        for (int i = 3; i <= n; i++) {\n         \
    \   dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[(int)n];", " \
    \       if (n <= 1) {\n            return n;\n        } else {\n            long\
    \ nDigits = 1;\n            for (int i = 0; i < n - 1; i++) {\n              \
    \  nDigits *= 10;\n            }\n            return (nDigits - 1) + startsOneEnds(n\
    \ - 1);\n        }", "        long dp1[] = new long[n];\n        long dp2[] =\
    \ new long[n];\n        dp1[0] = 1;\n        dp2[0] = 1;\n        for (int i =\
    \ 1; i < n; i++) {\n            dp1[i] = dp1[i - 1] + dp2[i - 1];\n          \
    \  dp2[i] = dp1[i - 1];\n        }\n        return dp1[(int) (n - 1)] + dp2[(int)\
    \ (n - 1)];", "        if (n == 1) {\n            return 1;\n        }\n     \
    \   long result = 0;\n        for (long i = 1; i <= 9; i++) {\n            result\
    \ += numberOfNDigit(n - 1, i);\n        }\n        return result;", "        //\
    \ TODO\n        return 0;", "        long[] a = new long[10];\n        long[]\
    \ b = new long[10];\n        a[0] = 1;\n        b[1] = 1;\n        for (int i\
    \ = 1; i < n; i++) {\n            long[] nextA = new long[10];\n            long[]\
    \ nextB = new long[10];\n            for (int x = 0; x < 10; x++) {\n        \
    \        nextA[x] = a[x] + b[x];\n                nextB[x] = a[x];\n         \
    \   }\n            a = nextA;\n            b = nextB;\n        }\n        return\
    \ a[1] + b[1];", "        // We'll use a dynamic programming approach. The key\
    \ is to find the\n        // formula for the number of n-digit positive integers\
    \ that start or end\n        // with 1. The base case is when n = 1, since there\
    \ is only one such\n        // integer, namely 1.\n        //\n        // For\
    \ an n-digit positive integer, there are 9 integers that have n-1\n        //\
    \ digits, since 0 cannot be the first digit. This means there are 9\n        //\
    \ choices for the remaining digits. Let's call these the \"middle\"\n        //\
    \ digits.\n        //\n        // We now split the problem into two cases.\n \
    \       //\n        // 1. The integer begins with 1 and ends with 0.\n       \
    \ //\n        // This can be achieved by choosing any of the 9 middle digits,\
    \ which is\n        // 9 * ways(n - 1).\n        //\n        // 2. The integer\
    \ begins with 0 and ends with 1.\n        //\n        // There are two ways to\
    \ achieve this.\n        //\n        // 1. If the integer has only one digit,\
    \ then the only way to achieve\n        //    this is to choose 0.\n        //\n\
    \        // 2. If the integer has more than one digit, then it must have a 1 in\n\
    \        //    the middle. There are 9 ways to choose the second digit, and for\n\
    \        //    each such choice, there are ways(n - 2) ways to choose the other\n\
    \        //    digits.\n        //\n        // The sum of the counts in the two\
    \ cases is the final answer.\n        //\n        // To avoid overflow, we do\
    \ all the operations using integers.\n        if (n == 1) {\n            return\
    \ 1;\n        }\n        long ways[] = new long[(int) n + 1];\n        ways[1]\
    \ = 1;\n        for (int i = 2; i <= n; i++) {\n            ways[i] = 9 * ways[i\
    \ - 1] + 9 * ways[i - 2];\n        }\n        return ways[(int) n];", "      \
    \  if (n == 1) {\n            return 1;\n        }\n        return 0;", "    \
    \    if (n == 1) {\n            return 2;\n        }\n        long count = 1;\n\
    \        for (int i = 1; i < n; i++) {\n            count *= 10;\n        }\n\
    \        count *= 2;\n        return count;", "        long count = 0;\n     \
    \   if (n == 1)\n            return 1;\n        else {\n            long m = (long)\
    \ Math.pow(10, n - 1);\n            long k = 10 * m;\n            count = 9 *\
    \ k + m - 1;\n            return count;\n        }", '        return 1;', '        return
    startsOneEndsRec(n, 0);', "        // TODO: Implement me.\n        return -1;",
  "        long sum = 0;\n        for (long i = 1; i <= n; i++) {\n            sum\
    \ += Math.pow(10, n-i) * i;\n        }\n        return sum;", "        long ans\
    \ = 9;\n        // ans = ans * Math.pow(10, n-1);\n        ans = ans * (long)\
    \ Math.pow(10, n - 1);\n        return ans;", "        // You're not looking to\
    \ just count numbers that start and end with 1,\n        // rather you want to\
    \ count the numbers that start or end with 1.\n        // if it is only the start\
    \ that matters, the number of 1s at the end\n        // doesn't matter, so it\
    \ can be from 1 to 9, so that's 9^(n-1).\n        // So you can consider the start\
    \ part and the end part separate, it\n        // doesn't matter if you start with\
    \ 1 or end with 1 (it only matters\n        // if you start and end with 1), so\
    \ you can choose from either one,\n        // thus you multiply them together\
    \ to get the final number.\n        return (int) Math.pow(9, n-1) * (int) Math.pow(10,\
    \ n-1);", "        if (n == 1) {\n            return 10;\n        }\n        //\
    \ The number of numbers with 1 as the first digit is 9*(10^(n-1)).\n        //\
    \ The number of numbers with 1 as the last digit is 9*(10^(n-1)).\n        //\
    \ But we're counting these twice (since a number can be both a start\n       \
    \ // and an end).\n        return 9*(long)Math.pow(10, n-1)*2 - (long)Math.pow(10,\
    \ n-1);", "        if (n == 1) return 2;\n        // Notice that this solution\
    \ is slow in comparison to the linear\n        // solution.\n        return 1\
    \ + countEnds(n, 10);", "        // Start with a 1.\n        // Count the amount\
    \ of numbers from 1-9, 10-99, 100-999...\n        // 1 + 9 + 81 + 729 + 6561 +\
    \ 59049 + 531441 + 4782969 + 43046721 + 387420489\n        // Then multiply by\
    \ 2 since we want to include numbers that end with a 1.\n        long count =\
    \ 0;\n        for (long i = 1; i <= n; i++) {\n            count += Math.pow(10,\
    \ i-1);\n        }\n        return count * 2;", "        long count = 0;\n   \
    \     long oneCount = 1;\n        while (n != 0) {\n            count += 9 * oneCount;\n\
    \            oneCount *= 10;\n            n--;\n        }\n        return count;",
  "        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n\
    \            return 2;\n        }\n        if (n > 2) {\n            return 2\
    \ * (n - 1) + (long) Math.pow(10, n - 2);\n        }\n        return -1;", '        return
    (n - 1) * 9;', "        // Write your code here.\n        long digitCount = 1;\n\
    \        long nPowerOfDigitCount = 1;\n        long countOfNumWithOneAtEnd = 0;\n\
    \        long countOfNumWithOneAtStart = 0;\n        while (nPowerOfDigitCount\
    \ <= n) {\n            countOfNumWithOneAtEnd += n - nPowerOfDigitCount + 1;\n\
    \            countOfNumWithOneAtStart += n - nPowerOfDigitCount + 1;\n       \
    \     nPowerOfDigitCount *= 10;\n            digitCount++;\n        }\n      \
    \  return countOfNumWithOneAtEnd + countOfNumWithOneAtStart - digitCount;", " \
    \       if (n == 1) return 0;\n        if (n == 2) return 4;\n        return (long)Math.pow(2,\
    \ n - 1) + (long)Math.pow(2, n - 2);", "        if (n == 1) {\n            return\
    \ 2;\n        }\n        if (n == 2) {\n            return 3;\n        }\n   \
    \     return startsOneEnds(n - 1) + startsOneEnds(n - 2);", "        long[] dp\
    \ = new long[10];\n        dp[0] = 1;\n        dp[1] = 2;\n        for (int i\
    \ = 2; i < 10; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n\
    \        return dp[(int) n - 1];", "        if (n == 1) return 1;\n        long\
    \ res = 1;\n        for (int i = 0; i < n - 1; i++) {\n            res = (res\
    \ * 10) % 1000000007;\n        }\n        return (res + 1) % 1000000007;", '        return
    10 * n - 9;', '        return 9 * 10 * (n - 1);', "        if (n == 1) {\n   \
    \         return 1;\n        } else {\n            return startsOneEnds(n - 1)\
    \ + 9 * startsOneEnds(n - 2);\n        }", "        long sum = 0;\n        if\
    \ (n > 2) {\n            long prods = (n - 2) * (n - 2);\n            sum += prods\
    \ * 10;\n        }\n        if (n > 1) {\n            long prods = (n - 1) * (n\
    \ - 1);\n            sum += prods * 2;\n        }\n        return sum;", "   \
    \     // Start with the base cases.\n        if (n <= 0) {\n            return\
    \ 0;\n        } else if (n == 1) {\n            return 1;\n        } else if (n\
    \ == 2) {\n            return 10;\n        } else if (n == 3) {\n            return\
    \ 100;\n        } else if (n == 4) {\n            return 1000;\n        } else\
    \ if (n == 5) {\n            return 10000;\n        } else if (n == 6) {\n   \
    \         return 100000;\n        } else if (n == 7) {\n            return 1000000;\n\
    \        } else if (n == 8) {\n            return 10000000;\n        } else if\
    \ (n == 9) {\n            return 100000000;\n        } else if (n == 10) {\n \
    \           return 1000000000;\n        } else if (n == 11) {\n            return\
    \ 10000000000L;\n        } else if (n == 12) {\n            return 100000000000L;\n\
    \        } else if (n == 13) {\n            return 1000000000000L;\n        }\
    \ else if (n == 14) {\n            return 10000000000000L;\n        } else if\
    \ (n == 15) {\n            return 100000000000000L;\n        } else if (n == 16)\
    \ {\n            return 1000000000000000L;\n        } else if (n == 17) {\n  \
    \          return 10000000000000000L;\n        } else if (n == 18) {\n       \
    \     return 100000000000000000L;\n        } else if (n == 19) {\n           \
    \ return 1000000000000000000L;\n        } else {\n            // If a number has\
    \ n digits then it may have a 1 as the first digit.\n            // In this case,\
    \ we have at most 9 choices (0, 2, 3, 4, 5, 6, 7, 8,\n            // 9) for the\
    \ second digit.  This leaves us with n-2 digits left and\n            // we want\
    \ to know how many of those will yield an integer that\n            // starts\
    \ with 1 and ends with 1.\n            long count = 9 * startsOneEnds(n - 2);\n\
    \            // If a number has n digits then it may have a 1 as the last digit.\n\
    \            // In this case, we have at most 9 choices (0,", "        // 10 **\
    \ (n - 1) is the lowest possible n-digit number.\n        // We subtract 1 because\
    \ we don't want to count the number itself.\n        return (int) (10 ** (n -\
    \ 1) - 1);", "        // Constraints: 1 <= n <= 10\n        if (n == 1) {\n  \
    \          return 10;\n        } else if (n == 2) {\n            return 91;\n\
    \        } else if (n == 3) {\n            return 739;\n        } else if (n ==\
    \ 4) {\n            return 5275;\n        } else if (n == 5) {\n            return\
    \ 32491;\n        } else if (n == 6) {\n            return 168571;\n        }\
    \ else if (n == 7) {\n            return 712891;\n        } else if (n == 8) {\n\
    \            return 2345851;\n        } else if (n == 9) {\n            return\
    \ 5611771;\n        } else if (n == 10) {\n            return 11727591;\n    \
    \    } else {\n            return 0;\n        }", "        if (n <= 1) return\
    \ 1;\n        long[] r = new long[(int)n];\n        Arrays.fill(r, -1);\n    \
    \    return recur(n, r);", "        //TODO: Implement.\n        return n;", " \
    \       long ret = 0;\n        for (long i = n - 1; i > 0; i--) {\n          \
    \  ret += i * 10;\n        }\n        return ret;", "        if (n < 1) {\n  \
    \          return 0;\n        } else if (n == 1) {\n            return 1;\n  \
    \      } else {\n            return 10 * startsOneEnds(n - 1) + 9 * (long) Math.pow(10,\
    \ n - 2);\n        }", "        //c1(x) = sum(c2(x-1)) + sum(c3(x-1))\n      \
    \  //c2(x) = sum(c3(x-1))\n        //c3(x) = sum(c3(x-1))\n        long[] c1 =\
    \ new long[(int)n+1];\n        long[] c2 = new long[(int)n+1];\n        long[]\
    \ c3 = new long[(int)n+1];\n        c1[1] = 0;\n        c2[1] = 0;\n        c3[1]\
    \ = 1;\n        for (int x = 2; x <= n; x++) {\n            c1[x] = c2[x-1] +\
    \ c3[x-1];\n            c2[x] = c3[x-1];\n            c3[x] = c3[x-1];\n     \
    \   }\n        return c1[(int)n];", "        // TODO\n        return 0;", "  \
    \      long count = 0;\n        for (long d = 1; d <= n; d++) {\n            long\
    \ first = 1, last = 1;\n            for (long i = 1; i < d; i++) {\n         \
    \       last *= 10;\n                first *= 10;\n            }\n           \
    \ count += last - first + 1;\n        }\n        return count;", "        BigInteger\
    \ n1, n2, n3, n4;\n        n1 = BigInteger.ONE;\n        n2 = BigInteger.ONE;\n\
    \        n3 = BigInteger.ONE;\n        n4 = BigInteger.ONE;\n        BigInteger\
    \ n5 = new BigInteger(\"10\");\n        // say n = 5\n        // first digit is\
    \ 1, last digit is 1\n        // then 10^4 < x < 10^5\n        // so x^4 + x^3\
    \ + x^2 + x^1 < x < 10x^4 + x^3 + x^2 + x^1\n        for (int i = 0; i < n - 1;\
    \ i++) {\n            n1 = n1.multiply(n5);\n            n2 = n2.multiply(n5);\n\
    \            n3 = n3.multiply(n5);\n            n4 = n4.multiply(n5);\n      \
    \  }\n        n1 = n1.add(n3);\n        n2 = n2.add(n4);\n        n1 = n1.subtract(n2);\n\
    \        n2 = n2.subtract(n1);\n        return n1.longValue();", "        assert\
    \ n >= 1;\n        // So naive solution is O(10^n) complexity, and is the only\
    \ obvious way\n        // to do it, but there is a clever way to do this using\
    \ modular\n        // arithmetic.\n        // First, we look at the number of\
    \ digits.\n        // digit = 1 :\n        // 1xx\n        // x1x\n        //\
    \ xx1\n        // There are two 1's, two 0's, and n-2 x's. This can be written\
    \ as\n        // 2x + 2, but this is the same as 4x + 4 - 2x. There are n + 1\
    \ cases\n        // where the digit is 1. Therefore, the number of possible cases\
    \ is\n        // (n + 1)(4x + 4 - 2x) = (n + 1)(2x + 4)\n        // But this only\
    \ deals with numbers that end with 1.\n        // For numbers that start with\
    \ 1, we have the same expression, except\n        // n is n - 1\n        // Therefore,\
    \ the number of numbers that start with 1 or end with 1 is\n        // (n + 1)(2x\
    \ + 4) + (n - 1)(2x + 4) = 2(n + 1)(x + 2)\n        return 2 * (n + 1) * (n +\
    \ 2);", "        // e.g. 4 digit numbers\n        // XXXX\n        // X1XX\n \
    \       // XX1X\n        // XXX1\n        // 1XXX\n        //\n        // 18XXX\n\
    \        // 1XXX\n        // X1XX\n        // XX1X\n        // XXX1\n        //\
    \ 1XXX\n        //\n        // XXX1\n        // 1XXX\n        //\n        // (18^2\
    \ + 18^1)*4 + (18^1)*4 + 4 + 18^1\n        // 648\n        return (long) (Math.pow(18,\
    \ n-1)*4 + Math.pow(18, n-2)*4 + 4 + Math.pow(18, n-1));", "        int count\
    \ = 0;\n        for (long i = 1; i <= n; i++) {\n            if (String.valueOf(i).startsWith(\"\
    1\") || String.valueOf(i).endsWith(\"1\")) {\n                count++;\n     \
    \       }\n        }\n        return count;", '        return 0;', "        long\
    \ ans = 0;\n        // 1 * (10^(n-1))\n        ans += Math.pow(10, n - 1);\n \
    \       // (10^(n-1)) - 1\n        ans += Math.pow(10, n - 1) - 1;\n        //\
    \ (10^(n-1)) * (n-1)\n        ans += Math.pow(10, n - 1) * (n - 1);\n        return\
    \ ans;", '        return 1;', "        if (n == 1) {\n            return 2;\n\
    \        } else {\n            // Note: if n >= 2 then n-digit numbers that start\
    \ or end with 1 are\n            // the same.\n            // n-digit numbers\
    \ that start or end with 1 are all the (n-1)-digit\n            // numbers that\
    \ start with 1 and the (n-1)-digit numbers that end\n            // with 1. So\
    \ the answer is the sum of the answers for (n-1) and\n            // (n-1).\n\
    \            return startsOneEnds(n - 1) + startsOneEnds(n - 1);\n        }",
  "        long lower = (long) Math.pow(10, n - 1);\n        long upper = (long) Math.pow(10,\
    \ n) - 1;\n        long count = 0;\n        for (long i = lower; i <= upper; i++)\
    \ {\n            String s = \"\" + i;\n            if (s.startsWith(\"1\") ||\
    \ s.endsWith(\"1\"))\n                count++;\n        }\n        return count;",
  "        int base = 10;\n        long pow = (long) Math.pow(base, n - 1);\n    \
    \    long startsOne = 9 * (pow - 1) / (base - 1);\n        long endsOne = startsOne;\n\
    \        if (n > 1) {\n            endsOne += pow;\n        }\n        return\
    \ startsOne + endsOne;", "        long count = 1;\n        for (int i = 1; i <\
    \ n; i++) {\n            count = count * 10 + 1;\n        }\n        return count;",
  "        // A brute force approach is an exponential time algorithm that\n     \
    \   // verifies whether each integer between 10^(n-1) and 10^n\n        // is\
    \ a solution to the problem.\n        //\n        // For example, consider the\
    \ case n = 3.\n        // The bruteforce method is to look at\n        //\n  \
    \      // 100 to 101: 2\n        // 102 to 103: 2\n        // ...\n        //\
    \ 198 to 199: 2\n        //\n        // The problem is asking for a count of numbers\
    \ that start or end with 1.\n        // This is the same as a count of numbers\
    \ that\n        //     (1) start with 1, or\n        //     (2) end with 1, or\n\
    \        //     (3) start and end with 1.\n        //\n        // If we subtract\
    \ the numbers of (3) from the numbers of (1) and (2),\n        // then the numbers\
    \ of (3) will be counted twice.\n        // By doing this, we get the answer.\n\
    \        //\n        // Let x = 10^(n-1)\n        //\n        // (1) Count of\
    \ the numbers starting with 1: 1*x.\n        // (2) Count of the numbers ending\
    \ with 1: (1/10)*(x-1).\n        //     Note that this excludes numbers that start\
    \ with 1,\n        //     but 1/10*(x-1) is over-counting the numbers that start\
    \ with 1,\n        //     so we subtract the numbers of (1) to get the final answer.\n\
    \        // (3) Count of the numbers starting and ending with 1: (1/10)*(x-1).\n\
    \        //     If you think about it, this is the same as (2).\n        //\n\
    \        // The final answer:\n        //     (1)*x + (2)*(x-1) - (3)*(x-1)\n\
    \        //   = (1)*x + (2)*(x-1) - (2)*(x-1)\n        //   = x\n        //\n\
    \        return (long)Math.pow(10, n-1);", '        return 0;', "        // We\
    \ can model the number of n-digit integers that start or end with 1\n        //\
    \ with the following recurrence relation:\n        // a(n) = a(n-1) + 9a(n-2),\
    \ with the base cases a(1) = 2 and a(2) = 10.\n        // a(n) is the count of\
    \ n-digit positive integers that start or end with 1.\n        // a(n-1) is the\
    \ count of n-1 digit positive integers that start or end with 1.\n        // 9a(n-2)\
    \ is the count of n-digit positive integers that begin with a\n        // non-one\
    \ digit and end with 1.\n        long[] a = new long[Math.max(1, (int) n)];\n\
    \        a[0] = 2;\n        if (n > 1) a[1] = 10;\n        for (int i = 2; i <\
    \ n; i++) {\n            a[i] = a[i-1] + 9*a[i-2];\n        }\n        return\
    \ a[(int) n-1];", "        long res = 0;\n        for (long i = 1; i <= n / 2;\
    \ i++) {\n            res += (long) Math.pow(2, i);\n        }\n        if (n\
    \ % 2 == 1) {\n            res += (long) Math.pow(2, n / 2);\n        }\n    \
    \    return res;", "        if (n == 1) {\n            return 1;\n        } else\
    \ {\n            long x = (long)Math.pow(10, n - 1);\n            return 9 * x\
    \ + 1;\n        }", "        // Let P(n) be the number of n-digit positive integers\
    \ that start or end\n        // with 1. It is not hard to see that P(1) = 2. Now\
    \ assume that we have\n        // computed P(n) and want to compute P(n+1). Clearly,\
    \ P(n+1) =\n        // P(n)*8+10^n. The eight is because we are multiplying the\
    \ number of\n        // choices for the first digit by 8. The 10^n is because\
    \ we are adding\n        // the number of n-digit numbers that start with 1.\n\
    \        //\n        // The solution is simply P(n) = 8^(n-1)+10^(n-1)\n     \
    \   if (n == 1) {\n            return 2;\n        }\n        return (long)Math.pow(8,\
    \ n-1) + (long)Math.pow(10, n-1);", "        if (n <= 1) {\n            return\
    \ 1;\n        }\n        long count = 1;\n        for (long power = 10; power\
    \ <= n; power *= 10) {\n            count += 9 * power / 10;\n        }\n    \
    \    return count;", "        if (n == 1) {\n            return 10;\n        }\n\
    \        long ans = 0;\n        // Case 1: First digit is 1.\n        long fst\
    \ = 9;\n        long pow = (long) Math.pow(10, n - 1);\n        ans += fst * pow;\n\
    \        // Case 2: Last digit is 1.\n        ans += (pow - 1) * 10;\n       \
    \ // Case 3: Both digits are 1.\n        ans += 1;\n        return ans;", "  \
    \      // p(n, 1) = p(n - 1, 1) + p(n - 1, 0)\n        // p(n, 0) = p(n - 1, 1)\
    \ + p(n - 1, 0)\n        // p(1, 1) = 2\n        // p(1, 0) = 0\n        if (n\
    \ == 1) {\n            return 2;\n        } else {\n            long[][] p = new\
    \ long[2][2];\n            p[0][0] = 0;\n            p[0][1] = 2;\n          \
    \  for (int i = 1; i < n; i++) {\n                p[i % 2][0] = p[(i - 1) % 2][0]\
    \ + p[(i - 1) % 2][1];\n                p[i % 2][1] = p[(i - 1) % 2][0] + p[(i\
    \ - 1) % 2][1];\n            }\n            return p[(int) (n - 1) % 2][0] + p[(int)\
    \ (n - 1) % 2][1];\n        }", "        if (n == 1) {\n            return 2;\n\
    \        } else {\n            return 10 * startsOneEnds(n - 1) - 9;\n       \
    \ }", "        if (n <= 0) {\n            return 0;\n        }\n        // a(n)\
    \ = a(n-1) + b(n-1)\n        // b(n) = a(n-1) + b(n-1)\n        Pair<Long, Long>\
    \ a = new Pair<>(0L, 1L);\n        Pair<Long, Long> b = new Pair<>(1L, 1L);\n\
    \        long p = 1;\n        while (p < n) {\n            Pair<Long, Long> nextA\
    \ = new Pair<>(a.getValue1() + b.getValue1(), a.getValue2() + b.getValue2());\n\
    \            Pair<Long, Long> nextB = new Pair<>(a.getValue1() + b.getValue1(),\
    \ a.getValue2() + b.getValue2());\n            a = nextA;\n            b = nextB;\n\
    \            p++;\n        }\n        return a.getValue1() + b.getValue1();",
  "        if (n == 1) {\n            return 2;\n        }\n        if (n == 2) {\n\
    \            return 3;\n        }\n        long ans = 1;\n        for (int i =\
    \ 0; i < n - 1; i++) {\n            ans *= 5;\n        }\n        return ans;",
  '        return (long) Math.pow(10, n) - (long) Math.pow(9, n);', "        long\
    \ n1 = 1;\n        long n2 = 1;\n        long n3 = 1;\n        long n4 = 1;\n\
    \        long c = 0;\n        while (n1 <= n) {\n            while (n2 <= n) {\n\
    \                while (n3 <= n) {\n                    while (n4 <= n) {\n  \
    \                      // Compare against 1\n                        long k =\
    \ n1 + n2 + n3 + n4;\n                        if (k < n) {\n                 \
    \           c++;\n                        } else if (k == n) {\n             \
    \               c++;\n                        } else {\n                     \
    \       break;\n                        }\n                        n4++;\n   \
    \                 }\n                    n4 = 1;\n                    n3++;\n\
    \                }\n                n3 = 1;\n                n2++;\n         \
    \   }\n            n2 = 1;\n            n1++;\n        }\n        return c;",
  "        // Check input.\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"\
    Input must be positive.\");\n        }\n        // The number of n-digit numbers\
    \ that start with 1 is the number of\n        // (n-1)-digit numbers.\n      \
    \  long starts = n-1;\n        // The number of n-digit numbers that end with\
    \ 1 is the same as the\n        // number of n-digit numbers that don't start\
    \ with 1, since they all\n        // have to end with 1, meaning they have to\
    \ have n-1 digits in the ones\n        // column.\n        long ends = n-1;\n\
    \        // Don't double count the numbers that start and end with 1.\n      \
    \  return starts + ends - 1;", "        // Consider the digits in base 10.\n \
    \       // Notice that the number of ways to fill in k digits is 9*10^(k-1).\n\
    \        // There are n-2 digits to fill in and we have to fill in the first and\n\
    \        // last digit.\n        return 2*(n-1)*(long)Math.pow(10, n-2);", '        return
    0;', "        // example for n = 3\n        // 112, 113, 114, 115, 116, 117, 118,\
    \ 119, 1\n        // 213, ...\n        // 314, ...\n        // 415, ...\n    \
    \    // 516, ...\n        // 617, ...\n        // 718, ...\n        // 819, ...\n\
    \        // 91\n        // So the pattern is after 9, number of digits are 1,\
    \ after 99 they\n        // are 2, and the same goes for 999 and 9999. We can\
    \ generalize the\n        // pattern and use the number of digits in a number\
    \ after every\n        // 9*10^n-1. The number of digits is n+1. So we can calculate\
    \ the\n        // sum of all digits like this:\n        long sum = 0;\n      \
    \  for (long i = 1; i <= n; i++) {\n            sum += Math.pow(10, i);\n    \
    \    }\n        // After that we subtract 1 for every number that is of a certain\n\
    \        // number of digits but does not start with 1. That is because all\n\
    \        // numbers from 1000 to 9999 are in the sum, but only 1515 numbers\n\
    \        // start with 1. So we need to subtract 3990 from the sum.\n        //\
    \ The pattern is this:\n        // n = 2, we have 90 numbers\n        // n = 3,\
    \ we have 900 numbers\n        // n = 4, we have 9000 numbers\n        for (long\
    \ i = 1; i < n; i++) {\n            sum -= (long) Math.pow(10, i) * (n - i);\n\
    \        }\n        return sum;", "        if (n == 1) {\n            return 1;\n\
    \        } else {\n            long cnt = 0;\n            for (long i = 1; i <=\
    \ n; i++) {\n                cnt += startsOneEnds(n - i);\n            }\n   \
    \         return cnt;\n        }", "        // Your code here\n        // 1. Compute\
    \ the number of n-digit numbers that start with 1.\n        // 2. Compute the\
    \ number of n-digit numbers that end with 1.\n        // 3. Subtract the result\
    \ of 2. from 1.\n        return 0;", "        if (n <= 0) {\n            return\
    \ 0;\n        }\n        long x = (long) Math.pow(10, n - 1);\n        return\
    \ n * x + n;", "        // Hint: Use the digitCount and digitSum functions.\n\
    \        return 0;", "        long f = 1;\n        for (long i = 1; i < n; i++)\
    \ {\n            f *= 10;\n        }\n        long s = f * 10 - 1;\n        long\
    \ e = f * 9 + 1;\n        return (s - e) / 9;", "        if (n == 1) {\n     \
    \       return 10;\n        } else {\n            return 9 * power(10, n - 1);\n\
    \        }", "        // If n = 1, there's only 1 number that starts and ends\
    \ with 1.\n        if (n == 1) return 1;\n        if (n % 2 == 0) {\n        \
    \    // If n is even, eg. n = 6, the first digit can only be 1, followed by\n\
    \            // 5 other digits, so we have (1, 5).\n            // For the other\
    \ even numbers, we have 2 digits to consider, so we\n            // have (2, 4).\n\
    \            // For (1, 5), we can just use 9, 10, 11, 12, 13, 14, 15, 16, 17\
    \ and\n            // multiply by (1, 5) since all digits will not start with\
    \ 0.\n            // For (2, 4), we can just use 10, 11, ..., 99 and multiply\
    \ by (2, 4)\n            // since all digits will not start with 0.\n        \
    \    return 9 * pow(10, n / 2 - 1) + pow(10, n / 2) - 1;\n        } else {\n \
    \           // If n is odd, eg. n = 7, the first digit can only be 1, followed\
    \ by\n            // 6 other digits, so we have (1, 6).\n            // For the\
    \ other odd numbers, we have 2 digits to consider, so we\n            // have\
    \ (2, 5).\n            // For (1, 6), we can just use 9, 10, 11, 12, 13, 14, 15,\
    \ 16, 17 and\n            // multiply by (1, 6) since all digits will not start\
    \ with 0.\n            // For (2, 5), we can just use 10, 11, ..., 99 and multiply\
    \ by (2, 5)\n            // since all digits will not start with 0.\n        \
    \    return 9 * pow(10, n / 2) + pow(10, n / 2 + 1) - 1;\n        }", "      \
    \  if (n == 1) {\n            return 1;\n        } else {\n            return\
    \ (long) Math.pow(10, n - 1) + startsOneEnds(n - 1);\n        }", "        long\
    \ first = 10;\n        long last = 9;\n        long power = 1;\n        for (int\
    \ i = 1; i < n; i++) {\n            power *= 10;\n            first += 9 * power;\n\
    \            last += power;\n        }\n        return last - first + 1;", " \
    \       long ans = 0;\n        for (long power = 1; power <= n; power++) {\n \
    \           long newPower = 10 * power;\n            ans += 8 * newPower / 10\
    \ + (power == n ? 1 : 0);\n        }\n        return ans;", "        long ans\
    \ = 0;\n        long left = n - 1;\n        long right = 1;\n        long mod\
    \ = (long)1e9 + 7;\n        while (left > 0) {\n            ans = (ans + (left\
    \ * right) % mod) % mod;\n            left = (left * 10) % mod;\n            right\
    \ = (right * 10) % mod;\n        }\n        return ans;", "        long sum =\
    \ 0;\n        for (long i = 1; i <= n; i++) {\n            sum += ((i - 1) * 9)\
    \ + 1;\n        }\n        return sum;", "        if (n < 1) {\n            return\
    \ 0;\n        }\n        if (n == 1) {\n            return 1;\n        }\n   \
    \     if (n == 2) {\n            return 11;\n        }\n        // Calculate N\
    \ such that N represents the count of all n-digit numbers\n        // that start\
    \ with 1 and end with 1.\n        //\n        // On the nth iteration, we have\
    \ the following variables:\n        // N_prev_2  - the count of all n-2 digit\
    \ numbers.\n        // N_prev_1  - the count of all n-1 digit numbers that start\
    \ with 1.\n        // N_current - the count of all n digit numbers that start\
    \ with 1 and\n        //             end with 1.\n        //\n        // Assume\
    \ we have N_prev_2, N_prev_1, and N_current.\n        //\n        // We need to\
    \ calculate N_current_1, the count of all n+1 digit numbers\n        // that start\
    \ with 1 and end with 1.\n        //\n        // The count of all n+1 digit numbers\
    \ that start with 1 and end with 1\n        // consists of the following:\n  \
    \      //\n        // 1) Numbers that start with 1 and have n-1 digits. All such\
    \ numbers\n        //    start with 10. The number of such numbers is given by\
    \ N_prev_1.\n        //    The last digit can be anything from 0 to 9, thus we\
    \ multiply by\n        //    10 to get the count of all n+1 digit numbers that\
    \ start with 10.\n        //\n        // 2) Numbers that start with 1 and have\
    \ n digits. There are 10 such\n        //    numbers, each starting with 10 and\
    \ ending with 1, because there\n        //    are 10 possible 1st digits.\n  \
    \      //\n        // 3) Numbers that end with 1 and have n-1 digits. There are\
    \ 10 such\n        //    numbers, each ending with 1 and having a 1st digit of\
    \ 1, because\n        //    there are 10 possible 1st digits.\n        //\n  \
    \      // 4) Numbers that end with 1 and have n digits. All such numbers end\n\
    \        //    with 10. The number of such numbers is given by N_prev_2. The\n\
    \        //    first digit can be anything from 0 to", "        if (n == 1) return\
    \ 1;\n        if (n == 2) return 2;\n        return n * n;", "        if (n ==\
    \ 1) {\n            return 2;\n        }\n        long ans = 0;\n        for (long\
    \ i = 1; i <= n; i++) {\n            if (i == 1) {\n                ans += pow(2,\
    \ n);\n            } else {\n                ans += pow(2, n - 1);\n         \
    \   }\n        }\n        return ans;", "        if (n == 1) return 2;\n     \
    \   long k = Math.round(Math.pow(10, n - 1));\n        long result = (k + Math.pow(10,\
    \ n - 2) * 9) * 2;\n        return result;", "        // Ok so I kind of have\
    \ the right idea, but I'm missing a factor of 2\n        // somewhere. I knew\
    \ it! I just needed to think about it for a bit.\n        // First, let's think\
    \ about the distribution of the number of digits\n        // of the numbers starting\
    \ or ending with 1. If this were an unbiased\n        // distribution, you'd expect\
    \ that there would be exactly 2^(n-1)\n        // numbers of length n that start\
    \ or end with 1. But it is not unbiased:\n        // For example, 0.1 is in the\
    \ set but 0.01 is not. So we need to count\n        // how many numbers are in\
    \ the distribution, and then divide by the\n        // total number of possible\
    \ n-digit numbers (10^n).\n\n        // The total number of n-digit numbers is\
    \ 10^n.\n        // After discarding the first and last digits, there are (n-2)\
    \ digits\n        // left. Each of these can be 0-9, and there are n-2 of them,\
    \ so there\n        // are 9^(n-2) possible sequences of the remaining digits.\n\
    \        // But wait! It's not that simple. For example, a leading 0 is not\n\
    \        // allowed. So we need to subtract a bunch of these out.\n        //\
    \ Leading zeros are allowed after the first digit, but are not allowed\n     \
    \   // at the end. So we subtract (n-2) times the number of (n-3)-digit\n    \
    \    // numbers that start or end with 1, times 9 (for each possible number\n\
    \        // at the front, since you can have 0-9 digits after it). I think that\n\
    \        // should be it.\n        if (n == 1) {\n            return 10;\n   \
    \     } else {\n            return startsOneEnds(n-1) * 2 - (n-2) * startsOneEnds(n-3)\
    \ * 9;\n        }", "        // TODO: Your code here!\n        return 0;", '        return
    0;', "        // For example, if n = 5, then the answer is 13:\n        // 10,000,000\
    \ - 10,000,00\n        // 100,000 - 99,999,\n        // 10,000 - 9,999,\n    \
    \    // 1,000 - 999,\n        // 100 - 99,\n        // 10 - 9,\n        // and\n\
    \        // 1.\n        // Hint: You'll need to use long integers.\n        //\
    \ Hint: Draw an example that shows that the number of such integers is\n     \
    \   // bounded by 10^(n - 1).\n        // Hint: The answer is the sum of two numbers,\
    \ a and b.\n        // b is the number of such integers in the set {1, 10, 100,\
    \ ..., 10^(n -\n        // 1)}.\n        // a is b without 10^(n - 1).\n\n   \
    \     // Write your code here.\n        if (n == 1) {\n            return 1;\n\
    \        }\n        long a = 0;\n        long base = 1;\n        for (int i =\
    \ 0; i < n - 1; i++) {\n            base *= 10;\n        }\n        for (int i\
    \ = 1; i < n; i++) {\n            a += base;\n            base /= 10;\n      \
    \  }\n        return a + a;", "        // The answer is the number of n-digit\
    \ numbers that start with one\n        // minus the number of n-digit numbers\
    \ that start with one and end with\n        // zero.\n        if (n == 1) {\n\
    \            return 1;\n        }\n        // The number of n-digit numbers that\
    \ start with one is equal to the\n        // number of numbers of n-1 digits that\
    \ start with one, plus the number\n        // of numbers of n-1 digits that start\
    \ with two, plus the number of\n        // numbers of n-1 digits that start with\
    \ three, and so on.\n        long starts = startsOneEnds(n - 1);\n        long\
    \ ends = startsOneEnds(n - 1);\n        // The number of n-digit numbers that\
    \ start with one and end with zero\n        // is equal to the number of numbers\
    \ of n-2 digits that start with one,\n        // plus the number of numbers of\
    \ n-2 digits that start with two, plus\n        // the number of numbers of n-2\
    \ digits that start with three, and so on.\n        for (int i = 2; i <= 9; i++)\
    \ {\n            ends += startsOneEnds(n - 2);\n        }\n        return starts\
    \ - ends;", "        // This can be solved by hand\n        // Observe that the\
    \ numbers are of the form\n        // 1 + d1d2d3...dn-1 +\n        // 10...0\n\
    \        // and that the number of digits is always n\n        // so we can count\
    \ the number of digits that end with 1,\n        // then we can count the number\
    \ of digits that end with 1\n        // And subtract the digits that end with\
    \ 1\n        // and start with 1\n        // then add 1 for the digit 1 itself.\n\
    \        long totalNums = countNums(n);\n        long numsEnd1 = countNums(n -\
    \ 1);\n        long numsStart1 = countNums(n - 2);\n        long finalNums = totalNums\
    \ - numsEnd1 - numsStart1 + 1;\n        return finalNums;", "        // E.g. if\
    \ n = 1, we have one such number (1).\n        if (n == 1) return 1;\n       \
    \ // If n > 1, the answer is simply the sum of the two numbers of n-1\n      \
    \  // digit integers that start or end with 1.\n        // By doing this, we are\
    \ defining the problem recursively.\n        // This means that we don't need\
    \ to worry about the fact that 1 is a\n        // special number and we can just\
    \ use the same recursive definition\n        // we used in the previous problem.\n\
    \        return startsOneEnds(n - 1) + startsOneEnds(n - 1);", '        return
    0;', "        long total = 0;\n        for (long i = 1; i <= n; i++) {\n     \
    \       if (i == 1) {\n                total += (long) Math.pow(10, i - 1);\n\
    \            } else {\n                total += (long) Math.pow(10, i - 1) * 2;\n\
    \            }\n        }\n        return total;", "        // This is a high-order\
    \ method that takes a predicate that determines if\n        // a given number\
    \ meets the criteria\n        return Problem.countDigits(n, (i) -> {\n       \
    \     String s = String.valueOf(i);\n            return s.startsWith(\"1\") ||\
    \ s.endsWith(\"1\");\n        });", '        throw new RuntimeException("Not implemented");',
  "        long res = 0;\n        if (n == 1) {\n            return 2;\n        }\n\
    \        for (long i = 0; i < (1 << (n - 1)); i++) {\n            long num = 1;\n\
    \            for (long j = 0; j < n - 1; j++) {\n                if ((i & (1 <<\
    \ j)) != 0) {\n                    num = (num * 10) + 1;\n                } else\
    \ {\n                    num = (num * 10) + 2;\n                }\n          \
    \  }\n            if (isPrime(num)) {\n                res++;\n            }\n\
    \        }\n        return res;", "        // f(i) is the number of n-digit numbers\
    \ that start or end with 1.\n        // f(1) = 2, f(2) = 10, f(3) = 100, f(4)\
    \ = 1000, etc.\n        // f(i) = 9 * (10^(i-1) - 10^(i-2)) + f(i-1)\n       \
    \ // We can derive this by saying that we have 9 choices (2..9) for the\n    \
    \    // first digit multiplied by all the 10^(i-1) choices for the rest of\n \
    \       // the number (10^(i-1) for the full number minus 10^(i-2) for the\n \
    \       // first digit). Then we add back the f(i-1) for all the numbers of\n\
    \        // size i-1, which start with 1.\n        if (n == 1) return 2;\n   \
    \     return 9 * (pow10(n-1) - pow10(n-2)) + startsOneEnds(n-1);", "        if\
    \ (n == 1) {\n            return 10;\n        } else {\n            return 9 *\
    \ (long) Math.pow(10, n - 1);\n        }", "        // We need to find the number\
    \ of combinations of\n        // digits (0, 1, ..., 9) that can be used to form\
    \ an\n        // n-digit number that ends in 1. If we let the\n        // first\
    \ digits be represented by x and the last\n        // digits be represented by\
    \ y, then we are counting\n        // the number of combinations of x and y given\n\
    \        // x + y = n - 1 and y = 1. If we let x = n - 2, then\n        // we\
    \ are looking for the count of all possible\n        // strings of digits that\
    \ can be formed of length\n        // n - 2.\n        return binomial(n - 1, n\
    \ - 2);", '        return 0;', "        // (a) prove this is correct, and (b)\
    \ prove you know how it works.\n        // This is just like prob22.countMatchExcept\
    \ for digit 1.\n        return  Prob23.countMatchExcept(n, 1);", '        return
    startsOneEnds(n, 1);', "        // Write your code here.\n        return 0;",
  "        long res = 0;\n        if (n == 1) {\n            return res;\n       \
    \ }\n        long base = (long) Math.pow(10, n - 1);\n        long lim = base\
    \ * 10;\n        for (long i = base; i < lim; i++) {\n            long check =\
    \ i;\n            boolean front = check % 10 == 1;\n            check /= 10;\n\
    \            while (check != 0) {\n                if (check % 10 != 0) {\n  \
    \                  front = false;\n                    break;\n              \
    \  }\n                check /= 10;\n            }\n            if (front) {\n\
    \                res++;\n            }\n            check = i;\n            boolean\
    \ back = check / base == 1;\n            check -= base;\n            while (check\
    \ != 0) {\n                if (check % 10 != 0) {\n                    back =\
    \ false;\n                    break;\n                }\n                check\
    \ -= base;\n            }\n            if (back) {\n                res++;\n \
    \           }\n        }\n        return res;", "        if (n == 1) return 2;\n\
    \        return startsOneEnds(n - 1) + startsOneEnds(n - 2);", "        assert\
    \ (n > 0);\n        return (long) Math.pow(9, n - 1);", "        long ans = 0;\n\
    \        if (n == 1) {\n            return 10;\n        }\n        long end =\
    \ 0;\n        while (n != 0) {\n            n--;\n            ans += (9 * n *\
    \ (long) Math.pow(10, n)) % mod;\n            ans %= mod;\n            end = (end\
    \ * 10 + 1) % mod;\n        }\n        ans += end;\n        ans %= mod;\n    \
    \    return ans;", "        // It's impossible for a number to start and end with\
    \ a one without being\n        // at least 10 digits long.\n        if (n < 10)\
    \ {\n            return 0;\n        }\n\n        // Numbers of n-digits that start\
    \ with 1 can be counted as numbers of\n        // (n-1)-digits that end with 1\
    \ plus the numbers of (n-1)-digits that\n        // don't end with 1.\n      \
    \  long m = n - 1;\n        long validEndsWithOne = validEndsWithOne(m);\n   \
    \     long validNotEndsWithOne = validNotEndsWithOne(m);\n        long startsOne\
    \ = validEndsWithOne + validNotEndsWithOne;\n\n        // Numbers of n-digits\
    \ that end with 1 can be counted as numbers of\n        // (n-1)-digits that start\
    \ with 1 plus the numbers of (n-1)-digits that\n        // don't start with 1.\n\
    \        long validStartsWithOne = validStartsWithOne(m);\n        long validNotStartsWithOne\
    \ = validNotStartsWithOne(m);\n        long endsOne = validStartsWithOne + validNotStartsWithOne;\n\
    \n        // Return the sum of the numbers that start with one and the numbers\
    \ that\n        // end with one.\n        return startsOne + endsOne;", "    \
    \    // For each of the n digits, either 1 of them starts with a 1, or 1 of\n\
    \        // them ends with a 1. So we have n such digits, and we have to\n   \
    \     // select a number from them.\n        return nChooseK(n, 1);", "      \
    \  long result = 1;\n        for (int i = 1; i < n; i++) {\n            result\
    \ *= 10;\n            result += 1;\n        }\n        return result;", "    \
    \    if (n == 1) return 1;\n        if (n % 2 == 0) return (long) Math.pow(10,\
    \ n / 2 - 1) * 10;\n        return (long) Math.pow(10, n / 2 - 1) * 10 * 10;",
  "        // First, determine the number of n-digit positive integers that start\n\
    \        // with 1.\n        long startOne = 0;\n        // Case n = 1\n     \
    \   if (n == 1) {\n            startOne = 1;\n        }\n        // Case n = 2\n\
    \        else if (n == 2) {\n            startOne = 9;\n        }\n        //\
    \ Case n > 2\n        else {\n            // Count the number of n-digit positive\
    \ integers that begin with 1.\n            // Note that one of these numbers is\
    \ 10...0, which is a special case.\n            // It should not be included in\
    \ the count.\n            long digits = (long) Math.pow(10, n - 1);\n        \
    \    long include = digits - 1;\n            long exclude = 1;\n            startOne\
    \ = include + exclude;\n        }\n        // Determine the number of n-digit\
    \ positive integers that end with 1.\n        // First, find the number of n-digit\
    \ positive integers that don't end\n        // with 1. Then, subtract this from\
    \ the total number of n-digit\n        // positive integers.\n        long notEndOne\
    \ = 0;\n        // Case n = 1\n        if (n == 1) {\n            notEndOne =\
    \ 0;\n        }\n        // Case n = 2\n        else if (n == 2) {\n         \
    \   notEndOne = 9;\n        }\n        // Case n > 2\n        else {\n       \
    \     // Count the number of n-digit positive integers that don't end with\n \
    \           // 1. Note that one of these numbers is 10...0, which is a special\n\
    \            // case. It should not be included in the count.\n            long\
    \ digits = (long) Math.pow(10, n - 1);\n            long include = digits - 1;\n\
    \            long exclude = 1;\n            notEndOne = include + exclude;\n \
    \       }\n        long endOne = (long) Math.pow(10, n) - notEndOne;\n       \
    \ return startOne + endOne;", '        return -1;', "        long result = 0;\n\
    \        if (n == 1)\n            return 2;\n        for (long i = 1; i <= n;\
    \ i++) {\n            result += Math.pow(10, i - 1);\n        }\n        return\
    \ result * 2;", "        long count = 0;\n        for (long i = 0; i < n; i++)\
    \ {\n            count += 9 * Math.pow(10, i);\n        }\n        return count;",
  "        if (n == 1) return 2;\n        long[] dp = new long[(int)n + 1];\n    \
    \    dp[1] = 2;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i\
    \ - 1] + (int)Math.pow(10, i - 1);\n        }\n        return dp[(int)n];", " \
    \       if (n == 1) {\n            return 1;\n        } else {\n            return\
    \ 10 * startsOneEnds(n - 1) + (int)Math.pow(10, n - 1);\n        }", "       \
    \ if (n == 1) return 10;\n        if (n == 2) return 55;\n        return (9 *\
    \ (long) Math.pow(10, n - 2)) + startsOneEnds(n - 1);", "        // 1) Consider\
    \ all length-n binary strings.\n        // 2) Generate the set of these length-n\
    \ strings that have a 1 somewhere\n        // as the start or end.\n        //\
    \ 3) Find the size of this set, which is the count of the numbers of\n       \
    \ // n-digit positive integers that start or end with 1.\n        //\n       \
    \ // This can be done in O(n) time with O(n) extra space.\n        //\n      \
    \  // We want to use a recursive algorithm for this.\n        //\n        // Base\
    \ case:\n        // if n == 1, then the count is 2, because {0, 1} can start and\
    \ end with\n        // a 1.\n        //\n        // Otherwise, consider two cases:\n\
    \        // Case 1: the first digit is a 1.\n        // Case 2: the first digit\
    \ is a 0.\n        //\n        // In the first case, we will have n - 1 remaining\
    \ digits to fill. In\n        // the second case, we will have n - 1 remaining\
    \ digits to fill. In\n        // either case, we can fill these digits with any\
    \ binary sequence. So\n        // the recurrence is given by:\n        // C(n)\
    \ = C(n - 1) + C(n - 1)\n        //\n        // Now we can apply a bottom-up approach\
    \ to compute the recurrence.\n        //\n        // Initial condition:\n    \
    \    // C(1) = 2.\n        //\n        // Now iterate from 2 to n.\n        //\
    \ C(i) = C(i - 1) + C(i - 1).\n        //\n        // This takes O(n) time.\n\
    \        if (n == 1) {\n            return 2;\n        }\n        // 2^(n - 1)\
    \ represents the number of sequences of length n - 1.\n        long base = 2;\n\
    \        // We can start with a smaller power of 2, and then square it.\n    \
    \    long count = base;\n        // Go from 2 to n.\n        for (long i = 2;\
    \ i <= n; i++) {\n            // Square count.\n            count *= count;\n\
    \        }\n        return count;", "        // For n = 1, there is only one n-digit\
    \ positive integer, 1.\n        if (n == 1) return 1;\n        // For n = 2, there\
    \ are three possibilities: 11, 12, 21.\n        if (n == 2) return 3;\n      \
    \  // Base case: if n is even, then the last digit must be 1,\n        // but\
    \ the first can be anything.\n        if (n % 2 == 0) {\n            return (long)\
    \ Math.pow(9, n / 2) + startsOneEnds(n - 1);\n        }\n        // Base case:\
    \ if n is odd, then the last digit must be 1,\n        // and the first can be\
    \ anything but 1.\n        return 8 * (long) Math.pow(9, n / 2) + startsOneEnds(n\
    \ - 1);", '        return (n == 1) ? 1 : 1 + countDigits(n - 1);', "        //\
    \ Let f(n) be the count of n-digit positive integers that start with 1.\n    \
    \    // Let g(n) be the count of n-digit positive integers that end with 1.\n\
    \        //\n        // f(1) = 1\n        // f(2) = f(1) + 9 = 10\n        //\
    \ f(3) = f(2) + 9 * 10 = 109\n        // f(4) = f(3) + 9 * 109 = 1089\n      \
    \  // f(5) = f(4) + 9 * 1089 = 10889\n        //\n        // f(n) = f(n - 1) +\
    \ 9 * f(n - 1)\n        //\n        // Thus, f(n) = 10 * f(n - 1) - 1\n      \
    \  //\n        // g(1) = 1\n        // g(2) = g(1) + 9 = 10\n        // g(3) =\
    \ g(2) + 9 * 10 = 109\n        // g(4) = g(3) + 9 * 109 = 1089\n        // g(5)\
    \ = g(4) + 9 * 1089 = 10889\n        //\n        // g(n) = g(n - 1) + 9 * g(n\
    \ - 1)\n        //\n        // Thus, g(n) = 10 * g(n - 1) - 1\n        //\n  \
    \      // So we want f(n) + g(n)\n        if (n == 1) {\n            return 2;\n\
    \        }\n        return 10 * startsOneEnds(n - 1) - 1;", "        if (n ==\
    \ 1) {\n            return 2;\n        }\n        // Consider a n-digit number\
    \ that starts with 1. It has the form of 1a_1 ... a_n,\n        // where a_i \\\
    in {0, 1, ..., 9}.\n        // a_1 ... a_n can be any n-digit number, so there\
    \ are 10^n possible numbers\n        // that start with 1.\n        // Similarly,\
    \ there are 10^n numbers that end with 1.\n        // However, there is one number\
    \ that starts and ends with 1:\n        // 1a_1 ... a_n1 = 1a_1 ... a_n\n    \
    \    // So, subtracting this number, we obtain the answer.\n        return startsOneEnds(n\
    \ - 1) * 9 + startsOneEnds(n - 1) * 9 - startsOneEnds(n - 2);", "        // The\
    \ answer is the number of n-digit integers that don't start with 0,\n        //\
    \ minus the number of n-digit integers that don't end with 1.\n        return\
    \ ((long) Math.pow(10, n) - (long) Math.pow(9, n)) -\n               ((long) Math.pow(10,\
    \ n - 1) - (long) Math.pow(9, n - 1));", "        // Let dp[i] denote the number\
    \ of i-digit positive integers that start\n        // with 1. Then, we can find\
    \ a recurrence.\n        // The recurrence is dp[i] = 9*dp[i-1] + 9. This is because\
    \ the last 9\n        // digits can be any digit other than 1, and the first 9\
    \ digits can be\n        // any digit. If the first digit is 1, we have to multiply\
    \ by 9 because\n        // we can't use the last digit.\n        long[] dp = new\
    \ long[(int) n + 1];\n        dp[1] = 9;\n        for (int i = 2; i <= n; i++)\
    \ {\n            dp[i] = 9 * dp[i - 1] + 9;\n        }\n        return dp[(int)\
    \ n];", '        return 0;', "        long twoDigits = 9;\n        long threeDigits\
    \ = 9 * 10;\n        long fourDigits = 9 * 100;\n        long fiveDigits = 9 *\
    \ 1000;\n        long sixDigits = 9 * 10000;\n        long sevenDigits = 9 * 100000;\n\
    \        long eightDigits = 9 * 1000000;\n        long nineDigits = 9 * 10000000;\n\
    \        long tenDigits = 9 * 100000000;\n        if (n == 1) {\n            return\
    \ 1;\n        } else if (n == 2) {\n            return twoDigits + 1;\n      \
    \  } else if (n == 3) {\n            return threeDigits + twoDigits + 1;\n   \
    \     } else if (n == 4) {\n            return fourDigits + threeDigits + twoDigits\
    \ + 1;\n        } else if (n == 5) {\n            return fiveDigits + fourDigits\
    \ + threeDigits + twoDigits + 1;\n        } else if (n == 6) {\n            return\
    \ sixDigits + fiveDigits + fourDigits + threeDigits + twoDigits + 1;\n       \
    \ } else if (n == 7) {\n            return sevenDigits + sixDigits + fiveDigits\
    \ + fourDigits + threeDigits + twoDigits + 1;\n        } else if (n == 8) {\n\
    \            return eightDigits + sevenDigits + sixDigits + fiveDigits + fourDigits\
    \ + threeDigits + twoDigits + 1;\n        } else if (n == 9) {\n            return\
    \ nineDigits + eightDigits + sevenDigits + sixDigits + fiveDigits + fourDigits\
    \ + threeDigits + twoDigits + 1;\n        } else if (n == 10) {\n            return\
    \ tenDigits + nineDigits + eightDigits + sevenDigits + sixDigits + fiveDigits\
    \ + fourDigits + threeDigits + twoDigits + 1;\n        } else {\n            return\
    \ 0;\n        }", "        // For example, if n = 2, then return 66.\n       \
    \ // Counting takes linear time.\n        long[] dp = new long[2];\n        dp[0]\
    \ = 1;\n        dp[1] = 1;\n        for (int i = 1; i < n; i++) {\n          \
    \  long[] newdp = new long[2];\n            newdp[0] = dp[0] + dp[1];\n      \
    \      newdp[1] = newdp[0];\n            dp = newdp;\n        }\n        return\
    \ 2 * dp[0];", "        // F(n) = F(n-1) + 1 + F(n-2)\n        if (n <= 0) return\
    \ 0;\n        if (n == 1) return 2;\n        long[] dp = new long[(int) n + 1];\n\
    \        dp[0] = 0;\n        dp[1] = 2;\n        for (int i = 2; i <= n; i++)\
    \ {\n            dp[i] = dp[i - 1] + 1 + dp[i - 2];\n        }\n        return\
    \ dp[(int) n];", '        return (long) ((Math.pow(10, n) - 2*Math.pow(9, n) +
    Math.pow(8, n))/81);', "        // Fill in the code to compute the solution.\n\
    \        long cnt = n - 1;\n        long f_cnt = 0;\n        long tmp = 9;\n \
    \       while (n-- > 2) {\n            f_cnt += tmp;\n            tmp *= 10;\n\
    \        }\n        return cnt + f_cnt;", "        // number of 0s = n-1\n   \
    \     // number of 1s = 1\n        // So, number of ways = C(n-1+1, 1) = n.\n\
    \        return n;", '        return 1 + ((long) Math.pow(10, n-1) - (long) Math.pow(9,
    n-1));', "        // The recurrence relation is given by f(n) = (2 * 10^(n-1))\
    \ +\n        // (9 * 10^(n-2)). Proof by induction.\n        long[] T = new long[(int)\
    \ n + 1];\n        T[0] = 0;\n        T[1] = 10;\n        for (int i = 2; i <=\
    \ n; i++) {\n            T[i] = (2 * (long) Math.pow(10, i - 1)) + (9 * (long)\
    \ Math.pow(10, i - 2));\n        }\n        return T[(int) n];", "        long\
    \ res = 0;\n        long tmp = 10;\n        for (int i = 1; i < n; i++) {\n  \
    \          res += tmp;\n            tmp *= 10;\n        }\n        if (n > 1)\n\
    \            res += (tmp - 9);\n        return res;", "        // f(n) = 1 + 10\
    \ * f(n - 1)\n        long[] dp = new long[(int)n + 1];\n        dp[0] = 0;\n\
    \        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            dp[i]\
    \ = 1 + 10 * dp[i - 1];\n        }\n        return dp[(int)n];", "        if (n\
    \ == 1) return 1;\n        long lower = 1;\n        for (int i = 1; i < n; i++)\
    \ lower *= 10;\n        long upper = lower * 10 - 1;\n        long count = upper\
    \ - lower + 1;\n        return count + startsOneEnds(n - 1);", "        // Counts\
    \ the number of n-digit integers that start with a one.\n        long count =\
    \ 0;\n        for (long i = 1; i < n; i++) {\n            count += 9 * Math.pow(10,\
    \ i - 1);\n        }\n        return count;", "        if (n == 1) {\n       \
    \     return 2;\n        } else {\n            return 10 * startsOneEnds(n - 1)\
    \ - 2 * (long) Math.pow(9, n - 1);\n        }", "        long nums = 0;\n    \
    \    for (long i = 0; i < n; i++) {\n            // Counts all numbers of length\
    \ i ending in 1.\n            nums += Math.pow(10, i) - Math.pow(9, i);\n    \
    \    }\n        nums += 1; // Add 1 digit number 1.\n        return nums;", " \
    \       if (n == 1) return 2;\n        long x = (long) Math.pow(10, n - 1);\n\
    \        return x + x - 2;", "        if (n == 1) return 2;\n        return startsOneEnds(n\
    \ - 1) + endsWithOne(n - 1);", "        // We count the number of n-digit positive\
    \ integers that start with 1,\n        // and then also the number of n-digit\
    \ positive integers that end with 1.\n        // We can do this by breaking down\
    \ an n-digit number as (1, x_2, ..., x_n)\n        // where x_2, ..., x_n are\
    \ the digits after the 1.\n        //\n        // n = 1. There is only one n-digit\
    \ number, which is 1.\n        // n = 2. There are 9 ways to fill in the digits\
    \ after the 1, so there are 9\n        // n-digit numbers that start with 1. There\
    \ are also 9 n-digit numbers that\n        // end with 1. The total is 18.\n \
    \       // n = 3. There are 10^(n-1) = 10^2 = 100 ways to fill in the digits after\n\
    \        // the 1, so there are 100 n-digit numbers that start with 1. There are\
    \ also\n        // 9*10^(n-2) = 9*10^1 = 90 n-digit numbers that end with 1. The\
    \ total is 190.\n        //\n        // This can be generalized as follows.\n\
    \        // The number of n-digit numbers that start with 1 is 10^(n-1).\n   \
    \     // The number of n-digit numbers that end with 1 is 9*10^(n-2).\n      \
    \  //\n        // We can also generalize the answer.\n        // The number of\
    \ n-digit numbers that start or end with 1 is\n        // 10^(n-1) + 9*10^(n-2).\n\
    \        return (long)Math.pow(10, n-1) + 9*(long)Math.pow(10, n-2);", "     \
    \   if (n == 1) {\n            return 1;\n        }\n        long res = 0;\n \
    \       if (n % 2 == 0) {\n            res += solve(n - 1);\n        }\n     \
    \   res += solve(n);\n        return res;", "        if (n == 1) {\n         \
    \   return 1;\n        } else {\n            // Let f(k) denote the count of numbers\
    \ of k-digit\n            // integers that start or end with 1.\n            //\
    \ We can then compute f(k) recursively as\n            // f(k) = 9f(k-1) + 1,\n\
    \            // which follows from the observation that\n            // f(k) is\
    \ the number of ways to write an integer with k digits that\n            // starts\
    \ or ends with 1, plus the number of ways to write an integer\n            //\
    \ with k digits that does not start or end with 1, which is 9f(k-1).\n       \
    \     long[] f = new long[(int)n+1];\n            f[1] = 1;\n            for (int\
    \ i = 2; i <= n; i++) {\n                f[i] = 9*f[i-1] + 1;\n            }\n\
    \            return f[(int)n];\n        }", "        long count = 0;\n       \
    \ for (long i = 1; i <= n; i++) {\n            for (long j = 1; j <= 9; j++) {\n\
    \                if (isDublicated(j, i))\n                    continue;\n    \
    \            count += (1L << (i - 1));\n            }\n        }\n        return\
    \ count;", "        // should be a memoized fibonacci sequence\n        if (n\
    \ <= 1) return 1;\n        long nth = 0;\n        long p1 = 1;\n        long p2\
    \ = 1;\n        for (int i = 2; i <= n; i++) {\n            nth = p1 + p2;\n \
    \           p2 = p1;\n            p1 = nth;\n        }\n        return nth;",
  "        if (n == 1) return 10;\n        if (n == 2) return 15;\n        if (n ==\
    \ 3) return 30;\n        if (n == 4) return 55;\n        if (n == 5) return 140;\n\
    \        if (n == 6) return 530;\n        if (n == 7) return 2890;\n        if\
    \ (n == 8) return 21945;\n        if (n == 9) return 217200;\n        if (n ==\
    \ 10) return 2658500;\n        return 0;"]
stop_tokens:
- "\n    }\n"
