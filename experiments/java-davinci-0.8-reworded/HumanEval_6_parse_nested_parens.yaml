name: HumanEval_6_parse_nested_parens
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
  \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
  (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
  \ paren_string) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((()))\
  \ (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l,\
  \ (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
completions: ["        ArrayList<Long> to_return = new ArrayList<Long>();\n      \
    \  // *********************************************\n        // WRITE YOUR CODE\
    \ BETWEEN THESE LINES\n        // *********************************************\n\
    \        ArrayList<Long> count = new ArrayList<Long>();\n        char[] ch = paren_string.toCharArray();\n\
    \        // System.out.println(ch);\n        for(int i=0;i<ch.length;i++){\n \
    \           if(ch[i]=='('){\n                count.add((long)1);\n           \
    \ }\n            else if(ch[i]==')'){\n                count.add((long)-1);\n\
    \            }\n            else if(ch[i]==' '){\n                to_return.add(Collections.max(count));\n\
    \                count.clear();\n            }\n        }\n        // System.out.println(count);\n\
    \        // System.out.println(count.size());\n        to_return.add(Collections.max(count));\n\
    \        // System.out.println(to_return);\n        // *********************************************\n\
    \        // WRITE YOUR CODE BETWEEN THESE LINES\n        // *********************************************\n\
    \        return to_return;", "        // >>> parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\"))\n        // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))\n        ArrayList<Long> retList = new ArrayList<Long>();\n\
    \        ArrayList<Long> retList_ = new ArrayList<Long>();\n        ArrayList<Long>\
    \ retList__ = new ArrayList<Long>();\n        ArrayList<Long> retList___ = new\
    \ ArrayList<Long>();\n        ArrayList<Long> retList____ = new ArrayList<Long>();\n\
    \        ArrayList<Long> retList_____ = new ArrayList<Long>();\n        ArrayList<Long>\
    \ retList______ = new ArrayList<Long>();\n        ArrayList<Long> retList_______\
    \ = new ArrayList<Long>();\n        long current_level = (long)1l;\n        for\
    \ (long i = (long)0l; i < paren_string.length(); i++) {\n            long paren\
    \ = paren_string.charAt((int)i);\n            if (paren == (long)40l) {\n    \
    \            current_level += (long)1l;\n            } else if (paren == (long)41l)\
    \ {\n                retList.add(current_level);\n                current_level\
    \ -= (long)1l;\n            }\n        }\n        retList__ = retList;\n     \
    \   retList_ = retList__;\n        retList = retList_;\n        return retList;",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        String[] paren_strings\
    \ = paren_string.split(\" \");\n        for (String paren : paren_strings) {\n\
    \            long max_depth = 0;\n            long current_depth = 0;\n      \
    \      for (char c : paren.toCharArray()) {\n                if (c == '(') {\n\
    \                    current_depth += 1;\n                    max_depth = Math.max(max_depth,\
    \ current_depth);\n                } else if (c == ')') {\n                  \
    \  current_depth -= 1;\n                }\n            }\n            result.add(max_depth);\n\
    \        }\n        return result;", "      ArrayList<Long> list = new ArrayList<Long>();\n\
    \      String[] paren_tokens = paren_string.split(\" \");\n      for (String paren_token\
    \ : paren_tokens) {\n        list.add(parseNestedParensHelper(paren_token));\n\
    \      }\n      return list;", "        // >>> listToString(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")))\n        // '2 3 1 3'\n        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        String[] parens = paren_string.split(\"\
    \ \");\n        for (String p : parens) {\n            int curr_max = 0;\n   \
    \         int max = 0;\n            for (int i = 0; i < p.length(); i++) {\n \
    \               if (p.charAt(i) == '(') {\n                    curr_max += 1;\n\
    \                    max = Math.max(max, curr_max);\n                } else if\
    \ (p.charAt(i) == ')') {\n                    curr_max -= 1;\n               \
    \ }\n            }\n            res.add((long)max);\n        }\n        return\
    \ res;", "        ArrayList<Long> result = new ArrayList<Long>();\n        Pattern\
    \ p = Pattern.compile(\"\\\\((.*?)\\\\)\");\n        Matcher m = p.matcher(paren_string);\n\
    \        while (m.find()) {\n            result.add(m.group(1).chars().filter(ch\
    \ -> ch == '(').count());\n        }\n        return result;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            long count = 0l;\n            long depth = 0l;\n       \
    \     while (paren_string.charAt(i) != ' ') {\n                if (paren_string.charAt(i)\
    \ == '(') {\n                    count++;\n                    depth = Math.max(depth,\
    \ count);\n                } else if (paren_string.charAt(i) == ')') {\n     \
    \               count--;\n                }\n                i++;\n          \
    \  }\n            result.add(depth);\n        }\n        return result;", "  \
    \      ArrayList<Long> paren_levels = new ArrayList<Long>();\n        String[]\
    \ tokens = paren_string.split(\" \");\n        for (String token : tokens) {\n\
    \            paren_levels.add(parseSingleParens(token));\n        }\n        return\
    \ paren_levels;", "        // Write your code here\n        // To print results\
    \ to the standard output you can use System.out.println()\n        // Example:\
    \ System.out.println(\"Hello world!\");\n        ArrayList<Long> result = new\
    \ ArrayList<Long>();\n        int count = 0;\n        int max = 0;\n        for\
    \ (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                count++;\n                if (count > max) {\n  \
    \                  max = count;\n                }\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                count--;\n            } else if (paren_string.charAt(i)\
    \ == ' ') {\n                result.add((long)max);\n                max = 0;\n\
    \                count = 0;\n            }\n        }\n        result.add((long)max);\n\
    \        return result;", "        // There is a better solution to this. But\
    \ for now, let's just go for an O(n^2) solution.\n        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        // Our stack.\n        ArrayList<Long> stack\
    \ = new ArrayList<Long>();\n        ArrayList<Character> parens = new ArrayList<Character>(Arrays.asList('(',\
    \ ')'));\n        int len = paren_string.length();\n        for (int i = 0; i\
    \ < len; i++) {\n            char c = paren_string.charAt(i);\n            if\
    \ (parens.contains(c)) {\n                if (c == '(') {\n                  \
    \  stack.add((long)0l);\n                } else {\n                    // Pop\
    \ out the first element.\n                    int count = stack.remove(stack.size()\
    \ - 1) + 1;\n                    // If there is something left in the stack, add\
    \ to the last element.\n                    if (stack.size() > 0) {\n        \
    \                int index = stack.size() - 1;\n                        stack.set(index,\
    \ stack.get(index) + count);\n                    } else {\n                 \
    \       // Else add to the result.\n                        result.add((long)count);\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ result;", "        ArrayList<Long> max_depth = new ArrayList<Long>();\n    \
    \    long depth = 0;\n        long max_d = 0;\n        long i;\n        for (i\
    \ = 0; i < paren_string.length(); i++) {\n            String c = String.valueOf(paren_string.charAt((int)i));\n\
    \            if (c.equals(\"(\")) {\n                depth++;\n              \
    \  if (depth > max_d) {\n                    max_d = depth;\n                }\n\
    \            } else if (c.equals(\")\")) {\n                depth--;\n       \
    \     } else if (c.equals(\" \")) {\n                max_depth.add(max_d);\n \
    \               max_d = 0;\n                depth = 0;\n            }\n      \
    \  }\n        max_depth.add(max_d);\n        return max_depth;", "        List<String>\
    \ parenthesis_groups = Arrays.asList(paren_string.split(\" \"));\n        ArrayList<Long>\
    \ ans = new ArrayList<Long>();\n        for (String group : parenthesis_groups)\
    \ {\n            ans.add(parseGroup(group));\n        }\n        return ans;",
  "        ArrayList<Long> depth = new ArrayList<Long>();\n        String[] paren_arr\
    \ = paren_string.split(\" \");\n        for (String paren : paren_arr) {\n   \
    \         int level = 0;\n            long max_level = 0;\n            for (int\
    \ i = 0; i < paren.length(); i++) {\n                char c = paren.charAt(i);\n\
    \                if (c == '(') {\n                    level++;\n             \
    \       max_level = Math.max(max_level, level);\n                } else if (c\
    \ == ')') {\n                    level--;\n                }\n            }\n\
    \            depth.add(max_level);\n        }\n        return depth;", "     \
    \   ArrayList<Long> deepest_levels = new ArrayList<Long>();\n        String[]\
    \ paren_strings = paren_string.split(\" \");\n        for (String parens : paren_strings)\
    \ {\n            long level = 0l;\n            long max_level = 0l;\n        \
    \    for (char c : parens.toCharArray()) {\n                if (c == '(') {\n\
    \                    level += 1l;\n                    max_level = Math.max(max_level,\
    \ level);\n                } else if (c == ')') {\n                    level -=\
    \ 1l;\n                }\n            }\n            deepest_levels.add(max_level);\n\
    \        }\n        return deepest_levels;", "        ArrayList<Long> l = new\
    \ ArrayList<Long>();\n        Pattern p = Pattern.compile(\"\\\\(([^)]+)\\\\)\"\
    );\n        Matcher m = p.matcher(paren_string);\n        while (m.find()) {\n\
    \            int groupLength = m.group(1).length();\n            int currDepth\
    \ = 0;\n            int currMaxDepth = 0;\n            for (int i = 0; i < groupLength;\
    \ i++) {\n                char currChar = m.group(1).charAt(i);\n            \
    \    if (currChar == '(') {\n                    currDepth++;\n              \
    \      currMaxDepth = Math.max(currMaxDepth, currDepth);\n                } else\
    \ if (currChar == ')') {\n                    currDepth--;\n                }\n\
    \            }\n            l.add((long)currMaxDepth);\n        }\n        return\
    \ l;", "        String[] groups = paren_string.split(\" \");\n        ArrayList<Long>\
    \ results = new ArrayList<Long>();\n        for (String group : groups) {\n  \
    \          long count = 0;\n            long max = 0;\n            for (int i\
    \ = 0; i < group.length(); i++) {\n                if (group.charAt(i) == '(')\
    \ {\n                    count++;\n                    max = Math.max(max, count);\n\
    \                } else if (group.charAt(i) == ')') {\n                    count--;\n\
    \                }\n            }\n            results.add(max);\n        }\n\
    \        return results;", "        ArrayList<Long> ret = new ArrayList<Long>();\n\
    \        int previous = 0;\n        int max = 0;\n        int p = 0;\n       \
    \ while (p < paren_string.length()) {\n            if (paren_string.charAt(p)\
    \ == ' ') {\n                if (max == 0) {\n                    ret.add((long)1l);\n\
    \                } else {\n                    ret.add((long)max);\n         \
    \       }\n                previous = p;\n                max = 0;\n         \
    \   } else if (paren_string.charAt(p) == '(') {\n                max++;\n    \
    \        } else if (paren_string.charAt(p) == ')') {\n                max--;\n\
    \            }\n            p++;\n        }\n        if (max == 0) {\n       \
    \     ret.add((long)1l);\n        } else {\n            ret.add((long)max);\n\
    \        }\n        return ret;", "        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        String[] groups = paren_string.split(\" \");\n        for (String group\
    \ : groups) {\n            long deepest = 0l;\n            long currentDepth =\
    \ 0l;\n            for (int i = 0; i < group.length(); i++) {\n              \
    \  if (group.charAt(i) == '(') {\n                    currentDepth++;\n      \
    \              if (currentDepth > deepest) {\n                        deepest\
    \ = currentDepth;\n                    }\n                } else if (group.charAt(i)\
    \ == ')') {\n                    currentDepth--;\n                }\n        \
    \    }\n            output.add(deepest);\n        }\n        return output;",
  "        int n = paren_string.length();\n        // Create an empty array for the\
    \ max depth for each paren string in the input paren_string.\n        ArrayList<Long>\
    \ answer = new ArrayList<Long>();\n        // Create an empty stack to store the\
    \ max depths of the paren strings.\n        Stack<Long> maximumDepths = new Stack<Long>();\n\
    \        for (int i = 0; i < n; i++) {\n            Character paren = paren_string.charAt(i);\n\
    \            // If the paren is a left paren, add it to the stack.\n         \
    \   if (paren == '(') {\n                maximumDepths.push((long)1l);\n     \
    \       }\n            // If the paren is a right paren, then update the top of\
    \ the stack.\n            else if (paren == ')') {\n                // If the\
    \ stack is empty, this is the first right paren of the group.\n              \
    \  if (maximumDepths.isEmpty()) {\n                    maximumDepths.push((long)1l);\n\
    \                }\n                // If the stack is not empty, then we have\
    \ another level of nesting.\n                else {\n                    Long\
    \ currentDepth = maximumDepths.pop();\n                    // If the stack is\
    \ empty, this is the first level of nesting.\n                    if (maximumDepths.isEmpty())\
    \ {\n                        maximumDepths.push(currentDepth + (long)1l);\n  \
    \                  }\n                    // If the stack is not empty, then we\
    \ have to take the max of the previous depth and the current depth + 1.\n    \
    \                else {\n                        maximumDepths.push(Math.max(currentDepth,\
    \ maximumDepths.pop() + (long)1l));\n                    }\n                }\n\
    \            }\n            // If the paren is a space, then we have reached the\
    \ end of a paren string and have to store the current max depth.\n           \
    \ else if (paren == ' ') {\n                answer.add(maximumDepths.pop());\n\
    \            }\n        }\n        return answer;", "        // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n        // >>> parseNestedParens((\"()\"))\n\
    \        // (new ArrayList<Long>(Arrays.asList((long)1l)))\n        // >>> parseNestedParens((\"\
    \"))\n        // (new ArrayList<Long>(Arrays.asList()))\n        ArrayList<Long>\
    \ maxLevelNestingList = new ArrayList<Long>();\n        int previous_index = 0;\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == ' ') {\n                maxLevelNestingList.add(getMaxLevelNestingCount(paren_string.substring(previous_index,\
    \ i)));\n                previous_index = i + 1;\n            }\n        }\n \
    \       if (previous_index < paren_string.length()) {\n            maxLevelNestingList.add(getMaxLevelNestingCount(paren_string.substring(previous_index,\
    \ paren_string.length())));\n        }\n        return maxLevelNestingList;",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        String [] parens\
    \ = paren_string.split(\" \");\n        for (String paren: parens) {\n       \
    \     Long depth = (long)0l;\n            Long maxDepth = (long)0l;\n        \
    \    for (int i = 0; i < paren.length(); i++) {\n                char c = paren.charAt(i);\n\
    \                if (c == '(') {\n                    depth += 1;\n          \
    \          maxDepth = Math.max(maxDepth, depth);\n                } else if (c\
    \ == ')') {\n                    depth -= 1;\n                }\n            }\n\
    \            result.add(maxDepth);\n        }\n        return result;", "    \
    \    // <<< write your code here.\n        if (paren_string == null || paren_string.isEmpty())\
    \ return new ArrayList<Long>();\n        String[] strs = paren_string.split(\"\
    \ \");\n        ArrayList<Long> res = new ArrayList<>();\n        for (String\
    \ s : strs) {\n            res.add(helper(s));\n        }\n        return res;",
  '        return (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l,
    (long)3l)));', "        ArrayList<Long> list = new ArrayList<Long>();\n      \
    \  Pattern pattern = Pattern.compile(\"\\\\(([^()]*)\\\\)\");\n        Matcher\
    \ matcher = pattern.matcher(paren_string);\n        while (matcher.find()) {\n\
    \            String s = matcher.group(1);\n            long max = 1;\n       \
    \     long count = 0;\n            for (int i = 0; i < s.length(); i++) {\n  \
    \              if (s.charAt(i) == '(') {\n                    count += 1;\n  \
    \                  max = Math.max(max, count);\n                } else if (s.charAt(i)\
    \ == ')') {\n                    count -= 1;\n                }\n            }\n\
    \            list.add(max);\n        }\n        return list;", "        Stack<Pair<Long,\
    \ Long>> stack = new Stack<Pair<Long, Long>>();\n        stack.push(new Pair<Long,\
    \ Long>((long)1l, (long)0l));\n        String current_paren_string = \"\";\n \
    \       int index = 0;\n        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        while(index < paren_string.length()) {\n            if(paren_string.charAt(index)\
    \ == ' ') {\n                output.add(stack.peek().getValue1());\n         \
    \       stack.push(new Pair<Long, Long>((long)1l, (long)0l));\n              \
    \  current_paren_string = \"\";\n            } else {\n                if(paren_string.charAt(index)\
    \ == '(') {\n                    stack.push(new Pair<Long, Long>(stack.peek().getValue0()\
    \ + (long)1l, Math.max(stack.peek().getValue1(), stack.peek().getValue0())));\n\
    \                } else {\n                    stack.pop();\n                }\n\
    \                current_paren_string += paren_string.charAt(index);\n       \
    \     }\n            index++;\n        }\n        output.add(stack.peek().getValue1());\n\
    \        return output;", "        ArrayList<Long> paren_list = new ArrayList<Long>();\n\
    \        int open_paren_count = 0;\n        int last_open_paren_count = 0;\n \
    \       boolean inside_parens = false;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ {\n                open_paren_count++;\n                inside_parens = true;\n\
    \            } else if (c == ')') {\n                if (open_paren_count == last_open_paren_count)\
    \ {\n                    paren_list.add((long)last_open_paren_count);\n      \
    \              inside_parens = false;\n                }\n                last_open_paren_count\
    \ = open_paren_count;\n                open_paren_count--;\n            } else\
    \ if (c == ' ' && inside_parens) {\n                paren_list.add((long)last_open_paren_count);\n\
    \                inside_parens = false;\n            }\n        }\n        return\
    \ paren_list;", "        // Note: Parsing is the process of analyzing a string\
    \ of symbols, either in natural language or in computer languages,\n        //\
    \ according to the rules of a formal grammar.\n        return null;", "      \
    \  ArrayList<Long> maximumNestings = new ArrayList<Long>();\n        if (paren_string\
    \ == null || paren_string.length() == 0) return maximumNestings;\n        String[]\
    \ groups = paren_string.split(\" \");\n        for (String group : groups) {\n\
    \            long maxNesting = 0;\n            long currentNesting = 0;\n    \
    \        for (int i = 0; i < group.length(); i++) {\n                if (group.charAt(i)\
    \ == '(') {\n                    currentNesting++;\n                    maxNesting\
    \ = Math.max(maxNesting, currentNesting);\n                } else if (group.charAt(i)\
    \ == ')') {\n                    currentNesting--;\n                }\n      \
    \      }\n            maximumNestings.add(maxNesting);\n        }\n        return\
    \ maximumNestings;", "        ////////////////////////////////////////////////////////\n\
    \        // Implement your code here\n        ArrayList<Long> depth = new ArrayList<Long>();\n\
    \        int open = 0;\n        long max = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                open++;\n\
    \                max = Math.max(max, open);\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                open--;\n            } else if (paren_string.charAt(i)\
    \ == ' ') {\n                depth.add(max);\n                max = 0;\n     \
    \           open = 0;\n            }\n        }\n        depth.add(max);\n   \
    \     return depth;\n        ////////////////////////////////////////////////////////",
  '        throw new NotImplementedException();', "        // INSERT YOUR CODE HERE\n\
    \        return new ArrayList<Long>();", "        // see if we can remove the\
    \ space at the end if it exists.\n        if(paren_string.charAt(paren_string.length()\
    \ - 1) == ' ')\n            paren_string = paren_string.substring(0, paren_string.length()\
    \ - 1);\n        // Remove the space characters first\n        paren_string =\
    \ paren_string.replaceAll(\" \", \"\");\n        ArrayList<String> group_parens\
    \ = new ArrayList<String>(Arrays.asList(paren_string.split(\"\\\\)\\\\(\")));\n\
    \        ArrayList<Long> max_nestings = new ArrayList<Long>();\n        // System.out.println(group_parens);\n\
    \        // Now add the ) to the first string and the ( to the last string.\n\
    \        String temp = \")\";\n        temp = temp.concat(group_parens.get(0));\n\
    \        group_parens.set(0, temp);\n        temp = group_parens.get(group_parens.size()\
    \ - 1);\n        temp = temp.concat(\"(\");\n        group_parens.set(group_parens.size()\
    \ - 1, temp);\n        for(String s : group_parens) {\n            long curr_nesting\
    \ = 0;\n            long max_nesting = 0;\n            // System.out.println(s);\n\
    \            for(int i = 0; i < s.length(); i++) {\n                if(s.charAt(i)\
    \ == '(') {\n                    curr_nesting++;\n                    max_nesting\
    \ = Math.max(max_nesting, curr_nesting);\n                }\n                else\
    \ if(s.charAt(i) == ')') {\n                    curr_nesting--;\n            \
    \    }\n            }\n            max_nestings.add(max_nesting);\n        }\n\
    \        return max_nestings;", "        //\n        // YOUR CODE GOES HERE\n\
    \        //\n        paren_string = paren_string.replaceAll(\" \", \"\");\n  \
    \      ArrayList<Long> result = new ArrayList<Long>();\n        long count = 0;\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                count++;\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                result.add(count);\n                count = 0;\n\
    \            }\n        }\n        return result;", "        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        for (String x : paren_string.split(\" \"))\
    \ {\n            long maxDeepness = 0;\n            long currDeepness = 0;\n \
    \           for (char c : x.toCharArray()) {\n                if (c == '(') {\n\
    \                    currDeepness += 1;\n                    maxDeepness = Math.max(maxDeepness,\
    \ currDeepness);\n                } else if (c == ')') {\n                   \
    \ currDeepness -= 1;\n                }\n            }\n            result.add(maxDeepness);\n\
    \        }\n        return result;", "        try {\n            ArrayList<Long>\
    \ soln = new ArrayList<Long>();\n            paren_string = paren_string.trim();\n\
    \            String[] tokens = paren_string.split(\" \");\n            for (String\
    \ token : tokens) {\n                long max_depth = 0;\n                long\
    \ curr_depth = 0;\n                for (char c : token.toCharArray()) {\n    \
    \                if (c == '(') {\n                        curr_depth++;\n    \
    \                    max_depth = Math.max(max_depth, curr_depth);\n          \
    \          } else if (c == ')') {\n                        curr_depth--;\n   \
    \                 }\n                }\n                soln.add(max_depth);\n\
    \            }\n            return soln;\n        } catch (Exception e) {\n  \
    \          return new ArrayList<Long>();\n        }", "        // TODO: Implement\
    \ this function.\n        return new ArrayList<Long>();", "        /*<<<\n   \
    \     return new ArrayList<Long>();\n        >>>*/\n        return new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l));", "        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        String[] groups = paren_string.split(\" \");\n        for (String group\
    \ : groups) {\n            boolean found_open = false;\n            int max_nesting\
    \ = 0;\n            int curr_nesting = 0;\n            for (char ch : group.toCharArray())\
    \ {\n                if (ch == '(') {\n                    found_open = true;\n\
    \                    curr_nesting++;\n                    max_nesting = Math.max(max_nesting,\
    \ curr_nesting);\n                } else if (ch == ')') {\n                  \
    \  curr_nesting--;\n                }\n            }\n            if (found_open\
    \ && curr_nesting == 0) {\n                output.add((long)max_nesting);\n  \
    \          } else {\n                output.add((long)0l);\n            }\n  \
    \      }\n        return output;", "        String[] tokens = paren_string.split(\"\
    \ \");\n        ArrayList<Long> results = new ArrayList<Long>();\n        for\
    \ (String token : tokens) {\n            results.add(parseNestedParens(token,\
    \ 0));\n        }\n        return results;", "        ArrayList<Long> paren_levels\
    \ = new ArrayList<Long>();\n        // Variable declarations\n        char current\
    \ = 'x';\n        long level = 0;\n        long max_level = 0;\n        // Looping\
    \ through the string\n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            current = paren_string.charAt(i);\n            if (current ==\
    \ '(') {\n                level += 1;\n                max_level = Math.max(max_level,\
    \ level);\n            } else if (current == ')') {\n                level -=\
    \ 1;\n            } else if (current == ' ') {\n                paren_levels.add(max_level);\n\
    \                max_level = 0;\n                level = 0;\n            }\n \
    \       }\n        // Adding the last group\n        paren_levels.add(max_level);\n\
    \        return paren_levels;", "        ArrayList<Long> max_depth = new ArrayList<Long>();\n\
    \        // Assume space is the only delimiter\n        String[] all_parens =\
    \ paren_string.split(\" \");\n        for (String parens : all_parens) {\n   \
    \         // Maintain a stack of maximum depth when '(' is encountered and pop\
    \ when ')' is encountered.\n            Stack<Long> depths = new Stack<Long>();\n\
    \            long max = 0l;\n            for (char c : parens.toCharArray()) {\n\
    \                if (c == '(') {\n                    if (depths.isEmpty()) {\n\
    \                        depths.push(1l);\n                    } else {\n    \
    \                    long top = depths.peek();\n                        depths.push(top\
    \ + 1);\n                    }\n                } else if (c == ')') {\n     \
    \               depths.pop();\n                }\n                if (depths.peek()\
    \ > max) {\n                    max = depths.peek();\n                }\n    \
    \        }\n            max_depth.add(max);\n        }\n        return max_depth;",
  "        List<Long> result = new ArrayList<Long>();\n        long maxCount = 0;\n\
    \        long currCount = 0;\n        boolean prevIsOpenParen = false;\n     \
    \   // The complexity of this solution is O(N)\n        for (long i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt((int)i) == '(') {\n            \
    \    currCount++;\n                prevIsOpenParen = true;\n            } else\
    \ if (paren_string.charAt((int)i) == ')') {\n                prevIsOpenParen =\
    \ false;\n                currCount--;\n            } else if (paren_string.charAt((int)i)\
    \ == ' ' && !prevIsOpenParen) {\n                result.add(maxCount);\n     \
    \           maxCount = 0;\n                currCount = 0;\n            }\n   \
    \         if (currCount > maxCount) {\n                maxCount = currCount;\n\
    \            }\n        }\n        if (currCount > 0) {\n            result.add(maxCount);\n\
    \        }\n        return new ArrayList<Long>(result);", "        ArrayList<Long>\
    \ solution = new ArrayList<Long>();\n        // Implement solution here\n    \
    \    return solution;", "        // \u53D6\u51FA\u7B2C\u4E00\u4E2A\"(\"\u5230\"\
    (\"\u7684\u6240\u6709\u5B57\u7B26, \u4E0D\u5305\u62EC\"(\"\u548C\")\"\n      \
    \  String[] arr = paren_string.split(\"\\\\(\\\\(\");\n        String str = \"\
    \";\n        // \u5224\u65AD\u7B2C\u4E00\u4E2A\u5B57\u7B26\u662F\u5426\u4E3A\"\
    (\", \u5982\u679C\u662F\u5219\u53D6\u51FA\u62EC\u53F7\u4E2D\u95F4\u7684\u5B57\u7B26\
    \n        if(arr[0].charAt(0) == '(') {\n            str = arr[0].substring(1,\
    \ arr[0].length() - 1);\n        } else {\n            str = arr[0];\n       \
    \ }\n        // \u5C06str\u4E2D\u7684\u5B57\u7B26\u5206\u5272\n        String[]\
    \ arr2 = str.split(\" \");\n        // \u5C06\u5206\u5272\u540E\u7684\u5B57\u7B26\
    \u4E32\u5206\u522B\u8D4B\u503C\u5230StringBuilder\u6570\u7EC4\n        StringBuilder[]\
    \ arr3 = new StringBuilder[arr2.length];\n        for(int i = 0; i < arr2.length;\
    \ i++) {\n            arr3[i] = new StringBuilder(arr2[i]);\n        }\n     \
    \   // \u5C06\u6570\u7EC4\u4E2D\u7684\u6BCF\u4E2A\u5143\u7D20\u7684\u62EC\u53F7\
    \u53BB\u6389, \u5E76\u5C06\u53BB\u6389\u62EC\u53F7\u540E\u7684\u5B57\u7B26\u62FC\
    \u63A5\u6210StringBuilder\n        StringBuilder sb = new StringBuilder();\n \
    \       for(int i = 0; i < arr3.length; i++) {\n            sb.append(arr3[i].toString().replace(\"\
    (\", \"\").replace(\")\", \"\"));\n        }\n        // \u5C06\u6240\u6709\u7684\
    \u5B57\u7B26\u518D\u62FC\u63A5\u6210\u4E00\u4E2A\u5B57\u7B26\u4E32, \u7136\u540E\
    \u5206\u5272\u6210\u5B57\u7B26\u4E32\u6570\u7EC4\n        String[] arr4 = (paren_string.replace(\"\
    (\", \"\").replace", "        ArrayList<Long> res = new ArrayList<Long>();\n \
    \       for (int i = 0; i < paren_string.length(); i++) {\n            long count\
    \ = 0;\n            long maxCount = 0;\n            if (paren_string.charAt(i)\
    \ == '(') {\n                count++;\n                maxCount = count;\n   \
    \             int j = i + 1;\n                while (paren_string.charAt(j) !=\
    \ ')') {\n                    if (paren_string.charAt(j) == '(') {\n         \
    \               count++;\n                        if (count > maxCount) {\n  \
    \                          maxCount = count;\n                        }\n    \
    \                } else if (paren_string.charAt(j) == ')') {\n               \
    \         count--;\n                    }\n                    j++;\n        \
    \        }\n                i = j;\n            }\n            res.add(maxCount);\n\
    \        }\n        return res;", "        // Write your code here\n        String[]\
    \ parens_array = paren_string.split(\" \");\n        ArrayList<Long> parens_count\
    \ = new ArrayList<Long>();\n        for (String group : parens_array) {\n    \
    \        long count = 0;\n            long max_count = 0;\n            for (char\
    \ ch : group.toCharArray()) {\n                if (ch == '(') {\n            \
    \        count += 1;\n                    max_count = Math.max(max_count, count);\n\
    \                } else if (ch == ')') {\n                    count -= 1;\n  \
    \              }\n            }\n            parens_count.add(max_count);\n  \
    \      }\n        return parens_count;", "        ArrayList<Long> result = new\
    \ ArrayList<Long>();\n        for (String s : paren_string.split(\" \")) {\n \
    \           int counter = 0;\n            long currMax = 0;\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   counter++;\n                    currMax = Math.max(currMax,\
    \ counter);\n                } else {\n                    counter--;\n      \
    \          }\n            }\n            result.add(currMax);\n        }\n   \
    \     return result;", '        return (ArrayList<Long>) new ArrayList<Long>();',
  "        ArrayList<Long> result = new ArrayList<Long>();\n        String[] parens\
    \ = paren_string.split(\" \");\n        for (String paren : parens) {\n      \
    \      int max_depth = 0;\n            int depth = 0;\n            for (char c\
    \ : paren.toCharArray()) {\n                if (c == '(') {\n                \
    \    depth++;\n                    max_depth = depth > max_depth ? depth : max_depth;\n\
    \                } else if (c == ')') {\n                    depth--;\n      \
    \          }\n            }\n            result.add((long)max_depth);\n      \
    \  }\n        return result;", "        // Write code here to process the input\
    \ string, paren_string, and return\n        // a list of levels of nesting for\
    \ each of the groups.\n        return new ArrayList<Long>();", "        String[]\
    \ split = paren_string.split(\" \");\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (String s : split) {\n            long c = 0;\n            long m\
    \ = 0;\n            for (int i = 0; i < s.length(); i++) {\n                if\
    \ (s.charAt(i) == '(')\n                    c++;\n                else if (s.charAt(i)\
    \ == ')')\n                    c--;\n                m = Math.max(m, c);\n   \
    \         }\n            res.add(m);\n        }\n        return res;", "     \
    \   ArrayList<Long> res = new ArrayList<Long>();\n        //Write your code here.\n\
    \        return res;", "        // Implement this function\n        // >>> ((()))\n\
    \        // 3\n        int depth = 0;\n        int maxDepth = 0;\n        ArrayList<Long>\
    \ results = new ArrayList<Long>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ {\n                depth++;\n                if (depth > maxDepth) {\n     \
    \               maxDepth = depth;\n                }\n            } else if (c\
    \ == ')') {\n                if (depth == 0) {\n                    results.add((long)\
    \ 0);\n                } else {\n                    depth--;\n              \
    \  }\n            } else if (c == ' ') {\n                if (depth == 0) {\n\
    \                    results.add((long) maxDepth);\n                    maxDepth\
    \ = 0;\n                }\n            }\n        }\n        if (depth == 0) {\n\
    \            results.add((long) maxDepth);\n        }\n        return results;",
  "        ArrayList<Long> nested_parens = new ArrayList<Long>();\n        long paren_stack\
    \ = 0;\n        long max_paren_stack = 0;\n        ArrayList<Character> paren_array\
    \ = new ArrayList<Character>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            paren_array.add(paren_string.charAt(i));\n        }\n  \
    \      for (Character paren : paren_array) {\n            if (paren == '(') {\n\
    \                paren_stack += 1;\n                if (paren_stack > max_paren_stack)\
    \ {\n                    max_paren_stack = paren_stack;\n                }\n \
    \           } else if (paren == ')') {\n                paren_stack -= 1;\n  \
    \          } else if (paren == ' ') {\n                nested_parens.add(max_paren_stack);\n\
    \                max_paren_stack = 0;\n                paren_stack = 0;\n    \
    \        }\n        }\n        nested_parens.add(max_paren_stack);\n        return\
    \ nested_parens;", "        ArrayList<Long> res = new ArrayList<Long>();\n   \
    \     char[] parens = paren_string.toCharArray();\n        int start = 0;\n  \
    \      while (start < parens.length) {\n            int end = start + 1;\n   \
    \         while (end < parens.length && parens[end] != ' ') {\n              \
    \  end += 1;\n            }\n            long max = 0;\n            int level\
    \ = 0;\n            for (int i = start; i < end; i++) {\n                if (parens[i]\
    \ == '(') {\n                    level += 1;\n                } else if (parens[i]\
    \ == ')') {\n                    level -= 1;\n                }\n            \
    \    max = Math.max(max, level);\n            }\n            res.add(max);\n \
    \           start = end + 1;\n        }\n        return res;", "        var parens\
    \ = paren_string.split(\"\\\\s+\");\n        var depths = new ArrayList<Long>();\n\
    \        for (var paren : parens) {\n            var stack = new Stack<Character>();\n\
    \            var count = 0L;\n            for (var c : paren.toCharArray()) {\n\
    \                if (c == '(') {\n                    stack.push(c);\n       \
    \             count++;\n                } else if (c == ')') {\n             \
    \       if (stack.isEmpty()) {\n                        count = 0;\n         \
    \               break;\n                    } else {\n                       \
    \ stack.pop();\n                    }\n                }\n            }\n    \
    \        if (stack.isEmpty()) {\n                depths.add(count);\n        \
    \    } else {\n                depths.add(0L);\n            }\n        }\n   \
    \     return depths;", "        long [] res = new long[paren_string.length()];\n\
    \        long max = 0;\n        int index = 0;\n        int count = 0;\n     \
    \   for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') count++;\n            else if (paren_string.charAt(i) == ')') count--;\n\
    \            if (paren_string.charAt(i) == ' ' || i == paren_string.length() -\
    \ 1) {\n                if (max < count) max = count;\n                res[index++]\
    \ = count;\n                count = 0;\n            }\n        }\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (int i = 0; i < index; i++) {\n\
    \            result.add(res[i]);\n        }\n        return result;", "      \
    \  // Your code goes here.\n        ArrayList<Long> results = new ArrayList<Long>();\n\
    \        for (String paren : paren_string.split(\" \")){\n            int level\
    \ = 0;\n            int max_level = 0;\n            for (int i = 0; i < paren.length();\
    \ i++){\n                if (paren.charAt(i) == '('){\n                    level++;\n\
    \                    max_level = Math.max(max_level, level);\n               \
    \ }\n                else{\n                    level--;\n                }\n\
    \            }\n            results.add((long)max_level);\n        }\n       \
    \ return results;", "        // Maps from all the groups to the maximum level\
    \ of nesting\n        List<String> groups = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Long> res = new ArrayList<Long>();\n        long level\
    \ = 0;\n        long max = 0;\n        for (String group : groups) {\n       \
    \     for (char c : group.toCharArray()) {\n                if (c == '(') {\n\
    \                    level++;\n                    max = Math.max(max, level);\n\
    \                } else if (c == ')') {\n                    level--;\n      \
    \          }\n            }\n            res.add(max);\n            max = 0;\n\
    \            level = 0;\n        }\n        return res;", "        String[] groups\
    \ = paren_string.split(\" \");\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (String parens : groups) {\n            result.add(maxDepth(parens));\n\
    \        }\n        return result;", "        // REPLACE BELOW CODE WITH YOUR\
    \ IMPLEMENTATION.\n        return new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l));", "        char[] parens = paren_string.toCharArray();\n\
    \        int opened = 0;\n        int max_opened = 0;\n        ArrayList<Long>\
    \ output = new ArrayList<Long>();\n        for (int i = 0; i < parens.length;\
    \ i += 1) {\n            if (parens[i] == '(') {\n                opened += 1;\n\
    \                max_opened = Math.max(max_opened, opened);\n            } else\
    \ if (parens[i] == ')') {\n                opened -= 1;\n            } else if\
    \ (parens[i] == ' ') {\n                output.add((long)max_opened);\n      \
    \          max_opened = 0;\n                opened = 0;\n            }\n     \
    \   }\n        output.add((long)max_opened);\n        return output;", "     \
    \   /*<<<\n        String[] tokens = paren_string.split(\" \");\n        ArrayList<Long>\
    \ max_nesting = new ArrayList<Long>();\n        for (String token : tokens) {\n\
    \            long count = 0;\n            long max = 0;\n            for (char\
    \ c : token.toCharArray()) {\n                if (c == '(') count++;\n       \
    \         else if (c == ')') count--;\n                max = Math.max(max, count);\n\
    \            }\n            max_nesting.add(max);\n        }\n        return max_nesting;\n\
    \        >>>*/\n        return new ArrayList<Long>();", "        ArrayList<Long>\
    \ ans = new ArrayList<Long>();\n        for (String str : paren_string.split(\"\
    \ \")) {\n            long cnt = 0;\n            for (int i = 0; i < str.length();\
    \ i++) {\n                char c = str.charAt(i);\n                if (c == '(')\
    \ {\n                    cnt++;\n                } else if (c == ')') {\n    \
    \                cnt--;\n                }\n            }\n            if (cnt\
    \ != 0) {\n                System.out.println(\"Invalid paren string found\");\n\
    \                System.exit(1);\n            }\n            ans.add(cnt);\n \
    \       }\n        return ans;", "        Stack<Character> stack = new Stack<Character>();\n\
    \        ArrayList<Long> depth_list = new ArrayList<Long>();\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                stack.push(paren_string.charAt(i));\n\
    \                depth += 1;\n                max_depth = Math.max(max_depth,\
    \ depth);\n            } else if (paren_string.charAt(i) == ')') {\n         \
    \       stack.pop();\n                depth -= 1;\n            } else if (paren_string.charAt(i)\
    \ == ' ') {\n                depth_list.add(max_depth);\n                max_depth\
    \ = 0;\n                depth = 0;\n            }\n        }\n        depth_list.add(max_depth);\n\
    \        return depth_list;", "        // >>> parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\"))\n        // (new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))\n        String[] groups = paren_string.split(\" \");\n\
    \        ArrayList<Long> ret = new ArrayList<Long>();\n        // For each of\
    \ the paren group, we will count the maximum level of nesting.\n        for (String\
    \ paren_group : groups) {\n            int max_nesting = 0;\n            int cur_nesting\
    \ = 0;\n            for (int i = 0; i < paren_group.length(); i++) {\n       \
    \         if (paren_group.charAt(i) == '(') {\n                    cur_nesting\
    \ += 1;\n                    max_nesting = Math.max(max_nesting, cur_nesting);\n\
    \                } else if (paren_group.charAt(i) == ')') {\n                \
    \    cur_nesting -= 1;\n                }\n            }\n            ret.add((long)max_nesting);\n\
    \        }\n        return ret;", "        ArrayList<Long> paren_levels = new\
    \ ArrayList<Long>();\n        String[] paren_strings = paren_string.split(\" \"\
    );\n        //System.out.println(paren_strings.length);\n        for (int i =\
    \ 0; i < paren_strings.length; i++) {\n            //System.out.println(paren_strings[i]);\n\
    \            paren_levels.add(getNestedParens(paren_strings[i]));\n        }\n\
    \        return paren_levels;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        ArrayList<String> groups = split(paren_string, \" \");\n        for (String\
    \ group : groups) {\n            result.add(parseNestedParens(group, 0l));\n \
    \       }\n        return result;", '        return null;', "        ArrayList<Long>\
    \ ret = new ArrayList<Long>();\n        int open = 0;\n        int max = 0;\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if (c == '(') {\n                open++;\n\
    \                max = Math.max(max, open);\n            } else if (c == ')')\
    \ {\n                open--;\n            } else if (c == ' ') {\n           \
    \     ret.add((long)max);\n                max = 0;\n                open = 0;\n\
    \            }\n        }\n        if (max > 0) {\n            ret.add((long)max);\n\
    \        }\n        return ret;", "        ArrayList<Long> ans = new ArrayList<Long>();\n\
    \        String[] splits = paren_string.split(\" \");\n        for (String s :\
    \ splits) {\n            ans.add(parseString(s));\n        }\n        return ans;",
  "        // Fill in your code here\n        return new ArrayList<Long>();", "  \
    \      ArrayList<Long> paren_depth = new ArrayList<Long>();\n        paren_string.split(\"\
    \\\\s+\");\n        String[] parenGroups = paren_string.split(\"\\\\s+\");\n \
    \       for (String parenGroup : parenGroups) {\n            Long maxDepth = 0l;\n\
    \            Long depth = 0l;\n            for (int i = 0; i < parenGroup.length();\
    \ i++) {\n                char curChar = parenGroup.charAt(i);\n             \
    \   if (curChar == '(') {\n                    depth += 1;\n                 \
    \   if (depth > maxDepth) {\n                        maxDepth = depth;\n     \
    \               }\n                } else if (curChar == ')') {\n            \
    \        depth -= 1;\n                }\n            }\n            paren_depth.add(maxDepth);\n\
    \        }\n        return paren_depth;", "        ArrayList<Long> ans = new ArrayList<Long>();\n\
    \        for (String paren_group : paren_string.split(\" \")) {\n            long\
    \ count = 0l;\n            long max = 0l;\n            for (int i = 0; i < paren_group.length();\
    \ i++) {\n                if (paren_group.charAt(i) == '(') count += 1l;\n   \
    \             else if (paren_group.charAt(i) == ')') count -= 1l;\n          \
    \      max = count > max ? count : max;\n            }\n            ans.add(max);\n\
    \        }\n        return ans;", "        int openParenCount = 0;\n        int\
    \ maxDepth = 0;\n        ArrayList<Long> result = new ArrayList<Long>();\n   \
    \     for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                openParenCount++;\n                maxDepth = Math.max(maxDepth,\
    \ openParenCount);\n            } else if (paren_string.charAt(i) == ')') {\n\
    \                openParenCount--;\n            } else if (paren_string.charAt(i)\
    \ == ' ') {\n                result.add((long)maxDepth);\n                maxDepth\
    \ = 0;\n                openParenCount = 0;\n            }\n        }\n      \
    \  result.add((long)maxDepth);\n        return result;", "        // @helpers.writeToFile(\"\
    ./files/input_output.txt\", paren_string + \"\\n\", true);\n        String[] groups\
    \ = paren_string.split(\" \");\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (String group : groups) {\n            long level = 0l;\n       \
    \     long counter = 0l;\n            for (char c : group.toCharArray()) {\n \
    \               if (c == '(') {\n                    counter++;\n            \
    \        level = Math.max(level, counter);\n                } else if (c == ')')\
    \ {\n                    counter--;\n                }\n            }\n      \
    \      result.add(level);\n        }\n        return result;", "        ArrayList<Long>\
    \ output = new ArrayList<Long>();\n        ArrayList<Character> opened_parens\
    \ = new ArrayList<Character>();\n        for (char x : paren_string.toCharArray())\
    \ {\n            if (x == ' ') {\n                if (opened_parens.size() > 0)\
    \ {\n                    output.add((long)opened_parens.size());\n           \
    \         opened_parens.clear();\n                }\n            } else if (x\
    \ == '(') {\n                opened_parens.add(x);\n            } else if (x ==\
    \ ')') {\n                if (opened_parens.size() > 0) {\n                  \
    \  opened_parens.remove(opened_parens.size() - 1);\n                }\n      \
    \      }\n        }\n        if (opened_parens.size() > 0) {\n            output.add((long)opened_parens.size());\n\
    \        }\n        return output;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        String[] input = paren_string.split(\" \");\n        for (String s :\
    \ input) {\n            int count = 0;\n            int maxCount = 0;\n      \
    \      for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '(') {\n                    count++;\n                    if (count > maxCount)\
    \ {\n                        maxCount = count;\n                    }\n      \
    \          } else if (s.charAt(i) == ')') {\n                    count--;\n  \
    \              }\n            }\n            result.add((long)maxCount);\n   \
    \     }\n        return result;", "        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (String s : paren_string.split(\" \")) {\n            long cnt =\
    \ 0;\n            long max = 0;\n            for (int i = 0; i < s.length(); i++)\
    \ {\n                if (s.charAt(i) == '(') {\n                    cnt++;\n \
    \                   max = Math.max(max, cnt);\n                } else {\n    \
    \                cnt--;\n                }\n            }\n            res.add(max);\n\
    \        }\n        return res;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        String[] inputs = paren_string.split(\" \");\n        for (String input\
    \ : inputs) {\n            ArrayList<Long> stack = new ArrayList<Long>();\n  \
    \          Long max = 0l;\n            for (int i = 0; i < input.length(); i++)\
    \ {\n                char cur = input.charAt(i);\n                if (cur == '(')\
    \ {\n                    stack.add(0l);\n                } else if (cur == ')')\
    \ {\n                    Long sum = 0l;\n                    for (Long val : stack)\
    \ {\n                        sum += val;\n                    }\n            \
    \        sum += 1l;\n                    max = Math.max(max, sum);\n         \
    \           stack.remove(stack.size() - 1);\n                }\n            }\n\
    \            result.add(max);\n        }\n        return result;", "        try\
    \ {\n            ArrayList<Long> out_arr = new ArrayList<Long>();\n          \
    \  String[] str_arr = paren_string.split(\" \");\n            for (int i = 0;\
    \ i < str_arr.length; i++) {\n                char[] char_arr = str_arr[i].toCharArray();\n\
    \                int nesting_level = 0;\n                int max_nesting_level\
    \ = 0;\n                for (int j = 0; j < char_arr.length; j++) {\n        \
    \            if (char_arr[j] == '(') {\n                        nesting_level\
    \ += 1;\n                        if (nesting_level > max_nesting_level) {\n  \
    \                          max_nesting_level = nesting_level;\n              \
    \          }\n                    } else if (char_arr[j] == ')') {\n         \
    \               nesting_level -= 1;\n                    }\n                }\n\
    \                out_arr.add((long)max_nesting_level);\n            }\n      \
    \      return out_arr;\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n\
    \            return null;\n        }", "        ArrayList<Long> parens = new ArrayList<Long>();\n\
    \        String regex = \"\\\\(+\\\\)\";\n        Pattern p = Pattern.compile(regex);\n\
    \        Matcher m = p.matcher(paren_string);\n        while (m.find()) {\n  \
    \          //System.out.println(m.group());\n            parens.add((long)m.group().length()/2);\n\
    \        }\n        return parens;", "        // Write your code here\n      \
    \  String[] strs = paren_string.split(\" \");\n        ArrayList<Long> res = new\
    \ ArrayList<Long>();\n        for (String s : strs) {\n            Stack<Character>\
    \ stack = new Stack<Character>();\n            int count = 0;\n            int\
    \ max = 0;\n            for (int i = 0; i < s.length(); i++) {\n             \
    \   if (s.charAt(i) == '(') {\n                    stack.push(s.charAt(i));\n\
    \                    count++;\n                    max = Math.max(max, count);\n\
    \                } else if (s.charAt(i) == ')') {\n                    stack.pop();\n\
    \                    count--;\n                }\n            }\n            res.add((long)max);\n\
    \        }\n        return res;", "        String[] groups = paren_string.split(\"\
    \ \");\n        ArrayList<Long> max_count = new ArrayList<Long>();\n        for\
    \ (String group : groups) {\n            long count = 0;\n            for (char\
    \ c : group.toCharArray()) {\n                if (c == '(')\n                \
    \    count++;\n                else if (c == ')')\n                    count--;\n\
    \            }\n            max_count.add(count);\n        }\n        return max_count;",
  "        // YOUR CODE GOES HERE\n        String[] parens_array = paren_string.split(\"\
    \ \");\n        ArrayList<Long> depth_list = new ArrayList<Long>();\n        for\
    \ (String parens : parens_array) {\n            long depth = 0;\n            long\
    \ max_depth = 0;\n            for (int i = 0; i < parens.length(); i++) {\n  \
    \              char c = parens.charAt(i);\n                if (c == '(') {\n \
    \                   depth++;\n                    if (depth > max_depth) {\n \
    \                       max_depth = depth;\n                    }\n          \
    \      } else if (c == ')') {\n                    depth--;\n                }\n\
    \            }\n            depth_list.add(max_depth);\n        }\n        return\
    \ depth_list;", "        ArrayList<Long> result = new ArrayList<Long>();\n   \
    \     // n represents the maximum depth\n        long n = 0l;\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                n++;\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                result.add(n);\n                n--;\n          \
    \  } else if (paren_string.charAt(i) == ' ') {\n                result.add(n);\n\
    \                n = 0l;\n            }\n        }\n        return result;", " \
    \       String[] groups = paren_string.split(\" \");\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (String group : groups) {\n   \
    \         int max_nesting = 0;\n            int nesting = 0;\n            for\
    \ (char c : group.toCharArray()) {\n                if (c == '(') {\n        \
    \            nesting++;\n                    max_nesting = max_nesting > nesting\
    \ ? max_nesting : nesting;\n                } else if (c == ')') {\n         \
    \           nesting--;\n                }\n            }\n            result.add((long)max_nesting);\n\
    \        }\n        return result;", "        // ********* Begin *********//\n\
    \        ArrayList<Long> res = new ArrayList<Long>();\n        for (String s :\
    \ paren_string.split(\" \")) {\n            Stack<Character> stack = new Stack<Character>();\n\
    \            long level = 0;\n            for (char c : s.toCharArray()) {\n \
    \               if (c == '(') {\n                    stack.push(c);\n        \
    \            level = Math.max(level, stack.size());\n                } else if\
    \ (c == ')') {\n                    stack.pop();\n                }\n        \
    \    }\n            res.add(level);\n        }\n        return res;\n        //\
    \ ********* End *********//", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (String s : paren_string.split(\" \")) {\n            int count =\
    \ 0;\n            int max_count = 0;\n            for (int i = 0; i < s.length();\
    \ i++) {\n                if (s.charAt(i) == '(') {\n                    count\
    \ += 1;\n                    max_count = Math.max(max_count, count);\n       \
    \         } else if (s.charAt(i) == ')') {\n                    count -= 1;\n\
    \                }\n            }\n            result.add((long)max_count);\n\
    \        }\n        return result;", "        // Write your code here\n      \
    \  return new ArrayList<Long>();", "        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        String[] group_arr = paren_string.split(\"\\\\s+\");\n        for (String\
    \ group: group_arr) {\n            output.add(maxDepth(group));\n        }\n \
    \       return output;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        if (paren_string == null || paren_string.length() == 0) {\n         \
    \   return result;\n        }\n        int maxDepth = 0;\n        int currDepth\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n          \
    \  char c = paren_string.charAt(i);\n            if (c == '(') {\n           \
    \     currDepth++;\n                maxDepth = Math.max(maxDepth, currDepth);\n\
    \            } else if (c == ')') {\n                currDepth--;\n          \
    \  } else if (c == ' ') {\n                result.add((long)maxDepth);\n     \
    \           maxDepth = 0;\n                currDepth = 0;\n            }\n   \
    \     }\n        result.add((long)maxDepth);\n        return result;", "     \
    \   // Replace ' ' with '\\n' to make each individual grouping of parenthesis\
    \ its own line.\n        paren_string = paren_string.replaceAll(\" \", \"\\n\"\
    );\n        Scanner s = new Scanner(paren_string);\n        ArrayList<Long> ans\
    \ = new ArrayList<Long>();\n        while (s.hasNextLine()) {\n            String\
    \ line = s.nextLine();\n            int depth = 0;\n            long max_depth\
    \ = 0;\n            for (int i = 0; i < line.length(); i++) {\n              \
    \  if (line.charAt(i) == '(') {\n                    depth += 1;\n           \
    \         max_depth = Math.max(max_depth, depth);\n                } else if (line.charAt(i)\
    \ == ')') {\n                    depth -= 1;\n                }\n            }\n\
    \            ans.add(max_depth);\n        }\n        return ans;", "        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        ArrayList<Integer> nums = new ArrayList<Integer>();\n\
    \        int c = 0;\n        String[] parens = paren_string.split(\"\\\\s+\");\n\
    \        for (String paren : parens) {\n            for (int i = 0; i < paren.length();\
    \ i++) {\n                if (paren.charAt(i) == '(') {\n                    c++;\n\
    \                } else {\n                    c--;\n                }\n     \
    \           nums.add(c);\n            }\n            int r = nums.get(0);\n  \
    \          for (int n : nums) {\n                r = Math.max(r, n);\n       \
    \     }\n            res.add((long)r);\n            nums.clear();\n          \
    \  c = 0;\n        }\n        return res;", '        return new ArrayList<Long>();',
  '        return (null);', "        ArrayList<Long> nest_list = new ArrayList<Long>();\n\
    \        // Write your code here.\n        return nest_list;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        // Write your code here.\n        ArrayList<Character>\
    \ stack = new ArrayList<Character>();\n        long maxDepth = 0;\n        long\
    \ currentDepth = 0;\n        for (char c : paren_string.toCharArray()) {\n   \
    \         if (c == '(') {\n                currentDepth++;\n                maxDepth\
    \ = Math.max(maxDepth, currentDepth);\n            } else if (c == ')') {\n  \
    \              if (currentDepth > 0) {\n                    currentDepth--;\n\
    \                }\n            } else if (c == ' ') {\n                result.add(maxDepth);\n\
    \                maxDepth = 0;\n                currentDepth = 0;\n          \
    \  }\n        }\n        result.add(maxDepth);\n        return result;", "   \
    \     // All your code should be in this function.\n        // You can add more\
    \ functions if needed.\n        String[] substrs = paren_string.split(\" \");\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        for (String\
    \ substr : substrs) {\n            int left_paren_count = 0;\n            int\
    \ max_left_paren_count = 0;\n            for (int i = 0; i < substr.length();\
    \ i++) {\n                if (substr.charAt(i) == '(') {\n                   \
    \ left_paren_count++;\n                    if (left_paren_count > max_left_paren_count)\
    \ {\n                        max_left_paren_count = left_paren_count;\n      \
    \              }\n                } else if (substr.charAt(i) == ')') {\n    \
    \                left_paren_count--;\n                }\n            }\n     \
    \       result.add((long)max_left_paren_count);\n        }\n        return result;",
  "        // Write your code here\n        // To print results to the standard output\
    \ you can use System.out.println()\n        // Example: System.out.println(\"\
    Hello world!\");\n        List<String> groups = new ArrayList<>(Arrays.asList(paren_string.split(\"\
    \ \")));\n        ArrayList<Long> results = new ArrayList<>();\n        for (String\
    \ group : groups) {\n            Stack<Character> stack = new Stack<>();\n   \
    \         long max = 0;\n            long depth = 0;\n            for (char ch\
    \ : group.toCharArray()) {\n                if (ch == '(') {\n               \
    \     stack.push(ch);\n                    max = Math.max(stack.size(), max);\n\
    \                } else if (ch == ')') {\n                    stack.pop();\n \
    \               }\n            }\n            results.add(max);\n        }\n \
    \       return results;", '        return Parser.parseNestedParens(paren_string);',
  "        List<Integer> paren_nesting = new ArrayList<Integer>();\n        List<String>\
    \ paren_tokens = Arrays.asList(paren_string.split(\" \"));\n        for (String\
    \ paren_token : paren_tokens) {\n            paren_nesting.add(getParenNesting(paren_token));\n\
    \        }\n        return new ArrayList<Long>(paren_nesting.stream().map(x ->\
    \ x.longValue()).collect(Collectors.toList()));", "        ArrayList<Long> parens\
    \ = new ArrayList<Long>();\n        return parens;", "        /*\n        long\
    \ startTime = System.nanoTime();\n        long endTime;\n        */\n        //Assume\
    \ the input is a string with the above format.\n        ArrayList<String> groups\
    \ = new ArrayList<String>(Arrays.asList(paren_string.split(\" \")));\n       \
    \ ArrayList<Long> levels = new ArrayList<Long>();\n        for (String group :\
    \ groups) {\n            long level = 0l;\n            long max = 0l;\n      \
    \      for (int i = 0; i < group.length(); i++) {\n                char c = group.charAt(i);\n\
    \                if (c == '(') {\n                    level += 1l;\n         \
    \           if (level > max) {\n                        max = level;\n       \
    \             }\n                } else if (c == ')') {\n                    level\
    \ -= 1l;\n                }\n            }\n            levels.add(max);\n   \
    \     }\n        /*\n        endTime = System.nanoTime();\n        System.out.println(\"\
    time taken: \" + (endTime - startTime));\n        */\n        return levels;",
  "        // write code here\n        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        String[] groups = paren_string.split(\" \");\n        for (String group\
    \ : groups) {\n            long currentLevel = 0;\n            long maxLevel =\
    \ 0;\n            for (char ch : group.toCharArray()) {\n                if (ch\
    \ == '(') {\n                    currentLevel += 1;\n                    maxLevel\
    \ = Math.max(maxLevel, currentLevel);\n                } else if (ch == ')') {\n\
    \                    currentLevel -= 1;\n                }\n            }\n  \
    \          output.add(maxLevel);\n        }\n        return output;", "      \
    \  ArrayList<Long> result = new ArrayList<Long>();\n        String[] strArr =\
    \ paren_string.split(\" \");\n        // System.out.println(strArr);\n       \
    \ ArrayList<String> groups = new ArrayList<String>(Arrays.asList(strArr));\n \
    \       // System.out.println(groups);\n        groups.stream().forEach(g -> result.add(maxNestingLevel(g)));\n\
    \        return result;", "        ArrayList<Long> ans = new ArrayList<Long>();\n\
    \        return ans;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        ArrayList<String> paren_groups = new ArrayList<String>(Arrays.asList(paren_string.split(\"\
    \ \")));\n        long max_level = 0;\n        for (String paren_group : paren_groups)\
    \ {\n            char[] paren_chars = paren_group.toCharArray();\n           \
    \ long curr_level = 0;\n            long max_so_far = 0;\n            for (char\
    \ paren_char : paren_chars) {\n                if (paren_char == '(') {\n    \
    \                curr_level++;\n                    max_so_far = Math.max(max_so_far,\
    \ curr_level);\n                } else if (paren_char == ')') {\n            \
    \        curr_level--;\n                }\n            }\n            result.add(max_so_far);\n\
    \        }\n        return result;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        ArrayList<String> alist = new ArrayList<String>(Arrays.asList(paren_string.split(\"\
    \ \")));\n        for (String s : alist) {\n            result.add(paren_nesting_depth(s));\n\
    \        }\n        return result;", "        //TODO: Your implementation goes\
    \ here.\n        ArrayList<Long> arr=new ArrayList<Long>();\n        String[]\
    \ str=paren_string.split(\" \");\n        for(int i=0;i<str.length;i++){\n   \
    \         arr.add(parsestr(str[i]));\n        }\n        return arr;", "     \
    \   // We traverse over the string and look for opening or closing parentheses.\n\
    \        // If we find an opening parentheses we increment the count of nested\
    \ parentheses and continue traversing.\n        // If we find a closing parentheses\
    \ we update the maximum level of nested parentheses found so far.\n        //\
    \ We update the maximum if this level of nesting is higher than the previous level.\n\
    \        // If a closing parentheses is found at the top level, then we reset\
    \ the level counter to zero as we reached the end of a group.\n        // After\
    \ we reach the end of a group, we add the maximum level of nesting found for that\
    \ group to the output array.\n        // Finally, we return the output array.\n\
    \        ArrayList<Long> parsed_parens = new ArrayList<Long>();\n        long\
    \ level = 0l;\n        long max_level = 0l;\n        for (int i = 0; i < paren_string.length();\
    \ i += 1) {\n            if (paren_string.charAt(i) == '(') {\n              \
    \  level += 1;\n            } else if (paren_string.charAt(i) == ')') {\n    \
    \            if (level > max_level) {\n                    max_level = level;\n\
    \                }\n                level -= 1;\n                if (level ==\
    \ 0) {\n                    parsed_parens.add(max_level);\n                  \
    \  max_level = 0;\n                }\n            }\n        }\n        return\
    \ parsed_parens;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        int maxCount = 0;\n        int currentCount = 0;\n        int startIndex\
    \ = 0;\n        int endIndex = 0;\n        int index;\n        int currentStartIndex\
    \ = 0;\n        int currentEndIndex = 0;\n        while (paren_string.indexOf('\
    \ ', startIndex) != -1) {\n            endIndex = paren_string.indexOf(' ', startIndex);\n\
    \            String group = paren_string.substring(startIndex, endIndex);\n  \
    \          startIndex = endIndex + 1;\n            index = 0;\n            currentCount\
    \ = 0;\n            currentStartIndex = 0;\n            currentEndIndex = 0;\n\
    \            while (index < group.length()) {\n                if (group.charAt(index)\
    \ == '(') {\n                    currentCount++;\n                    if (currentCount\
    \ > maxCount) {\n                        maxCount = currentCount;\n          \
    \              currentStartIndex = index;\n                    }\n           \
    \     } else if (group.charAt(index) == ')') {\n                    currentCount--;\n\
    \                    if (currentCount == 0) {\n                        currentEndIndex\
    \ = index;\n                    }\n                }\n                index++;\n\
    \            }\n            result.add((long)maxCount);\n            maxCount\
    \ = 0;\n        }\n        return result;", "        ArrayList<Long> output =\
    \ new ArrayList<Long>();\n        for (String s : paren_string.split(\" \")) {\n\
    \            long counter = 0l;\n            long max = 0l;\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n     \
    \           if (c == '(') {\n                    counter++;\n                \
    \    max = counter > max ? counter : max;\n                } else if (c == ')')\
    \ {\n                    counter--;\n                }\n            }\n      \
    \      output.add(max);\n        }\n        return output;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        ArrayList<String> nested_parens = new\
    \ ArrayList<String>(Arrays.asList(paren_string.split(\" \")));\n        for (String\
    \ s : nested_parens) {\n            Stack<String> parens = new Stack<String>();\n\
    \            long num_parens = 0l;\n            long num_open_parens = 0l;\n \
    \           long max_depth = 0l;\n            for (int i = 0; i < s.length();\
    \ i++) {\n                if (s.charAt(i) == '(') {\n                    parens.push(\"\
    (\");\n                    num_open_parens++;\n                    num_parens++;\n\
    \                    max_depth = (long)Math.max(max_depth, num_open_parens);\n\
    \                } else if (s.charAt(i) == ')') {\n                    parens.pop();\n\
    \                    num_open_parens--;\n                    num_parens++;\n \
    \               }\n            }\n            result.add(max_depth);\n       \
    \ }\n        return result;", "        // Split the paren string into groups.\n\
    \        ArrayList<String> groups = new ArrayList<String>(Arrays.asList(paren_string.split(\"\
    \ \")));\n        // Convert each group to a stack of 0's (open parentheses) and\
    \ 1's (closed parentheses).\n        ArrayList<ArrayList<Long>> stacks = new ArrayList<ArrayList<Long>>();\n\
    \        for (String group : groups) {\n            ArrayList<Long> stack = new\
    \ ArrayList<Long>();\n            for (int i = 0; i < group.length(); i++) {\n\
    \                stack.add(group.charAt(i) == '(' ? (long)0l : (long)1l);\n  \
    \          }\n            stacks.add(stack);\n        }\n        // Pop from the\
    \ stacks until they're empty.\n        ArrayList<Long> depths = new ArrayList<Long>();\n\
    \        for (ArrayList<Long> stack : stacks) {\n            depths.add(maxDepth(stack));\n\
    \        }\n        return depths;", "        ArrayList<Long> results = new ArrayList<Long>();\n\
    \        ArrayList<Character> currParens = new ArrayList<Character>();\n     \
    \   long max = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n\
    \            if (paren_string.charAt(i) == '(') {\n                currParens.add(paren_string.charAt(i));\n\
    \                max++;\n            } else if (paren_string.charAt(i) == ')')\
    \ {\n                if (currParens.size() == 0) {\n                    System.out.println(\"\
    WARNING: unbalanced parentheses\");\n                    return results;\n   \
    \             }\n                currParens.remove(currParens.size() - 1);\n \
    \           } else if (paren_string.charAt(i) == ' ') {\n                if (currParens.size()\
    \ == 0) {\n                    results.add(max);\n                    max = 0;\n\
    \                } else {\n                    System.out.println(\"WARNING: unbalanced\
    \ parentheses\");\n                    return results;\n                }\n  \
    \          }\n        }\n        if (currParens.size() != 0) {\n            System.out.println(\"\
    WARNING: unbalanced parentheses\");\n            return results;\n        }\n\
    \        results.add(max);\n        return results;", "        // Fill in your\
    \ code here.\n        String [] tokens = paren_string.split(\" \");\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (String str : tokens) {\n     \
    \       result.add(new Long(countNestedParens(str)));\n        }\n        return\
    \ result;", "        ArrayList<Long> ret = new ArrayList<Long>();\n        String[]\
    \ tokens = paren_string.split(\" \");\n        for (String t : tokens) {\n   \
    \         long cnt = 0;\n            long max_cnt = 0;\n            for (int i\
    \ = 0; i < t.length(); i++) {\n                char c = t.charAt(i);\n       \
    \         if (c == '(') {\n                    cnt++;\n                    max_cnt\
    \ = Math.max(max_cnt, cnt);\n                } else if (c == ')') {\n        \
    \            cnt--;\n                }\n            }\n            ret.add(max_cnt);\n\
    \        }\n        return ret;", "        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        Stack<Long> stack = new Stack<Long>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                if\
    \ (stack.isEmpty()) {\n                    stack.push((long)0l);\n           \
    \     } else {\n                    stack.push(stack.peek() + (long)1l);\n   \
    \             }\n            } else if (paren_string.charAt(i) == ')') {\n   \
    \             stack.pop();\n            } else if (paren_string.charAt(i) == '\
    \ ') {\n                res.add(stack.peek());\n            }\n        }\n   \
    \     res.add(stack.peek());\n        return res;", "        // Fill in here\n\
    \        return new ArrayList<Long>();", "        ArrayList<Long> nest_list =\
    \ new ArrayList<Long>();\n        int nest_level = 0;\n        int max_nest_level\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i += 1) {\n       \
    \     char c = paren_string.charAt(i);\n            if (c == '(') {\n        \
    \        nest_level += 1;\n                if (nest_level > max_nest_level) {\n\
    \                    max_nest_level = nest_level;\n                }\n       \
    \     } else if (c == ')') {\n                nest_level -= 1;\n            }\
    \ else if (c == ' ') {\n                nest_list.add((long)max_nest_level);\n\
    \                max_nest_level = 0;\n                nest_level = 0;\n      \
    \      }\n        }\n        nest_list.add((long)max_nest_level);\n        return\
    \ nest_list;", "        ArrayList<Long> res = new ArrayList<Long>();\n       \
    \ String[] strings = paren_string.split(\" \");\n        for (String s : strings)\
    \ {\n            int i = 0;\n            int max = 0;\n            int depth =\
    \ 0;\n            while (i < s.length()) {\n                if (s.charAt(i) ==\
    \ '(') {\n                    depth++;\n                    max = Math.max(max,\
    \ depth);\n                } else {\n                    depth--;\n          \
    \      }\n                i++;\n            }\n            res.add((long)max);\n\
    \        }\n        return res;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        char[] a = paren_string.toCharArray();\n        int count = 0;\n    \
    \    int i = 0;\n        int j = 0;\n        for (int x = 0; x < a.length; x++)\
    \ {\n            if (a[x] == '(') {\n                count += 1;\n           \
    \ } else if (a[x] == ')') {\n                count -= 1;\n            } else if\
    \ (a[x] == ' ') {\n                int temp = count;\n                while (temp\
    \ != 0) {\n                    x += 1;\n                    if (a[x] == '(') {\n\
    \                        temp += 1;\n                    } else if (a[x] == ')')\
    \ {\n                        temp -= 1;\n                    }\n             \
    \   }\n                result.add((long)count);\n                count = 0;\n\
    \            }\n        }\n        return result;", "        ArrayList<Long> ret\
    \ = new ArrayList<Long>();\n        for (String paren : paren_string.split(\"\
    \ \")) {\n            ret.add(parse_nested_parens_helper(paren));\n        }\n\
    \        return ret;", "        // REPLACE THE BODY OF THIS METHOD WITH YOUR OWN\
    \ IMPLEMENTATION\n        return new ArrayList<Long>();", "        // Your code\
    \ here\n        return null;", "        paren_string = paren_string.replaceAll(\"\
    \\\\s\", \"\");\n        ArrayList<Long> output = new ArrayList<Long>();\n   \
    \     long count = 0;\n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            if (paren_string.charAt(i) == '(') {\n                count++;\n\
    \            } else if (paren_string.charAt(i) == ')') {\n                output.add(count);\n\
    \                count = 0;\n            }\n        }\n        return output;",
  "        String[] splits = paren_string.split(\" \");\n        ArrayList<Long> list\
    \ = new ArrayList<Long>();\n        for (String split : splits) {\n          \
    \  long max = 0l;\n            long count = 0l;\n            for (char c : split.toCharArray())\
    \ {\n                if (c == '(') {\n                    count++;\n         \
    \           max = Math.max(max, count);\n                } else if (c == ')')\
    \ {\n                    count--;\n                }\n            }\n        \
    \    list.add(max);\n        }\n        return list;", '        return _passTwo(paren_string);',
  '        throw new UnsupportedOperationException("Method parseNestedParens not implemented
    yet.");', "        ArrayList<Long> res = new ArrayList<Long>();\n        String[]\
    \ paren_groups = paren_string.split(\" \");\n        for (String paren_group :\
    \ paren_groups) {\n            long depth = 0;\n            long max_depth = 0;\n\
    \            for (int i = 0; i < paren_group.length(); i++) {\n              \
    \  if (paren_group.charAt(i) == '(') {\n                    depth++;\n       \
    \             max_depth = Math.max(max_depth, depth);\n                } else\
    \ if (paren_group.charAt(i) == ')') {\n                    depth--;\n        \
    \        }\n            }\n            res.add(max_depth);\n        }\n      \
    \  return res;", '        return new ArrayList<Long>();', '        return null;',
  "        int max_level = 0;\n        ArrayList<Long> max_levels = new ArrayList<Long>();\n\
    \        int level = 0;\n        for (char c : paren_string.toCharArray()) {\n\
    \            if (c == '(') {\n                level += 1;\n                max_level\
    \ = Math.max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level -= 1;\n            } else if (c == ' ') {\n                max_levels.add((long)max_level);\n\
    \                max_level = 0;\n                level = 0;\n            }\n \
    \       }\n        max_levels.add((long)max_level);\n        return max_levels;",
  "        // >>> parseNestedParens(\"(()()) ((())) () ((())()())\")\n        // [2,\
    \ 3, 1, 3]\n        var parens = new ArrayList<Long>();\n        paren_string\
    \ = paren_string.trim();\n        var paren_groups = paren_string.split(\"\\\\\
    s+\");\n        for (var paren_group : paren_groups) {\n            var stack\
    \ = new Stack<Long>();\n            var max = 0l;\n            var current = 0l;\n\
    \            for (var ch : paren_group.toCharArray()) {\n                if (ch\
    \ == '(') {\n                    stack.push(0l);\n                    current\
    \ += 1;\n                    max = Math.max(max, current);\n                }\
    \ else if (ch == ')') {\n                    if (stack.empty()) {\n          \
    \              throw new RuntimeException(\"Malformed string\");\n           \
    \         }\n                    stack.pop();\n                    current -=\
    \ 1;\n                } else {\n                    throw new RuntimeException(\"\
    Malformed string\");\n                }\n            }\n            if (!stack.empty())\
    \ {\n                throw new RuntimeException(\"Malformed string\");\n     \
    \       }\n            parens.add(max);\n        }\n        return parens;", " \
    \       // Write your code here.\n        return new ArrayList<Long>();", "  \
    \      int maxLevel = 0;\n        int level = 0;\n        ArrayList<Long> results\
    \ = new ArrayList<Long>();\n        String[] groups = paren_string.split(\" \"\
    );\n        for (String group : groups) {\n            maxLevel = 0;\n       \
    \     level = 0;\n            for (int i = 0; i < group.length(); i++) {\n   \
    \             if (group.charAt(i) == '(') {\n                    level++;\n  \
    \                  if (level > maxLevel) {\n                        maxLevel =\
    \ level;\n                    }\n                } else if (group.charAt(i) ==\
    \ ')') {\n                    level--;\n                }\n            }\n   \
    \         results.add((long)maxLevel);\n        }\n        return results;", " \
    \       ArrayList<Long> res = new ArrayList<Long>();\n        int max_nesting\
    \ = 0;\n        int cur_nesting = 0;\n        boolean open_paren = false;\n  \
    \      for (int i = 0; i < paren_string.length(); i++) {\n            char c =\
    \ paren_string.charAt(i);\n            if (c == '(') {\n                cur_nesting\
    \ += 1;\n                open_paren = true;\n            } else if (c == ')')\
    \ {\n                if (open_paren) {\n                    cur_nesting -= 1;\n\
    \                    open_paren = false;\n                } else {\n         \
    \           res.add((long) max_nesting);\n                    max_nesting = 0;\n\
    \                    cur_nesting = 0;\n                }\n            } else if\
    \ (c == ' ') {\n                if (open_paren) {\n                    max_nesting\
    \ = Math.max(max_nesting, cur_nesting);\n                    cur_nesting = 0;\n\
    \                    open_paren = false;\n                }\n            }\n \
    \       }\n        if (open_paren) {\n            max_nesting = Math.max(max_nesting,\
    \ cur_nesting);\n            cur_nesting = 0;\n            open_paren = false;\n\
    \        }\n        res.add((long) max_nesting);\n        return res;", "    \
    \    ArrayList<Long> arr = new ArrayList<Long>();\n        int[] max_lvl = new\
    \ int[1];\n        max_lvl[0] = 0;\n        String[] groups = paren_string.split(\"\
    \ \");\n        for (String s : groups) {\n            max_lvl[0] = 0;\n     \
    \       parseNestedParensUtil(s, 1, max_lvl);\n            arr.add((long)max_lvl[0]);\n\
    \        }\n        return arr;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (String paren : paren_string.split(\" \")) {\n            int depth\
    \ = 0;\n            int max_depth = 0;\n            for (char c : paren.toCharArray())\
    \ {\n                if (c == '(') {\n                    depth += 1;\n      \
    \              max_depth = Math.max(max_depth, depth);\n                } else\
    \ if (c == ')') {\n                    depth -= 1;\n                }\n      \
    \      }\n            result.add((long)max_depth);\n        }\n        return\
    \ result;", "        StringTokenizer tokens = new StringTokenizer(paren_string,\
    \ \" \");\n        ArrayList<Long> max_depth = new ArrayList<Long>();\n      \
    \  while (tokens.hasMoreTokens()) {\n            String group = tokens.nextToken();\n\
    \            int group_depth = 0;\n            long max_depth_group = 0;\n   \
    \         for (int i = 0; i < group.length(); i++) {\n                if (group.charAt(i)\
    \ == '(') {\n                    group_depth += 1;\n                    max_depth_group\
    \ = Math.max(max_depth_group, group_depth);\n                } else if (group.charAt(i)\
    \ == ')') {\n                    group_depth -= 1;\n                }\n      \
    \      }\n            max_depth.add(max_depth_group);\n        }\n        return\
    \ max_depth;", "        int depth = 0;\n        int max = 0;\n        List<Integer>\
    \ depths = new ArrayList<Integer>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char paren = paren_string.charAt(i);\n            if (paren\
    \ == '(') {\n                depth++;\n                if (depth > max) {\n  \
    \                  max = depth;\n                }\n            } else if (paren\
    \ == ')') {\n                depth--;\n            } else if (paren == ' ') {\n\
    \                depths.add(max);\n                max = 0;\n                depth\
    \ = 0;\n            }\n        }\n        depths.add(max);\n        return new\
    \ ArrayList<Long>(depths.stream().map(a -> (long)a).collect(Collectors.toList()));",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        ArrayList<Character>\
    \ open_parens = new ArrayList<Character>();\n        ArrayList<Character> close_parens\
    \ = new ArrayList<Character>();\n        Stack<Character> paren_stack = new Stack<Character>();\n\
    \        int i = 0;\n        int paren_max = 0;\n        while (i < paren_string.length())\
    \ {\n            if (paren_string.charAt(i) == '(') {\n                open_parens.add(paren_string.charAt(i));\n\
    \                paren_stack.push(paren_string.charAt(i));\n                paren_max\
    \ = Math.max(paren_max, paren_stack.size());\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                close_parens.add(paren_string.charAt(i));\n     \
    \           paren_stack.pop();\n            } else if (paren_string.charAt(i)\
    \ == ' ') {\n                result.add((long)paren_max);\n                paren_max\
    \ = 0;\n            }\n            i = i + 1;\n        }\n        result.add((long)paren_max);\n\
    \        return result;", '        return null;', "        ArrayList<Long> res\
    \ = new ArrayList<Long>();\n        for (String parens : paren_string.split(\"\
    \ \")) {\n            long maxCount = 0;\n            long currCount = 0;\n  \
    \          for (int i = 0; i < parens.length(); i++) {\n                if (parens.charAt(i)\
    \ == '(') {\n                    currCount += 1;\n                    maxCount\
    \ = Math.max(maxCount, currCount);\n                } else {\n               \
    \     currCount -= 1;\n                }\n            }\n            res.add(maxCount);\n\
    \        }\n        return res;", "        ArrayList<Long> out = new ArrayList<Long>();\n\
    \        // TODO: Implement this function\n        return out;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        return result;", "        ArrayList<Long>\
    \ nestingLevel = new ArrayList<Long>();\n        StringTokenizer st = new StringTokenizer(paren_string);\n\
    \        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n\
    \            // Your code goes here.\n            nestingLevel.add((long)0l);\n\
    \        }\n        return nestingLevel;", '        return new ArrayList<Long>();',
  "        String[] groups = paren_string.split(\" \");\n        ArrayList<Long> levels\
    \ = new ArrayList<Long>();\n        for (String g : groups) {\n            long\
    \ level = 0l;\n            for (int i = 0; i < g.length(); i++) {\n          \
    \      if (g.charAt(i) == '(') {\n                    level++;\n             \
    \   } else if (g.charAt(i) == ')') {\n                    level--;\n         \
    \       }\n            }\n            levels.add(level);\n        }\n        return\
    \ levels;", "        ArrayList<Long> results = new ArrayList<Long>();\n      \
    \  long max = 0;\n        String temp = \"\";\n        String[] groups = paren_string.split(\"\
    \ \");\n        for (int i = 0; i < groups.length; i++) {\n            temp =\
    \ groups[i];\n            long curr = 0;\n            for (int j = 0; j < temp.length();\
    \ j++) {\n                if (temp.charAt(j) == '(') {\n                    curr++;\n\
    \                } else if (temp.charAt(j) == ')') {\n                    curr--;\n\
    \                }\n                if (curr > max) {\n                    max\
    \ = curr;\n                }\n            }\n            results.add(max);\n \
    \           max = 0;\n        }\n        return results;", '        return null;',
  "        // checking whether input is a string and it's not null/empty\n       \
    \ if (!(paren_string instanceof String) || paren_string == null || paren_string.isEmpty())\
    \ {\n            throw new IllegalArgumentException(\"The input is either not\
    \ a string or empty.\");\n        }\n        // splitting string on ' ' in order\
    \ to parse each group separately\n        ArrayList<String> split_parens = new\
    \ ArrayList<String>(Arrays.asList(paren_string.split(\" \")));\n        // creating\
    \ an array to store the results of depth calculation per group\n        ArrayList<Long>\
    \ depth_count = new ArrayList<Long>();\n        // we need to check each of the\
    \ groups for the depth of nesting\n        for (String group : split_parens) {\n\
    \            // we need to store the current nested depth\n            long current_depth\
    \ = 0;\n            // we need to store the maximum nested depth\n           \
    \ long max_depth = 0;\n            // we need to store a character from the current\
    \ group\n            Character ch;\n            // we need to iterate through\
    \ each of the characters in the group\n            for (int i = 0; i < group.length();\
    \ i++) {\n                // store the current character\n                ch =\
    \ group.charAt(i);\n                // if opening parenthesis increase the current\
    \ depth\n                if (ch == '(') {\n                    current_depth++;\n\
    \                }\n                // if closing parenthesis decrease the current\
    \ depth\n                if (ch == ')') {\n                    current_depth--;\n\
    \                }\n                // if current depth is larger than maximum,\
    \ we are at the deepest level\n                if (current_depth > max_depth)\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            // add the maximum depth for this group to the depth_count\
    \ array\n            depth_count.add(max_depth);\n        }\n        // return\
    \ all the depths\n        return depth_count;", "        /* IMPLEMENTATION OF\
    \ parseNestedParens GOES HERE */\n        ArrayList<Long> output = new ArrayList<Long>();\n\
    \        ArrayList<Long> nestedLevel = new ArrayList<Long>();\n        long temp\
    \ = 0;\n        for(int i = 0; i < paren_string.length(); i++){\n            char\
    \ c = paren_string.charAt(i);\n            if(c == '('){\n                temp++;\n\
    \            }else if(c == ')'){\n                temp--;\n            }else if(c\
    \ == ' '){\n                nestedLevel.add(temp);\n                temp = 0;\n\
    \            }\n        }\n        for(int i = 0; i < nestedLevel.size(); i++){\n\
    \            long t = nestedLevel.get(i);\n            t = t / 2;\n          \
    \  output.add(t);\n        }\n        return output;", "        long n = paren_string.length();\n\
    \        ArrayList<Long> ret = new ArrayList<Long>();\n        long cur_max =\
    \ 0l;\n        long cur_depth = 0l;\n        for (long i = 0l; i < n; i++) {\n\
    \            char c = paren_string.charAt((int)i);\n            if (c == '(')\
    \ {\n                cur_depth += 1l;\n                cur_max = Math.max(cur_max,\
    \ cur_depth);\n            } else if (c == ')') {\n                cur_depth -=\
    \ 1l;\n            } else if (c == ' ') {\n                ret.add(cur_max);\n\
    \                cur_max = 0l;\n                cur_depth = 0l;\n            }\n\
    \        }\n        ret.add(cur_max);\n        return ret;", "        ArrayList<Long>\
    \ depth_of_nesting = new ArrayList<Long>();\n        // >>> (str.substring(0,\
    \ str.length()-1))\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length()-1)\n        // ((()()())(())())\n        // >>> str.substring(0,\
    \ str.length", "        ArrayList<Long> result = new ArrayList<Long>();\n    \
    \    ArrayList<Long> stack = new ArrayList<Long>();\n        Long first_open_paren_idx\
    \ = 0l;\n        Long idx = 0l;\n        for (Long _i = 0l; _i < paren_string.length();\
    \ _i++) {\n            final Long i = _i;\n            switch (paren_string.charAt(i.intValue()))\
    \ {\n                case '(':\n                    stack.add(i);\n          \
    \          break;\n                case ')':\n                    first_open_paren_idx\
    \ = stack.get(stack.size() - 1);\n                    stack.remove(stack.size()\
    \ - 1);\n                    result.add(idx);\n                    idx = first_open_paren_idx;\n\
    \                    break;\n                default:\n                    break;\n\
    \            }\n        }\n        return result;", "        ArrayList<Long> res\
    \ = new ArrayList<Long>();\n        for (String parens : paren_string.split(\"\
    \ \")) {\n            long max_depth = 0;\n            long cur_depth = 0;\n \
    \           for (char c : parens.toCharArray()) {\n                if (c == '(')\
    \ {\n                    cur_depth++;\n                    max_depth = Math.max(max_depth,\
    \ cur_depth);\n                } else if (c == ')') {\n                    cur_depth--;\n\
    \                }\n            }\n            res.add(max_depth);\n        }\n\
    \        return res;", "        // Assumptions: paren_string has well-formed parentheses\
    \ with no spaces in between.\n        // The paren_string is non-empty. Each paren_string\
    \ follows the form:\n        // (paren_string)* (paren_string)* ... (paren_string)*\n\
    \        // where each paren_string follows the form:\n        // ((paren_string)*)*((paren_string)*)*\
    \ ... ((paren_string)*)*\n        // In other words, each paren_string is the\
    \ concatenation of many groups of \n        // properly nested parentheses.\n\
    \        // The return value is an ArrayList containing the depth of nesting for\
    \ each group of\n        // parentheses.\n        // Example: The string, \"((())(())(()))()\"\
    \ has three paren_strings: \"(())(())(())\" and \"()\" and \"\".\n        // The\
    \ first has depth 3, the second has depth 1, and the third has depth 0. So the\
    \ return value\n        // should be an ArrayList with 3 elements having values\
    \ 3, 1, and 0, in that order.\n        return null;", "        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        String[] groups = paren_string.split(\"\
    \ \");\n        for (String s : groups) {\n            Stack<Character> st = new\
    \ Stack<Character>();\n            for (int i = 0; i < s.length(); i++) {\n  \
    \              if (s.charAt(i) == '(') {\n                    st.push('(');\n\
    \                } else {\n                    if (st.size() == 0) {\n       \
    \                 throw new IllegalArgumentException(\"String is not valid\");\n\
    \                    }\n                    st.pop();\n                }\n   \
    \         }\n            if (st.size() != 0) {\n                throw new IllegalArgumentException(\"\
    String is not valid\");\n            }\n            long depth = 0;\n        \
    \    for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) ==\
    \ '(') {\n                    depth++;\n                } else {\n           \
    \         depth--;\n                }\n                res.add(depth);\n     \
    \       }\n        }\n        return res;", "        ArrayList<Long> answer =\
    \ new ArrayList<Long>();\n        String[] arr = paren_string.split(\" \");\n\
    \        for (int i = 0; i < arr.length; i++) {\n            answer.add(0,0l);\n\
    \            int r = arr[i].length() - 1;\n            while (r >= 0) {\n    \
    \            long cur = answer.get(0);\n                if (arr[i].charAt(r) ==\
    \ ')') {\n                    answer.set(0, cur + 1);\n                } else\
    \ if (arr[i].charAt(r) == '(') {\n                    answer.set(0, cur - 1);\n\
    \                }\n                r--;\n            }\n            answer.remove(0);\n\
    \        }\n        return answer;", "        ArrayList<Long> nested_depth = new\
    \ ArrayList<Long>();\n        long maxdepth = 0l;\n        long depth = 0l;\n\
    \        boolean in_paren = false;\n        for (int i = 0; i < paren_string.length();\
    \ i += 1) {\n            char c = paren_string.charAt(i);\n            if (c ==\
    \ '(') {\n                depth += 1;\n                if (depth > maxdepth) {\n\
    \                    maxdepth = depth;\n                }\n                in_paren\
    \ = true;\n            } else if (c == ')') {\n                depth -= 1;\n \
    \               in_paren = false;\n            } else if (!in_paren) {\n     \
    \           nested_depth.add(maxdepth);\n                maxdepth = 0l;\n    \
    \        }\n        }\n        return nested_depth;", "        String[] parts\
    \ = paren_string.split(\" \");\n        ArrayList<Long> ans = new ArrayList<Long>();\n\
    \        for (String t : parts) {\n            long c = 0;\n            for (int\
    \ i = 0; i < t.length(); i++) {\n                if (t.charAt(i) == '(') {\n \
    \                   c++;\n                } else {\n                    c--;\n\
    \                }\n            }\n            ans.add(c);\n        }\n      \
    \  return ans;", "        ArrayList<Long> depths = new ArrayList<Long>();\n  \
    \      String[] paren_groups = paren_string.split(\" \");\n        for (String\
    \ paren_group : paren_groups) {\n            depths.add(countParenDepth(paren_group));\n\
    \        }\n        return depths;", "        int count = 0;\n        int max\
    \ = 0;\n        ArrayList<Long> ans = new ArrayList<Long>();\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(')\n                count++;\n            else if (paren_string.charAt(i)\
    \ == ')')\n                count--;\n            if (paren_string.charAt(i) ==\
    \ ' ') {\n                max = Math.max(max, count);\n                ans.add((long)\
    \ max);\n                max = 0;\n                count = 0;\n            }\n\
    \        }\n        max = Math.max(max, count);\n        ans.add((long) max);\n\
    \        return ans;", "        ArrayList<Long> out = new ArrayList<Long>();\n\
    \        // Fill out code here.\n        return out;", '        // Your code here',
  "        String[] arr = paren_string.split(\" \");\n        ArrayList<Long> res\
    \ = new ArrayList<Long>();\n        for (String s : arr) {\n            if (s.length()\
    \ == 0) {\n                res.add((long)0l);\n                continue;\n   \
    \         }\n            Stack<Character> st = new Stack<Character>();\n     \
    \       int max_level = 0;\n            int cur_level = 0;\n            for (int\
    \ i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '(') {\n \
    \                   st.push('(');\n                    cur_level++;\n        \
    \            max_level = Math.max(max_level, cur_level);\n                } else\
    \ {\n                    st.pop();\n                    cur_level--;\n       \
    \         }\n            }\n            res.add((long)max_level);\n        }\n\
    \        return res;", "        if (paren_string == null) {\n            throw\
    \ new IllegalArgumentException(\"paren_string can't be null.\");\n        } else\
    \ if (paren_string.isEmpty()) {\n            throw new IllegalArgumentException(\"\
    paren_string can't be empty.\");\n        } else {\n            ArrayList<Long>\
    \ ret = new ArrayList<Long>();\n            String[] parens = paren_string.split(\"\
    \ \");\n            for (String paren : parens) {\n                if (paren.length()\
    \ % 2 != 0) {\n                    throw new IllegalArgumentException(\"Invalid\
    \ input.\");\n                } else {\n                    int deep = 0;\n  \
    \                  int max = 0;\n                    for (int i = 0; i < paren.length();\
    \ i++) {\n                        if (paren.charAt(i) == '(') {\n            \
    \                deep++;\n                            if (deep > max) {\n    \
    \                            max = deep;\n                            }\n    \
    \                    } else if (paren.charAt(i) == ')') {\n                  \
    \          deep--;\n                        } else {\n                       \
    \     throw new IllegalArgumentException(\"Invalid input.\");\n              \
    \          }\n                    }\n                    ret.add((long)max);\n\
    \                }\n            }\n            return ret;\n        }", "    \
    \    ArrayList<Long> result = new ArrayList<Long>();\n        String[] parens\
    \ = paren_string.split(\"\\\\s+\");\n        for (String paren : parens) {\n \
    \           result.add(parenNestingLevel(paren));\n        }\n        return result;",
  '        return new ArrayList<Long>();', "        var al = new ArrayList<Long>();\n\
    \        for (var parens : paren_string.split(\" \")) {\n            var count\
    \ = 0L;\n            var max = 0L;\n            for (var c : parens.toCharArray())\
    \ {\n                if (c == '(') {\n                    count++;\n         \
    \           max = Math.max(max, count);\n                } else if (c == ')')\
    \ {\n                    count--;\n                }\n            }\n        \
    \    al.add(max);\n        }\n        return al;", '        return problem_solution_space.ProblemModule.parseNestedParens(paren_string);',
  "        ArrayList<Long> result = new ArrayList<Long>();\n        ArrayList<String>\
    \ paren_strings = new ArrayList<String>(Arrays.asList(paren_string.split(\" \"\
    )));\n        for (String s : paren_strings) {\n            long depth = 0;\n\
    \            long max_depth = 0;\n            for (int i = 0; i < s.length();\
    \ i++) {\n                if (s.charAt(i) == '(') {\n                    depth\
    \ += 1;\n                    max_depth = Math.max(max_depth, depth);\n       \
    \         } else if (s.charAt(i) == ')') {\n                    depth -= 1;\n\
    \                }\n            }\n            result.add(max_depth);\n      \
    \  }\n        return result;", '        return new ArrayList<Long>();', "    \
    \    ArrayList<Long> res = new ArrayList<Long>();\n        for (String paren_group\
    \ : paren_string.split(\" \")) {\n            res.add(helper(paren_group));\n\
    \        }\n        return res;", '        throw new UnsupportedOperationException("Answer
    not found");', "        ArrayList<Long> max_depth = new ArrayList<Long>();\n \
    \       String[] paren_strings = paren_string.split(\" \");\n        for (String\
    \ paren_str : paren_strings) {\n            Stack<Character> paren_stack = new\
    \ Stack<Character>();\n            long depth = 0;\n            long max_depth_so_far\
    \ = 0;\n            for (int i = 0; i < paren_str.length(); i++) {\n         \
    \       if (paren_str.charAt(i) == '(') {\n                    paren_stack.push('(');\n\
    \                    depth += 1;\n                    max_depth_so_far = Math.max(max_depth_so_far,\
    \ depth);\n                } else if (paren_str.charAt(i) == ')') {\n        \
    \            if (paren_stack.size() > 0) {\n                        paren_stack.pop();\n\
    \                        depth -= 1;\n                    } else {\n         \
    \               // paren_stack empty.\n                        depth = 0;\n  \
    \                  }\n                }\n            }\n            max_depth.add(max_depth_so_far);\n\
    \        }\n        return max_depth;", "        List<String> parenList = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Long> result = new ArrayList<Long>();\n        for\
    \ (String s : parenList) {\n            System.out.println(s);\n            Stack<Character>\
    \ stack = new Stack<Character>();\n            int max = 0;\n            int count\
    \ = 0;\n            for (int i = 0; i < s.length(); i++) {\n                char\
    \ temp = s.charAt(i);\n                if (temp == '(') {\n                  \
    \  stack.push(temp);\n                    count++;\n                    if (count\
    \ > max) {\n                        max = count;\n                    }\n    \
    \            } else if (temp == ')') {\n                    stack.pop();\n   \
    \                 count--;\n                }\n            }\n            result.add((long)max);\n\
    \        }\n        return result;", '        return new ArrayList<Long>();',
  "        ArrayList<Long> ret = new ArrayList<Long>();\n        Scanner s = new Scanner(paren_string);\n\
    \        while (s.hasNext()) {\n            String str = s.next();\n         \
    \   int max_paren_count = 0;\n            int paren_count = 0;\n            for\
    \ (int i = 0; i < str.length(); i++) {\n                if (str.charAt(i) == '(')\
    \ {\n                    paren_count += 1;\n                    max_paren_count\
    \ = Math.max(max_paren_count, paren_count);\n                } else if (str.charAt(i)\
    \ == ')') {\n                    paren_count -= 1;\n                }\n      \
    \      }\n            ret.add((long)max_paren_count);\n        }\n        return\
    \ ret;", "        ArrayList<Long> result = new ArrayList<Long>();\n        for\
    \ (String parens : paren_string.split(\" \")) {\n            char[] parens_array\
    \ = parens.toCharArray();\n            long max = 0;\n            long count =\
    \ 0;\n            for (char paren : parens_array) {\n                if (paren\
    \ == '(') {\n                    count += 1;\n                    max = count\
    \ > max ? count : max;\n                } else if (paren == ')') {\n         \
    \           count -= 1;\n                }\n            }\n            result.add(max);\n\
    \        }\n        return result;", "        // TODO: Write your code here.\n\
    \        ArrayList<Long> results = new ArrayList<Long>();\n        ArrayList<Long>\
    \ mystack = new ArrayList<Long>();\n        int len = paren_string.length();\n\
    \        int max = 0;\n        int count = 0;\n        int start = 0;\n      \
    \  for(int i = 0; i < len; i++){\n            char c = paren_string.charAt(i);\n\
    \            if(c == '('){\n                count++;\n                if(count\
    \ > max){\n                    max = count;\n                }\n            }else\
    \ if(c == ')'){\n                count--;\n            }else if(c == ' '){\n \
    \               results.add((long)max);\n                max = 0;\n          \
    \      count = 0;\n            }\n        }\n        results.add((long)max);\n\
    \        return results;", "        ArrayList<Long> answer = new ArrayList<Long>();\n\
    \        String[] listOfParens = paren_string.split(\" \");\n        for (String\
    \ paren : listOfParens) {\n            Stack<Character> stack = new Stack<Character>();\n\
    \            long depth = 0;\n            long max_depth = 0;\n            for\
    \ (char c : paren.toCharArray()) {\n                if (c == '(') {\n        \
    \            depth += 1;\n                    max_depth = Math.max(max_depth,\
    \ depth);\n                } else if (c == ')') {\n                    depth -=\
    \ 1;\n                }\n            }\n            answer.add(max_depth);\n \
    \       }\n        return answer;", "        // 1) Split string by space.\n  \
    \      // 2) For each paren string, find the number of nested levels of parentheses.\n\
    \        // 3) Return a list of integers where each integer corresponds to the\
    \ number of nested levels of parentheses in the ith paren string.\n        ArrayList<Long>\
    \ longest_level_list = new ArrayList<Long>();\n        String[] paren_strings\
    \ = paren_string.split(\" \");\n        for (String parens : paren_strings) {\n\
    \            Stack<String> paren_stack = new Stack<String>();\n            long\
    \ max_level = 0l;\n            for (int i = 0; i < parens.length(); i++) {\n \
    \               if (parens.charAt(i) == '(') {\n                    paren_stack.push(\"\
    (\");\n                    if (paren_stack.size() > max_level) {\n           \
    \             max_level = paren_stack.size();\n                    }\n       \
    \         } else if (parens.charAt(i) == ')') {\n                    paren_stack.pop();\n\
    \                }\n            }\n            longest_level_list.add(max_level);\n\
    \        }\n        return longest_level_list;", "        ArrayList<Long> ret\
    \ = new ArrayList<Long>();\n        int maxNestDepth = 0;\n        int currentNestDepth\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n          \
    \  if (paren_string.charAt(i) == '(') {\n                currentNestDepth += 1;\n\
    \                maxNestDepth = Math.max(maxNestDepth, currentNestDepth);\n  \
    \          } else if (paren_string.charAt(i) == ')') {\n                currentNestDepth\
    \ -= 1;\n            } else if (paren_string.charAt(i) == ' ') {\n           \
    \     ret.add((long)maxNestDepth);\n                maxNestDepth = 0;\n      \
    \          currentNestDepth = 0;\n            }\n        }\n        return ret;",
  "        ArrayList<Long> max_count = new ArrayList<Long>();\n        // input_array\
    \ is an array of strings separated by space.\n        String[] input_array = paren_string.split(\"\
    \ \");\n        for (int i = 0; i < input_array.length; i++) {\n            long\
    \ count = 0;\n            for (int j = 0; j < input_array[i].length(); j++) {\n\
    \                if (input_array[i].charAt(j) == '(') {\n                    count++;\n\
    \                } else if (input_array[i].charAt(j) == ')') {\n             \
    \       max_count.add(count);\n                    count--;\n                }\n\
    \            }\n        }\n        return max_count;", "        long n = paren_string.length();\n\
    \        long max_depth = 0l;\n        long depth = 0l;\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (long x = 0l; x < n; x++) {\n \
    \           char c = paren_string.charAt((int)x);\n            if (c == '(') {\n\
    \                depth += 1l;\n                max_depth = Math.max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth -= 1l;\n\
    \            } else if (c == ' ') {\n                result.add(max_depth);\n\
    \                max_depth = 0l;\n                depth = 0l;\n            }\n\
    \        }\n        if (max_depth > 0l) {\n            result.add(max_depth);\n\
    \        }\n        return result;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        // >>> Implement me!\n        long max=0;\n        long cur=0;\n    \
    \    ArrayList<Character> temp=new ArrayList<Character>();\n        boolean flag=false;\n\
    \        for(int i=0;i<paren_string.length();i++){\n            if(paren_string.charAt(i)=='('){\n\
    \                temp.add(paren_string.charAt(i));\n                cur++;\n \
    \               if(cur>max){\n                    max=cur;\n                }\n\
    \            }\n            else if(paren_string.charAt(i)==')'){\n          \
    \      temp.add(paren_string.charAt(i));\n                cur--;\n           \
    \ }\n            else if(paren_string.charAt(i)==' '){\n                if(!temp.isEmpty()\
    \ && temp.get(0)=='(' && temp.get(temp.size()-1)==')'){\n                    flag=true;\n\
    \                }\n                else{\n                    flag=false;\n \
    \               }\n                if(flag){\n                    temp.clear();\n\
    \                    result.add(max);\n                    max=0;\n          \
    \          cur=0;\n                }\n            }\n        }\n        return\
    \ result;", "        ArrayList<Long> results = new ArrayList<Long>();\n      \
    \  if (paren_string == null || paren_string.isEmpty()) {\n            return results;\n\
    \        }\n        long maxdepth = 0;\n        long count = 0;\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                count++;\n                maxdepth = Math.max(maxdepth,\
    \ count);\n            } else if (paren_string.charAt(i) == ')') {\n         \
    \       count--;\n            } else if (paren_string.charAt(i) == ' ') {\n  \
    \              results.add(maxdepth);\n                maxdepth = 0;\n       \
    \         count = 0;\n            }\n        }\n        results.add(maxdepth);\n\
    \        return results;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        return result;", "        // Iterate through each character and check\
    \ if it is an opening bracket.\n        // If so, track the max depth and set\
    \ it to the next character.\n        // If not, check if it is a closing bracket.\n\
    \        // If so, reduce the max depth by 1.\n        // This algorithm works\
    \ because we will only be looking at the max depth of the current group at any\
    \ given time.\n        // We know the depth of the current group will only be\
    \ reduced by one when we hit a closing bracket.\n        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        long maxDepth = 0;\n        long currDepth\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n          \
    \  if (paren_string.charAt(i) == '(') {\n                currDepth++;\n      \
    \          maxDepth = Math.max(maxDepth, currDepth);\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                currDepth--;\n            } else if (paren_string.charAt(i)\
    \ == ' ') {\n                result.add(maxDepth);\n                maxDepth =\
    \ 0;\n                currDepth = 0;\n            }\n        }\n        result.add(maxDepth);\n\
    \        return result;", "        ArrayList<Long> paren_levels = new ArrayList<Long>();\n\
    \        String[] tokens = paren_string.split(\"\\\\s+\");\n        for (String\
    \ token : tokens) {\n            paren_levels.add(deepestNesting(token));\n  \
    \      }\n        return paren_levels;", "        // Take the string and split\
    \ the string based on spaces\n        String[] paren_groups = paren_string.split(\"\
    \ \");\n        ArrayList<Long> result = new ArrayList<Long>();\n        for (String\
    \ single_group : paren_groups) {\n            // We keep track of the maximum\
    \ value seen so far.\n            // We also keep track of the current level of\
    \ nesting.\n            long max_seen = 0;\n            long current_level = 0;\n\
    \            // Now we loop through each character of each group.\n          \
    \  for (int i = 0; i < single_group.length(); i++) {\n                if (single_group.charAt(i)\
    \ == '(') {\n                    // We increment the nesting level by 1.\n   \
    \                 current_level += 1;\n                    // We check if the\
    \ current level exceeds max seen.\n                    if (current_level > max_seen)\
    \ {\n                        max_seen = current_level;\n                    }\n\
    \                } else if (single_group.charAt(i) == ')') {\n               \
    \     // We decrement the nesting level by 1.\n                    current_level\
    \ -= 1;\n                }\n            }\n            // We then add the deepest\
    \ nesting to the result.\n            result.add(max_seen);\n        }\n     \
    \   return result;", "        // Write your code here.\n        return null;",
  "        // Replace this code with a faster implementation\n        return (new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)));", " \
    \       ArrayList<Long> max_parens = new ArrayList<Long>();\n        long max_depth\
    \ = 0;\n        long curr_depth = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                curr_depth++;\n\
    \                if (curr_depth > max_depth) {\n                    max_depth\
    \ = curr_depth;\n                }\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                if (curr_depth == 0) {\n                    max_parens.add((long)0);\n\
    \                } else {\n                    curr_depth--;\n               \
    \ }\n            } else if (paren_string.charAt(i) == ' ') {\n               \
    \ max_parens.add(max_depth);\n                max_depth = 0;\n               \
    \ curr_depth = 0;\n            }\n        }\n        max_parens.add(max_depth);\n\
    \        return max_parens;", "        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        return res;", "        final int PARENS_STRING_INDEX = 0;\n        final\
    \ int PARENS_INDEX = 1;\n        final int DEPTH_INDEX = 2;\n        final long\
    \ NUM_PARENS_STRINGS = Long.parseLong(\"1\");\n        final long NUM_PARENS =\
    \ Long.parseLong(\"2\");\n        final long NUM_DEPTHS = Long.parseLong(\"3\"\
    );\n        final long NUM_CHARS = Long.parseLong(\"100\");\n        final long\
    \ NUM_SPACES = Long.parseLong(\"100\");\n        final long NUM_LETTERS = Long.parseLong(\"\
    26\");\n        ArrayList<Long> paren_string_list = splitStringIntoCharacters(paren_string);\n\
    \        ArrayList<Long> parens_list = new ArrayList<Long>();\n        ArrayList<Long>\
    \ depth_list = new ArrayList<Long>();\n        long parens_iter = Long.parseLong(\"\
    0\");\n        long depth_iter = Long.parseLong(\"0\");\n        for (long i =\
    \ Long.parseLong(\"0\"); ((i) < (count(paren_string_list))); i = (i) + (Long.parseLong(\"\
    1\"))) {\n            if ((paren_string_list.get((int)(i))) == (Long.parseLong(\"\
    40\"))) {\n                depth_iter = (depth_iter) + (Long.parseLong(\"1\"));\n\
    \            } else if ((paren_string_list.get((int)(i))) == (Long.parseLong(\"\
    41\"))) {\n                depth_iter = (depth_iter) - (Long.parseLong(\"1\"));\n\
    \            } else if ((paren_string_list.get((int)(i))) == (Long.parseLong(\"\
    32\"))) {\n                depth_list.add(depth_iter);\n                depth_iter\
    \ = Long.parseLong(\"0\");\n            }\n        }\n        depth_list.add(depth_iter);\n\
    \        return depth_list;", "        //parseNestedParens\n        return new\
    \ ArrayList<Long>();"]
stop_tokens:
- "\n    }\n"
