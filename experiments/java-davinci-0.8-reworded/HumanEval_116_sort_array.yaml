name: HumanEval_116_sort_array
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // In this Kata, you have to sort an array array list of non-negative\
  \ integers according to\n    // number of ones in their binary representation in\
  \ ascending order.\n    // For similar number of ones, sort based on decimal value.\n\
  \    // It must be implemented like this:\n    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)5l, (long)2l, (long)3l, (long)4l))))\n    // (new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)2l, (long)3l, (long)4l, (long)5l)))\n    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)-2l,\
  \ (long)-3l, (long)-4l, (long)-5l, (long)-6l))))\n    // (new ArrayList<Long>(Arrays.asList((long)-6l,\
  \ (long)-5l, (long)-4l, (long)-3l, (long)-2l)))\n    // >>> sortArray((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)0l, (long)2l, (long)3l, (long)4l))))\n    // (new ArrayList<Long>(Arrays.asList((long)0l,\
  \ (long)1l, (long)2l, (long)3l, (long)4l)))\n    public static ArrayList<Long> sortArray(ArrayList<Long>\
  \ arr) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(sortArray((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)2l, (long)3l, (long)4l)))).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)4l, (long)3l, (long)5l)))));\n\
  \    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)-2l, (long)-3l, (long)-4l,\
  \ (long)-5l, (long)-6l)))).equals((new ArrayList<Long>(Arrays.asList((long)-4l,\
  \ (long)-2l, (long)-6l, (long)-5l, (long)-3l)))));\n    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)0l, (long)2l, (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)0l,\
  \ (long)1l, (long)2l, (long)4l, (long)3l)))));\n    assert(sortArray((new ArrayList<Long>(Arrays.asList()))).equals((new\
  \ ArrayList<Long>(Arrays.asList()))));\n    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)5l, (long)77l, (long)4l, (long)5l, (long)3l, (long)5l, (long)7l, (long)2l,\
  \ (long)3l, (long)4l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)2l,\
  \ (long)4l, (long)4l, (long)3l, (long)3l, (long)5l, (long)5l, (long)5l, (long)7l,\
  \ (long)77l)))));\n    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)3l,\
  \ (long)6l, (long)44l, (long)12l, (long)32l, (long)5l)))).equals((new ArrayList<Long>(Arrays.asList((long)32l,\
  \ (long)3l, (long)5l, (long)6l, (long)12l, (long)44l)))));\n    assert(sortArray((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l, (long)16l, (long)32l)))).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l, (long)16l, (long)32l)))));\n\
  \    assert(sortArray((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)8l,\
  \ (long)16l, (long)32l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)4l,\
  \ (long)8l, (long)16l, (long)32l)))));\n    }\n\n}\n"
completions: ["        // return arr.stream().sorted(new Comparator<Long>() {\n  \
    \      //     @Override\n        //     public int compare(Long i1, Long i2) {\n\
    \        //         if (i1.equals(i2)) {\n        //             return 0;\n \
    \       //         }\n        //         int c1 = Long.bitCount(i1);\n       \
    \ //         int c2 = Long.bitCount(i2);\n        //         return c1 > c2 ?\
    \ 1 : c1 < c2 ? -1 : i1 > i2 ? 1 : -1;\n        //     }\n        // }).collect(Collectors.toCollection(ArrayList::new));\n\
    \        return arr.stream().sorted(Comparator.comparingInt(i -> Long.bitCount(i)).thenComparing(i\
    \ -> i)).collect(Collectors.toCollection(ArrayList::new));", "        List<Pair<Long,\
    \ Long>> rank = new ArrayList<>();\n        for (Long x : arr) {\n           \
    \ rank.add(new Pair<Long, Long>(kata5.Problem.countOnes(x), x));\n        }\n\
    \        // sort by ones first then sort by number (if ones are equal)\n     \
    \   Collections.sort(rank, new Comparator<Pair<Long, Long>>() {\n            @Override\n\
    \            public int compare(Pair<Long, Long> o1, Pair<Long, Long> o2) {\n\
    \                if (o1.getValue0().equals(o2.getValue0())) {\n              \
    \      return o1.getValue1().compareTo(o2.getValue1());\n                }\n \
    \               return o1.getValue0().compareTo(o2.getValue0());\n           \
    \ }\n        });\n        ArrayList<Long> sorted = new ArrayList<>();\n      \
    \  for (Pair<Long, Long> p : rank) {\n            sorted.add(p.getValue1());\n\
    \        }\n        return sorted;", "        Collections.sort(arr, (x, y) ->\
    \ {\n            int v = Integer.bitCount(x.intValue()) - Integer.bitCount(y.intValue());\n\
    \            if (v != 0) {\n                return v;\n            }\n       \
    \     return Long.compare(x, y);\n        });\n        return arr;", "       \
    \ if (arr == null) {\n            return null;\n        }\n        else if (arr.size()\
    \ == 0) {\n            return arr;\n        }\n        else {\n            int\
    \ numOnesInBinary(long arg) {\n                String bin = Long.toBinaryString(arg);\n\
    \                int count = 0;\n                for (int i = 0; i < bin.length();\
    \ i++) {\n                    if (bin.charAt(i) == '1') {\n                  \
    \      count++;\n                    }\n                }\n                return\
    \ count;\n            }\n            boolean isSorted = false;\n            while\
    \ (!isSorted) {\n                isSorted = true;\n                for (int i\
    \ = 0; i < arr.size() - 1; i++) {\n                    if (numOnesInBinary(arr.get(i))\
    \ > numOnesInBinary(arr.get(i + 1))) {\n                        isSorted = false;\n\
    \                        Collections.swap(arr, i, i + 1);\n                  \
    \  }\n                    else if (numOnesInBinary(arr.get(i)) == numOnesInBinary(arr.get(i\
    \ + 1))) {\n                        if (arr.get(i) > arr.get(i + 1)) {\n     \
    \                       isSorted = false;\n                            Collections.swap(arr,\
    \ i, i + 1);\n                        }\n                    }\n             \
    \   }\n            }\n            return arr;\n        }", "        ArrayList<Long>\
    \ nonNegativeInts = new ArrayList<Long>();\n        ArrayList<Long> negativeInts\
    \ = new ArrayList<Long>();\n        for (long num : arr) {\n            if (num\
    \ < 0) {\n                negativeInts.add(num);\n            } else {\n     \
    \           nonNegativeInts.add(num);\n            }\n        }\n        nonNegativeInts.sort(new\
    \ Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ num1, Long num2) {\n                int num1Ones = Long.bitCount(num1);\n  \
    \              int num2Ones = Long.bitCount(num2);\n                if (num1Ones\
    \ == num2Ones) {\n                    return num1.compareTo(num2);\n         \
    \       } else {\n                    return num1Ones - num2Ones;\n          \
    \      }\n            }\n        });\n        negativeInts.sort(new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long num1, Long num2)\
    \ {\n                int num1Ones = Long.bitCount(Math.abs(num1));\n         \
    \       int num2Ones = Long.bitCount(Math.abs(num2));\n                if (num1Ones\
    \ == num2Ones) {\n                    return num1.compareTo(num2);\n         \
    \       } else {\n                    return num1Ones - num2Ones;\n          \
    \      }\n            }\n        });\n        Collections.reverse(negativeInts);\n\
    \        nonNegativeInts.addAll(negativeInts);\n        return nonNegativeInts;",
  "        ArrayList<Long> copy = new ArrayList<Long>(arr);\n        for (int i =\
    \ 0; i < copy.size(); i++) {\n            long val = copy.get(i);\n          \
    \  int  count = (int)Long.bitCount(val);\n            copy.set(i, (long)count);\n\
    \        }\n        Pair<ArrayList<Long>, ArrayList<Long>> xs = List.unzip(List.zip(copy,\
    \ arr));\n        ArrayList<Long> ones = xs.getValue0();\n        ArrayList<Long>\
    \ vals = xs.getValue1();\n        Pair<ArrayList<Long>, ArrayList<Long>> ys =\
    \ List.unzip(List.zip(ones, vals));\n        ArrayList<Long> newOnes = ys.getValue0();\n\
    \        ArrayList<Long> newVals = ys.getValue1();\n        Pair<ArrayList<Long>,\
    \ ArrayList<Long>> zs = List.unzip(List.zip(newOnes, newVals));\n        ArrayList<Long>\
    \ onesSorted = zs.getValue0();\n        ArrayList<Long> valsSorted = zs.getValue1();\n\
    \        Collections.sort(onesSorted);\n        Collections.sort(valsSorted);\n\
    \        Pair<ArrayList<Long>, ArrayList<Long>> ws = List.unzip(List.zip(onesSorted,\
    \ valsSorted));\n        ArrayList<Long> sortedOnes = ws.getValue0();\n      \
    \  ArrayList<Long> sortedVals = ws.getValue1();\n        List<Long> sorted = List.zip(sortedOnes,\
    \ sortedVals).stream().map(e -> e.getValue1()).collect(Collectors.toList());\n\
    \        return new ArrayList<Long>(sorted);", "        ArrayList<String> temp\
    \ = new ArrayList<String>();\n        ArrayList<Long> temp2 = new ArrayList<Long>();\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        ArrayList<Long>\
    \ temp3 = new ArrayList<Long>();\n        ArrayList<Long> result2 = new ArrayList<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            long n = arr.get(i);\n\
    \            if (n > 0) {\n                long j = n;\n                int count\
    \ = 0;\n                while (j > 0) {\n                    if (j % 2 == 1) {\n\
    \                        count++;\n                    }\n                   \
    \ j = j / 2;\n                }\n                temp.add(Integer.toString(count)\
    \ + \"-\" + Long.toString(n));\n            } else {\n                temp.add(Integer.toString(0)\
    \ + \"-\" + Long.toString(n));\n            }\n        }\n        Collections.sort(temp);\n\
    \        for (int i = 0; i < temp.size(); i++) {\n            String str = temp.get(i);\n\
    \            String[] words = str.split(\"-\");\n            long k = Long.parseLong(words[1]);\n\
    \            result.add(k);\n        }\n        return result;", "        // Your\
    \ code here\n        long[] array = new long[arr.size()];\n        for (int i\
    \ = 0; i < arr.size(); i++)\n            array[i] = arr.get(i);\n        Arrays.sort(array);\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i =\
    \ 0; i < array.length; i++)\n            result.add(array[i]);\n        return\
    \ result;", "        // 1l 11111111111111111111111111111111\n        // 2l 10000000000000000000000000000000\n\
    \        // 3l 10000000000000000000000000000001\n        ArrayList<Long> zeroList\
    \ = new ArrayList<Long>();\n        ArrayList<Long> oneList = new ArrayList<Long>();\n\
    \        for (Long i : arr) {\n            if (BigInteger.valueOf(i).bitCount()\
    \ == 0) {\n                zeroList.add(i);\n            } else {\n          \
    \      oneList.add(i);\n            }\n        }\n        if (zeroList.size()\
    \ > 0) {\n            zeroList.sort(null);\n        }\n        if (oneList.size()\
    \ > 0) {\n            oneList.sort(null);\n        }\n        zeroList.addAll(oneList);\n\
    \        return zeroList;", "        ArrayList<Tuple> array = new ArrayList<Tuple>();\n\
    \        ArrayList<Long> answer = new ArrayList<Long>();\n        for (int i =\
    \ 0; i < arr.size(); i++) {\n            String bin = Long.toBinaryString(arr.get(i));\n\
    \            int ones = 0;\n            for (int j = 0; j < bin.length(); j++)\
    \ {\n                if (bin.charAt(j) == '1') {\n                    ones++;\n\
    \                }\n            }\n            Tuple t = new Tuple(arr.get(i),\
    \ ones);\n            array.add(t);\n        }\n        Collections.sort(array,\
    \ new Comparator<Tuple>() {\n            @Override\n            public int compare(Tuple\
    \ o1, Tuple o2) {\n                int first = o1.ones;\n                int second\
    \ = o2.ones;\n                if (first == second) {\n                    return\
    \ o1.value.compareTo(o2.value);\n                }\n                return Integer.compare(first,\
    \ second);\n            }\n        });\n        for (int i = 0; i < array.size();\
    \ i++) {\n            answer.add(array.get(i).value);\n        }\n        return\
    \ answer;", "        Comparator<Long> comparator = (Long a, Long b) -> {\n   \
    \         if(Long.bitCount(a) == Long.bitCount(b)) {\n                return Long.compare(a,\
    \ b);\n            }\n            return Long.compare(Long.bitCount(a), Long.bitCount(b));\n\
    \        };\n        Collections.sort(arr, comparator);\n        return arr;",
  "        List<Pair<Long, String>> temp = new ArrayList<>();\n        for (Long n\
    \ : arr) {\n            String binaryString = Long.toBinaryString(n);\n      \
    \      temp.add(new Pair<>(n, binaryString));\n        }\n        temp.sort((a,\
    \ b) -> {\n            int onesInA = a.getValue1().replaceAll(\"0\", \"\").length();\n\
    \            int onesInB = b.getValue1().replaceAll(\"0\", \"\").length();\n \
    \           return onesInA == onesInB ? a.getValue0().compareTo(b.getValue0())\
    \ : onesInA - onesInB;\n        });\n        List<Long> result = new ArrayList<>();\n\
    \        for (Pair<Long, String> p : temp) {\n            result.add(p.getValue0());\n\
    \        }\n        return new ArrayList<>(result);", "        TreeMap<Integer,\
    \ ArrayList<Long>> map = new TreeMap<>();\n        ArrayList<Long> ans = new ArrayList<>();\n\
    \        int c = 0;\n        String s = \"\";\n        for (Long i : arr) {\n\
    \            s = Long.toBinaryString(i);\n            c = s.length() - s.replace(\"\
    1\", \"\").length();\n            if (map.containsKey(c)) {\n                map.get(c).add(i);\n\
    \            } else {\n                ArrayList<Long> temp = new ArrayList<>();\n\
    \                temp.add(i);\n                map.put(c, temp);\n           \
    \ }\n        }\n        for (Integer i : map.keySet()) {\n            Collections.sort(map.get(i));\n\
    \            ans.addAll(map.get(i));\n        }\n        return ans;", "     \
    \   ArrayList<Pair<Long, Integer>> onesPairs = new ArrayList<>();\n        for\
    \ (Long i : arr) {\n            int ones = Long.bitCount(i);\n            onesPairs.add(new\
    \ Pair<>(i, ones));\n        }\n        onesPairs.sort((a, b) -> {\n         \
    \   if (a.getValue1() < b.getValue1()) {\n                return -1;\n       \
    \     } else if (a.getValue1() > b.getValue1()) {\n                return 1;\n\
    \            } else {\n                if (a.getValue0() < b.getValue0()) {\n\
    \                    return -1;\n                } else if (a.getValue0() > b.getValue0())\
    \ {\n                    return 1;\n                } else {\n               \
    \     return 0;\n                }\n            }\n        });\n        ArrayList<Long>\
    \ sortedArray = new ArrayList<>();\n        for (Pair<Long, Integer> pair : onesPairs)\
    \ {\n            sortedArray.add(pair.getValue0());\n        }\n        return\
    \ sortedArray;", "        // return new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l, (long)5l));\n        ArrayList<Long> ret = new\
    \ ArrayList<Long>();\n        HashMap<Long, Long> map = new HashMap<Long, Long>();\n\
    \        for (Long i : arr) {\n            String bitString = Long.toBinaryString(i);\n\
    \            Long bitSum = 0l;\n            for (char ch : bitString.toCharArray())\
    \ {\n                if (ch == '1') {\n                    bitSum += 1l;\n   \
    \             }\n            }\n            Long number = map.get(bitSum);\n \
    \           if (number == null) {\n                number = 0l;\n            }\n\
    \            map.put(bitSum, number + 1l);\n        }\n        System.out.println(map);\n\
    \        List<Long> bitList = new ArrayList<Long>(map.keySet());\n        Collections.sort(bitList);\n\
    \        for (Long bit : bitList) {\n            Long number = map.get(bit);\n\
    \            for (Long i = 0l; i < number; i++) {\n                ret.add(bit);\n\
    \            }\n        }\n        return ret;", "        // Write your code here\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            for (int j = i +\
    \ 1; j < arr.size(); j++) {\n                if (Long.bitCount(arr.get(i)) > Long.bitCount(arr.get(j)))\
    \ {\n                    swap(arr, i, j);\n                } else if (Long.bitCount(arr.get(i))\
    \ == Long.bitCount(arr.get(j))) {\n                    if (arr.get(i) > arr.get(j))\
    \ {\n                        swap(arr, i, j);\n                    }\n       \
    \         }\n            }\n        }\n        return arr;", "        // long\
    \ time = System.nanoTime();\n        // int n = arr.size();\n        // int ones[][]\
    \ = new int[2][n];\n        // for (int i = 0; i < n; i++) {\n        //     long\
    \ x = arr.get(i);\n        //     if (x < 0) {\n        //         x = -x;\n \
    \       //         ones[0][i] = n;\n        //     }\n        //     while (x\
    \ > 0) {\n        //         ones[0][i]++;\n        //         ones[1][i] = (int)x;\n\
    \        //         x /= 2;\n        //     }\n        // }\n        // for (int\
    \ i = 1; i < n; i++) {\n        //     int j = i - 1;\n        //     while (j\
    \ >= 0 && ones[0][j] > ones[0][j + 1]) {\n        //         int tmp = ones[0][j];\n\
    \        //         ones[0][j] = ones[0][j + 1];\n        //         ones[0][j\
    \ + 1] = tmp;\n        //         long tmp1 = arr.get(j);\n        //        \
    \ arr.set(j, arr.get(j + 1));\n        //         arr.set(j + 1, tmp1);\n    \
    \    //         j--;\n        //     }\n        // }\n        // for (int i =\
    \ 1; i < n; i++) {\n        //     int j = i - 1;\n        //     while (j >=\
    \ 0 && ones[0][j] == ones[0][j + 1] && ones[1][j] > ones[1][j + 1]) {\n      \
    \  //         int tmp = ones[1][j];\n        //         ones[1][j] = ones[1][j\
    \ + 1];\n        //         ones[1][j + 1] = tmp;\n        //         long tmp1\
    \ = arr.get(j);\n        //         arr.set(j, arr.get(j + 1));\n        //  \
    \       arr.set(j + 1, tmp1);\n        //         j--;\n        //     }\n   \
    \     // }\n        // System.out", "        // long[] arr2 = arr.stream().mapToLong(Long::longValue).toArray();\n\
    \        // long[] arr3 = Arrays.stream(arr2).map(n -> Long.bitCount(n)).toArray();\n\
    \        // long[] arr4 = Arrays.stream(arr2).map(n -> n).toArray();\n       \
    \ // int[] arr5 = IntStream.range(0, arr3.length).toArray();\n        // Arrays.sort(arr5,\
    \ new Comparator<Integer>() {\n        //     @Override\n        //     public\
    \ int compare(Integer a, Integer b) {\n        //         if (arr3[a] == arr3[b])\
    \ {\n        //             return arr4[a] < arr4[b] ? -1 : 1;\n        //   \
    \      }\n        //         return arr3[a] < arr3[b] ? -1 : 1;\n        //  \
    \   }\n        // });\n        // ArrayList<Long> finalList = new ArrayList<Long>();\n\
    \        // for (int x : arr5) {\n        //     finalList.add(arr2[x]);\n   \
    \     // }\n        // return finalList;\n        return arr.stream().map(n ->\
    \ new Pair<Long, Long>(n, Long.bitCount(n))).sorted((a, b) -> {\n            if\
    \ (a.getValue1().equals(b.getValue1())) {\n                return a.getValue0().compareTo(b.getValue0());\n\
    \            }\n            return a.getValue1().compareTo(b.getValue1());\n \
    \       }).map(t -> t.getValue0()).collect(Collectors.toCollection(ArrayList::new));",
  "        if (arr == null)\n            return null;\n        ArrayList<Long> sortedArray\
    \ = new ArrayList<Long>();\n        Map<Integer, Long> countMap = new HashMap<Integer,\
    \ Long>();\n        for (Long n : arr) {\n            int bitCount = BigInteger.valueOf(n).bitCount();\n\
    \            if (countMap.containsKey(bitCount)) {\n                if (n < countMap.get(bitCount))\
    \ {\n                    countMap.put(bitCount, n);\n                }\n     \
    \       } else {\n                countMap.put(bitCount, n);\n            }\n\
    \        }\n        for (int i = 0; i < arr.size(); i++) {\n            sortedArray.add(countMap.get(i));\n\
    \        }\n        return sortedArray;", "        Map<Long, List<Long>> map =\
    \ new HashMap<>();\n        for (long num : arr) {\n            int count = Integer.bitCount(num);\n\
    \            if (!map.containsKey(count)) {\n                map.put(count, new\
    \ ArrayList<>());\n            }\n            map.get(count).add(num);\n     \
    \   }\n        for (List<Long> list : map.values()) {\n            Collections.sort(list);\n\
    \        }\n        ArrayList<Long> ans = new ArrayList<>();\n        for (long\
    \ count = 0; count < Collections.max(map.keySet()) + 1; count++) {\n         \
    \   if (map.containsKey(count)) {\n                ans.addAll(map.get(count));\n\
    \            }\n        }\n        return ans;", "        arr.sort(new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long a, Long b) {\n\
    \                return getNumberOfOnes(a) == getNumberOfOnes(b) ? a.compareTo(b)\
    \ : getNumberOfOnes(a) - getNumberOfOnes(b);\n            }\n        });\n   \
    \     return arr;", "        ArrayList<Long> ans = new ArrayList<Long>();\n  \
    \      HashMap<Long, ArrayList<Long>> ones = new HashMap<Long, ArrayList<Long>>();\n\
    \        for (long i : arr) {\n            int c = 0;\n            for (char ch\
    \ : Long.toBinaryString(i).toCharArray()) {\n                if (ch == '1') {\n\
    \                    c++;\n                }\n            }\n            if (!ones.containsKey((long)c))\
    \ {\n                ones.put((long)c, new ArrayList<Long>());\n            }\n\
    \            ones.get((long)c).add(i);\n        }\n        for (long n : ones.keySet())\
    \ {\n            ArrayList<Long> list = ones.get(n);\n            Collections.sort(list);\n\
    \            ans.addAll(list);\n        }\n        return ans;", "        if (arr\
    \ == null) return null;\n        if (arr.size() == 0) return arr;\n        if\
    \ (arr.size() == 1) return arr;\n        ArrayList<Long> list = new ArrayList<>();\n\
    \        return list;", "        arr.sort(Comparator.comparing(Long::bitCount).thenComparing(i\
    \ -> i));\n        return arr;", "        // what?\n        // arr.stream().map(x\
    \ -> )\n        return arr;", "        ArrayList<Long> sorted = new ArrayList<Long>();\n\
    \        int [] ones = new int[arr.size()];\n        String [] bin = new String[arr.size()];\n\
    \        long [] list = new long[arr.size()];\n        int i = 0;\n        for\
    \ (long x : arr) {\n            bin[i] = Long.toBinaryString(x);\n           \
    \ list[i] = x;\n            ones[i] = countOnes(bin[i]);\n            i++;\n \
    \       }\n        int [] index = sortIndex(ones);\n        for (int j : index)\
    \ {\n            sorted.add(list[j]);\n        }\n        return sorted;", " \
    \       if (arr == null) {\n            return arr;\n        }\n        else if\
    \ (arr.size() == 0) {\n            return arr;\n        }\n        else {\n  \
    \          long[] numArray = new long[arr.size()];\n            for (int i = 0;\
    \ i < arr.size(); i++) {\n                numArray[i] = arr.get(i);\n        \
    \    }\n            Arrays.sort(numArray);\n            ArrayList<Long> sortedArr\
    \ = new ArrayList<Long>();\n            for (int i = 0; i < numArray.length; i++)\
    \ {\n                sortedArr.add(numArray[i]);\n            }\n            return\
    \ sortedArr;\n        }", "        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        ArrayList<Integer> ones = new ArrayList<Integer>();\n        for (int\
    \ i = 0; i < arr.size(); i++) {\n            String b = Long.toBinaryString(arr.get(i));\n\
    \            int count = 0;\n            for (int j = 0; j < b.length(); j++)\
    \ {\n                if (b.charAt(j) == '1') {\n                    count++;\n\
    \                }\n            }\n            ones.add(count);\n        }\n \
    \       System.out.println(ones);\n        for (int i = 0; i < ones.size(); i++)\
    \ {\n            for (int j = i + 1; j < ones.size(); j++) {\n               \
    \ if (ones.get(i) > ones.get(j)) {\n                    long t = arr.get(i);\n\
    \                    arr.set(i, arr.get(j));\n                    arr.set(j, t);\n\
    \                    int c = ones.get(i);\n                    ones.set(i, ones.get(j));\n\
    \                    ones.set(j, c);\n                }\n            }\n     \
    \   }\n        System.out.println(arr);\n        System.out.println(ones);\n \
    \       return arr;", "        Comparator<Long> sortByOnesThenValue = new Comparator<Long>()\
    \ {\n            public int compare(Long x, Long y) {\n                if (Long.bitCount(x)\
    \ == Long.bitCount(y)) {\n                    return x.compareTo(y);\n       \
    \         } else {\n                    return Long.bitCount(x) - Long.bitCount(y);\n\
    \                }\n            }\n        };\n        arr.sort(sortByOnesThenValue);\n\
    \        return arr;", "        ArrayList<Long> al = new ArrayList<Long>();\n\
    \        ArrayList<Pair<Long, Long>> pal = new ArrayList<Pair<Long, Long>>();\n\
    \        for (Long i : arr) {\n            pal.add(new Pair<Long, Long>(i, new\
    \ Long(Long.bitCount(i))));\n        }\n        Collections.sort(pal, new Comparator<Pair<Long,\
    \ Long>>() {\n            @Override\n            public int compare(Pair<Long,\
    \ Long> o1, Pair<Long, Long> o2) {\n                if (o1.getValue1().equals(o2.getValue1()))\
    \ {\n                    return o1.getValue0().compareTo(o2.getValue0());\n  \
    \              }\n                return o1.getValue1().compareTo(o2.getValue1());\n\
    \            }\n        });\n        for (Pair<Long, Long> p : pal) {\n      \
    \      al.add(p.getValue0());\n        }\n        return al;", "        // it\
    \ might help to know that the array starts and ends with the most significant\
    \ bit.\n        // how can we use this knowledge to help us?\n        // what\
    \ if we could sort by the most significant bit without caring about the number\
    \ of ones?\n        // that would be a great start!\n        // what if we sort\
    \ the array first?\n        // that would help us to determine the most significant\
    \ bit\n        // so we could use a binary search to find it.\n        // once\
    \ we find the most significant bit we can start counting the ones.\n        //\
    \ this will take O(nlogn) time and O(n) space.\n        // but there is a faster\
    \ way\n        // we can split the array into two arrays.\n        // the first\
    \ array will have the most significant bit set to zero and the second array\n\
    \        // will have the most significant bit set to one.\n        // this will\
    \ take O(n) time and O(n) space.\n        // if we want to get this down to O(1)\
    \ space then we will need to find a way to do it in place.\n        // lets start\
    \ by sorting the array into two arrays\n        // one array will have the most\
    \ significant bit set to zero\n        // the other array will have the most significant\
    \ bit set to one.\n        // once we have that we can start counting the ones.\n\
    \        // the array with the most significant bit set to zero will have a count\
    \ of ones equal to zero.\n        // the array with the most significant bit set\
    \ to one will have a count of ones equal to one.\n        // we will then have\
    \ an array that is sorted by the number of ones.\n        // now lets think about\
    \ how we can do this in place.\n        // we can think of the array as a binary\
    \ tree.\n        // lets assume that the array starts and ends with the most significant\
    \ bit.\n        // lets assume that we want to do this in place.\n        // lets\
    \ assume that we want to do this in O(nlogn) time and O(1) space.\n        //\
    \ lets assume that we can use recursion.\n        // lets assume that we can use\
    \ a divide and conquer approach.\n        // lets assume that we can use a stack.\n\
    \        // to do this in place we will need to modify the array without making\
    \ a copy of it.\n        // this is what we", '        return arr;', "       \
    \ arr.sort(new Comparator<Long>() {\n            @Override\n            public\
    \ int compare(Long a, Long b) {\n                int A = Long.bitCount(a);\n \
    \               int B = Long.bitCount(b);\n                if (A == B) {\n   \
    \                 return Long.compare(a, b);\n                }\n            \
    \    return Integer.compare(A, B);\n            }\n        });\n        return\
    \ arr;", "        // your code here\n        HashMap<Long, Integer> map = new\
    \ HashMap<>();\n        for (long n : arr) {\n            int count = 0;\n   \
    \         for (int i = 0; i < 32; i++) {\n                if (((n >> i) & 1) ==\
    \ 1) {\n                    count++;\n                }\n            }\n     \
    \       map.put(n, count);\n        }\n        arr.sort((a, b) -> {\n        \
    \    int countA = map.get(a);\n            int countB = map.get(b);\n        \
    \    if (countA == countB) {\n                return (int) (a - b);\n        \
    \    }\n            return countA - countB;\n        });\n        return arr;",
  "        if (arr == null) return arr;\n        // Arrays.sort(arr.toArray(), new\
    \ java.util.Comparator<Long>() {\n        //     public int compare(Long a, Long\
    \ b) {\n        //         int onesA = ones((long)a);\n        //         int\
    \ onesB = ones((long)b);\n        //         if (onesA == onesB) {\n        //\
    \             return a.compareTo(b);\n        //         } else {\n        //\
    \             return onesA - onesB;\n        //         }\n        //     }\n\
    \        // });\n        Collections.sort(arr, new java.util.Comparator<Long>()\
    \ {\n            public int compare(Long a, Long b) {\n                int onesA\
    \ = ones((long)a);\n                int onesB = ones((long)b);\n             \
    \   if (onesA == onesB) {\n                    return a.compareTo(b);\n      \
    \          } else {\n                    return onesA - onesB;\n             \
    \   }\n            }\n        });\n        return arr;", "        ArrayList<Long>\
    \ res = new ArrayList<>();\n        if (arr == null || arr.size() == 0) {\n  \
    \          return res;\n        }\n        if (arr.size() == 1) {\n          \
    \  return arr;\n        }\n        List<Pair<Long, Long>> list = new ArrayList<>();\n\
    \        for (Long item : arr) {\n            long count = 0;\n            if\
    \ (item >= 0) {\n                count = count(item);\n            } else {\n\
    \                count = -1;\n            }\n            list.add(new Pair<>(count,\
    \ item));\n        }\n        list.sort((a, b) -> {\n            if (a.getValue0()\
    \ == b.getValue0()) {\n                return (int) (a.getValue1() - b.getValue1());\n\
    \            } else {\n                return (int) (a.getValue0() - b.getValue0());\n\
    \            }\n        });\n        for (Pair<Long, Long> item : list) {\n  \
    \          res.add(item.getValue1());\n        }\n        return res;", "    \
    \    ArrayList<Long> sorted = (ArrayList<Long>)arr.clone();\n        Collections.sort(sorted,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ a, Long b) {\n                return Long.compare(ones(a), ones(b));\n     \
    \       }\n        });\n        return sorted;", "        // for (int i = 0; i\
    \ < arr.size(); i++) {\n        //     long next = arr.get(i);\n        //   \
    \  int j = i;\n        //     while (j > 0 && (Integer.bitCount(arr.get(j - 1).intValue())\
    \ > Integer.bitCount(next.intValue()) || (Integer.bitCount(arr.get(j - 1).intValue())\
    \ == Integer.bitCount(next.intValue()) && arr.get(j - 1) > next))) {\n       \
    \ //         arr.set(j, arr.get(j - 1));\n        //         j--;\n        //\
    \     }\n        //     arr.set(j, next);\n        // }\n        Collections.sort(arr,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ long1, Long long2) {\n                int ans = Integer.bitCount(long1.intValue())\
    \ - Integer.bitCount(long2.intValue());\n                if (ans == 0) {\n   \
    \                 ans = long1.compareTo(long2);\n                }\n         \
    \       return ans;\n            }\n        });\n        return arr;", "     \
    \   // Your Code goes here\n        // return null;\n        int oneCount(long\
    \ n) {\n            int c = 0;\n            for (long i = n; i > 0; i >>>= 1)\
    \ {\n                c += i & 1;\n            }\n            return c;\n     \
    \   }\n        ArrayList<Long> sorted = new ArrayList<Long>(arr);\n        Collections.sort(sorted,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ a, Long b) {\n                if (oneCount(a) < oneCount(b)) {\n           \
    \         return -1;\n                } else if (oneCount(a) > oneCount(b)) {\n\
    \                    return 1;\n                } else {\n                   \
    \ return Long.compare(a, b);\n                }\n            }\n        });\n\
    \        return sorted;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        ArrayList<Tuple2<Long, Long>> list = new ArrayList<Tuple2<Long, Long>>();\n\
    \        arr.forEach(value -> {\n            list.add(new Tuple2<Long, Long>(value,\
    \ getBinaryOnes(value)));\n        });\n        Collections.sort(list, (t1, t2)\
    \ -> {\n            if (t1.getValue1().equals(t2.getValue1())) {\n           \
    \     return (int) (t1.getValue0() - t2.getValue0());\n            } else {\n\
    \                return (int) (t1.getValue1() - t2.getValue1());\n           \
    \ }\n        });\n        list.forEach(value -> {\n            result.add(value.getValue0());\n\
    \        });\n        return result;", "        ArrayList<Long> sorted = new ArrayList<Long>();\n\
    \        ArrayList<Long> negatives = new ArrayList<Long>();\n        ArrayList<Long>\
    \ positives = new ArrayList<Long>();\n        for (Long x : arr) {\n         \
    \   if (x > 0) {\n                positives.add(x);\n            } else {\n  \
    \              negatives.add(x);\n            }\n        }\n        positives.sort(Comparator.comparingInt(y\
    \ -> Long.bitCount(y)));\n        Collections.reverse(negatives);\n        negatives.sort(Comparator.comparingInt(y\
    \ -> Long.bitCount(y)));\n        Collections.reverse(negatives);\n        sorted.addAll(negatives);\n\
    \        sorted.addAll(positives);\n        return sorted;", "        List<Pair<Long,\
    \ Long>> zipped = zip(arr, arr.stream().map(x -> Long.bitCount(x)).collect(Collectors.toList()));\n\
    \        return unzip(zipped.stream().sorted((a, b) -> {\n            int result\
    \ = Long.compare(a.getValue1(), b.getValue1());\n            if (result == 0)\n\
    \                result = Long.compare(a.getValue0(), b.getValue0());\n      \
    \      return result;\n        }).collect(Collectors.toList()));", "        ArrayList<Tuple2<Long,\
    \ Long>> tmp = new ArrayList<>();\n        for (long l : arr) {\n            tmp.add(new\
    \ Tuple2<Long, Long>(l, countOnes(l)));\n        }\n        Collections.sort(tmp,\
    \ (l1, l2) -> l1.getValue1().compareTo(l2.getValue1()));\n        return new ArrayList<Long>(tmp.stream().map(x\
    \ -> x.getValue0()).collect(Collectors.toList()));", "        return new ArrayList<Long>(arr.stream().map(x\
    \ -> Pair.with(x, Long.bitCount(x))).sorted((a, b) -> {\n            return a.getValue1().compareTo(b.getValue1())\
    \ == 0 ? a.getValue0().compareTo(b.getValue0()) : a.getValue1().compareTo(b.getValue1());\n\
    \        }).map(x -> x.getValue0()).collect(Collectors.toList()));", "       \
    \ // int count = 0;\n        // for (int i = 0; i < arr.size(); i++) {\n     \
    \   //     long num = arr.get(i);\n        //     while (num > 0) {\n        //\
    \         num = num & (num - 1);\n        //         count++;\n        //    \
    \ }\n        //     arr.set(i, count);\n        //     count = 0;\n        //\
    \ }\n        // int temp;\n        // for (int i = 0; i < arr.size(); i++) {\n\
    \        //     for (int j = i + 1; j < arr.size(); j++) {\n        //       \
    \  if (arr.get(i) > arr.get(j)) {\n        //             temp = arr.get(i);\n\
    \        //             arr.set(i, arr.get(j));\n        //             arr.set(j,\
    \ temp);\n        //         }\n        //     }\n        // }\n        // ArrayList<Long>\
    \ sorted = new ArrayList<Long>();\n        // for (int i = 0; i < arr.size();\
    \ i++) {\n        //     sorted.add(arr.get(i));\n        // }\n        // return\
    \ sorted;\n        Collections.sort(arr, new Comparator<Long>() {\n          \
    \  public int compare(Long a, Long b) {\n                long a1 = a;\n      \
    \          long b1 = b;\n                int count = 0;\n                int count1\
    \ = 0;\n                while (a1 > 0) {\n                    a1 = a1 & (a1 -\
    \ 1);\n                    count++;\n                }\n                while\
    \ (b1 > 0) {\n                    b1 = b1 & (b1 - 1);\n                    count1++;\n\
    \                }\n                if (count == count1) {\n                 \
    \   return a.compareTo(b);\n                }\n                return count -\
    \ count1;\n            }\n        });\n        return arr;", "        //int[]\
    \ count = new int[arr.size()];\n        ArrayList<Tuple2<Long, Integer>> ret =\
    \ new ArrayList<Tuple2<Long, Integer>>();\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            //String binary = Integer.toBinaryString(arr.get(i));\n\
    \            int count = 0;\n            long num = arr.get(i);\n            while\
    \ (num > 0) {\n                count += num & 1;\n                num >>= 1;\n\
    \            }\n            ret.add(new Tuple2<Long, Integer>(arr.get(i), count));\n\
    \        }\n        ret.sort(new Comparator<Tuple2<Long, Integer>>() {\n     \
    \       @Override\n            public int compare(Tuple2<Long, Integer> v1, Tuple2<Long,\
    \ Integer> v2) {\n                if (v1.getValue1() == v2.getValue1()) {\n  \
    \                  return Long.compare(v1.getValue0(), v2.getValue0());\n    \
    \            }\n                return Integer.compare(v1.getValue1(), v2.getValue1());\n\
    \            }\n        });\n        ArrayList<Long> finalRet = new ArrayList<Long>();\n\
    \        for (int i = 0; i < ret.size(); i++) {\n            finalRet.add(ret.get(i).getValue0());\n\
    \        }\n        return finalRet;", "        Comparator<Long> comp = (Long\
    \ one, Long two) -> {\n            String oneBinary = Long.toBinaryString(one);\n\
    \            String twoBinary = Long.toBinaryString(two);\n            int numOnes\
    \ = (int) oneBinary.chars().filter(ch -> ch == '1').count();\n            int\
    \ numTwos = (int) twoBinary.chars().filter(ch -> ch == '1').count();\n       \
    \     return numOnes == numTwos ? one.compareTo(two) : numOnes - numTwos;\n  \
    \      };\n        Collections.sort(arr, comp);\n        return arr;", "     \
    \   ArrayList<Long> binList = new ArrayList<Long>();\n        for (Long x : arr)\
    \ {\n            if (x < 0) {\n                binList.add(0l);\n            }\
    \ else {\n                binList.add(Long.parseLong(Long.toBinaryString(x)));\n\
    \            }\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        while (binList.size() > 0) {\n            int index = binList.indexOf(Collections.min(binList));\n\
    \            result.add(arr.get(index));\n            binList.remove(index);\n\
    \            arr.remove(index);\n        }\n        return result;", "       \
    \ // your code goes here\n        String pattern = \"%\" + (int)Math.ceil(Math.log(Collections.max(arr))\
    \ / Math.log(2)) + \"s\";\n        System.out.println(pattern);\n        HashMap<Long,\
    \ String> binary = new HashMap<>();\n        for (Long num : arr) {\n        \
    \    binary.put(num, String.format(pattern, Long.toBinaryString(num)).replace('\
    \ ', '0'));\n        }\n        ArrayList<Pair<Long, String>> pairs = new ArrayList<>(binary.size());\n\
    \        for (Map.Entry<Long, String> entry : binary.entrySet()) {\n         \
    \   pairs.add(new Pair<>(entry.getKey(), entry.getValue()));\n        }\n    \
    \    Collections.sort(pairs, new Comparator<Pair<Long, String>>() {\n        \
    \    @Override\n            public int compare(Pair<Long, String> o1, Pair<Long,\
    \ String> o2) {\n                int ones = Integer.compare(o1.getValue1().length()\
    \ - o1.getValue1().replace(\"1\", \"\").length(), o2.getValue1().length() - o2.getValue1().replace(\"\
    1\", \"\").length());\n                return ones == 0 ? o1.getValue0().compareTo(o2.getValue0())\
    \ : ones;\n            }\n        });\n        ArrayList<Long> sorted = new ArrayList<>(arr.size());\n\
    \        for (Pair<Long, String> pair : pairs) {\n            sorted.add(pair.getValue0());\n\
    \        }\n        return sorted;", "        ArrayList<Long> newArr = new ArrayList<Long>();\n\
    \        newArr.addAll(arr);\n        newArr.sort(new Comparator<Long>() {\n \
    \           @Override\n            public int compare(Long o1, Long o2) {\n  \
    \              Integer o1Ones = getNumOfOnes(o1);\n                Integer o2Ones\
    \ = getNumOfOnes(o2);\n                return o1Ones.compareTo(o2Ones);\n    \
    \        }\n        });\n        return newArr;", "        ArrayList<Long> ans\
    \ = new ArrayList<Long>();\n        return ans;", "        if (arr == null) {\n\
    \            return null;\n        }\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (Long n : arr) {\n            String s = Long.toBinaryString(n);\n\
    \            String r = new StringBuilder(s).reverse().toString();\n         \
    \   int index = 0;\n            for (int i = 0; i < result.size(); i++) {\n  \
    \              String m = Long.toBinaryString(result.get(i));\n              \
    \  String v = new StringBuilder(m).reverse().toString();\n                if (count(r)\
    \ < count(v)) {\n                    index = i;\n                    break;\n\
    \                } else if (count(r) == count(v)) {\n                    if (n\
    \ < result.get(i)) {\n                        index = i;\n                   \
    \     break;\n                    }\n                }\n            }\n      \
    \      result.add(index, n);\n        }\n        return result;", "        return\
    \ new ArrayList<Long>(\n            arr.stream()\n            .sorted(Problem::bitSort)\n\
    \            .collect(Collectors.toList())\n        );", "        // your code\
    \ here\n        return arr;", "        arr.sort(new Comparator<Long>() {\n   \
    \         @Override\n            public int compare(Long a, Long b) {\n      \
    \          Integer aOnes = Long.bitCount(a);\n                Integer bOnes =\
    \ Long.bitCount(b);\n                if(aOnes == bOnes)\n                    return\
    \ a.compareTo(b);\n                return aOnes.compareTo(bOnes);\n          \
    \  }\n        });\n        return arr;", "        ArrayList<Long> sorted = new\
    \ ArrayList<Long>();\n        for (long i = 0; i < arr.size(); i++) {\n      \
    \      sorted.add(Long.valueOf(i));\n        }\n        Collections.sort(sorted,\
    \ new Comparator<Long>() {\n            public int compare(Long l1, Long l2) {\n\
    \                int l1Bits = Long.bitCount(arr.get(l1.intValue()));\n       \
    \         int l2Bits = Long.bitCount(arr.get(l2.intValue()));\n              \
    \  if (l1Bits == l2Bits) {\n                    return Long.compare(arr.get(l1.intValue()),\
    \ arr.get(l2.intValue()));\n                }\n                return Integer.compare(l1Bits,\
    \ l2Bits);\n            }\n        });\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (long i = 0; i < arr.size(); i++) {\n            result.add(arr.get(sorted.get(Math.toIntExact(i)).intValue()));\n\
    \        }\n        return result;", "        if (arr == null) {\n           \
    \ return null;\n        }\n        if (arr.size() == 0) {\n            return\
    \ arr;\n        }\n        ArrayList<Long> ret = new ArrayList<>();\n        ArrayList<Long>\
    \ retOne = new ArrayList<>();\n        ArrayList<Long> retZero = new ArrayList<>();\n\
    \        long min = Collections.min(arr);\n        long max = Collections.max(arr);\n\
    \        for (long i = 0; i < arr.size(); i++) {\n            long tmp = arr.get((int)i);\n\
    \            if (tmp < 0) {\n                ret.add(tmp);\n            } else\
    \ if (tmp == 0) {\n                retZero.add(tmp);\n            } else {\n \
    \               retOne.add(tmp);\n            }\n        }\n        Collections.sort(retOne);\n\
    \        Collections.sort(retZero);\n        ret.addAll(retZero);\n        ret.addAll(retOne);\n\
    \        return ret;", "        // Implement this method.\n        if (arr.size()\
    \ == 0) {\n            return arr;\n        }\n        ArrayList<Long> positive\
    \ = new ArrayList<Long>();\n        ArrayList<Long> negative = new ArrayList<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) <\
    \ 0) {\n                negative.add(arr.get(i));\n            } else {\n    \
    \            positive.add(arr.get(i));\n            }\n        }\n        ArrayList<Long>\
    \ positiveSorted = new ArrayList<Long>();\n        if (positive.size() > 0) {\n\
    \            long max = positive.get(0);\n            for (int i = 0; i < positive.size();\
    \ i++) {\n                if (positive.get(i) > max) {\n                    max\
    \ = positive.get(i);\n                }\n            }\n            HashMap<Integer,\
    \ ArrayList<Long>> countsMap = new HashMap<Integer, ArrayList<Long>>();\n    \
    \        for (int i = 0; i < positive.size(); i++) {\n                int onesCount\
    \ = countOnesInBinary(positive.get(i));\n                if (countsMap.containsKey(onesCount))\
    \ {\n                    countsMap.get(onesCount).add(positive.get(i));\n    \
    \            } else {\n                    ArrayList<Long> newList = new ArrayList<Long>();\n\
    \                    newList.add(positive.get(i));\n                    countsMap.put(onesCount,\
    \ newList);\n                }\n            }\n            ArrayList<Integer>\
    \ keysList = new ArrayList<Integer>(countsMap.keySet());\n            keysList.sort(null);\n\
    \            for (int i = 0; i < keysList.size(); i++) {\n                positiveSorted.addAll(countsMap.get(keysList.get(i)));\n\
    \            }\n        }\n        negative.sort(null);\n        negative.addAll(positiveSorted);\n\
    \        return negative;", "        // your code here\n        ArrayList<Long>\
    \ ans = new ArrayList<Long>();\n        long sumOfOnes = 0l;\n        HashMap<Long,\
    \ ArrayList<Long>> map = new HashMap<Long, ArrayList<Long>>();\n        for (long\
    \ i = 0; i < arr.size(); i++) {\n            sumOfOnes = 0l;\n            for\
    \ (long j = 0; j < arr.get((int) i).toString(2).length(); j++) {\n           \
    \     if (arr.get((int) i).toString(2).charAt((int) j) == '1') {\n           \
    \         sumOfOnes++;\n                }\n            }\n            if (map.containsKey(sumOfOnes))\
    \ {\n                map.get(sumOfOnes).add(arr.get((int) i));\n            }\
    \ else {\n                ArrayList<Long> newList = new ArrayList<Long>();\n \
    \               newList.add(arr.get((int) i));\n                map.put(sumOfOnes,\
    \ newList);\n            }\n        }\n        for (long l : map.keySet()) {\n\
    \            Collections.sort(map.get(l));\n            for (long num : map.get(l))\
    \ {\n                ans.add(num);\n            }\n        }\n        return ans;",
  "        ArrayList<Long> onesArray = new ArrayList<Long>();\n        ArrayList<Long>\
    \ sortedArray = new ArrayList<Long>();\n        ArrayList<Long> zerosArray = new\
    \ ArrayList<Long>();\n        arr.stream().forEach(n -> {\n            if (n <=\
    \ -1) {\n                onesArray.add(n);\n            } else if (n == 0) {\n\
    \                zerosArray.add(n);\n            } else {\n                if\
    \ (Integer.bitCount(n.intValue()) % 2 == 0) {\n                    onesArray.add(n);\n\
    \                } else {\n                    sortedArray.add(n);\n         \
    \       }\n            }\n        });\n        onesArray.sort(Comparator.naturalOrder());\n\
    \        sortedArray.sort(Comparator.naturalOrder());\n        ArrayList<Long>\
    \ ret = new ArrayList<Long>();\n        ret.addAll(zerosArray);\n        ret.addAll(sortedArray);\n\
    \        ret.addAll(onesArray);\n        return ret;", "        arr.sort(\n  \
    \          (e1, e2) -> {\n                String e1Bin = Long.toBinaryString(e1);\n\
    \                String e2Bin = Long.toBinaryString(e2);\n                int\
    \ c = 0;\n                for (int i = 0; i < e1Bin.length(); i++) {\n       \
    \             if (e1Bin.charAt(i) == '1') c++;\n                }\n          \
    \      int c2 = 0;\n                for (int i = 0; i < e2Bin.length(); i++) {\n\
    \                    if (e2Bin.charAt(i) == '1') c2++;\n                }\n  \
    \              if (c != c2) return c - c2;\n                else return e1.compareTo(e2);\n\
    \            }\n        );\n        return arr;", "        // 1, 5, 2, 3, 4 ->\
    \ 1, 2, 3, 4, 5\n        // 1, 0, 2, 3, 4 -> 0, 1, 2, 3, 4\n        // -2, -3,\
    \ -4, -5, -6 -> -6, -5, -4, -3, -2\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        ArrayList<Tuple2<Long, Long>> temp = new ArrayList<Tuple2<Long, Long>>();\n\
    \        for (Long l : arr) {\n            temp.add(Tuple.with(l, numOnes(l)));\n\
    \        }\n        Collections.sort(temp, new Comparator<Tuple2<Long, Long>>()\
    \ {\n            @Override\n            public int compare(Tuple2<Long, Long>\
    \ t1, Tuple2<Long, Long> t2) {\n                if (t1.getValue1().equals(t2.getValue1()))\
    \ {\n                    return t1.getValue0().compareTo(t2.getValue0());\n  \
    \              }\n                return t1.getValue1().compareTo(t2.getValue1());\n\
    \            }\n        });\n        for (Tuple2<Long, Long> t : temp) {\n   \
    \         res.add(t.getValue0());\n        }\n        return res;", "      Collections.sort(arr,\
    \ new Comparator<Long>() {\n        @Override\n        public int compare(Long\
    \ x, Long y) {\n          int x_one = Long.bitCount(x);\n          int y_one =\
    \ Long.bitCount(y);\n          if (x_one > y_one) {\n            return 1;\n \
    \         } else if (x_one < y_one) {\n            return -1;\n          } else\
    \ {\n            if (x > y) {\n              return 1;\n            } else if\
    \ (x < y) {\n              return -1;\n            } else {\n              return\
    \ 0;\n            }\n          }\n        }\n      });\n      return arr;", " \
    \       ArrayList<Long> sorted = new ArrayList<>();\n        for (long l : arr)\
    \ {\n            sorted.add(l);\n        }\n        Collections.sort(sorted, new\
    \ Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ l1, Long l2) {\n                long x1 = l1.longValue();\n                long\
    \ x2 = l2.longValue();\n                int count1 = 0;\n                int count2\
    \ = 0;\n                while (x1 > 0) {\n                    count1 += x1 & 1;\n\
    \                    x1 >>= 1;\n                }\n                while (x2 >\
    \ 0) {\n                    count2 += x2 & 1;\n                    x2 >>= 1;\n\
    \                }\n                if (count1 == count2) {\n                \
    \    return (int) (l1 - l2);\n                }\n                return count1\
    \ - count2;\n            }\n        });\n        return sorted;", "        ArrayList<Long>\
    \ newArr = new ArrayList<Long>();\n        ArrayList<Pair<Long, Integer>> arrPair\
    \ = new ArrayList<Pair<Long, Integer>>();\n        // Transform array list of\
    \ numbers into pairs of numbers and their\n        // number of ones in binary\
    \ representation\n        for (int i = 0; i < arr.size(); i++) {\n           \
    \ arrPair.add(new Pair<Long, Integer>(arr.get(i),\n                          \
    \                      numberOfOnesInBinaryRepresentation(arr.get(i))));\n   \
    \     }\n        arrPair.sort(new Comparator<Pair<Long, Integer>>() {\n      \
    \      @Override\n            public int compare(Pair<Long, Integer> a, Pair<Long,\
    \ Integer> b) {\n                // sort by number of ones\n                if\
    \ (a.getValue1() > b.getValue1())\n                    return 1;\n           \
    \     else if (a.getValue1() < b.getValue1())\n                    return -1;\n\
    \                // else sort by the number itself\n                else if (a.getValue0()\
    \ > b.getValue0())\n                    return 1;\n                else if (a.getValue0()\
    \ < b.getValue0())\n                    return -1;\n                else\n   \
    \                 return 0;\n            }\n        });\n        // Transform\
    \ the pair of numbers into a list of numbers\n        for (int i = 0; i < arrPair.size();\
    \ i++) {\n            newArr.add(arrPair.get(i).getValue0());\n        }\n   \
    \     return newArr;", "        // Define an internal comparator to represent\
    \ the frequency of 1's in the binary\n        // representation of the number.\n\
    \        Comparator<Long> numOfOnes = (Long a, Long b) -> {\n            int aOnes\
    \ = countOnesInBinaryRepresentation(a);\n            int bOnes = countOnesInBinaryRepresentation(b);\n\
    \            return aOnes - bOnes;\n        };\n        // Create a map from the\
    \ comparator to the array elements.\n        Map<Long, Long> map = new TreeMap<Long,\
    \ Long>(numOfOnes);\n        for (Long elem : arr) {\n            map.put(elem,\
    \ elem);\n        }\n        return new ArrayList<Long>(map.values());", "   \
    \     HashMap<Integer, List<Long>> map = new HashMap<>();\n        for (long l\
    \ : arr) {\n            String bitStr = Long.toBinaryString(l);\n            int\
    \ len = bitStr.length();\n            int count = 0;\n            for (int i =\
    \ 0; i < len; i++) {\n                if (bitStr.charAt(i) == '1') {\n       \
    \             count++;\n                }\n            }\n            List<Long>\
    \ list = map.get(count);\n            if (list == null) {\n                list\
    \ = new ArrayList<>();\n                map.put(count, list);\n            }\n\
    \            list.add(l);\n        }\n        // \u6700\u540E\uFF0C\u53EA\u9700\
    \u8981\u5728 map.keySet \u4E2D\u6392\u4E2A\u5E8F\uFF0C\u518D\u6309\u987A\u5E8F\
    \u904D\u5386\u8FD9\u4E2A keySet\uFF0Cmap.get(key) \u51FA\u6765\u7684 list \u518D\
    \u6392\u4E2A\u5E8F\uFF0C\n        // \u6700\u540E\u653E\u5165\u5230\u7ED3\u679C\
    \u96C6\u4E2D\u3002\n        ArrayList<Long> res = new ArrayList<>();\n       \
    \ ArrayList<Integer> keys = new ArrayList<>(map.keySet());\n        Collections.sort(keys);\n\
    \        for (int key : keys) {\n            List<Long> list = map.get(key);\n\
    \            Collections.sort(list);\n            res.addAll(list);\n        }\n\
    \        return res;", "        // Your code goes here\n        return arr;",
  "        arr.sort(new Comparator<Long>() {\n            @Override\n            public\
    \ int compare(Long o1, Long o2) {\n                return Long.compare(Long.bitCount(o1),\
    \ Long.bitCount(o2));\n            }\n        });\n        return arr;", "   \
    \     Collections.sort(arr,\n            (Long o1, Long o2) -> {\n           \
    \     String ones1 = Long.toBinaryString(o1);\n                String ones2 =\
    \ Long.toBinaryString(o2);\n                int num1 = ones1.replaceAll(\"0\"\
    , \"\").length();\n                int num2 = ones2.replaceAll(\"0\", \"\").length();\n\
    \                if (num1 > num2) {\n                    return 1;\n         \
    \       } else if (num1 < num2) {\n                    return -1;\n          \
    \      } else {\n                    return o1.compareTo(o2);\n              \
    \  }\n            }\n        );\n        return arr;", "        ArrayList<Long>\
    \ temp = new ArrayList<Long>();\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        StringBuilder str;\n        String[] sarr = new String[arr.size()];\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            str = new StringBuilder(Long.toBinaryString(arr.get(i)));\n\
    \            while (str.length() < 32) {\n                str.insert(0, \"0\"\
    );\n            }\n            sarr[i] = str.toString();\n        }\n        Map<String,\
    \ List<Long>> map = new HashMap<String, List<Long>>();\n        for (int i = 0;\
    \ i < arr.size(); i++) {\n            String sum = Long.toString(Arrays.stream(sarr[i].split(\"\
    \")).filter(s -> s.equals(\"1\")).count());\n            if (map.containsKey(sum))\
    \ {\n                map.get(sum).add(arr.get(i));\n            } else {\n   \
    \             temp = new ArrayList<Long>();\n                temp.add(arr.get(i));\n\
    \                map.put(sum, temp);\n            }\n        }\n        for (String\
    \ s : map.keySet()) {\n            Collections.sort(map.get(s));\n           \
    \ result.addAll(map.get(s));\n        }\n        return result;", "        Collections.sort(arr,\
    \ (a, b) -> {\n            return Long.bitCount(a) == Long.bitCount(b) ? Long.compare(a,\
    \ b) : Long.compare(Long.bitCount(a), Long.bitCount(b));\n        });\n      \
    \  return arr;", "        Collections.sort(arr, new Comparator<Long>() {\n   \
    \         @Override\n            public int compare(Long l1, Long l2) {\n    \
    \            int diff = Long.bitCount(l1) - Long.bitCount(l2);\n             \
    \   if (diff != 0) return diff;\n                return l1.compareTo(l2);\n  \
    \          }\n        });\n        return arr;", "        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        result.addAll(arr);\n        Collections.sort(result,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ o1, Long o2) {\n                return Long.compare(countOnes(o1), countOnes(o2));\n\
    \            }\n        });\n        return result;", '        return arr;', " \
    \       ArrayList<Long> res = new ArrayList<>();\n        ArrayList<Pair<Long,\
    \ Integer>> arr1 = new ArrayList<>();\n        for (Long item : arr) {\n     \
    \       int cnt = 0;\n            for (int i = 0; i < 32; i++) {\n           \
    \     if ((item & (1 << i)) > 0) {\n                    cnt++;\n             \
    \   }\n            }\n            arr1.add(new Pair<>(item, cnt));\n        }\n\
    \        Collections.sort(arr1, new Comparator<Pair<Long, Integer>>() {\n    \
    \        @Override\n            public int compare(Pair<Long, Integer> o1, Pair<Long,\
    \ Integer> o2) {\n                if (o1.getValue1() > o2.getValue1()) {\n   \
    \                 return 1;\n                } else if (o1.getValue1() < o2.getValue1())\
    \ {\n                    return -1;\n                } else {\n              \
    \      if (o1.getValue0() > o2.getValue0()) {\n                        return\
    \ 1;\n                    } else if (o1.getValue0() < o2.getValue0()) {\n    \
    \                    return -1;\n                    } else {\n              \
    \          return 0;\n                    }\n                }\n            }\n\
    \        });\n        for (Pair<Long, Integer> item : arr1) {\n            res.add(item.getValue0());\n\
    \        }\n        return res;", "        Collections.sort(arr, (first, second)\
    \ -> {\n            int firstBits = Long.bitCount(first);\n            int secondBits\
    \ = Long.bitCount(second);\n            return firstBits != secondBits ? firstBits\
    \ - secondBits : Long.compare(first, second);\n        });\n        return arr;",
  "        arr.sort(new Comparator<Long>() {\n            @Override\n            public\
    \ int compare(Long o1, Long o2) {\n                String binaryO1 = Long.toBinaryString(o1);\n\
    \                String binaryO2 = Long.toBinaryString(o2);\n                int\
    \ o1Ones = (int)binaryO1.chars().filter(x -> x == '1').count();\n            \
    \    int o2Ones = (int)binaryO2.chars().filter(x -> x == '1').count();\n     \
    \           if (o1Ones == o2Ones) {\n                    return (int)(o1 - o2);\n\
    \                }\n                return o1Ones - o2Ones;\n            }\n \
    \       });\n        return arr;", "        Collections.sort(arr, (a, b) -> {\n\
    \            int a1 = Long.bitCount(a);\n            int b1 = Long.bitCount(b);\n\
    \            if (a1 == b1) {\n                return Long.compare(a, b);\n   \
    \         }\n            return Integer.compare(a1, b1);\n        });\n      \
    \  return arr;", "        // Write your code here\n        Comparator<Long> comparer\
    \ = (n1, n2) -> {\n            long c = Long.bitCount(n1) - Long.bitCount(n2);\n\
    \            if (c != 0) return (int)c;\n            else return (int)(n1 - n2);\n\
    \        };\n        Collections.sort(arr, comparer);\n        return arr;", " \
    \       Collections.sort(arr, new Comparator<Long>() {\n            @Override\n\
    \            public int compare(Long o1, Long o2) {\n                int x = Long.bitCount(o1);\n\
    \                int y = Long.bitCount(o2);\n                if (x == y)\n   \
    \                 return o1.compareTo(o2);\n                return x - y;\n  \
    \          }\n        });\n        return arr;", '        return null;', "   \
    \     ArrayList<Long> res = new ArrayList<Long>();\n        ArrayList<Pair<Long,Long>>\
    \ arr_num_ones = new ArrayList<Pair<Long,Long>>();\n        for (int i = 0; i\
    \ < arr.size(); i++) {\n            long val = arr.get(i);\n            long num_ones\
    \ = 0;\n            while (val > 0) {\n                if (val % 2 == 1) {\n \
    \                   num_ones++;\n                }\n                val /= 2;\n\
    \            }\n            arr_num_ones.add(new Pair<Long,Long>(arr.get(i), num_ones));\n\
    \        }\n        Collections.sort(arr_num_ones, new Comparator<Pair<Long,Long>>()\
    \ {\n            @Override\n            public int compare(Pair<Long,Long> o1,\
    \ Pair<Long,Long> o2) {\n                long num_ones_1 = o1.getValue1();\n \
    \               long num_ones_2 = o2.getValue1();\n                long val_1\
    \ = o1.getValue0();\n                long val_2 = o2.getValue0();\n          \
    \      if (num_ones_1 == num_ones_2) {\n                    return (int)(val_1\
    \ - val_2);\n                }\n                return (int)(num_ones_1 - num_ones_2);\n\
    \            }\n        });\n        for (int i = 0; i < arr_num_ones.size();\
    \ i++) {\n            res.add(arr_num_ones.get(i).getValue0());\n        }\n \
    \       return res;", "        return new ArrayList<Long>(\n            arr.stream()\n\
    \                .sorted(\n                    (a, b) -> {\n                 \
    \       String binaryRepA = Long.toBinaryString(a);\n                        String\
    \ binaryRepB = Long.toBinaryString(b);\n                        int numOnesA =\
    \ (int) binaryRepA.chars().filter(c -> c == '1').count();\n                  \
    \      int numOnesB = (int) binaryRepB.chars().filter(c -> c == '1').count();\n\
    \                        return numOnesA == numOnesB ? a.compareTo(b) : numOnesA\
    \ - numOnesB;\n                    })\n                .collect(Collectors.toList()));",
  "        ArrayList<Long> sarr = new ArrayList<Long>(arr);\n        Collections.sort(sarr,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ x, Long y) {\n                String xb = Long.toBinaryString(x), yb = Long.toBinaryString(y);\n\
    \                int xones = getOnes(xb), yones = getOnes(yb);\n             \
    \   if (xones == yones) {\n                    if (x < y) {\n                \
    \        return -1;\n                    } else if (x > y) {\n               \
    \         return 1;\n                    } else {\n                        return\
    \ 0;\n                    }\n                } else if (xones < yones) {\n   \
    \                 return -1;\n                } else {\n                    return\
    \ 1;\n                }\n            }\n        });\n        return sarr;", " \
    \       return arr.stream().sorted(new Comparator<Long>() {\n            @Override\n\
    \            public int compare(Long o1, Long o2) {\n                int x = o1.intValue(),\
    \ y = o2.intValue();\n                if (Integer.bitCount(x) == Integer.bitCount(y))\
    \ {\n                    return Long.compare(o1, o2);\n                }\n   \
    \             return Integer.compare(Integer.bitCount(x), Integer.bitCount(y));\n\
    \            }\n        }).collect(Collectors.toCollection(ArrayList::new));",
  "        // sort in reverse order\n        Collections.sort(arr, Collections.reverseOrder());\n\
    \        return arr;", "        ArrayList<Long> positives = new ArrayList<Long>();\n\
    \        ArrayList<Long> negatives = new ArrayList<Long>();\n        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        ArrayList<Tuple2<Long, Long>> pairs =\
    \ new ArrayList<Tuple2<Long, Long>>();\n        for (Long l : arr) {\n       \
    \     if (l >= 0) {\n                positives.add(l);\n            } else {\n\
    \                negatives.add(l);\n            }\n        }\n        for (Long\
    \ l : positives) {\n            int count = Long.bitCount(l);\n            pairs.add(new\
    \ Tuple2<Long, Long>(l, (long)count));\n        }\n        for (Long l : negatives)\
    \ {\n            int count = Long.bitCount(l);\n            pairs.add(new Tuple2<Long,\
    \ Long>(l, (long)count));\n        }\n        // sort the array list of pairs\n\
    \        Collections.sort(pairs, new MyComparator());\n        for (Tuple2<Long,\
    \ Long> t : pairs) {\n            res.add(t.getValue0());\n        }\n       \
    \ return res;", "        // <<< your code here\n        ArrayList<Integer> a =\
    \ arr.stream().map(x -> Integer.parseInt(Long.toBinaryString(x))).collect(Collectors.toCollection(ArrayList::new));\n\
    \        ArrayList<Integer> aClone = (ArrayList<Integer>) a.clone();\n       \
    \ Collections.sort(aClone);\n        aClone.forEach(x -> System.out.print(x +\
    \ \" \"));\n        System.out.println();\n        // >>>\n        return null;",
  "        return (ArrayList<Long>) arr.stream().sorted(Comparator.comparing((Long\
    \ l) -> {\n            return Long.bitCount(l);\n        }).thenComparing(Comparator.naturalOrder())).collect(Collectors.toList());",
  "        if (arr == null) {\n            return arr;\n        }\n        return\
    \ new ArrayList<Long>(\n            arr.stream()\n                .map(x -> new\
    \ Pair<Long, Integer>(x, Long.bitCount(x)))\n                .sorted((a, b) ->\
    \ {\n                    if (a.getValue1() == b.getValue1()) {\n             \
    \           return a.getValue0().compareTo(b.getValue0());\n                 \
    \   }\n                    return a.getValue1().compareTo(b.getValue1());\n  \
    \              })\n                .map(x -> x.getValue0())\n                .collect(Collectors.toList()));",
  "        ArrayList<Long> res = new ArrayList<>();\n        if (arr.size() == 0)\
    \ return res;\n        Collections.sort(arr, new Comparator<Long>() {\n      \
    \      @Override\n            public int compare(Long a, Long b) {\n         \
    \       int onesA = countOne(a);\n                int onesB = countOne(b);\n \
    \               if (onesA == onesB) {\n                    return Long.compare(a,\
    \ b);\n                }\n                return Integer.compare(onesA, onesB);\n\
    \            }\n        });\n        return arr;", "      long[] sortedarr = arr.stream().mapToLong(i\
    \ -> i).toArray();\n      Arrays.sort(sortedarr);\n      ArrayList<Long> sorted_arr\
    \ = new ArrayList<Long>();\n      for (long i : sortedarr) {\n        sorted_arr.add(i);\n\
    \      }\n      return sorted_arr;", "        if (arr == null) {\n           \
    \ return null;\n        } else if (arr.size() == 0) {\n            return arr;\n\
    \        } else {\n            LongTuple[] tuples = new LongTuple[arr.size()];\n\
    \            for (int i = 0; i < arr.size(); i++) {\n                long l =\
    \ arr.get(i);\n                tuples[i] = new LongTuple(\n                  \
    \  (int)Math.floor(Math.log(l) / Math.log(2)),\n                    Long.bitCount(l),\n\
    \                    l\n                );\n            }\n            Arrays.sort(tuples,\
    \ new Comparator<LongTuple>() {\n                @Override\n                public\
    \ int compare(LongTuple a, LongTuple b) {\n                    int r = a.getValue(0).compareTo(b.getValue(0));\n\
    \                    if (r == 0) {\n                        r = a.getValue(1).compareTo(b.getValue(1));\n\
    \                        if (r == 0) {\n                            r = a.getValue(2).compareTo(b.getValue(2));\n\
    \                        }\n                    }\n                    return\
    \ r;\n                }\n            });\n            ArrayList<Long> result =\
    \ new ArrayList<Long>();\n            for (int i = 0; i < tuples.length; i++)\
    \ {\n                result.add(tuples[i].getValue(2));\n            }\n     \
    \       return result;\n        }", "        // return new ArrayList<Long>(arr);\n\
    \        ArrayList<Long> list = new ArrayList<Long>(arr);\n        list.sort(new\
    \ Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ x, Long y) {\n                int binaryX = Long.bitCount(x);\n            \
    \    int binaryY = Long.bitCount(y);\n                if (binaryX == binaryY)\
    \ {\n                    return Long.compare(x, y);\n                }\n     \
    \           return Integer.compare(binaryX, binaryY);\n            }\n       \
    \ });\n        return list;", "        arr.sort(\n            (Long a, Long b)\
    \ -> {\n                var countA = Integer.bitCount(a.intValue());\n       \
    \         var countB = Integer.bitCount(b.intValue());\n                return\
    \ countA == countB ? a.compareTo(b) : countA - countB;\n            }\n      \
    \  );\n        return arr;", "        ArrayList<Long> result = new ArrayList<>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            Long current = arr.get(i);\n\
    \            if (current >= 0) {\n                result.add(current);\n     \
    \       }\n        }\n        Collections.sort(result, new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long o1, Long o2) {\n\
    \                String s1 = Long.toBinaryString(o1);\n                String\
    \ s2 = Long.toBinaryString(o2);\n                Integer ones1 = 0;\n        \
    \        Integer ones2 = 0;\n                for (char c : s1.toCharArray()) {\n\
    \                    if (c == '1') ones1++;\n                }\n             \
    \   for (char c : s2.toCharArray()) {\n                    if (c == '1') ones2++;\n\
    \                }\n                if (ones1 < ones2) return -1;\n          \
    \      if (ones1 > ones2) return 1;\n                if (o1 < o2) return -1;\n\
    \                if (o1 > o2) return 1;\n                return 0;\n         \
    \   }\n        });\n        for (int i = 0; i < arr.size(); i++) {\n         \
    \   Long current = arr.get(i);\n            if (current < 0) {\n             \
    \   result.add(current);\n            }\n        }\n        return result;", " \
    \       ArrayList<Long> sortedArr = new ArrayList<Long>();\n        for (int i\
    \ = 0; i < arr.size(); i++) {\n            if (arr.get(i) < 0) {\n           \
    \     arr.set(i, arr.get(i) * -1);\n            }\n        }\n        Collections.sort(arr);\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) <\
    \ 0) {\n                arr.set(i, arr.get(i) * -1);\n            }\n        }\n\
    \        // add a multiset method to binary list\n        return sortedArr;",
  "        arr.sort(new Comparator<Long>() {\n            @Override\n            public\
    \ int compare(Long a, Long b) {\n                if (numOnes(a) != numOnes(b))\n\
    \                    return numOnes(a) - numOnes(b);\n                return a.compareTo(b);\n\
    \            }\n        });\n        return arr;", "        Collections.sort(arr,\
    \ (a, b) -> {\n            int aOnes = Long.bitCount(a);\n            int bOnes\
    \ = Long.bitCount(b);\n            if (aOnes != bOnes) {\n                return\
    \ Integer.compare(aOnes, bOnes);\n            }\n            return Long.compare(a,\
    \ b);\n        });\n        return arr;", '        return arr;', '        return
    arr;', "        // type your code here\n        // NOTE: this is a slow implementation;\
    \ it is slow because it converts\n        // numbers to binary strings and back\
    \ many times\n        // An alternative implementation is to use bitwise operations\n\
    \        // instead of converting numbers to strings.\n        List<Pair<Long,\
    \ Long>> data = new ArrayList<>();\n        for (long n : arr) {\n           \
    \ long numberOfOnes = Long.bitCount(n);\n            data.add(new Pair<>(numberOfOnes,\
    \ n));\n        }\n        data.sort((p1, p2) -> {\n            if (p1.getValue0().equals(p2.getValue0()))\
    \ {\n                return p1.getValue1().compareTo(p2.getValue1());\n      \
    \      } else {\n                return p1.getValue0().compareTo(p2.getValue0());\n\
    \            }\n        });\n        ArrayList<Long> result = new ArrayList<>();\n\
    \        for (Pair<Long, Long> pair : data) {\n            result.add(pair.getValue1());\n\
    \        }\n        return result;", "        // Sort by count of 1's.\n     \
    \   arr.sort((a, b) -> countOnes(a).compareTo(countOnes(b)));\n        // Sort\
    \ by actual long value if 1's are equal.\n        arr.sort((a, b) -> a.compareTo(b));\n\
    \        return arr;", "        // Pairs of (number of ones, the number)\n   \
    \     ArrayList<Pair<Integer, Long>> ones = new ArrayList<>();\n        for (Long\
    \ a : arr) {\n            int count = Long.bitCount(a);\n            ones.add(new\
    \ Pair<>(count, a));\n        }\n        ones.sort((a, b) -> {\n            if\
    \ (a.getValue0().equals(b.getValue0()))\n                return a.getValue1().compareTo(b.getValue1());\n\
    \            return a.getValue0().compareTo(b.getValue0());\n        });\n   \
    \     ArrayList<Long> ans = new ArrayList<>();\n        for (Pair<Integer, Long>\
    \ p : ones) {\n            ans.add(p.getValue1());\n        }\n        return\
    \ ans;", "        var vals = new ArrayList<Pair<Long, Long>>();\n        for (var\
    \ i = 0; i < arr.size(); i++) {\n            vals.add(new Pair<Long, Long>(arr.get(i),\
    \ i));\n        }\n        var index = 0;\n        var sorted = new ArrayList<Long>();\n\
    \        Collections.sort(vals, new Comparator<Pair<Long, Long>>() {\n       \
    \     @Override\n            public int compare(Pair<Long, Long> a, Pair<Long,\
    \ Long> b) {\n                var cmp1 = (Long)a.getValue0().bitCount();\n   \
    \             var cmp2 = (Long)b.getValue0().bitCount();\n                if (cmp1\
    \ == cmp2) {\n                    return a.getValue0().compareTo(b.getValue0());\n\
    \                }\n                return cmp1.compareTo(cmp2);\n           \
    \ }\n        });\n        for (var i = 0; i < vals.size(); i++) {\n          \
    \  var val = vals.get(i);\n            sorted.add(val.getValue0());\n        }\n\
    \        return sorted;", "        //implement here\n        ArrayList<Long> out\
    \ = arr;\n        return out;", "        ArrayList<Pair<Long, Long>> pairs = new\
    \ ArrayList<>();\n        for (Long val : arr) {\n            pairs.add(new Pair<Long,\
    \ Long>(val, countOnes(val)));\n        }\n        Collections.sort(pairs, new\
    \ PairComparator());\n        ArrayList<Long> ret = new ArrayList<>();\n     \
    \   for (Pair<Long, Long> p : pairs) {\n            ret.add(p.getValue0());\n\
    \        }\n        return ret;", "        // sort the array according to binary\
    \ representation\n        Collections.sort(arr, new Comparator<Long>() {\n   \
    \         @Override\n            public int compare(Long l1, Long l2) {\n    \
    \            long n1 = l1;\n                long n2 = l2;\n                int\
    \ n1NumOnes = Long.bitCount(n1);\n                int n2NumOnes = Long.bitCount(n2);\n\
    \                if (n1NumOnes == n2NumOnes) {\n                    if (n1 < n2)\
    \ {\n                        return -1;\n                    } else if (n1 > n2)\
    \ {\n                        return 1;\n                    } else {\n       \
    \                 return 0;\n                    }\n                } else if\
    \ (n1NumOnes < n2NumOnes) {\n                    return -1;\n                }\
    \ else {\n                    return 1;\n                }\n            }\n  \
    \      });\n        return arr;", "        // your code here\n        // sort\
    \ array and return\n        List<Pair<Long, Integer>> list = new ArrayList<>();\n\
    \        for (long i : arr) {\n            String binary = Long.toBinaryString(i);\n\
    \            int count = binary.length() - binary.replace(\"1\", \"\").length();\n\
    \            list.add(new Pair<>(i, count));\n        }\n        Collections.sort(list,\
    \ new Comparator<Pair<Long, Integer>>() {\n            @Override\n           \
    \ public int compare(Pair<Long, Integer> p1, Pair<Long, Integer> p2) {\n     \
    \           if (p1.getValue1() > p2.getValue1())\n                    return 1;\n\
    \                else if (p1.getValue1() < p2.getValue1())\n                 \
    \   return -1;\n                else {\n                    if (p1.getValue0()\
    \ > p2.getValue0())\n                        return 1;\n                    else\
    \ if (p1.getValue0() < p2.getValue0())\n                        return -1;\n \
    \                   else\n                        return 0;\n                }\n\
    \            }\n        });\n        ArrayList<Long> result = new ArrayList<>();\n\
    \        for (Pair<Long, Integer> pair : list) {\n            result.add(pair.getValue0());\n\
    \        }\n        return result;", "        for (int i = 0; i < arr.size();\
    \ i++) {\n            for (int j = i + 1; j < arr.size(); j++) {\n           \
    \     if (Integer.bitCount(arr.get(i).intValue()) > Integer.bitCount(arr.get(j).intValue()))\
    \ {\n                    Long tmp = arr.get(i);\n                    arr.set(i,\
    \ arr.get(j));\n                    arr.set(j, tmp);\n                } else if\
    \ (Integer.bitCount(arr.get(i).intValue()) == Integer.bitCount(arr.get(j).intValue()))\
    \ {\n                    if (arr.get(i) > arr.get(j)) {\n                    \
    \    Long tmp = arr.get(i);\n                        arr.set(i, arr.get(j));\n\
    \                        arr.set(j, tmp);\n                    }\n           \
    \     }\n            }\n        }\n        return arr;", "        Integer[] indices\
    \ = new Integer[arr.size()];\n        for (int i = 0; i < indices.length; i++)\
    \ {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, (a,\
    \ b) -> {\n            Long first = arr.get(a);\n            Long second = arr.get(b);\n\
    \            if (first >= 0 && second >= 0) {\n                int firstOnes =\
    \ Long.bitCount(first);\n                int secondOnes = Long.bitCount(second);\n\
    \                if (firstOnes == secondOnes) {\n                    return first.compareTo(second);\n\
    \                } else {\n                    return firstOnes - secondOnes;\n\
    \                }\n            } else if (first < 0 && second < 0) {\n      \
    \          int firstOnes = Long.bitCount(first);\n                int secondOnes\
    \ = Long.bitCount(second);\n                if (firstOnes == secondOnes) {\n \
    \                   return second.compareTo(first);\n                } else {\n\
    \                    return secondOnes - firstOnes;\n                }\n     \
    \       } else if (first >= 0 && second < 0) {\n                return -1;\n \
    \           } else {\n                return 1;\n            }\n        });\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        for (int i =\
    \ 0; i < indices.length; i++) {\n            result.add(arr.get(indices[i]));\n\
    \        }\n        return result;", "        ArrayList<Long> al = new ArrayList<Long>();\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            al.add(countOnes(arr.get(i)));\n\
    \        }\n        for (int i = 0; i < arr.size(); i++) {\n            for (int\
    \ j = 0; j < al.size(); j++) {\n                if (al.get(j) == i) {\n      \
    \              System.out.println(al.get(j));\n                }\n           \
    \ }\n        }\n        return arr;", "      Collections.sort(arr, new Comparator<Long>()\
    \ {\n        @Override\n        public int compare(Long a, Long b) {\n       \
    \   int aOnes = Long.bitCount(a);\n          int bOnes = Long.bitCount(b);\n \
    \         if (aOnes == bOnes) {\n            return a.compareTo(b);\n        \
    \  }\n          return aOnes - bOnes;\n        }\n      });\n      return arr;",
  "        ArrayList<Long> ret = new ArrayList<Long>();\n        ArrayList<Pair<Long,\
    \ Integer>> oneCount = new ArrayList<Pair<Long, Integer>>();\n        for (Long\
    \ l : arr) {\n            oneCount.add(new Pair<Long, Integer>(l, Long.bitCount(l)));\n\
    \        }\n        oneCount.sort((Pair<Long, Integer> a, Pair<Long, Integer>\
    \ b) -> {\n            if (a.getValue1() < b.getValue1()) return -1;\n       \
    \     if (a.getValue1() > b.getValue1()) return 1;\n            if (a.getValue0()\
    \ < b.getValue0()) return -1;\n            if (a.getValue0() > b.getValue0())\
    \ return 1;\n            return 0;\n        });\n        for (Pair<Long, Integer>\
    \ p : oneCount) {\n            ret.add(p.getValue0());\n        }\n        return\
    \ ret;", "        ArrayList<Long> result = new ArrayList<Long>();\n        ArrayList<Long>\
    \ temp = new ArrayList<Long>();\n        for (Long elem : arr) {\n           \
    \ int onesCount = countOnes(elem);\n            if (temp.size() <= onesCount)\
    \ {\n                for (int i = temp.size(); i <= onesCount; i++) {\n      \
    \              temp.add(i, new Long(0));\n                }\n            }\n \
    \           long tempElem = temp.get(onesCount);\n            if (tempElem > elem)\
    \ {\n                int i = onesCount;\n                while (i < temp.size()\
    \ && temp.get(i) <= elem) {\n                    i++;\n                }\n   \
    \             temp.add(i, elem);\n            } else {\n                temp.set(onesCount,\
    \ elem);\n            }\n        }\n        for (Long elem : temp) {\n       \
    \     if (elem != 0) {\n                result.add(elem);\n            }\n   \
    \     }\n        return result;", "        Collections.sort(arr, new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long a, Long b) {\n\
    \                int ret = 0;\n                if (Long.bitCount(a) == Long.bitCount(b))\n\
    \                    ret = a.compareTo(b);\n                else\n           \
    \         ret = Integer.compare(Long.bitCount(a), Long.bitCount(b));\n       \
    \         return ret;\n            }\n        });\n        return arr;", "   \
    \     System.out.println(\"Input: \" + arr);\n        // 2. Sort by # of ones\n\
    \        ArrayList<Long> arr_copy = new ArrayList<>(arr);\n        // 2.1 Assign\
    \ # of ones to each element\n        HashMap<Long, Long> ones_map = new HashMap<>();\n\
    \        for (Long l : arr_copy) {\n            Long n_ones = new Long(getNumberOfOnesInBinary(l));\n\
    \            ones_map.put(l, n_ones);\n        }\n        // 2.2 Sort by # of\
    \ ones\n        arr_copy.sort(new Comparator<Long>() {\n            @Override\n\
    \            public int compare(Long l1, Long l2) {\n                Long n_ones_l1\
    \ = ones_map.get(l1);\n                Long n_ones_l2 = ones_map.get(l2);\n  \
    \              if (n_ones_l1 > n_ones_l2) {\n                    return 1;\n \
    \               } else if (n_ones_l1 < n_ones_l2) {\n                    return\
    \ -1;\n                } else {\n                    // break tie by decimal value\n\
    \                    if (l1 > l2) {\n                        return 1;\n     \
    \               } else if (l1 < l2) {\n                        return -1;\n  \
    \                  } else {\n                        return 0;\n             \
    \       }\n                }\n            }\n        });\n        System.out.println(\"\
    Sorted: \" + arr_copy);\n        return arr_copy;", "        TreeMap<Integer,\
    \ ArrayList<Long>> map = new TreeMap<>();\n        for (long val : arr) {\n  \
    \          int c = Long.bitCount(val);\n            if (!map.containsKey(c)) map.put(c,\
    \ new ArrayList<>());\n            map.get(c).add(val);\n        }\n        arr.clear();\n\
    \        for (int key : map.keySet()) {\n            ArrayList<Long> values =\
    \ map.get(key);\n            Collections.sort(values);\n            arr.addAll(values);\n\
    \        }\n        return arr;", "        Long[] array = arr.toArray(new Long[arr.size()]);\n\
    \        Arrays.sort(array, new Comparator<Long>() {\n            @Override\n\
    \            public int compare(Long a, Long b) {\n                String aBinary\
    \ = Long.toBinaryString(a);\n                String bBinary = Long.toBinaryString(b);\n\
    \                int aOnes = 0;\n                int bOnes = 0;\n            \
    \    for (char c : aBinary.toCharArray()) {\n                    if (c == '1')\
    \ aOnes++;\n                }\n                for (char c : bBinary.toCharArray())\
    \ {\n                    if (c == '1') bOnes++;\n                }\n         \
    \       if (aOnes == bOnes) {\n                    return a.compareTo(b);\n  \
    \              } else {\n                    return Integer.compare(aOnes, bOnes);\n\
    \                }\n            }\n        });\n        return new ArrayList<Long>(Arrays.asList(array));",
  "        ArrayList<Pair<Integer, Long>> list = new ArrayList<>();\n        for (long\
    \ l : arr) {\n            int count = Long.bitCount(l);\n            Pair<Integer,\
    \ Long> p = new Pair<>(count, l);\n            list.add(p);\n        }\n     \
    \   Comparator<Pair<Integer, Long>> comp = new Comparator<Pair<Integer, Long>>()\
    \ {\n            @Override\n            public int compare(Pair<Integer, Long>\
    \ a, Pair<Integer, Long> b) {\n                if (a.getValue0() > b.getValue0())\n\
    \                    return 1;\n                else if (a.getValue0() < b.getValue0())\n\
    \                    return -1;\n                else if (a.getValue1() > b.getValue1())\n\
    \                    return 1;\n                else if (a.getValue1() < b.getValue1())\n\
    \                    return -1;\n                else\n                    return\
    \ 0;\n            }\n        };\n        list.sort(comp);\n        ArrayList<Long>\
    \ result = new ArrayList<>();\n        for (Pair<Integer, Long> p : list) {\n\
    \            result.add(p.getValue1());\n        }\n        return result;", " \
    \       ArrayList<Long> ans = new ArrayList<Long>();\n        Map<Integer, ArrayList<Long>>\
    \ counter = new HashMap<Integer, ArrayList<Long>>();\n        for (Long n : arr)\
    \ {\n            String bits = Long.toBinaryString(n);\n            int ones =\
    \ (int)Arrays.stream(bits.split(\"\")).filter(s -> s.equals(\"1\")).count();\n\
    \            if (counter.containsKey(ones)) {\n                counter.get(ones).add(n);\n\
    \            } else {\n                ArrayList<Long> list = new ArrayList<Long>();\n\
    \                list.add(n);\n                counter.put(ones, list);\n    \
    \        }\n        }\n        for (Map.Entry<Integer, ArrayList<Long>> entry\
    \ : counter.entrySet()) {\n            ArrayList<Long> list = entry.getValue();\n\
    \            Collections.sort(list);\n            ans.addAll(list);\n        }\n\
    \        return ans;", "        List<Long> collect = arr.stream().sorted(Collections.reverseOrder(new\
    \ Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ x, Long y) {\n                return compareBinary(x, y);\n            }\n \
    \       })).collect(Collectors.toList());\n        return new ArrayList<Long>(collect);",
  "        arr.sort(Comparator.comparing(x -> Long.bitCount(x)).thenComparing(x ->\
    \ x));\n        return arr;", "        ArrayList<Long> sorted = new ArrayList<>();\n\
    \        for (Long i : arr) {\n            int index = 0;\n            for (int\
    \ j = 0; j < sorted.size(); j++) {\n                if (i == sorted.get(j)) {\n\
    \                    break;\n                }\n                int count = countOnes(i);\n\
    \                int nextCount = countOnes(sorted.get(j));\n                if\
    \ (count < nextCount) {\n                    index = j;\n                    break;\n\
    \                }\n                else if (count == nextCount) {\n         \
    \           if (i < sorted.get(j)) {\n                        index = j;\n   \
    \                     break;\n                    }\n                }\n     \
    \       }\n            sorted.add(index, i);\n        }\n        return sorted;",
  "        if (arr == null)\n            return arr;\n        arr.sort((a, b) -> {\n\
    \            int c = Integer.bitCount(a.intValue()) - Integer.bitCount(b.intValue());\n\
    \            if (c != 0)\n                return c;\n            return a.compareTo(b);\n\
    \        });\n        return arr;", "        return new ArrayList<Long>(arr.stream().sorted(\n\
    \                    (l,r) -> {\n                        int l1 = Long.bitCount(l);\n\
    \                        int r1 = Long.bitCount(r);\n                        if\
    \ (l1 == r1) {\n                            return (int)(l - r);\n           \
    \             }\n                        return l1 - r1;\n                   \
    \ }\n                ).collect(Collectors.toList()));", "        ArrayList<Long>\
    \ copy = new ArrayList<Long>(arr);\n        Collections.sort(copy, (a, b) -> {\n\
    \            int aOnes = onesInBinary(a);\n            int bOnes = onesInBinary(b);\n\
    \            if (aOnes < bOnes) return -1;\n            if (aOnes > bOnes) return\
    \ 1;\n            return (int) (a - b);\n        });\n        return copy;", " \
    \       // sort the array using a custom sort function\n        // pass in the\
    \ array and a method that returns the number of ones\n        // in the binary\
    \ representation of the number\n        // after sorting them according to the\
    \ number of ones\n        // sort them based on their decimal value\n        Collections.sort(arr,\
    \ new Comparator<Long>() {\n            public int compare(Long a, Long b) {\n\
    \                int a1 = numOnes(a);\n                int b1 = numOnes(b);\n\
    \                if (a1 == b1) {\n                    return (int)(a - b);\n \
    \               }\n                return a1 - b1;\n            }\n        });\n\
    \        return arr;", "        for (int i = 0; i < arr.size(); i++) {\n     \
    \       for (int j = i + 1; j < arr.size(); j++) {\n                if (Long.bitCount(arr.get(i))\
    \ > Long.bitCount(arr.get(j))) {\n                    // swap\n              \
    \      Long tmp = arr.get(i);\n                    arr.set(i, arr.get(j));\n \
    \                   arr.set(j, tmp);\n                } else if (Long.bitCount(arr.get(i))\
    \ == Long.bitCount(arr.get(j))) {\n                    if (arr.get(i) > arr.get(j))\
    \ {\n                        // swap\n                        Long tmp = arr.get(i);\n\
    \                        arr.set(i, arr.get(j));\n                        arr.set(j,\
    \ tmp);\n                    }\n                }\n            }\n        }\n\
    \        return arr;", "        Collections.sort(arr, (a, b) -> {\n          \
    \  int i = a.compareTo(b);\n            if (i == 0) {\n                return\
    \ 0;\n            }\n            if (i > 0) {\n                return (int) (countOnes(a)\
    \ - countOnes(b));\n            } else {\n                return (int) (countOnes(b)\
    \ - countOnes(a));\n            }\n        });\n        return arr;", "      \
    \  ArrayList<Long> res = new ArrayList<Long>();\n        ArrayList<Long> resNeg\
    \ = new ArrayList<Long>();\n        ArrayList<Long> resPos = new ArrayList<Long>();\n\
    \        ArrayList<Long> resPosNeg = new ArrayList<Long>();\n        resNeg.addAll(arr);\n\
    \        for (Long l : arr) {\n            if (l > 0) {\n                resPos.add(l);\n\
    \                resNeg.remove(l);\n            }\n        }\n        resPosNeg.addAll(resPos);\n\
    \        resPosNeg.addAll(resNeg);\n        for (Long l : resPosNeg) {\n     \
    \       if (l < 0) {\n                res.add(l);\n                resPosNeg.remove(l);\n\
    \            }\n        }\n        res.addAll(resPosNeg);\n        return res;",
  "        ArrayList<Long> ret = new ArrayList<Long>();\n        int[][] ones = new\
    \ int[arr.size()][2];\n        for (int i = 0; i < arr.size(); i++) {\n      \
    \      ones[i][0] = numOfOnes(arr.get(i));\n            ones[i][1] = (int) arr.get(i);\n\
    \        }\n        // Sort using Arrays.sort(array,Comparator).\n        Arrays.sort(ones,\
    \ new Comparator<int[]>() {\n            @Override\n            public int compare(int[]\
    \ o1, int[] o2) {\n                if (o1[0] > o2[0])\n                    return\
    \ 1;\n                else if (o1[0] < o2[0])\n                    return -1;\n\
    \                else\n                    return 0;\n            }\n        });\n\
    \        for (int i = 0; i < ones.length; i++) {\n            System.out.println(ones[i][0]\
    \ + \" \" + ones[i][1]);\n            ret.add((long) ones[i][1]);\n        }\n\
    \        return ret;", "        // int[] res = new int[arr.size()];\n        Map<Long,\
    \ Long> map = new HashMap<>();\n        // Map<Long, Integer> map = new HashMap<>();\n\
    \        for (Long e : arr) {\n            // if (!map.containsKey(e)) {\n   \
    \         //     map.put(e, 1);\n            // } else {\n            //     map.put(e,\
    \ map.get(e) + 1);\n            // }\n            map.put(e, convertToBinary(e));\n\
    \        }\n        // for (Long e : arr) {\n        //     long binary = convertToBinary(e);\n\
    \        //     if (!map.containsKey(binary)) {\n        //         map.put(binary,\
    \ 1);\n        //     } else {\n        //         map.put(binary, map.get(binary)\
    \ + 1);\n        //     }\n        // }\n        // arr.sort((a, b) -> (int)(convertToBinary(a)\
    \ - convertToBinary(b)));\n        // arr.sort((a, b) -> (int)(a - b));\n    \
    \    // arr.sort((a, b) -> (int)(convertToBinary(a) - convertToBinary(b)));\n\
    \        Collections.sort(arr, (a, b) -> {\n            if (map.get(a) == map.get(b))\
    \ {\n                return (int)(a - b);\n            } else {\n            \
    \    return (int)(map.get(a) - map.get(b));\n            }\n        });\n    \
    \    return arr;", "        ArrayList<Long> sortedArr = new ArrayList<Long>();\n\
    \        ArrayList<Integer> counts = new ArrayList<Integer>();\n        for (int\
    \ i = 0; i < arr.size(); i++) {\n            String binaryString = Long.toBinaryString(arr.get(i));\n\
    \            int count = 0;\n            for (int j = 0; j < binaryString.length();\
    \ j++) {\n                if (binaryString.charAt(j) == '1') {\n             \
    \       count++;\n                }\n            }\n            counts.add(count);\n\
    \        }\n        for (int i = 0; i < arr.size(); i++) {\n            int min\
    \ = arr.size();\n            int temp = 0;\n            for (int j = 0; j < counts.size();\
    \ j++) {\n                if (counts.get(j) < min) {\n                    min\
    \ = counts.get(j);\n                    temp = j;\n                }\n       \
    \     }\n            sortedArr.add(arr.get(temp));\n            counts.remove(temp);\n\
    \            arr.remove(temp);\n        }\n        return sortedArr;", "     \
    \   // return arr.stream().sorted((a, b) -> a.bitCount() - b.bitCount()).collect(Collectors.toCollection(ArrayList::new));\n\
    \        Long[] arrCopy = arr.toArray(new Long[arr.size()]);\n        Arrays.sort(arrCopy,\
    \ (a, b) -> {\n            int bitComparison = Integer.compare(Long.bitCount(a),\
    \ Long.bitCount(b));\n            if (bitComparison == 0) {\n                return\
    \ Long.compare(a, b);\n            }\n            return bitComparison;\n    \
    \    });\n        return new ArrayList<Long>(Arrays.asList(arrCopy));", "    \
    \    List<Pair<Long, Long>> pairs = new ArrayList<>();\n        for (Long l :\
    \ arr) {\n            pairs.add(Pair.with(l, Long.bitCount(l)));\n        }\n\
    \        return new ArrayList<>(\n            pairs.stream()\n               \
    \ .sorted((a, b) -> a.getValue1().equals(b.getValue1()) ?\n                  \
    \  a.getValue0().compareTo(b.getValue0()) :\n                    a.getValue1().compareTo(b.getValue1()))\n\
    \                .map(Pair::getValue0)\n                .collect(Collectors.toList()));",
  "        //your code here\n        Collections.sort(arr, new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long a, Long b) {\n\
    \                return countOnes(a).compareTo(countOnes(b));\n            }\n\
    \        });\n        return arr;", "        ArrayList<Long> output = new ArrayList<>();\n\
    \        while (arr.size() > 0) {\n            long currentMax = Long.MIN_VALUE;\n\
    \            long currentOneCount = 0;\n            int index = 0;\n         \
    \   for (int i = 0; i < arr.size(); i++) {\n                long x = arr.get(i);\n\
    \                long oneCount = getOneCount(x);\n                if (oneCount\
    \ > currentOneCount) {\n                    currentMax = x;\n                \
    \    currentOneCount = oneCount;\n                    index = i;\n           \
    \     } else if (oneCount == currentOneCount) {\n                    if (x > currentMax)\
    \ {\n                        currentMax = x;\n                        currentOneCount\
    \ = oneCount;\n                        index = i;\n                    }\n   \
    \             }\n            }\n            output.add(currentMax);\n        \
    \    arr.remove(index);\n        }\n        return output;", "        ArrayList<Long>\
    \ zeros = new ArrayList<Long>();\n        ArrayList<Long> ones = new ArrayList<Long>();\n\
    \        ArrayList<Long> twos = new ArrayList<Long>();\n        for (Long n :\
    \ arr) {\n            Long n2 = Math.abs(n);\n            Long onesCount = Long.bitCount(n2);\n\
    \            if (onesCount == 0) {\n                zeros.add(n);\n          \
    \  } else if (onesCount == 1) {\n                ones.add(n);\n            } else\
    \ {\n                twos.add(n);\n            }\n        }\n        Collections.sort(zeros);\n\
    \        Collections.sort(ones);\n        Collections.sort(twos);\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        result.addAll(zeros);\n        result.addAll(ones);\n\
    \        result.addAll(twos);\n        return result;", '        return null;',
  "        ArrayList<Tuple> arrTuple = new ArrayList<Tuple>();\n        for (Long\
    \ l : arr) {\n            String s = Long.toBinaryString(l);\n            arrTuple.add(new\
    \ Tuple(l, s.chars().filter(ch -> ch == '1').count()));\n        }\n        Collections.sort(arrTuple,\
    \ new TupleComparator());\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (Tuple t : arrTuple) {\n            result.add(t.getValue0());\n\
    \        }\n        return result;", "        if (arr == null) {\n           \
    \ return arr;\n        }\n        else if (arr.size() <= 1) {\n            return\
    \ arr;\n        }\n        int numOfCalls = 0;\n        ArrayList<Long> originalArray\
    \ = new ArrayList<Long>(arr);\n        ArrayList<Long> sortedArray = new ArrayList<Long>(arr);\n\
    \        // System.out.println(\"Original array: \" + originalArray);\n      \
    \  // System.out.println(\"Sorted array: \" + sortedArray);\n        // System.out.println(\"\
    Size: \" + arr.size());\n        // System.out.println(\"First element: \" + arr.get(0));\n\
    \        // System.out.println(\"Last element: \" + arr.get(arr.size() - 1));\n\
    \        for (int i = 0; i < arr.size(); i++) {\n            for (int j = 0; j\
    \ < arr.size() - 1; j++) {\n                numOfCalls++;\n                //\
    \ System.out.println(\"current element: \" + sortedArray.get(j));\n          \
    \      // System.out.println(\"next element: \" + sortedArray.get(j + 1));\n \
    \               if (sortedArray.get(j) > sortedArray.get(j + 1)) {\n         \
    \           Long temp = sortedArray.get(j);\n                    sortedArray.set(j,\
    \ sortedArray.get(j + 1));\n                    sortedArray.set(j + 1, temp);\n\
    \                }\n            }\n        }\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            for (int j = 0; j < arr.size() - 1; j++) {\n           \
    \     numOfCalls++;\n                // System.out.println(\"current element:\
    \ \" + sortedArray.get(j));\n                // System.out.println(\"next element:\
    \ \" + sortedArray.get(j + 1));\n                if (sortedArray.get(j) == sortedArray.get(j\
    \ + 1)) {\n                    if (numberOfOnes(sortedArray.get(j)) > numberOfOnes(sortedArray.get(j\
    \ + 1))) {\n                        Long temp = sortedArray.get(j);\n        \
    \                sortedArray.set(", "        return arr.stream().sorted(new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long o1, Long o2) {\n\
    \                String a = String.format(\"%32s\", Long.toBinaryString(o1)).replace('\
    \ ', '0');\n                String b = String.format(\"%32s\", Long.toBinaryString(o2)).replace('\
    \ ', '0');\n                int c = Integer.compare(a.length() - a.replace(\"\
    1\", \"\").length(), b.length() - b.replace(\"1\", \"\").length());\n        \
    \        if (c == 0) {\n                    return Long.compare(o1, o2);\n   \
    \             }\n                return c;\n            }\n        }).collect(Collectors.toCollection(ArrayList::new));",
  "        ArrayList<Pair<Long, Long>> arrayOfPairs = new ArrayList<Pair<Long, Long>>();\n\
    \        for (Long i : arr) {\n            long binaryOnes = Problem.getNumOnesInBinary(i);\n\
    \            arrayOfPairs.add(new Pair<Long, Long>(binaryOnes, i));\n        }\n\
    \        Collections.sort(arrayOfPairs, new Comparator<Pair<Long, Long>>() {\n\
    \            @Override\n            public int compare(Pair<Long, Long> o1, Pair<Long,\
    \ Long> o2) {\n                if (o1.getValue0().equals(o2.getValue0())) {\n\
    \                    return o1.getValue1().compareTo(o2.getValue1());\n      \
    \          }\n                return o1.getValue0().compareTo(o2.getValue0());\n\
    \            }\n        });\n        ArrayList<Long> sortedArr = new ArrayList<Long>();\n\
    \        for (Pair<Long, Long> i : arrayOfPairs) {\n            sortedArr.add(i.getValue1());\n\
    \        }\n        return sortedArr;", "      long size = arr.size();\n     \
    \ for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++)\
    \ {\n          long xor1 = arr.get(i) ^ arr.get(j);\n          long xor2 = arr.get(i)\
    \ + arr.get(j);\n          long cnt = Long.bitCount(xor1);\n          if (cnt\
    \ == 0) {\n            if (arr.get(i) > arr.get(j)) {\n              Collections.swap(arr,\
    \ i, j);\n            }\n          } else {\n            if (cnt % 2 == 0) {\n\
    \              if (arr.get(i) > arr.get(j)) {\n                Collections.swap(arr,\
    \ i, j);\n              }\n            } else {\n              if (arr.get(i)\
    \ < arr.get(j)) {\n                Collections.swap(arr, i, j);\n            \
    \  }\n            }\n          }\n        }\n      }\n      return arr;", "  \
    \      ArrayList<Pair<Long, Integer>> z = new ArrayList<>();\n        for (Long\
    \ i : arr) {\n            z.add(new Pair<Long, Integer>(i, Long.bitCount(i)));\n\
    \        }\n        Collections.sort(z, new Comparator<Pair<Long, Integer>>()\
    \ {\n            @Override\n            public int compare(Pair<Long, Integer>\
    \ o1, Pair<Long, Integer> o2) {\n                int cmp = Integer.compare(o1.getValue1(),\
    \ o2.getValue1());\n                if (cmp == 0)\n                    return\
    \ Long.compare(o1.getValue0(), o2.getValue0());\n                return cmp;\n\
    \            }\n        });\n        ArrayList<Long> res = new ArrayList<>();\n\
    \        for (Pair<Long, Integer> i : z) {\n            res.add(i.getValue0());\n\
    \        }\n        return res;", "        Collections.sort(arr, (a, b) -> {\n\
    \            var onesA = countOnes(a);\n            var onesB = countOnes(b);\n\
    \            return onesA == onesB ? a.compareTo(b) : onesA - onesB;\n       \
    \ });\n        return arr;", "        long maxv = 0;\n        long minv = 0;\n\
    \        long maxv2 = 0;\n        ArrayList<Long> values = new ArrayList<Long>();\n\
    \        ArrayList<Long> values2 = new ArrayList<Long>();\n        ArrayList<Long>\
    \ values3 = new ArrayList<Long>();\n        ArrayList<Long> values4 = new ArrayList<Long>();\n\
    \        ArrayList<Long> values5 = new ArrayList<Long>();\n        if (arr.size()\
    \ == 0) {\n            return arr;\n        }\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            if (arr.get(i) > maxv) {\n                maxv = arr.get(i);\n\
    \            }\n            if (arr.get(i) < minv) {\n                minv = arr.get(i);\n\
    \            }\n        }\n        for (int i = 0; i < arr.size(); i++) {\n  \
    \          if (arr.get(i) < 0) {\n                values.add(arr.get(i));\n  \
    \          } else {\n                values2.add(arr.get(i));\n            }\n\
    \        }\n        for (int i = 0; i < values.size(); i++) {\n            String\
    \ temp = String.format(\"%8s\", Integer.toBinaryString(values.get(i).intValue())).replace('\
    \ ', '0');\n            long count = temp.chars().filter(num -> num == '1').count();\n\
    \            values3.add(count);\n        }\n        for (int i = 0; i < values2.size();\
    \ i++) {\n            String temp = String.format(\"%8s\", Integer.toBinaryString(values2.get(i).intValue())).replace('\
    \ ', '0');\n            long count = temp.chars().filter(num -> num == '1').count();\n\
    \            values4.add(count);\n        }\n        for (int i = 0; i < values.size();\
    \ i++) {\n            for (int j = 0; j < values.size(); j++) {\n            \
    \    if (values3.get(i) < values3.get(j)) {\n                    long temp", " \
    \       ArrayList<Long> ans = new ArrayList<>();\n        ArrayList<Long> negative\
    \ = new ArrayList<>();\n        ArrayList<Long> positive = new ArrayList<>();\n\
    \        for (Long l : arr) {\n            if (l > 0) {\n                positive.add(l);\n\
    \            } else {\n                negative.add(l);\n            }\n     \
    \   }\n        Collections.sort(positive, new Comparator<Long>() {\n         \
    \   @Override\n            public int compare(Long o1, Long o2) {\n          \
    \      int count1 = Long.bitCount(o1);\n                int count2 = Long.bitCount(o2);\n\
    \                if (count1 == count2) {\n                    return o1.compareTo(o2);\n\
    \                } else {\n                    return count1 - count2;\n     \
    \           }\n            }\n        });\n        Collections.sort(negative,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ o1, Long o2) {\n                int count1 = Long.bitCount(o1);\n          \
    \      int count2 = Long.bitCount(o2);\n                if (count1 == count2)\
    \ {\n                    return o1.compareTo(o2);\n                } else {\n\
    \                    return count1 - count2;\n                }\n            }\n\
    \        });\n        ans.addAll(negative);\n        ans.addAll(positive);\n \
    \       return ans;", "        Collections.sort(arr, (e1, e2) -> {\n         \
    \   int n1 = Long.bitCount(e1);\n            int n2 = Long.bitCount(e2);\n   \
    \         if (n1 != n2) {\n                return Integer.compare(n1, n2);\n \
    \           }\n            return Long.compare(e1, e2);\n        });\n       \
    \ return arr;", "        return new ArrayList<Long>(\n                arr.stream()\n\
    \                .sorted(\n                        Comparator.comparing((Long\
    \ x) -> Integer.bitCount(x.intValue()))\n                        .thenComparing((Long\
    \ x) -> x)\n                )\n                .collect(Collectors.toList())\n\
    \        );", "        // your code here\n        Comparator<Long> comparator\
    \ = new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ a, Long b) {\n                return Long.compare(getOnes(a), getOnes(b));\n\
    \            }\n        };\n        Collections.sort(arr, comparator);\n     \
    \   return arr;", "        //Please code here\n        Collections.sort(arr, new\
    \ Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ a, Long b) {\n                int x = Integer.bitCount(a.intValue());\n    \
    \            int y = Integer.bitCount(b.intValue());\n                return x\
    \ == y ? a.compareTo(b) : x - y;\n            }\n        });\n        return arr;",
  "        ArrayList<Long> sortedArr = new ArrayList<Long>();\n        ArrayList<Long>\
    \ sortedArrBin = new ArrayList<Long>();\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            Long curr = arr.get(i);\n            if (curr > 0) {\n \
    \               Long bin = Long.parseLong(Integer.toBinaryString(curr.intValue()));\n\
    \                Long binCpy = bin;\n                int ones = 0;\n         \
    \       while (binCpy > 0) {\n                    if (binCpy % 10 == 1) {\n  \
    \                      ones++;\n                    }\n                    binCpy\
    \ /= 10;\n                }\n                sortedArrBin.add(bin);\n        \
    \        sortedArr.add(curr);\n            } else {\n                sortedArrBin.add((long)\
    \ 0);\n                sortedArr.add(curr);\n            }\n        }\n      \
    \  boolean sorted = false;\n        while (!sorted) {\n            sorted = true;\n\
    \            for (int i = 0; i < sortedArrBin.size() - 1; i++) {\n           \
    \     if (sortedArrBin.get(i) > sortedArrBin.get(i + 1)) {\n                 \
    \   Long binCpy = sortedArrBin.get(i);\n                    sortedArrBin.set(i,\
    \ sortedArrBin.get(i + 1));\n                    sortedArrBin.set(i + 1, binCpy);\n\
    \                    Long cpy = sortedArr.get(i);\n                    sortedArr.set(i,\
    \ sortedArr.get(i + 1));\n                    sortedArr.set(i + 1, cpy);\n   \
    \                 sorted = false;\n                }\n            }\n        }\n\
    \        return sortedArr;", "        ArrayList<Long> sorted = new ArrayList<Long>();\n\
    \        // Add your code here\n        Collections.sort(arr, (Long i1, Long i2)\
    \ -> Integer.compare(\n            Long.bitCount(i1),\n            Long.bitCount(i2)\n\
    \        ));\n        for (Long i : arr) {\n            sorted.add(i);\n     \
    \   }\n        return sorted;", "        ArrayList<Long> array_with_ones = new\
    \ ArrayList<Long>();\n        ArrayList<Long> array_with_zeros = new ArrayList<Long>();\n\
    \        for (Long i : arr) {\n            String binary_string = Long.toBinaryString(i);\n\
    \            int ones = binary_string.length() - binary_string.replace(\"1\",\
    \ \"\").length();\n            if (ones > 0) {\n                array_with_ones.add(i);\n\
    \            } else {\n                array_with_zeros.add(i);\n            }\n\
    \        }\n        Collections.sort(array_with_ones);\n        array_with_ones.addAll(array_with_zeros);\n\
    \        return array_with_ones;", "        ArrayList<Long> res = (ArrayList<Long>)arr.clone();\n\
    \        // res.sort((Long o1, Long o2) -> o1 > o2 ? -1 : 1);\n        // Collections.sort(res,\
    \ (Long o1, Long o2) -> o1 > o2 ? -1 : 1);\n        // Collections.sort(res, (o1,\
    \ o2) -> o1 > o2 ? -1 : 1);\n        // Collections.sort(res, (o1, o2) -> new\
    \ Long(o1.toString()).compareTo(new Long(o2.toString())));\n        Collections.sort(res,\
    \ (o1, o2) -> new Long(o1).compareTo(new Long(o2)));\n        return res;", " \
    \       Collections.sort(arr, new Comparator<Long>() {\n            @Override\n\
    \            public int compare(Long a, Long b) {\n                long x = Long.bitCount(a);\n\
    \                long y = Long.bitCount(b);\n                if (x < y) {\n  \
    \                  return -1;\n                } else if (x > y) {\n         \
    \           return 1;\n                } else {\n                    return Long.compare(a,\
    \ b);\n                }\n            }\n        });\n        return arr;", " \
    \       HashMap<Long, Long> map = new HashMap<>();\n        HashMap<Long, Long>\
    \ map2 = new HashMap<>();\n        ArrayList<Long> sortedArray = new ArrayList<>();\n\
    \        for (Long i : arr) {\n            if (i >= 0) {\n                map.put(i,\
    \ convertToBinary(i));\n                map2.put(i, convertToBinary(i));\n   \
    \         } else {\n                sortedArray.add(i);\n            }\n     \
    \   }\n        ArrayList<Long> sortedKeys = new ArrayList<>();\n        ArrayList<Long>\
    \ sortedKeys2 = new ArrayList<>();\n        for (Long i : map.keySet()) {\n  \
    \          sortedKeys.add(i);\n            sortedKeys2.add(i);\n        }\n  \
    \      Collections.sort(sortedKeys, (a, b) -> (int) (map.get(a) - map.get(b)));\n\
    \        Collections.sort(sortedKeys2, (a, b) -> (int) (map2.get(a) - map2.get(b)));\n\
    \        int j = 0;\n        while (j < sortedKeys.size()) {\n            for\
    \ (int i = 0; i < sortedKeys.size(); i++) {\n                if (sortedKeys.get(i)\
    \ == sortedKeys2.get(j)) {\n                    sortedArray.add(sortedKeys.get(i));\n\
    \                    sortedKeys.remove(i);\n                    sortedKeys2.remove(j);\n\
    \                    j = 0;\n                    break;\n                }\n \
    \           }\n            j++;\n        }\n        return sortedArray;", "  \
    \      // System.out.println(arr);\n        List<Tuple2<Long, Integer>> arr_list\
    \ = \n        arr.stream().map(\n            (Long num) -> {\n               \
    \ int num_ones = Integer.bitCount(num.intValue());\n                Tuple2<Long,\
    \ Integer> result = new Tuple2<Long, Integer>(num, num_ones);\n              \
    \  return result;\n            }\n        ).collect(Collectors.toList());\n  \
    \      // System.out.println(arr_list);\n        ArrayList<Long> result = new\
    \ ArrayList<Long>();\n        List<Tuple2<Long, Integer>> filtered_list = arr_list.stream().filter(\n\
    \            (Tuple2<Long, Integer> e) -> {\n                int num_ones = e.getValue1();\n\
    \                if (num_ones == 0) {\n                    result.add(e.getValue0());\n\
    \                    return false;\n                }\n                return\
    \ true;\n            }\n        ).collect(Collectors.toList());\n        // System.out.println(filtered_list);\n\
    \        List<Tuple2<Long, Integer>> sorted_list = filtered_list.stream().sorted(\n\
    \            (Tuple2<Long, Integer> e1, Tuple2<Long, Integer> e2) -> {\n     \
    \           int num_ones1 = e1.getValue1();\n                int num_ones2 = e2.getValue1();\n\
    \                if (num_ones1 > num_ones2) {\n                    return 1;\n\
    \                } else if (num_ones1 < num_ones2) {\n                    return\
    \ -1;\n                } else {\n                    Long num1 = e1.getValue0();\n\
    \                    Long num2 = e2.getValue0();\n                    if (num1\
    \ > num2) {\n                        return 1;\n                    } else if\
    \ (num1 < num2) {\n                        return -1;\n                    } else\
    \ {\n                        return 0;\n                    }\n              \
    \  }\n            }\n        ).collect(Collectors.toList());\n        for (Tuple2<Long,\
    \ Integer> elem : sorted_list) {\n            result.add(elem.getValue0());\n\
    \        }\n        return", "        // long[] array = new long[arr.size()];\n\
    \        // for (int i = 0; i < arr.size(); i++) {\n        // array[i] = arr.get(i);\n\
    \        // }\n        // // quick sort\n        // quickSort(array, 0, array.length\
    \ - 1);\n        // ArrayList<Long> arrayList = new ArrayList<Long>();\n     \
    \   // for (int i = 0; i < array.length; i++) {\n        // arrayList.add(array[i]);\n\
    \        // }\n        // return arrayList;\n        arr.sort(new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long one, Long two)\
    \ {\n                int oneOnes = countOnes(one);\n                int twoOnes\
    \ = countOnes(two);\n                if (oneOnes > twoOnes) {\n              \
    \      return 1;\n                } else if (oneOnes < twoOnes) {\n          \
    \          return -1;\n                } else {\n                    return (int)\
    \ (one - two);\n                }\n            }\n        });\n        return\
    \ arr;", "        arr.sort(new Comparator<Long>() {\n            @Override\n \
    \           public int compare(Long o1, Long o2) {\n                return Long.compare(ones(o1),\
    \ ones(o2));\n            }\n        });\n        return arr;", "        arr.sort(new\
    \ Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ a, Long b) {\n                return a.equals(b) ? Long.compare(a, b) : Long.compare(Long.bitCount(a),\
    \ Long.bitCount(b));\n            }\n        });\n        return arr;", "    \
    \    ArrayList<Long> result = new ArrayList<>();\n        ArrayList<Pair<Long,\
    \ Long>> keyValuePairs = new ArrayList<>();\n        ArrayList<Long> sortedKeys\
    \ = new ArrayList<>();\n        for (Long value : arr) {\n            Long key\
    \ = Long.bitCount(value);\n            keyValuePairs.add(new Pair<>(key, value));\n\
    \            if (!sortedKeys.contains(key))\n                sortedKeys.add(key);\n\
    \        }\n        Collections.sort(sortedKeys);\n        Collections.reverse(sortedKeys);\n\
    \        for (Long key : sortedKeys) {\n            ArrayList<Long> values = new\
    \ ArrayList<>();\n            for (Pair<Long, Long> keyValuePair : keyValuePairs)\
    \ {\n                if (keyValuePair.getValue0().equals(key))\n             \
    \       values.add(keyValuePair.getValue1());\n            }\n            Collections.sort(values);\n\
    \            Collections.reverse(values);\n            for (Long value : values)\n\
    \                result.add(value);\n        }\n        Collections.reverse(result);\n\
    \        return result;", "        return new ArrayList<Long>(arr.stream().map(x\
    \ -> new Pair<Long, Long>(x, toBin(x))).sorted((x, y) -> {\n            int xx\
    \ = x.getValue0().intValue();\n            int yy = y.getValue0().intValue();\n\
    \            int a = Long.bitCount(xx);\n            int b = Long.bitCount(yy);\n\
    \            if (a != b) {\n                return a - b;\n            }\n   \
    \         return xx - yy;\n        }).map(x -> x.getValue0()).collect(Collectors.toList()));",
  "        // Write your code here...\n        ArrayList<Pair<Long,Long>> list = new\
    \ ArrayList<Pair<Long,Long>>();\n        for (Long i : arr) {\n            Pair<Long,Long>\
    \ pair = new Pair<Long,Long>(Long.bitCount(i), i);\n            list.add(pair);\n\
    \        }\n        Collections.sort(list, (p1, p2) -> {\n            if (p1.getValue0().equals(p2.getValue0()))\
    \ {\n                return p1.getValue1().compareTo(p2.getValue1());\n      \
    \      } else {\n                return p1.getValue0().compareTo(p2.getValue0());\n\
    \            }\n        });\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (Pair<Long,Long> pair : list) {\n            result.add(pair.getValue1());\n\
    \        }\n        return result;", "        // Write your solution here\n  \
    \      ArrayList<Pair<Long, Long>> list = new ArrayList<>();\n        for (long\
    \ x : arr) {\n            list.add(new Pair<Long, Long>(x, countOnes(x)));\n \
    \       }\n        Collections.sort(list, new Comparator<Pair<Long, Long>>() {\n\
    \            @Override\n            public int compare(Pair<Long, Long> p1, Pair<Long,\
    \ Long> p2) {\n                if (p1.getValue1().equals(p2.getValue1())) {\n\
    \                    return p1.getValue0().compareTo(p2.getValue0());\n      \
    \          }\n                return p1.getValue1().compareTo(p2.getValue1());\n\
    \            }\n        });\n        ArrayList<Long> res = new ArrayList<>();\n\
    \        for (Pair<Long, Long> p : list) {\n            res.add(p.getValue0());\n\
    \        }\n        return res;", "        Collections.sort(arr, new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long o1, Long o2) {\n\
    \                int ones1 = Long.bitCount(o1);\n                int ones2 = Long.bitCount(o2);\n\
    \                return ones1 < ones2 ? -1 : ones1 > ones2 ? 1 : o1.compareTo(o2);\n\
    \            }\n        });\n        return arr;", "        ArrayList<Long> copy\
    \ = new ArrayList<Long>(arr);\n        Comparator<Long> comp = (a, b) -> {\n \
    \           int countA = Long.bitCount(a);\n            int countB = Long.bitCount(b);\n\
    \            if (countA == countB) {\n                return Long.compare(a, b);\n\
    \            }\n            return Integer.compare(countA, countB);\n        };\n\
    \        Collections.sort(copy, comp);\n        return copy;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        int length = arr.size();\n        while\
    \ (length > 0) {\n            int counter = 0;\n            long leastValue =\
    \ 0;\n            Long value = new Long(0);\n            for (Long i : arr) {\n\
    \                int ones = getOnes(i);\n                if (ones > counter) {\n\
    \                    counter = ones;\n                    leastValue = i;\n  \
    \              } else if (ones == counter) {\n                    if (i < leastValue)\
    \ {\n                        leastValue = i;\n                    }\n        \
    \        }\n            }\n            result.add(leastValue);\n            arr.remove(leastValue);\n\
    \            length--;\n        }\n        return result;", "        return arr.stream().sorted(Comparator.comparing(x\
    \ -> {\n            String s = Long.toBinaryString(x);\n            int count\
    \ = 0;\n            for (int i = 0; i < s.length(); i++) {\n                if\
    \ (s.charAt(i) == '1') {\n                    count++;\n                }\n  \
    \          }\n            return Pair.with(count, x);\n        })).collect(Collectors.toCollection(ArrayList::new));",
  "        int len = arr.size();\n        ArrayList<Long> sorted = new ArrayList<Long>();\n\
    \        HashMap<Integer, ArrayList<Long>> dict = new HashMap<Integer, ArrayList<Long>>();\n\
    \        ArrayList<Integer> counts = new ArrayList<Integer>();\n        for (int\
    \ i = 0; i < len; i++) {\n            int counter = 0;\n            long number\
    \ = arr.get(i);\n            for (int j = 0; j < 32; j++) {\n                counter\
    \ += (number & 1) == 1 ? 1 : 0;\n                number >>= 1;\n            }\n\
    \            if (!counts.contains(counter)) {\n                counts.add(counter);\n\
    \                dict.put(counter, new ArrayList<Long>());\n            }\n  \
    \          dict.get(counter).add(arr.get(i));\n        }\n        Collections.sort(counts);\n\
    \        for (int i = 0; i < counts.size(); i++) {\n            ArrayList<Long>\
    \ unsortedList = dict.get(counts.get(i));\n            Collections.sort(unsortedList);\n\
    \            sorted.addAll(unsortedList);\n        }\n        return sorted;",
  '        return arr;', '        return null;', "        if (arr == null)\n     \
    \       return null;\n        if (arr.size() == 0)\n            return arr;\n\
    \        TreeMap<Pair<Integer, BigInteger>, Long> map = new TreeMap<>();\n   \
    \     for (Long l : arr) {\n            BigInteger value = BigInteger.valueOf(l);\n\
    \            int ones = value.bitCount();\n            Pair<Integer, BigInteger>\
    \ p = new Pair<>(ones, value);\n            map.put(p, l);\n        }\n      \
    \  ArrayList<Long> result = new ArrayList<>(map.values());\n        return result;",
  "        ArrayList<Long> sort = arr;\n        ArrayList<Long> total = new ArrayList<Long>();\n\
    \        long cur, cur1, index;\n        int minones = 1000;\n        while(sort.size()\
    \ != 0) {\n            for(int i = 0; i < sort.size(); i++) {\n              \
    \  cur = sort.get(i);\n                cur1 = sort.get(i);\n                index\
    \ = i;\n                if (i == 0) {\n                    minones = countOnes(cur);\n\
    \                }\n                if (countOnes(cur) < minones) {\n        \
    \            minones = countOnes(cur);\n                    cur1 = cur;\n    \
    \                index = i;\n                }\n                else if (countOnes(cur)\
    \ == minones) {\n                    if (cur1 > cur) {\n                     \
    \   cur1 = cur;\n                        index = i;\n                    }\n \
    \               }\n            }\n            sort.remove(index);\n          \
    \  total.add(cur1);\n        }\n        return total;", "        ArrayList<Long>\
    \ result = (ArrayList<Long>)arr.clone();\n        for (int i = 0; i < result.size();\
    \ i++) {\n            if (result.get(i) < 0) {\n                Long l = result.get(i);\n\
    \                result.remove(i);\n                result.add(0, l);\n      \
    \      }\n        }\n        Collections.sort(result, new Comparator<Long>() {\n\
    \            @Override\n            public int compare(Long a, Long b) {\n   \
    \             String s1 = Long.toBinaryString(a);\n                String s2 =\
    \ Long.toBinaryString(b);\n                int count1 = 0;\n                int\
    \ count2 = 0;\n                for (int i = 0; i < s1.length(); i++) {\n     \
    \               if (s1.charAt(i) == '1') count1++;\n                }\n      \
    \          for (int i = 0; i < s2.length(); i++) {\n                    if (s2.charAt(i)\
    \ == '1') count2++;\n                }\n                if (count1 == count2)\
    \ {\n                    return a.compareTo(b);\n                } else {\n  \
    \                  return Integer.compare(count1, count2);\n                }\n\
    \            }\n        });\n        return result;", "        // do your magic\
    \ here\n        return new ArrayList<Long>(arr);", "        ArrayList<Long> a\
    \ = new ArrayList<Long>();\n        ArrayList<Long> b = new ArrayList<Long>();\n\
    \        ArrayList<Long> c = new ArrayList<Long>();\n        arr.stream().forEach(x\
    \ -> {\n            int bitCount = 0;\n            String s = Long.toBinaryString(x);\n\
    \            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)\
    \ == '1') bitCount++;\n            }\n            if (bitCount % 2 == 0) a.add(x);\n\
    \            else b.add(x);\n        });\n        a.sort(null);\n        b.sort(null);\n\
    \        c.addAll(a);\n        c.addAll(b);\n        return c;", "        ArrayList<Tuple2<Integer,Long>>\
    \ res = new ArrayList<>();\n        for (long x : arr) {\n            String b\
    \ = Long.toBinaryString(x);\n            res.add(new Tuple2<Integer,Long>(numberOfOnes(b),\
    \ x));\n        }\n        res.sort(Comparator.comparing(Tuple2::getValue0));\n\
    \        ArrayList<Long> ans = new ArrayList<>();\n        for (Tuple2<Integer,Long>\
    \ t : res) {\n            ans.add(t.getValue1());\n        }\n        return ans;",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        HashMap<Long,\
    \ Long> counts = new HashMap<Long, Long>();\n        for (Long i : arr) {\n  \
    \          long count = 0;\n            for (long j = 0; j < 32; j++) {\n    \
    \            if ((i & (1 << j)) != 0) {\n                    count++;\n      \
    \          }\n            }\n            counts.put(i, count);\n        }\n  \
    \      Map<Long, List<Long>> map = counts.entrySet().stream().collect(Collectors.groupingBy(e\
    \ -> e.getValue()));\n        List<Long> keys = new ArrayList<Long>(map.keySet());\n\
    \        Collections.sort(keys);\n        for (Long key : keys) {\n          \
    \  List<Long> value = map.get(key);\n            Collections.sort(value);\n  \
    \          result.addAll(value);\n        }\n        return result;", '        return
    arr.stream().sorted(Problem::compare).collect(Collectors.toCollection(ArrayList::new));',
  "        var o = (long l1, long l2) -> {\n            var v1 = Long.bitCount(l1);\n\
    \            var v2 = Long.bitCount(l2);\n            if (v1 == v2) return l1.compareTo(l2);\n\
    \            return v1.compareTo(v2);\n        };\n        arr.sort(o);\n    \
    \    return arr;", "        // Your code here\n        arr.sort(new Comparator<Long>()\
    \ {\n            @Override\n            public int compare(Long o1, Long o2) {\n\
    \                if (o1 < 0) {\n                    o1 = -o1;\n              \
    \  }\n                if (o2 < 0) {\n                    o2 = -o2;\n         \
    \       }\n                int c1 = 0;\n                int c2 = 0;\n        \
    \        for (char c : Long.toBinaryString(o1).toCharArray()) {\n            \
    \        if (c == '1') {\n                        c1++;\n                    }\n\
    \                }\n                for (char c : Long.toBinaryString(o2).toCharArray())\
    \ {\n                    if (c == '1') {\n                        c2++;\n    \
    \                }\n                }\n                if (c1 == c2) {\n     \
    \               return Long.compare(o1, o2);\n                }\n            \
    \    return Integer.compare(c1, c2);\n            }\n        });\n        return\
    \ arr;", "        // return new ArrayList<Long>(arr.stream().sorted((a, b) ->\
    \ {\n        //     // long aCount = Long.bitCount(a);\n        //     // long\
    \ bCount = Long.bitCount(b);\n        //     // if (aCount > bCount) {\n     \
    \   //     //     return 1;\n        //     // } else if (aCount < bCount) {\n\
    \        //     //     return -1;\n        //     // } else {\n        //    \
    \ //     return a.compareTo(b);\n        //     // }\n        //     return Long.bitCount(a)\
    \ > Long.bitCount(b) ? 1 : Long.bitCount(a) < Long.bitCount(b) ? -1 : a.compareTo(b);\n\
    \        // }).collect(Collectors.toList()));\n        return new ArrayList<Long>(arr.stream().sorted((a,\
    \ b) -> Long.bitCount(a) > Long.bitCount(b) ? 1 : Long.bitCount(a) < Long.bitCount(b)\
    \ ? -1 : a.compareTo(b)).collect(Collectors.toList()));", "        // Write your\
    \ code here\n        return arr;", "        arr.sort(new Comparator<Long>() {\n\
    \            @Override\n            public int compare(Long a, Long b) {\n   \
    \             int c = Long.bitCount(a) - Long.bitCount(b);\n                if\
    \ (c != 0) {\n                    return c;\n                }\n             \
    \   return a.compareTo(b);\n            }\n        });\n        return arr;",
  "        ArrayList<Long> out = new ArrayList<Long>();\n        Map<Long, Long> map\
    \ = new HashMap<Long, Long>();\n        for (Long l : arr) {\n            map.put(l,\
    \ Long.bitCount(l));\n        }\n        for (Map.Entry<Long, Long> entry : map.entrySet())\
    \ {\n            ArrayList<Pair<Long, Long>> list = new ArrayList<Pair<Long, Long>>();\n\
    \            Long key = entry.getKey();\n            Long value = entry.getValue();\n\
    \            list.add(new Pair<Long, Long>(key, value));\n            if (out.contains(value))\
    \ {\n                ArrayList<Pair<Long, Long>> newList = new ArrayList<Pair<Long,\
    \ Long>>();\n                boolean added = false;\n                for (Pair<Long,\
    \ Long> pair : out) {\n                    if (pair.getValue1() < list.get(0).getValue1())\
    \ {\n                        newList.add(pair);\n                    } else if\
    \ (pair.getValue1() == list.get(0).getValue1()) {\n                        newList.add(pair);\n\
    \                        newList.add(list.get(0));\n                        added\
    \ = true;\n                    } else {\n                        if (!added) {\n\
    \                            newList.add(list.get(0));\n                     \
    \       added = true;\n                        }\n                        newList.add(pair);\n\
    \                    }\n                }\n                if (!added) {\n   \
    \                 newList.add(list.get(0));\n                }\n             \
    \   out = newList;\n            } else {\n                out.add(list.get(0).getValue1());\n\
    \            }\n        }\n        return out;", "        // your code here!\n\
    \        return arr;", "        ArrayList<Long> sorted = new ArrayList<Long>();\n\
    \        Set<Long> seen = new HashSet<Long>();\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            // sort by number of 1's in binary\n            // for each\
    \ number of 1's, sort by decimal value\n            for (int j = 0; j < arr.size();\
    \ j++) {\n                if (i == j) continue;\n                if (countOnes(arr.get(i))\
    \ < countOnes(arr.get(j))) continue;\n                if (countOnes(arr.get(i))\
    \ > countOnes(arr.get(j))) break;\n                if (countOnes(arr.get(i)) ==\
    \ countOnes(arr.get(j))) {\n                    if (arr.get(i) > arr.get(j)) continue;\n\
    \                    if (arr.get(i) < arr.get(j)) break;\n                }\n\
    \            }\n            if (!seen.contains(arr.get(i))) {\n              \
    \  sorted.add(arr.get(i));\n                seen.add(arr.get(i));\n          \
    \  }\n        }\n        return sorted;", "        ArrayList<Long> sorted = new\
    \ ArrayList<Long>();\n        for (int i = 0; i < arr.size(); i++) {\n       \
    \     sorted.add(arr.get(i));\n        }\n        Collections.sort(sorted, new\
    \ Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ a, Long b) {\n                int a_ones = ones(a);\n                int b_ones\
    \ = ones(b);\n                if (a_ones == b_ones) {\n                    return\
    \ (int) (a - b);\n                } else {\n                    return a_ones\
    \ - b_ones;\n                }\n            }\n        });\n        return sorted;",
  "        Collections.sort(arr, (a, b) -> {\n            String aa = Long.toBinaryString(a),\
    \ bb = Long.toBinaryString(b);\n            return aa.chars().filter(x -> x ==\
    \ '1').count() == bb.chars().filter(x -> x == '1').count() ?\n               \
    \ Long.compare(a, b) :\n                Integer.compare(aa.chars().filter(x ->\
    \ x == '1').count(), bb.chars().filter(x -> x == '1').count());\n        });\n\
    \        return arr;", "        Collections.sort(arr, (a, b) -> {\n          \
    \  long a1 = a, b1 = b;\n            if (a1 < 0) {\n                a1 = -a1;\n\
    \            }\n            if (b1 < 0) {\n                b1 = -b1;\n       \
    \     }\n            return Long.bitCount(a1) == Long.bitCount(b1) ? Long.compare(a,\
    \ b) : Integer.compare(Long.bitCount(a1), Long.bitCount(b1));\n        });\n \
    \       return arr;", "        ArrayList<Pair<Long, Integer>> pairs = new ArrayList<>();\n\
    \        for (Long l : arr) {\n            pairs.add(new Pair<>(l, countOnes(l)));\n\
    \        }\n        //pairs.sort((p1, p2) -> p1.getValue0().compareTo(p2.getValue0()));\n\
    \        pairs.sort((p1, p2) -> p1.getValue1().compareTo(p2.getValue1()));\n \
    \       ArrayList<Long> sorted = new ArrayList<>();\n        for (Pair<Long, Integer>\
    \ p : pairs) {\n            sorted.add(p.getValue0());\n        }\n        return\
    \ sorted;", "        ArrayList<Long> copy = (ArrayList<Long>)arr.clone();\n  \
    \      Collections.sort(copy, (Long l1, Long l2) -> {\n            int i1 = getOnes(l1);\n\
    \            int i2 = getOnes(l2);\n            if (i1 < i2) {\n             \
    \   return -1;\n            } else if (i1 > i2) {\n                return 1;\n\
    \            } else {\n                if (l1 < l2) {\n                    return\
    \ -1;\n                } else if (l1 > l2) {\n                    return 1;\n\
    \                } else {\n                    return 0;\n                }\n\
    \            }\n        });\n        return copy;", "        int len = arr.size();\n\
    \        boolean[] oneIndices = new boolean[len];\n        boolean[] zeroIndices\
    \ = new boolean[len];\n        // First pass: sort by number of ones in binary\n\
    \        long[] indices = new long[len];\n        int index = 0;\n        for\
    \ (long i : arr) {\n            long numOnes = Long.bitCount(i);\n           \
    \ // If both zero and one indices exist, insert at the first non-zero index\n\
    \            if (zeroIndices[index] && oneIndices[index]) {\n                for\
    \ (int k = 0; k < len; k++) {\n                    if (!zeroIndices[k] && !oneIndices[k])\
    \ {\n                        index = k;\n                        break;\n    \
    \                }\n                }\n            }\n            // If one indices\
    \ exist, skip it\n            if (oneIndices[index]) {\n                for (int\
    \ k = index + 1; k < len; k++) {\n                    if (!oneIndices[k]) {\n\
    \                        index = k;\n                        break;\n        \
    \            }\n                }\n            }\n            // If zero indices\
    \ exist, skip it\n            if (zeroIndices[index]) {\n                for (int\
    \ k = index + 1; k < len; k++) {\n                    if (!zeroIndices[k]) {\n\
    \                        index = k;\n                        break;\n        \
    \            }\n                }\n            }\n            indices[index] =\
    \ i;\n            if (numOnes == 0) {\n                zeroIndices[index] = true;\n\
    \            } else {\n                oneIndices[index] = true;\n           \
    \ }\n            // Go to next index\n            index++;\n        }\n      \
    \  // Second pass: sort by decimal value\n        // Sort zeros and ones separately\
    \ first\n        long[] zeros = new long[len];\n        long[] ones = new long[len];\n\
    \        int zerosCount = 0;\n        int onesCount = 0;\n        for (int i =\
    \ 0; i < len; i++) {\n            if (zeroIndices[i]) {\n                zeros[zerosCount]\
    \ = indices[i];\n                zerosCount++;\n            } else if (oneIndices[i])\
    \ {\n                ones[onesCount] = indices", "        ArrayList<Long> sortedArray\
    \ = new ArrayList<Long>();\n        HashMap<Long, Integer> hash = new HashMap<Long,\
    \ Integer>();\n        for (int i = 0; i < arr.size(); i++) {\n            String\
    \ binaryString = Long.toBinaryString(arr.get(i));\n            int binaryCount\
    \ = 0;\n            for (int j = 0; j < binaryString.length(); j++) {\n      \
    \          char ch = binaryString.charAt(j);\n                if (ch == '1') {\n\
    \                    binaryCount++;\n                }\n            }\n      \
    \      hash.put(arr.get(i), binaryCount);\n        }\n        Collections.sort(arr,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ o1, Long o2) {\n                int one = hash.get(o1);\n                int\
    \ two = hash.get(o2);\n                return one == two ? o1.compareTo(o2) :\
    \ one - two;\n            }\n        });\n        return arr;", "        Collections.sort(arr,\
    \ new Comparator<Long>() {\n            @Override\n            public int compare(Long\
    \ n1, Long n2) {\n                int cmp = Long.bitCount(n1) - Long.bitCount(n2);\n\
    \                if (cmp == 0) {\n                    return n1.compareTo(n2);\n\
    \                }\n                return cmp;\n            }\n        });\n\
    \        return arr;", "      ArrayList<Long> l = new ArrayList<Long>();\n   \
    \   ArrayList<Long> r = new ArrayList<Long>();\n      ArrayList<Long> n = new\
    \ ArrayList<Long>();\n      for (long i : arr) {\n        if (i < 0) {\n     \
    \     l.add(i);\n        } else if (i > 0) {\n          r.add(i);\n        } else\
    \ {\n          n.add(i);\n        }\n      }\n      Collections.sort(l);\n   \
    \   Collections.sort(r);\n      l.addAll(n);\n      l.addAll(r);\n      Collections.reverse(l);\n\
    \      return l;"]
stop_tokens:
- "\n    }\n"
