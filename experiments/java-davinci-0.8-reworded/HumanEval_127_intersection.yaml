name: HumanEval_127_intersection
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // You are given two intervals,\n    // where each interval\
  \ is a pair of integers. For example, interval = (start, end) = (1, 2).\n    //\
  \ The given intervals are closed which means that the interval (start, end)\n  \
  \  // includes both start and end.\n    // For each given interval, it is assumed\
  \ that its start is less or equal its end.\n    // Your task is to determine whether\
  \ the length of intersection of these two \n    // intervals is a prime number.\n\
  \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  \
  \  // which its length is 1, which not a prime number.\n    // If the length of\
  \ the intersection is a prime number, return \"YES\",\n    // otherwise, return\
  \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    // [input/output]\
  \ samples:\n    // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l, 3l)))\n\
  \    // (\"NO\")\n    // >>> intersection((Pair.with(-1l, 1l)), (Pair.with(0l, 4l)))\n\
  \    // (\"NO\")\n    // >>> intersection((Pair.with(-3l, -1l)), (Pair.with(-5l,\
  \ 5l)))\n    // (\"YES\")\n    public static String intersection(Pair<Long, Long>\
  \ interval1, Pair<Long, Long> interval2) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(intersection((Pair.with(1l,\
  \ 2l)), (Pair.with(2l, 3l))).equals((\"NO\")));\n    assert(intersection((Pair.with(-1l,\
  \ 1l)), (Pair.with(0l, 4l))).equals((\"NO\")));\n    assert(intersection((Pair.with(-3l,\
  \ -1l)), (Pair.with(-5l, 5l))).equals((\"YES\")));\n    assert(intersection((Pair.with(-2l,\
  \ 2l)), (Pair.with(-4l, 0l))).equals((\"YES\")));\n    assert(intersection((Pair.with(-11l,\
  \ 2l)), (Pair.with(-1l, -1l))).equals((\"NO\")));\n    assert(intersection((Pair.with(1l,\
  \ 2l)), (Pair.with(3l, 5l))).equals((\"NO\")));\n    assert(intersection((Pair.with(1l,\
  \ 2l)), (Pair.with(1l, 2l))).equals((\"NO\")));\n    assert(intersection((Pair.with(-2l,\
  \ -2l)), (Pair.with(-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
completions: ["        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start <= end) {\n            long length = end - start + 1;\n   \
    \         return BigInteger.valueOf(length).isProbablePrime(100) ? \"YES\" : \"\
    NO\";\n        }\n        return \"NO\";", "      Long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n      Long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \      if (start > end) return \"NO\";\n      if (isPrime(end - start + 1)) return\
    \ \"YES\";\n      return \"NO\";", "        Pair<Long, Long> intersection = interval1.intersect(interval2);\n\
    \        Long start = intersection.getValue0();\n        Long end = intersection.getValue1();\n\
    \        if(start == null || end == null) {\n            return \"NO\";\n    \
    \    }\n        return (end - start) > 1 ? \"NO\" : \"YES\";", "        long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        long end\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        if (start\
    \ >= end) return \"NO\";\n        if (isPrime(end - start)) return \"YES\";\n\
    \        return \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long diff = end - start;\n        if (diff\
    \ < 0) {\n            return \"NO\";\n        }\n        return BigInteger.valueOf(diff).isProbablePrime(100)\
    \ ? \"YES\" : \"NO\";", "        // Write your code here\n        return \"\";",
  "        // write your code here.\n        // If the two intervals don't intersect,\
    \ return \"NO\".\n        if (interval1.getValue0() > interval2.getValue1() ||\
    \ interval2.getValue0() > interval1.getValue1()) {\n            return \"NO\"\
    ;\n        }\n        // determine lower and upper bound.\n        long lhs =\
    \ Math.max(interval1.getValue0(), interval2.getValue0());\n        long rhs =\
    \ Math.min(interval1.getValue1(), interval2.getValue1());\n        // determine\
    \ length of intersection.\n        long length = Math.abs(rhs - lhs) + 1;\n  \
    \      // if length is 1, then not a prime.\n        if (length == 1) {\n    \
    \        return \"NO\";\n        }\n        // if length is 2, then is a prime.\n\
    \        if (length == 2) {\n            return \"YES\";\n        }\n        //\
    \ if length is greater than 2, determine if prime or not.\n        boolean prime\
    \ = true;\n        for (long i = 2; i <= Math.sqrt(length); i++) {\n         \
    \   if (length % i == 0) {\n                prime = false;\n                break;\n\
    \            }\n        }\n        return prime ? \"YES\" : \"NO\";", "      \
    \  long start1 = interval1.getValue0();\n        long end1 = interval1.getValue1();\n\
    \        long start2 = interval2.getValue0();\n        long end2 = interval2.getValue1();\n\
    \        long start = Math.max(start1, start2);\n        long end = Math.min(end1,\
    \ end2);\n        if (start >= end) {\n            return \"NO\";\n        }\n\
    \        long length = end - start;\n        // prime numbers > 2 are odd\n  \
    \      if (length % 2 == 0) {\n            return \"NO\";\n        }\n       \
    \ // if (length == 1) {\n        //     return \"YES\";\n        // }\n      \
    \  boolean isPrime = true;\n        for (long i = 3; i <= Math.sqrt(length); i\
    \ += 2) {\n            if (length % i == 0) {\n                isPrime = false;\n\
    \                break;\n            }\n        }\n        return isPrime ? \"\
    YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        return start <= end && Math.abs(end - start) + 1 == isPrime(Math.abs(end\
    \ - start) + 1) ? \"YES\" : \"NO\";", "        Long first = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        Long second = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long distance = second - first;\n        if\
    \ (distance <= 0l) return \"NO\";\n        for (long i = 2l; i < distance; i++)\
    \ {\n            if (distance % i == 0) return \"NO\";\n        }\n        return\
    \ \"YES\";", "        // Write your code here\n        return \"\";", "      \
    \  long start = Math.max(interval1.getValue0(), interval2.getValue0());\n    \
    \    long end = Math.min(interval1.getValue1(), interval2.getValue1());\n    \
    \    long length = end - start + 1;\n        return isPrime(length) ? \"YES\"\
    \ : \"NO\";", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long diff = end - start;\n        if (diff <= 0) return \"NO\";\n   \
    \     else {\n            return BigInteger.valueOf(diff).isProbablePrime(10)\
    \ ? \"YES\" : \"NO\";\n        }", "        long start1 = interval1.getValue0();\n\
    \        long end1 = interval1.getValue1();\n        long start2 = interval2.getValue0();\n\
    \        long end2 = interval2.getValue1();\n        long maxStart = Math.max(start1,\
    \ start2);\n        long minEnd = Math.min(end1, end2);\n        long length;\n\
    \        if (maxStart > minEnd) {\n            length = 0;\n        } else {\n\
    \            length = minEnd - maxStart + 1;\n        }\n        if (isPrime(length))\
    \ {\n            return \"YES\";\n        } else {\n            return \"NO\"\
    ;\n        }", "        long start1 = interval1.getValue0();\n        long end1\
    \ = interval1.getValue1();\n        long start2 = interval2.getValue0();\n   \
    \     long end2 = interval2.getValue1();\n        long start = Math.max(start1,\
    \ start2);\n        long end = Math.min(end1, end2);\n        if (start > end)\
    \ return \"NO\";\n        long diff = end - start + 1;\n        if (diff < 2)\
    \ return \"NO\";\n        return isPrime(diff) ? \"YES\" : \"NO\";", "       \
    \ long a = interval1.getValue0();\n        long b = interval1.getValue1();\n \
    \       long c = interval2.getValue0();\n        long d = interval2.getValue1();\n\
    \        long from = a > c ? a : c;\n        long to = b < d ? b : d;\n      \
    \  if (from > to) return \"NO\";\n        else return isPrime(to - from + 1) ?\
    \ \"YES\" : \"NO\";", "        long left = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long right = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (left > right) {\n            return \"NO\";\n        }\n        return\
    \ isPrime(right - left + 1) ? \"YES\" : \"NO\";", "        long lowerBound = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long upperBound = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (lowerBound > upperBound) {\n          \
    \  return \"NO\";\n        }\n        return new BigInteger(Long.toString(upperBound\
    \ - lowerBound + 1)).isProbablePrime(1) ? \"YES\" : \"NO\";", "        Long resIntervalStart\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        Long resIntervalEnd\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        Long resIntervalLength\
    \ = resIntervalEnd - resIntervalStart + 1;\n        if (resIntervalLength < 0)\
    \ {\n            return \"NO\";\n        }\n        boolean isPrime = true;\n\
    \        for (Long i = 2l; i < resIntervalLength / 2; i++) {\n            if (resIntervalLength\
    \ % i == 0) {\n                isPrime = false;\n                break;\n    \
    \        }\n        }\n        return isPrime ? \"YES\" : \"NO\";", "        long\
    \ start = Math.max(interval1.getValue0(), interval2.getValue0());\n        long\
    \ end = Math.min(interval1.getValue1(), interval2.getValue1());\n        if (start\
    \ <= end) {\n            for (long i = 2; i <= end / 2; i++) {\n             \
    \   if (end % i == 0) {\n                    return \"NO\";\n                }\n\
    \            }\n            return \"YES\";\n        }\n        return \"NO\";",
  "        // Write your code here!\n        return null;", "        if(interval1.getValue0()\
    \ <= interval2.getValue0() && interval2.getValue0() <= interval1.getValue1())\
    \ {\n            if(interval1.getValue1() <= interval2.getValue1()) {\n      \
    \          long diff = interval1.getValue1() - interval2.getValue0();\n      \
    \          return isPrime(diff) ? \"YES\" : \"NO\";\n            } else {\n  \
    \              long diff = interval2.getValue1() - interval2.getValue0();\n  \
    \              return isPrime(diff) ? \"YES\" : \"NO\";\n            }\n     \
    \   } else if(interval2.getValue0() <= interval1.getValue0() && interval1.getValue0()\
    \ <= interval2.getValue1()) {\n            if(interval2.getValue1() <= interval1.getValue1())\
    \ {\n                long diff = interval2.getValue1() - interval1.getValue0();\n\
    \                return isPrime(diff) ? \"YES\" : \"NO\";\n            } else\
    \ {\n                long diff = interval1.getValue1() - interval1.getValue0();\n\
    \                return isPrime(diff) ? \"YES\" : \"NO\";\n            }\n   \
    \     } else {\n            return \"NO\";\n        }", "        long low = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long high = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (low > high) return \"NO\";\n        long\
    \ diff = high - low + 1;\n        if (diff <= 1) return \"NO\";\n        long\
    \ factors = 0;\n        for (long i = 1; i <= diff; i++) {\n            if (diff\
    \ % i == 0) factors++;\n        }\n        return factors > 2 ? \"NO\" : \"YES\"\
    ;", "        if(interval1.getValue0() > interval1.getValue1() || interval2.getValue0()\
    \ > interval2.getValue1())\n            return \"interval malformed\";\n     \
    \   long start = Math.max(interval1.getValue0(), interval2.getValue0());\n   \
    \     long end = Math.min(interval1.getValue1(), interval2.getValue1());\n   \
    \     long i = (end - start) + 1;\n        if(i <= 0) return \"NO\";\n       \
    \ return isPrime(i) ? \"YES\" : \"NO\";", "        // Write your code here\n \
    \       // To print results to the standard output you can use System.out.println()\n\
    \        // Example: System.out.println(\"Hello world!\");\n        Long a1 =\
    \ interval1.getValue0();\n        Long a2 = interval1.getValue1();\n        Long\
    \ b1 = interval2.getValue0();\n        Long b2 = interval2.getValue1();\n    \
    \    Long x1 = Math.max(a1, b1);\n        Long x2 = Math.min(a2, b2);\n      \
    \  Long l = x2 - x1 + 1;\n        if (x1 > x2) {\n            return \"NO\";\n\
    \        }\n        for (int i = 2; i < l; i++) {\n            if (l % i == 0)\
    \ {\n                return \"NO\";\n            }\n        }\n        return\
    \ \"YES\";", "        long l = 0;\n        long r = 0;\n        if (interval1.getValue0()\
    \ > interval2.getValue0()) {\n            l = interval1.getValue0();\n       \
    \ } else {\n            l = interval2.getValue0();\n        }\n        if (interval1.getValue1()\
    \ < interval2.getValue1()) {\n            r = interval1.getValue1();\n       \
    \ } else {\n            r = interval2.getValue1();\n        }\n        long length\
    \ = (r - l + 1);\n        if (length < 0) {\n            return \"NO\";\n    \
    \    }\n        if (length == 1) {\n            return \"NO\";\n        }\n  \
    \      for (long i = 2; i <= Math.sqrt(length); i++) {\n            if (length\
    \ % i == 0) {\n                return \"NO\";\n            }\n        }\n    \
    \    return \"YES\";", "      long from = max(interval1.getValue0(), interval2.getValue0());\n\
    \      long to = min(interval1.getValue1(), interval2.getValue1());\n      long\
    \ intervalLen = to - from + 1;\n      if (intervalLen < 1) return \"NO\";\n  \
    \    return isPrime(intervalLen) ? \"YES\" : \"NO\";", "        BigInteger start\
    \ = BigInteger.valueOf(Math.max(interval1.getValue0(), interval2.getValue0()));\n\
    \        BigInteger end = BigInteger.valueOf(Math.min(interval1.getValue1(), interval2.getValue1()));\n\
    \        if (start.compareTo(end) >= 0) {\n            return \"NO\";\n      \
    \  }\n        return isPrime(end.subtract(start).add(BigInteger.ONE)) ? \"YES\"\
    \ : \"NO\";", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long intervalLength = end - start + 1;\n        if (intervalLength <\
    \ 1) {\n            return \"NO\";\n        }\n        boolean isPrime = true;\n\
    \        for (long i = 2; i <= intervalLength / 2; i++) {\n            if (intervalLength\
    \ % i == 0) {\n                isPrime = false;\n                break;\n    \
    \        }\n        }\n        return isPrime ? \"YES\" : \"NO\";", "        //\
    \ your code here\n        return \"\";", "        // your code goes here\n   \
    \     long min = Math.max(interval1.getValue0(), interval2.getValue0());\n   \
    \     long max = Math.min(interval1.getValue1(), interval2.getValue1());\n   \
    \     long n = max - min + 1;\n        boolean isPrime = true;\n        if (n\
    \ <= 1) {\n            isPrime = false;\n        } else {\n            for (long\
    \ i = 2; i < n; i++) {\n                if (n % i == 0) {\n                  \
    \  isPrime = false;\n                    break;\n                }\n         \
    \   }\n        }\n        return isPrime ? \"YES\" : \"NO\";", "        // initial\
    \ check\n        if (interval1.getValue0() > interval1.getValue1() || interval2.getValue0()\
    \ > interval2.getValue1())\n            return \"NO\";\n        // check intersection\n\
    \        if (interval1.getValue1() < interval2.getValue0() || interval2.getValue1()\
    \ < interval1.getValue0())\n            return \"NO\";\n        // get intersection\n\
    \        long start, end;\n        start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        end = Math.min(interval1.getValue1(), interval2.getValue1());\n     \
    \   // length is a prime number?\n        long length = end - start + 1;\n   \
    \     if (isPrime(length))\n            return \"YES\";\n        else\n      \
    \      return \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long diff = end - start;\n        return isPrime(diff)\
    \ ? \"YES\" : \"NO\";", "        long s = interval1.getValue0();\n        long\
    \ e = interval1.getValue1();\n        long s2 = interval2.getValue0();\n     \
    \   long e2 = interval2.getValue1();\n        long start = Math.max(s, s2);\n\
    \        long end = Math.min(e, e2);\n        if (start > end) return \"NO\";\n\
    \        long len = end - start + 1;\n        for (long i = 2; i < len; i++) {\n\
    \            if (len % i == 0) return \"NO\";\n        }\n        return \"YES\"\
    ;", "        Long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        Long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        Long len = end - start + 1;\n        if (len < 1) {\n            return\
    \ \"NO\";\n        }\n        if (isPrime(len)) {\n            return \"YES\"\
    ;\n        }\n        return \"NO\";", "        // your code goes here\n     \
    \   long a = interval1.getValue0();\n        long b = interval1.getValue1();\n\
    \        long c = interval2.getValue0();\n        long d = interval2.getValue1();\n\
    \        long start = Math.max(a, c);\n        long end = Math.min(b, d);\n  \
    \      if (a < b && c < d && end - start > 0) {\n            BigInteger length\
    \ = BigInteger.valueOf(end - start);\n            return length.isProbablePrime(5)\
    \ ? \"YES\" : \"NO\";\n        }\n        return \"NO\";", "        if (interval1.getValue0()\
    \ > interval1.getValue1()) {\n            Pair<Long, Long> tmp = interval1;\n\
    \            interval1 = interval2;\n            interval2 = tmp;\n        }\n\
    \        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        // 0, 1 are not prime numbers\n        if (start < 2 || end < 2) {\n\
    \            return \"NO\";\n        }\n        long len = end - start + 1;\n\
    \        if (len < 2) {\n            return \"NO\";\n        }\n        int sqrtLen\
    \ = (int) Math.sqrt(len);\n        for (int i = 2; i <= sqrtLen; i++) {\n    \
    \        if (len % i == 0) {\n                return \"NO\";\n            }\n\
    \        }\n        return \"YES\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (start > end) {\n            return \"NO\"\
    ;\n        }\n        long length = end - start + 1;\n        for (long i = 2;\
    \ i <= Math.sqrt(length); i++) {\n            if (length % i == 0) {\n       \
    \         return \"NO\";\n            }\n        }\n        return \"YES\";",
  "        // Your code here\n        if(interval1.equals(interval2)) return \"YES\"\
    ;\n        List<Long> list = Arrays.asList(interval1.getValue0(), interval1.getValue1(),\
    \ interval2.getValue0(), interval2.getValue1());\n        Collections.sort(list);\n\
    \        long start = list.get(1);\n        long end = list.get(2);\n        boolean\
    \ isPrime = true;\n        for(long i = start; i < end; i++) {\n            if(i\
    \ == start || i == end) continue;\n            isPrime = false;\n            break;\n\
    \        }\n        return isPrime ? \"YES\" : \"NO\";", "        // Write your\
    \ code here\n        return null;", "        // your code goes here\n        long\
    \ start = Math.max(interval1.getValue0(), interval2.getValue0());\n        long\
    \ end = Math.min(interval1.getValue1(), interval2.getValue1());\n        if (start\
    \ > end) {\n            return \"NO\";\n        }\n        if (end-start < 2)\
    \ {\n            return \"YES\";\n        }\n        for (long i = 2; i < (end-start);\
    \ i++) {\n            if ((end-start) % i == 0) {\n                return \"NO\"\
    ;\n            }\n        }\n        return \"YES\";", "        if(interval1.getValue0()\
    \ > interval1.getValue1()\n            || interval2.getValue0() > interval2.getValue1())\
    \ {\n            throw new IllegalArgumentException(\"interval end should be greater\
    \ or equal than start.\");\n        }\n        Long lowerBound = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        Long upperBound = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if(lowerBound > upperBound) {\n           \
    \ return \"NO\";\n        }\n        BigInteger difference = BigInteger.valueOf(upperBound\
    \ - lowerBound);\n        return difference.isProbablePrime(1000) ? \"YES\" :\
    \ \"NO\";", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        long\
    \ length = end - start + 1;\n        if (length == 1) {\n            return \"\
    NO\";\n        }\n        if (length == 2) {\n            return \"YES\";\n  \
    \      }\n        for (long i = 2; i <= Math.sqrt(length); i++) {\n          \
    \  if (length % i == 0) {\n                return \"NO\";\n            }\n   \
    \     }\n        return \"YES\";", '        return "NO";', "        // Implemented\
    \ with conditional statements rather than functions\n        // because the problem\
    \ description explicitly states that `start` <= `end`\n        // This can also\
    \ be implemented using streams.\n        // But again, since `start` <= `end`,\
    \ it is easier to use conditions.\n        // Also, this uses the \"static import\"\
    \ approach for easy utility methods\n        // for the `Pair` class.\n      \
    \  // Note: This can be easily modified to return true or false instead of \"\
    YES\" or \"NO\"\n        if(interval1.getValue0() <= interval2.getValue0() &&\
    \ interval2.getValue0() <= interval1.getValue1()) {\n            // When `interval2.start`\
    \ is in the range of `interval1`\n            if(interval1.getValue1() <= interval2.getValue1())\
    \ {\n                // When `interval1.end` is less than `interval2.end`\n  \
    \              return isPrime(interval1.getValue1() - interval2.getValue0() +\
    \ 1) ? \"YES\" : \"NO\";\n            } else {\n                // When `interval1.end`\
    \ is greater than `interval2.end`\n                return isPrime(interval2.getValue1()\
    \ - interval2.getValue0() + 1) ? \"YES\" : \"NO\";\n            }\n        } else\
    \ if(interval2.getValue0() <= interval1.getValue0() && interval1.getValue0() <=\
    \ interval2.getValue1()) {\n            // When `interval1.start` is in the range\
    \ of `interval2`\n            if(interval2.getValue1() <= interval1.getValue1())\
    \ {\n                // When `interval2.end` is less than `interval1.end`\n  \
    \              return isPrime(interval2.getValue1() - interval1.getValue0() +\
    \ 1) ? \"YES\" : \"NO\";\n            } else {\n                // When `interval2.end`\
    \ is greater than `interval1.end`\n                return isPrime(interval1.getValue1()\
    \ - interval1.getValue0() + 1) ? \"YES\" : \"NO\";\n            }\n        } else\
    \ {\n           ", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long length = end - start + 1;\n        if (length < 0) return \"NO\"\
    ;\n        for (long n = 2; n < length; n++) {\n            if (length % n ==\
    \ 0) return \"NO\";\n        }\n        return \"YES\";", "        Long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        Long end\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        if (start\
    \ > end) return \"NO\";\n        int length = (int)(end - start + 1);\n      \
    \  return isPrime(length) ? \"YES\" : \"NO\";", "        if (interval1.getValue0()\
    \ >= interval2.getValue1() || interval2.getValue0() >= interval1.getValue1())\
    \ {\n            return \"NO\";\n        }\n        long start = interval1.getValue0()\
    \ > interval2.getValue0() ? interval1.getValue0() : interval2.getValue0();\n \
    \       long end = interval1.getValue1() < interval2.getValue1() ? interval1.getValue1()\
    \ : interval2.getValue1();\n        return BigInteger.valueOf(end - start + 1).isProbablePrime(10)\
    \ ? \"YES\" : \"NO\";", "        //build the intervals, sorted by low point\n\
    \        ArrayList<Pair<Long,Long>> intervalList = new ArrayList<Pair<Long,Long>>();\n\
    \        intervalList.add(interval1);\n        intervalList.add(interval2);\n\
    \        Collections.sort(intervalList, (c1, c2) -> c1.getValue0().compareTo(c2.getValue0()));\n\
    \        //check for intersection\n        if(intervalList.get(0).getValue1()\
    \ < intervalList.get(1).getValue0()) {\n            return \"NO\";\n        }\n\
    \        //build intersection\n        Pair<Long,Long> interval = Pair.with(intervalList.get(0).getValue0(),\
    \ intervalList.get(1).getValue1());\n        if(interval.getValue0() > interval.getValue1())\
    \ {\n            return \"NO\";\n        }\n        //check for primality\n  \
    \      //O(sqrt(n))\n        for(long i = 2; i <= Math.sqrt(interval.getValue1()\
    \ - interval.getValue0()); i++) {\n            if((interval.getValue1() - interval.getValue0())\
    \ % i == 0) {\n                return \"NO\";\n            }\n        }\n    \
    \    return \"YES\";", "        long start1 = interval1.getValue0();\n       \
    \ long end1 = interval1.getValue1();\n        long start2 = interval2.getValue0();\n\
    \        long end2 = interval2.getValue1();\n        long start = Math.max(start1,\
    \ start2);\n        long end = Math.min(end1, end2);\n        if (start > end)\
    \ {\n            return \"NO\";\n        }\n        long intersection = end -\
    \ start + 1;\n        return BigInteger.valueOf(intersection).isProbablePrime(20)\
    \ ? \"YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (start >= end) {\n            return \"\
    NO\";\n        }\n        if (isPrime(end - start)) {\n            return \"YES\"\
    ;\n        }\n        return \"NO\";", "        long max_start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long min_end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long diff = min_end - max_start;\n        if\
    \ (diff < 0) {\n            return \"NO\";\n        }\n        // diff is the\
    \ intersection\n        boolean prime = true;\n        if (diff == 1) {\n    \
    \        return \"YES\";\n        }\n        for (long n = 2; n <= Math.sqrt(diff);\
    \ n++) {\n            if (diff % n == 0) {\n                prime = false;\n \
    \               break;\n            }\n        }\n        if (prime) {\n     \
    \       return \"YES\";\n        }\n        return \"NO\";", "        long m =\
    \ Long.max(interval1.getValue0(), interval2.getValue0());\n        long n = Long.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (m > n) {\n            return \"NO\";\n\
    \        }\n        long v = n - m + 1;\n        return v == 1 || (v != 2 && v\
    \ % 2 != 0) ? \"YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long result = end - start + 1;\n        if\
    \ (result <= 0) return \"NO\";\n        return isPrime(result) ? \"YES\" : \"\
    NO\";", "        // Returns the length of intersection of the two intervals.\n\
    \        long start1 = interval1.getValue0();\n        long end1 = interval1.getValue1();\n\
    \        long start2 = interval2.getValue0();\n        long end2 = interval2.getValue1();\n\
    \        long intersectionStart = Math.max(start1, start2);\n        long intersectionEnd\
    \ = Math.min(end1, end2);\n        long intersectionLength = intersectionEnd -\
    \ intersectionStart + 1;\n        if (intersectionLength <= 0) {\n           \
    \ return \"NO\";\n        }\n        BigInteger intersectionLengthBigInteger =\
    \ BigInteger.valueOf(intersectionLength);\n        boolean result = intersectionLengthBigInteger.isProbablePrime(1);\n\
    \        if (result) {\n            return \"YES\";\n        } else {\n      \
    \      return \"NO\";\n        }", "        long startInterval1 = interval1.getValue0();\n\
    \        long endInterval1 = interval1.getValue1();\n        long startInterval2\
    \ = interval2.getValue0();\n        long endInterval2 = interval2.getValue1();\n\
    \        if (startInterval1 > endInterval1 || startInterval2 > endInterval2) {\n\
    \            throw new RuntimeException(\"Invalid interval\");\n        }\n  \
    \      long start = Math.max(startInterval1, startInterval2);\n        long end\
    \ = Math.min(endInterval1, endInterval2);\n        if (start > end) {\n      \
    \      return \"NO\";\n        }\n        long diff = end - start + 1;\n     \
    \   if (diff == 1 || diff == 2) {\n            return \"YES\";\n        }\n  \
    \      if (diff % 2 == 0) {\n            return \"NO\";\n        }\n        if\
    \ (diff == 3) {\n            return \"YES\";\n        }\n        for (long i =\
    \ 3; i <= Math.sqrt(diff); i += 2) {\n            if (diff % i == 0) {\n     \
    \           return \"NO\";\n            }\n        }\n        return \"YES\";",
  "        long startIntersection = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long endIntersection = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long lengthIntersection = endIntersection - startIntersection + 1;\n\
    \        if (lengthIntersection < 0) {\n            return \"NO\";\n        }\n\
    \        if (lengthIntersection == 1) {\n            return \"NO\";\n        }\n\
    \        if (lengthIntersection == 2) {\n            return \"YES\";\n       \
    \ }\n        if (lengthIntersection % 2 == 0) {\n            return \"NO\";\n\
    \        }\n        for (long i = 3; i * i <= lengthIntersection; i += 2) {\n\
    \            if (lengthIntersection % i == 0) {\n                return \"NO\"\
    ;\n            }\n        }\n        return \"YES\";", "        long lowerLimit\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        long upperLimit\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        if (lowerLimit\
    \ > upperLimit) {\n            return \"NO\";\n        }\n        return (isPrime(upperLimit\
    \ - lowerLimit + 1)) ? \"YES\" : \"NO\";", "        List<Long> a = Arrays.asList(interval1.getValue0(),\
    \ interval1.getValue1());\n        List<Long> b = Arrays.asList(interval2.getValue0(),\
    \ interval2.getValue1());\n        Collections.sort(a);\n        Collections.sort(b);\n\
    \        if (a.get(0) > b.get(1) || b.get(0) > a.get(1)) {\n            return\
    \ \"NO\";\n        }\n        long k = Math.max(a.get(0), b.get(0));\n       \
    \ long j = Math.min(a.get(1), b.get(1));\n        long diff = j - k + 1;\n   \
    \     System.out.println(diff);\n        return isPrime(diff) ? \"YES\" : \"NO\"\
    ;", "        boolean isPrime = true;\n        Long smallerStart = interval1.getValue0()\
    \ > interval2.getValue0() ? interval1.getValue0() : interval2.getValue0();\n \
    \       Long biggerEnd = interval1.getValue1() < interval2.getValue1() ? interval1.getValue1()\
    \ : interval2.getValue1();\n        if (smallerStart <= biggerEnd) {\n       \
    \     Long diff = biggerEnd - smallerStart;\n            for (int i = 2; i < diff;\
    \ i++) {\n                if (diff % i == 0) {\n                    isPrime =\
    \ false;\n                    break;\n                }\n            }\n     \
    \   } else {\n            isPrime = false;\n        }\n        return isPrime\
    \ ? \"YES\" : \"NO\";", "        // if there is no intersection, return \"NO\"\
    \n        if (interval1.getValue0() > interval2.getValue1() || interval2.getValue0()\
    \ > interval1.getValue1()) {\n            return \"NO\";\n        }\n        //\
    \ find the start and end of the intersection\n        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        // if the length of the intersection is a prime\
    \ number, return \"YES\", otherwise, return \"NO\"\n        if (isPrime(end -\
    \ start + 1)) {\n            return \"YES\";\n        } else {\n            return\
    \ \"NO\";\n        }", "        String ans = \"\";\n        long x_start = interval1.getValue0();\n\
    \        long x_end = interval1.getValue1();\n        long y_start = interval2.getValue0();\n\
    \        long y_end = interval2.getValue1();\n        long start = Math.max(x_start,\
    \ y_start);\n        long end = Math.min(x_end, y_end);\n        long length =\
    \ end - start;\n        if (length < 0) {\n            ans = \"NO\";\n       \
    \ } else {\n            ans = (isPrime(length)) ? \"YES\" : \"NO\";\n        }\n\
    \        return ans;", "        if (interval1.getValue0() > interval2.getValue1()\
    \ || interval2.getValue0() > interval1.getValue1()) {\n            return \"NO\"\
    ;\n        }\n        long intersectionStart = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long intersectionEnd = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (intersectionStart >= intersectionEnd) {\n\
    \            return \"NO\";\n        }\n        return isPrime(intersectionEnd\
    \ - intersectionStart + 1) ? \"YES\" : \"NO\";", "        long firstStart = interval1.getValue0();\n\
    \        long firstEnd = interval1.getValue1();\n        long secondStart = interval2.getValue0();\n\
    \        long secondEnd = interval2.getValue1();\n        long beginning = Math.max(firstStart,\
    \ secondStart);\n        long end = Math.min(firstEnd, secondEnd);\n        long\
    \ length = end - beginning;\n        if (length < 0) {\n            return \"\
    NO\";\n        }\n        return (isPrime(length)) ? \"YES\" : \"NO\";", "   \
    \     long start = Math.max(interval1.getValue0(), interval2.getValue0());\n \
    \       long end = Math.min(interval1.getValue1(), interval2.getValue1());\n \
    \       if (start > end) {\n            return \"NO\";\n        }\n        return\
    \ String.valueOf(isPrime(end - start + 1));", "        // how does one do a max\
    \ and min?\n        Long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        Long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        Long length = end - start;\n        if (length < 1) return \"NO\";\n\
    \        // isPrime()\n        if (length == 1) return \"NO\";\n        else if\
    \ (length == 2) return \"YES\";\n        else if (length == 3) return \"YES\"\
    ;\n        else if (length % 2 == 0) return \"NO\";\n        else if (length %\
    \ 3 == 0) return \"NO\";\n        else {\n            // we know all primes are\
    \ 1 mod 6\n            for (Long i = 5l; i * i <= length; i += 6) {\n        \
    \        if (length % i == 0 || length % (i + 2) == 0) {\n                   \
    \ return \"NO\";\n                }\n            }\n            return \"YES\"\
    ;\n        }", '        return "YES";', "        long start1 = interval1.getValue0();\n\
    \        long end1 = interval1.getValue1();\n        long start2 = interval2.getValue0();\n\
    \        long end2 = interval2.getValue1();\n        if (end1 < start2 || end2\
    \ < start1) return \"NO\";\n        return isPrime(Long.max(start1, start2) -\
    \ Long.min(end1, end2) + 1) ? \"YES\" : \"NO\";", "        long s = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long e = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        return isPrime(e - s + 1) ? \"YES\" : \"NO\";", '        return "";',
  '        return "";', "        if (interval1.getValue0() > interval2.getValue1()\
    \ || interval2.getValue0() > interval1.getValue1()) {\n            return \"NO\"\
    ;\n        }\n        long min = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long max = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        return isPrime(max - min + 1) ? \"YES\" : \"NO\";", "        long max\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        long min\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        return max\
    \ <= min && isPrime(min - max + 1) ? \"YES\" : \"NO\";", "        // just generate\
    \ the intersection and check if its length is prime\n        // we know that the\
    \ intersection is always smaller than both intervals\n        // so we can just\
    \ generate it\n        long first = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long second = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long length = second - first;\n        if (length < 0) {\n          \
    \  return \"NO\";\n        }\n        return isPrime(length) ? \"YES\" : \"NO\"\
    ;", '        return "";', "        Long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        Long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (start <= end) {\n            return (new\
    \ BigInteger(String.valueOf(end - start))).isProbablePrime(100) ? \"YES\" : \"\
    NO\";\n        }\n        return \"NO\";", "        // range - 0..0\n        if\
    \ (interval1.getValue0() <= interval2.getValue0() && interval2.getValue0() <=\
    \ interval1.getValue1() && interval1.getValue1() <= interval2.getValue1()) {\n\
    \            return \"NO\";\n        }\n        // range - -1..0\n        if (interval1.getValue0()\
    \ <= interval2.getValue0() && interval2.getValue0() <= interval1.getValue1() &&\
    \ interval1.getValue1() <= interval2.getValue1()) {\n            return \"NO\"\
    ;\n        }\n        // range - 0..-1\n        if (interval1.getValue0() <= interval2.getValue0()\
    \ && interval2.getValue0() <= interval1.getValue1() && interval1.getValue1() <=\
    \ interval2.getValue1()) {\n            return \"NO\";\n        }\n        //\
    \ range - -1..-1\n        if (interval1.getValue0() <= interval2.getValue0() &&\
    \ interval2.getValue0() <= interval1.getValue1() && interval1.getValue1() <= interval2.getValue1())\
    \ {\n            return \"NO\";\n        }\n        return \"NO\";", "       \
    \ long start, end;\n        if (interval1.getValue0() < interval2.getValue0())\
    \ {\n            start = interval2.getValue0();\n        } else {\n          \
    \  start = interval1.getValue0();\n        }\n        if (interval1.getValue1()\
    \ < interval2.getValue1()) {\n            end = interval1.getValue1();\n     \
    \   } else {\n            end = interval2.getValue1();\n        }\n        if\
    \ (start > end) {\n            return \"NO\";\n        }\n        int length =\
    \ (int) (end - start + 1);\n        return isPrime(length) ? \"YES\" : \"NO\";",
  '        return "";', "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        for\
    \ (long i = 2; i < end; i++) {\n            if (start % i == 0) {\n          \
    \      return \"NO\";\n            }\n        }\n        return \"YES\";", " \
    \       // test if the intervals intersect\n        // if (interval1.getValue0()\
    \ > interval2.getValue1() \n        //     || interval2.getValue0() > interval1.getValue1())\
    \ {\n        //     return \"NO\";\n        // }\n        long len = Math.abs(Math.min(interval1.getValue1(),\
    \ interval2.getValue1()) - Math.max(interval1.getValue0(), interval2.getValue0()));\n\
    \        System.out.println(len);\n        if (isPrime(len)) {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";", "        List<Long> list = new\
    \ ArrayList<>();\n        list.add(interval1.getValue0());\n        list.add(interval1.getValue1());\n\
    \        list.add(interval2.getValue0());\n        list.add(interval2.getValue1());\n\
    \        Collections.sort(list);\n        long low = list.get(1);\n        long\
    \ high = list.get(2);\n        if (high < low) {\n            return \"NO\";\n\
    \        }\n        return isPrime(high - low) ? \"YES\" : \"NO\";", "       \
    \ long maxStart = Math.max(interval1.getValue0(), interval2.getValue0());\n  \
    \      long minEnd = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long length = minEnd - maxStart;\n        return isPrime(length) ? \"\
    YES\" : \"NO\";", "        // write your code here\n        return \"\";", " \
    \       ArrayList<Long> list = new ArrayList<Long>();\n        list.add(interval1.getValue0());\n\
    \        list.add(interval1.getValue1());\n        list.add(interval2.getValue0());\n\
    \        list.add(interval2.getValue1());\n        Collections.sort(list);\n \
    \       long min = list.get(1);\n        long max = list.get(2);\n        if (min\
    \ < max) {\n            return \"YES\";\n        }\n        else {\n         \
    \   return \"NO\";\n        }", "        // write your code here\n        long\
    \ maxStart = Math.max(interval1.getValue0(), interval2.getValue0());\n       \
    \ long minEnd = Math.min(interval1.getValue1(), interval2.getValue1());\n    \
    \    return (maxStart <= minEnd && isPrime(minEnd - maxStart + 1)) ? \"YES\" :\
    \ \"NO\";", "        // make a new interval1 in case of swapping\n        Pair<Long,\
    \ Long> tmp = Pair.with(interval1.getValue0(), interval1.getValue1());\n     \
    \   if (interval1.getValue0() > interval1.getValue1()) {\n            tmp = Pair.with(interval1.getValue1(),\
    \ interval1.getValue0());\n        }\n        if (interval2.getValue0() > interval2.getValue1())\
    \ {\n            interval2 = Pair.with(interval2.getValue1(), interval2.getValue0());\n\
    \        }\n        if (tmp.getValue0() > interval2.getValue1() || tmp.getValue1()\
    \ < interval2.getValue0()) {\n            return \"NO\";\n        }\n        //\
    \ this is the length\n        long len = 0;\n        if (tmp.getValue0() >= interval2.getValue0()\
    \ && tmp.getValue1() <= interval2.getValue1()) {\n            len = tmp.getValue1()\
    \ - tmp.getValue0() + 1;\n        } else if (tmp.getValue0() >= interval2.getValue0()\
    \ && tmp.getValue1() > interval2.getValue1()) {\n            len = interval2.getValue1()\
    \ - tmp.getValue0() + 1;\n        } else if (tmp.getValue0() < interval2.getValue0()\
    \ && tmp.getValue1() <= interval2.getValue1()) {\n            len = tmp.getValue1()\
    \ - interval2.getValue0() + 1;\n        } else if (tmp.getValue0() < interval2.getValue0()\
    \ && tmp.getValue1() > interval2.getValue1()) {\n            len = interval2.getValue1()\
    \ - interval2.getValue0() + 1;\n        }\n        return (isPrime(len)) ? \"\
    YES\" : \"NO\";", "        // your code here\n        return \"\";", "       \
    \ Long l1 = interval1.getValue0();\n        Long l2 = interval1.getValue1();\n\
    \        Long r1 = interval2.getValue0();\n        Long r2 = interval2.getValue1();\n\
    \        Long l = Math.max(l1, r1);\n        Long r = Math.min(l2, r2);\n    \
    \    if (l > r) {\n            return \"NO\";\n        }\n        long d = r -\
    \ l + 1;\n        if (isPrime(d)) {\n            return \"YES\";\n        }\n\
    \        return \"NO\";", "        // Intervals are closed and sorted\n      \
    \  // If start of first is greater than end of second, they do not intersect\n\
    \        long start, end;\n        String answer = \"NO\";\n        if (interval1.getValue0()\
    \ <= interval2.getValue0()) {\n            if (interval1.getValue1() < interval2.getValue0())\
    \ {\n                return answer;\n            }\n            start = interval2.getValue0();\n\
    \            if (interval1.getValue1() < interval2.getValue1()) {\n          \
    \      end = interval1.getValue1();\n            } else {\n                end\
    \ = interval2.getValue1();\n            }\n        } else {\n            if (interval2.getValue1()\
    \ < interval1.getValue0()) {\n                return answer;\n            }\n\
    \            start = interval1.getValue0();\n            if (interval2.getValue1()\
    \ < interval1.getValue1()) {\n                end = interval2.getValue1();\n \
    \           } else {\n                end = interval1.getValue1();\n         \
    \   }\n        }\n        if (end < start) {\n            return answer;\n   \
    \     }\n        if (isPrime(end - start + 1)) {\n            answer = \"YES\"\
    ;\n        }\n        return answer;", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long length = end - start + 1;\n        if\
    \ (length < 0) {\n            return \"NO\";\n        }\n        boolean result\
    \ = isPrime(length);\n        return result ? \"YES\" : \"NO\";", "        //\
    \ Write your code here\n        Long a = interval1.getValue0();\n        Long\
    \ b = interval1.getValue1();\n        Long c = interval2.getValue0();\n      \
    \  Long d = interval2.getValue1();\n        if(c > b || a > d) return \"NO\";\n\
    \        if(c > a) a = c;\n        if(d < b) b = d;\n        if(a >= b) return\
    \ \"NO\";\n        Long len = b - a;\n        if(len == 1) return \"YES\";\n \
    \       if(len == 2) return \"NO\";\n        Long rem = len % 6;\n        if(rem\
    \ == 1 || rem == 5) return \"YES\";\n        return \"NO\";", "        long start1\
    \ = interval1.getValue0();\n        long end1 = interval1.getValue1();\n     \
    \   long start2 = interval2.getValue0();\n        long end2 = interval2.getValue1();\n\
    \        long low = Math.max(start1, start2);\n        long high = Math.min(end1,\
    \ end2);\n        if (low <= high) {\n            long diff = high - low + 1;\n\
    \            if (diff == 1) return \"NO\";\n            if (diff == 2) return\
    \ \"YES\";\n            if (diff % 2 == 0) return \"NO\";\n            long sqrt\
    \ = (long) Math.sqrt(diff);\n            for (long i = 3; i <= sqrt; i += 2) {\n\
    \                if (diff % i == 0) return \"NO\";\n            }\n          \
    \  return \"YES\";\n        }\n        return \"NO\";", "        long s1 = interval1.getValue0();\n\
    \        long e1 = interval1.getValue1();\n        long s2 = interval2.getValue0();\n\
    \        long e2 = interval2.getValue1();\n        long intersection = Math.min(e1,\
    \ e2) - Math.max(s1, s2);\n        if (intersection < 0) {\n            return\
    \ \"NO\";\n        }\n        if (isPrime(intersection)) {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";", "        // Your code here\n \
    \       return null;", "        // if interval1 doesnt intersect interval2 return\
    \ \"NO\"\n        if (interval1.getValue0() >= interval2.getValue1() || interval2.getValue0()\
    \ >= interval1.getValue1()) {\n            return \"NO\";\n        }\n       \
    \ // calculate the length of the intersection\n        long start, end;\n    \
    \    if (interval1.getValue0() > interval2.getValue0()) {\n            start =\
    \ interval1.getValue0();\n        } else {\n            start = interval2.getValue0();\n\
    \        }\n        if (interval1.getValue1() < interval2.getValue1()) {\n   \
    \         end = interval1.getValue1();\n        } else {\n            end = interval2.getValue1();\n\
    \        }\n        BigInteger length = BigInteger.valueOf(end - start);\n   \
    \     // if the length is a prime number return \"YES\"\n        if (length.isProbablePrime(100))\
    \ {\n            return \"YES\";\n        }\n        // otherwise return \"NO\"\
    \n        return \"NO\";", "        final long s1 = interval1.getValue0();\n \
    \       final long e1 = interval1.getValue1();\n        final long s2 = interval2.getValue0();\n\
    \        final long e2 = interval2.getValue1();\n        final long s = Math.max(s1,\
    \ s2);\n        final long e = Math.min(e1, e2);\n        if (s <= e) {\n    \
    \        return prime(e - s + 1) ? \"YES\" : \"NO\";\n        }\n        return\
    \ \"NO\";", "        long start1 = interval1.getValue0();\n        long end1 =\
    \ interval1.getValue1();\n        long start2 = interval2.getValue0();\n     \
    \   long end2 = interval2.getValue1();\n        long minStart = Math.max(start1,\
    \ start2);\n        long maxEnd = Math.min(end1, end2);\n        if (minStart\
    \ > maxEnd) {\n            return \"NO\";\n        }\n        long length = maxEnd\
    \ - minStart + 1;\n        if (length < 2) {\n            return \"NO\";\n   \
    \     }\n        for (long i = 2; i <= Math.sqrt(length); i++) {\n           \
    \ if (length % i == 0) {\n                return \"NO\";\n            }\n    \
    \    }\n        return \"YES\";", "        // TODO: write your code here\n   \
    \     Long left = Math.max(interval1.getValue0(), interval2.getValue0());\n  \
    \      Long right = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (left <= right) {\n            // if (left == right) {\n         \
    \   //     return \"YES\";\n            // }\n            boolean isPrime = true;\n\
    \            for (long i = 2; i < right - left + 1; i++) {\n                if\
    \ ((right - left + 1) % i == 0) {\n                    isPrime = false;\n    \
    \                break;\n                }\n            }\n            if (isPrime)\
    \ {\n                return \"YES\";\n            }\n        }\n        return\
    \ \"NO\";", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long diff = end - start;\n        if (diff < 0) {\n            return\
    \ \"NO\";\n        }\n        if (diff > 0 && BigInteger.valueOf(diff).isProbablePrime(100))\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";", "      \
    \  long intersection_length = Math.max(interval1.getValue0(), interval2.getValue0())\
    \ - Math.min(interval1.getValue1(), interval2.getValue1());\n        if (intersection_length\
    \ <= 0) return \"NO\";\n        if (isPrime(intersection_length)) return \"YES\"\
    ;\n        return \"NO\";", "        int len = (int)interval1.getValue0().longValue()\
    \ - (int)interval1.getValue1().longValue();\n        int start1 = (int)interval1.getValue0().longValue();\n\
    \        int end1 = (int)interval1.getValue1().longValue();\n        int start2\
    \ = (int)interval2.getValue0().longValue();\n        int end2 = (int)interval2.getValue1().longValue();\n\
    \        int start3 = Math.max(start1, start2);\n        int end3 = Math.min(end1,\
    \ end2);\n        int len1 = end3 - start3;\n        if (len1 < 0) {\n       \
    \     return \"NO\";\n        }\n        if (len1 == 0) {\n            return\
    \ \"YES\";\n        }\n        if (len1 == 1) {\n            return \"NO\";\n\
    \        }\n        if (len1 == 2) {\n            return \"YES\";\n        }\n\
    \        for (int i = 2; i <= len1 / 2; i++) {\n            if (len1 % i == 0)\
    \ {\n                return \"NO\";\n            }\n        }\n        return\
    \ \"YES\";", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        long\
    \ length = end - start + 1;\n        if (length <= 1) {\n            return \"\
    NO\";\n        }\n        if (isPrime(length)) {\n            return \"YES\";\n\
    \        }\n        return \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long length = end - start + 1;\n        return\
    \ (isPrime(length)) ? \"YES\" : \"NO\";", "        // Write your code here\n \
    \       // To print results to the standard output you can use System.out.println()\n\
    \        // Example: System.out.println(\"Hello world!\");\n        if (interval1.getValue0()\
    \ > interval1.getValue1() || interval2.getValue0() > interval2.getValue1()) {\n\
    \            throw new IllegalArgumentException(\"Interval end must be greater\
    \ than start\");\n        }\n        long a = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long b = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long primeLength = b - a + 1;\n        return BigInteger.valueOf(primeLength).isProbablePrime(1)\
    \ ? \"YES\" : \"NO\";", "        // merge intervals\n        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        // check if valid interval\n        if (start\
    \ <= end) {\n            // check if length is prime\n            long intervalLength\
    \ = end - start + 1;\n            if (isPrime(intervalLength)) {\n           \
    \     return \"YES\";\n            }\n        }\n        return \"NO\";", "  \
    \      // https://www.tutorialspoint.com/java/lang/number_valueof_integer_int.htm\n\
    \        // https://www.geeksforgeeks.org/primenumber-java-examples/\n       \
    \ // https://www.geeksforgeeks.org/pair-in-java/\n        // https://www.javatuples.org/\n\
    \        // https://www.javatuples.org/docs/javadoc/org/javatuples/Pair.html\n\
    \        // https://www.javatuples.org/docs/userguide/userguide.pdf\n        //\
    \ https://www.javatuples.org/\n        // https://www.geeksforgeeks.org/primenumber-java-examples/\n\
    \        // https://www.baeldung.com/java-intersection-of-two-arrays\n       \
    \ // https://www.geeksforgeeks.org/java-8-streams-filter-examples/\n        //\
    \ https://www.baeldung.com/java-math-pow\n        // https://www.programiz.com/java-programming/examples/prime-number\n\
    \        // https://www.tutorialspoint.com/java/lang/math_pow.htm\n        //\
    \ https://www.tutorialspoint.com/java/lang/math_abs.htm\n        // https://www.geeksforgeeks.org/abs-in-java/\n\
    \        // https://www.tutorialspoint.com/java/lang/math_ceil.htm\n        //\
    \ https://www.geeksforgeeks.org/java-ceil-method-examples/\n        // https://www.tutorialspoint.com/java/lang/math_min.htm\n\
    \        // https://www.geeksforgeeks.org/min-max-methods-java-util-collections/\n\
    \        // https://www.geeksforgeeks.org/comparator-interface-java/\n       \
    \ // https://www.geeksforgeeks.org/comparator-interface-java-examples/\n     \
    \   // https://www.geeksforgeeks.org/java-util-arraylist-add-method-java/\n",
  "        Long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        Long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start >= end) {\n            return \"NO\";\n        }\n        return\
    \ isPrime(end - start) ? \"YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (start >= end) {\n            return \"\
    NO\";\n        }\n        long intersize = end - start + 1;\n        return (new\
    \ BigInteger(String.valueOf(intersize)).isProbablePrime(100)) ? \"YES\" : \"NO\"\
    ;", "        // Your code here...\n        return \"NO\";", "        // Long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        // Long end\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        // if (start\
    \ > end) {\n        //     return \"NO\";\n        // }\n        // Long intersection\
    \ = end - start + 1;\n        // return isPrime(intersection) ? \"YES\" : \"NO\"\
    ;\n        return \"NO\";", "        // return \"YES\";\n        long start =\
    \ Math.max(interval1.getValue0(), interval2.getValue0());\n        long end =\
    \ Math.min(interval1.getValue1(), interval2.getValue1());\n        long length\
    \ = end - start + 1;\n        if (length <= 0) {\n            return \"NO\";\n\
    \        }\n        if (new BigInteger(Long.toString(length)).isProbablePrime(100))\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";", "      \
    \  // your code here\n        long min = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long max = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long val = max - min;\n        if (val <= 0) {\n            return \"\
    NO\";\n        }\n        if (val == 1) {\n            return \"NO\";\n      \
    \  }\n        return isPrime(val) ? \"YES\" : \"NO\";", "        Long start =\
    \ Math.max(interval1.getValue0(), interval2.getValue0());\n        Long end =\
    \ Math.min(interval1.getValue1(), interval2.getValue1());\n        Long length\
    \ = Math.max(end - start + 1, 0);\n        return isPrime(length) ? \"YES\" :\
    \ \"NO\";", '        return "";', "        List<Long> result = new ArrayList<>();\n\
    \        result.add(interval1.getValue0());\n        result.add(interval1.getValue1());\n\
    \        result.add(interval2.getValue0());\n        result.add(interval2.getValue1());\n\
    \        Collections.sort(result);\n        Long start = result.get(1);\n    \
    \    Long end = result.get(2);\n        System.out.println(start + \" \" + end);\n\
    \        return isPrime(end - start) ? \"YES\" : \"NO\";", "        Long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        Long end\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        if (start\
    \ <= end) {\n            return isPrime(end - start + 1) ? \"YES\" : \"NO\";\n\
    \        }\n        return \"NO\";", "        // write your code here\n      \
    \  Long start = Math.max(interval1.getValue0(), interval2.getValue0());\n    \
    \    Long end = Math.min(interval1.getValue1(), interval2.getValue1());\n    \
    \    if (start > end) {\n            return \"NO\";\n        }\n        if (isPrime(end\
    \ - start + 1)) {\n            return \"YES\";\n        }\n        return \"NO\"\
    ;", "        long lowerBound = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long upperBound = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (lowerBound > upperBound) {\n            return \"NO\";\n        }\n\
    \        if (lowerBound == upperBound) {\n            if (isPrime(lowerBound))\
    \ {\n                return \"YES\";\n            }\n            return \"NO\"\
    ;\n        }\n        if (isPrime(upperBound - lowerBound + 1)) {\n          \
    \  return \"YES\";\n        }\n        return \"NO\";", "        long l = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long r = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (l <= r) {\n            long len = r - l + 1;\n            if (isPrime(len))\
    \ {\n                return \"YES\";\n            }\n        }\n        return\
    \ \"NO\";", "        long a = interval1.getValue0();\n        long b = interval1.getValue1();\n\
    \        long c = interval2.getValue0();\n        long d = interval2.getValue1();\n\
    \        long x = Long.max(a, c);\n        long y = Long.min(b, d);\n        //\
    \ If the two intervals don't intersect, return \"NO\".\n        if (x > y) return\
    \ \"NO\";\n        long len = y - x + 1;\n        // If the length of the intersection\
    \ is a prime number, return \"YES\",\n        // otherwise, return \"NO\".\n \
    \       if (isPrime(len)) return \"YES\";\n        return \"NO\";", "        //\
    \ 1. create an interval that is the intersection of interval1 and interval2\n\
    \        // 2. if the interval is the empty set, return \"NO\"\n        // 3.\
    \ return \"YES\" if the length of the interval is a prime number, and \"NO\" otherwise.\n\
    \        return null;", "        List<Long> xs = new ArrayList<>();\n        List<Long>\
    \ ys = new ArrayList<>();\n        xs.add(interval1.getValue0());\n        xs.add(interval1.getValue1());\n\
    \        ys.add(interval2.getValue0());\n        ys.add(interval2.getValue1());\n\
    \        Collections.sort(xs);\n        Collections.sort(ys);\n        Long i1\
    \ = xs.get(0);\n        Long i2 = xs.get(1);\n        Long j1 = ys.get(0);\n \
    \       Long j2 = ys.get(1);\n        if (i1 > j2 || j1 > i2) {\n            return\
    \ \"NO\";\n        }\n        Long s1 = Math.max(i1, j1);\n        Long s2 = Math.min(i2,\
    \ j2);\n        long n = s2 - s1 + 1;\n        return LongStream.rangeClosed(2,\
    \ n / 2).noneMatch(i -> n % i == 0) ? \"YES\" : \"NO\";", "        long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        long end\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        long len\
    \ = Math.max(end - start + 1, 0);\n        return BigInteger.valueOf(len).isProbablePrime(10)\
    \ ? \"YES\" : \"NO\";", "        Long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        Long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        Long count = end - start + 1;\n        if (count\
    \ <= 0) {\n            return \"NO\";\n        }\n        if (count == 1) {\n\
    \            return \"YES\";\n        }\n        return count % 2 == 0 || count\
    \ % 3 == 0 || count % 5 == 0 || count % 7 == 0 || count % 11 == 0 ? \"NO\" : \"\
    YES\";", "        // let's consider each case of intersection\n        Long firstStart\
    \ = interval1.getValue0();\n        Long firstEnd = interval1.getValue1();\n \
    \       Long secondStart = interval2.getValue0();\n        Long secondEnd = interval2.getValue1();\n\
    \        // case 1: second interval is subset of first interval.\n        if (firstStart\
    \ <= secondStart && secondEnd <= firstEnd) {\n            return isPrime(Math.abs(secondEnd\
    \ - secondStart)) ? \"YES\" : \"NO\";\n        }\n        // case 2: first interval\
    \ is subset of second interval.\n        if (secondStart <= firstStart && firstEnd\
    \ <= secondEnd) {\n            return isPrime(Math.abs(firstEnd - firstStart))\
    \ ? \"YES\" : \"NO\";\n        }\n        // case 3: second start is within the\
    \ first interval\n        if (firstStart <= secondStart && secondStart <= firstEnd)\
    \ {\n            return isPrime(Math.abs(firstEnd - secondStart)) ? \"YES\" :\
    \ \"NO\";\n        }\n        // case 4: first start is within the second interval\n\
    \        if (secondStart <= firstStart && firstStart <= secondEnd) {\n       \
    \     return isPrime(Math.abs(secondEnd - firstStart)) ? \"YES\" : \"NO\";\n \
    \       }\n        // case 5: there is no intersection at all\n        return\
    \ \"NO\";", "        // ***your code***\n        return null;", "        // start\
    \ is the leftmost element in the intersection of the two intervals\n        long\
    \ start = Math.max(interval1.getValue0(), interval2.getValue0());\n        //\
    \ end is the rightmost element in the intersection of the two intervals\n    \
    \    long end = Math.min(interval1.getValue1(), interval2.getValue1());\n    \
    \    // if start is less than end, then they intersect,\n        // otherwise\
    \ they don't intersect\n        return start < end ? isPrime(end - start) ? \"\
    YES\" : \"NO\" : \"NO\";", "        Long left = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        Long right = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (left > right) {\n            return \"\
    NO\";\n        }\n        int size = (int) (right - left) + 1;\n        if (isPrime(size))\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";", "      \
    \  long lo = Math.max(interval1.getValue0(), interval2.getValue0());\n       \
    \ long hi = Math.min(interval1.getValue1(), interval2.getValue1());\n        long\
    \ diff = hi - lo;\n        return isPrime(diff + 1) ? \"YES\" : \"NO\";", "  \
    \      // Try to find intersection\n        // interval1 is (1, 2) interval2 is\
    \ (2, 3)\n        // is intersection ?\n        // if (interval1.getValue0() >=\
    \ interval2.getValue0() || interval1.getValue1() <= interval2.getValue1()) return\
    \ \"NO\";\n        // if it is intersection then find the intersection values\n\
    \        long a = interval1.getValue0();\n        long b = interval1.getValue1();\n\
    \        long c = interval2.getValue0();\n        long d = interval2.getValue1();\n\
    \        long x = Math.max(a, c);\n        long y = Math.min(b, d);\n        if\
    \ (x <= y) {\n            return (isPrime(y - x + 1)) ? \"YES\" : \"NO\";\n  \
    \      }\n        return \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long len = end - start + 1;\n        if (len\
    \ < 1) return \"NO\";\n        return Utils.isPrime(len) ? \"YES\" : \"NO\";",
  "        // Your code here\n        long start1 = interval1.getValue0();\n     \
    \   long end1 = interval1.getValue1();\n        long start2 = interval2.getValue0();\n\
    \        long end2 = interval2.getValue1();\n        long max = Math.max(start1,\
    \ start2);\n        long min = Math.min(end1, end2);\n        if (max <= min)\
    \ {\n            long len = min - max + 1;\n            if (isPrime(len)) {\n\
    \                return \"YES\";\n            }\n        }\n        return \"\
    NO\";", "        String output = \"NO\";\n        // use BigInteger and BigDecimal\
    \ whenever possible\n        BigInteger start = BigInteger.valueOf(0L);\n    \
    \    BigInteger end = BigInteger.valueOf(0L);\n        BigInteger gcd = BigInteger.valueOf(0L);\n\
    \        // put in your code here:\n        BigInteger bint1 = BigInteger.valueOf(interval1.getValue0());\n\
    \        BigInteger bint2 = BigInteger.valueOf(interval1.getValue1());\n     \
    \   BigInteger bint3 = BigInteger.valueOf(interval2.getValue0());\n        BigInteger\
    \ bint4 = BigInteger.valueOf(interval2.getValue1());\n        BigInteger bmax1\
    \ = bint1.max(bint3);\n        BigInteger bmin1 = bint1.min(bint3);\n        BigInteger\
    \ bmax2 = bint2.max(bint4);\n        BigInteger bmin2 = bint2.min(bint4);\n  \
    \      BigInteger dist = BigInteger.valueOf(1L);\n        if (bmax1.compareTo(bmin2)\
    \ > 0) {\n            return output;\n        }\n        start = bmax1;\n    \
    \    end = bmin2;\n        gcd = end.subtract(start).add(dist);\n        for (BigInteger\
    \ i = dist; i.compareTo(gcd) < 0; i = i.add(dist)) {\n            if (gcd.mod(i).equals(BigInteger.valueOf(0L)))\
    \ {\n                return output;\n            }\n        }\n        output\
    \ = \"YES\";\n        return output;", "        if (interval1.getValue0() > interval2.getValue1()\
    \ || interval2.getValue0() > interval1.getValue1())\n            return \"NO\"\
    ;\n        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long length = end - start + 1;\n        if (length <= 0)\n          \
    \  return \"NO\";\n        if (length == 1)\n            return \"YES\";\n   \
    \     for (long i = 2; i < length; i++) {\n            if (length % i == 0)\n\
    \                return \"NO\";\n        }\n        return \"YES\";", "      \
    \  // Good luck!\n        // (c) https://www.codingame.com/ide/puzzle/prime-interval\n\
    \        // (c) 2020-04-20, Marie Goldsmith\n        Long min = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        Long max = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (min <= max) {\n            return isPrime(max\
    \ - min + 1l) ? \"YES\" : \"NO\";\n        }\n        return \"NO\";", "     \
    \   long start = 0;\n        long end = 0;\n        // This finds the start point\
    \ of the intersection\n        if (interval1.getValue0() > interval2.getValue0())\
    \ {\n            start = interval1.getValue0();\n        } else {\n          \
    \  start = interval2.getValue0();\n        }\n        // This finds the end point\
    \ of the intersection\n        if (interval1.getValue1() < interval2.getValue1())\
    \ {\n            end = interval1.getValue1();\n        } else {\n            end\
    \ = interval2.getValue1();\n        }\n        if (start > end) {\n          \
    \  return \"NO\";\n        }\n        // This finds the length of the intersection\n\
    \        long length = end - start + 1;\n        if (length <= 0) {\n        \
    \    return \"NO\";\n        }\n        // This finds if the length is a prime\
    \ number\n        if (isPrime(length)) {\n            return \"YES\";\n      \
    \  } else {\n            return \"NO\";\n        }", "        long start1 = interval1.getValue0();\n\
    \        long end1 = interval1.getValue1();\n        long start2 = interval2.getValue0();\n\
    \        long end2 = interval2.getValue1();\n        long greaterStart = start1\
    \ > start2 ? start1 : start2;\n        long smallerEnd = end1 < end2 ? end1 :\
    \ end2;\n        long length = greaterStart < smallerEnd ? smallerEnd - greaterStart\
    \ : 0;\n        if (length == 0) {\n            return \"NO\";\n        }\n  \
    \      if (isPrime(length)) {\n            return \"YES\";\n        }\n      \
    \  return \"NO\";", "        Long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        Long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        //\
    \ We have to use BigInteger, because the interval's length may be > 2^32\n   \
    \     // which is greater than the size of long type.\n        BigInteger len\
    \ = BigInteger.valueOf(end).subtract(BigInteger.valueOf(start)).add(BigInteger.ONE);\n\
    \        if (len.isProbablePrime(100)) {\n            return \"YES\";\n      \
    \  }\n        return \"NO\";", "        BigInteger lo = BigInteger.valueOf(Math.max(interval1.getValue0(),\
    \ interval2.getValue0()));\n        BigInteger hi = BigInteger.valueOf(Math.min(interval1.getValue1(),\
    \ interval2.getValue1()));\n        int lo_int = lo.intValue();\n        int hi_int\
    \ = hi.intValue();\n        if (lo_int > hi_int) {\n            return \"NO\"\
    ;\n        }\n        BigInteger cnt = BigInteger.valueOf(hi_int - lo_int + 1);\n\
    \        if (cnt.isProbablePrime(100)) {\n            return \"YES\";\n      \
    \  }\n        return \"NO\";", "        // fail fast.\n        if (interval1.getValue0()\
    \ > interval1.getValue1() || interval2.getValue0() > interval2.getValue1()) {\n\
    \            return \"NO\";\n        }\n        if (interval1.getValue0() > interval2.getValue1()\
    \ || interval2.getValue0() > interval1.getValue1()) {\n            return \"NO\"\
    ;\n        }\n        final long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        final long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        return BigInteger.valueOf(end - start + 1).isProbablePrime(100) ? \"\
    YES\" : \"NO\";", "        // First, we have to determine whether the intervals\
    \ intersect or not.\n        // Let (start1, end1) and (start2, end2) be the intervals,\
    \ the intervals\n        // intersect if the condition below is satisfied.\n \
    \       // start1 <= end2 && start2 <= end1\n        if (interval1.getValue0()\
    \ <= interval2.getValue1() && interval2.getValue0() <= interval1.getValue1())\
    \ {\n            // If they intersect, calculate the starting point of the intersection\
    \ and\n            // the length of the intersection.\n            long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n            long\
    \ length = Math.min(interval1.getValue1(), interval2.getValue1()) - start + 1;\n\
    \            // Then, determine whether the length is a prime number or not.\n\
    \            // We have a few methods to determine whether a number is a prime\
    \ number\n            // or not.\n            // 1) Use trial division\n     \
    \       // Start from 2 and divide the number by all numbers in [2,number-1].\n\
    \            // If the number is divided by any of these numbers, then it is not\
    \ a prime number.\n            // Otherwise, the number is a prime number.\n \
    \           // 2) Use sieve of Eratosthenes\n            // We mark all numbers\
    \ from 2 to (number-1) as numbers that can be prime numbers.\n            // Then\
    \ we take a number p, mark all numbers that can be divided by p as not a prime\
    \ number.\n            // And take another number p which is not marked as not\
    \ a prime number,\n            // and mark all numbers that can be divided by\
    \ p as not a prime number.\n            // The numbers left on our list at the\
    \ end are prime numbers.\n            // 3) Use Sieve of Sundaram\n          \
    \  // We only need to mark all numbers from 1 to (number-1) as numbers that can\
    \ be prime numbers.\n            // Then we mark all numbers that can be written\
    \ as i + j + 2ij (1 <= i <= j, i + j + 2ij <= number-1)\n            // as not\
    \ a prime number.\n            // The numbers left on our list at the end are\
    \ prime numbers.\n            // 4) Calculate the prime numbers up to (number-1",
  '        throw new UnsupportedOperationException("Not Implemented yet");', "   \
    \     if (interval1.getValue0() > interval1.getValue1()) {\n            return\
    \ \"NO\";\n        }\n        if (interval2.getValue0() > interval2.getValue1())\
    \ {\n            return \"NO\";\n        }\n        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long len = Math.max(end - start + 1, 0);\n\
    \        return isPrime(len) ? \"YES\" : \"NO\";", "        // put your code here\n\
    \        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        long\
    \ len = end - start + 1;\n        return isPrime(len) ? \"YES\" : \"NO\";", " \
    \       long maxStart = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long minEnd = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (maxStart <= minEnd) {\n            if (isPrime(minEnd - maxStart\
    \ + 1))\n                return \"YES\";\n        }\n        return \"NO\";",
  "        long right = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long left = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long length = right - left;\n        if (length < 0) {\n            return\
    \ \"NO\";\n        }\n        return isPrime(length) ? \"YES\" : \"NO\";", " \
    \       long maxstart = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long minend = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long intersectionLength = minend - maxstart;\n        if (intersectionLength\
    \ < 0) {\n            return \"NO\";\n        }\n        if (maxstart > minend)\
    \ {\n            return \"NO\";\n        }\n        if (isPrime(intersectionLength))\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";", "      \
    \  long start = Math.max(interval1.getValue0(), interval2.getValue0());\n    \
    \    long end = Math.min(interval1.getValue1(), interval2.getValue1());\n    \
    \    if (start <= end) {\n            if (isPrime(end - start + 1))\n        \
    \        return \"YES\";\n            else\n                return \"NO\";\n \
    \       } else {\n            return \"NO\";\n        }", "        // your code\
    \ goes here\n        long start1 = interval1.getValue0();\n        long end1 =\
    \ interval1.getValue1();\n        long start2 = interval2.getValue0();\n     \
    \   long end2 = interval2.getValue1();\n        long l1 = end1 - start1 + 1;\n\
    \        long l2 = end2 - start2 + 1;\n        if (start1 >= end2 || start2 >=\
    \ end1) return \"NO\";\n        long linter = Math.min(end1, end2) - Math.max(start1,\
    \ start2) + 1;\n        if (linter == 2 || linter == 3 || linter == 5 || linter\
    \ == 7) return \"YES\";\n        return \"NO\";", "        // Write your code\
    \ here\n        return \"YES\";", "        final long left = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        final long right = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (left <= right) {\n            final long\
    \ i = right - left + 1;\n            if (i > 2 && i % 2 == 0) {\n            \
    \    return \"NO\";\n            }\n            for (long j = 3; j < i; j++) {\n\
    \                if (i % j == 0) {\n                    return \"NO\";\n     \
    \           }\n            }\n            return \"YES\";\n        }\n       \
    \ return \"NO\";", '        return (isPrime(intersectionLength(interval1, interval2)))
    ? "YES" : "NO";', "        long p = interval1.getValue0();\n        long q = interval1.getValue1();\n\
    \        long r = interval2.getValue0();\n        long s = interval2.getValue1();\n\
    \        long a = Math.max(p, r);\n        long b = Math.min(q, s);\n        if\
    \ (a <= b) {\n            // The following method is faster than the naive version\
    \ below.\n            return BigInteger.valueOf(b - a + 1).isProbablePrime(16)\
    \ ? \"YES\" : \"NO\";\n            // The following code is the naive version\
    \ which is slower.\n            // for (long i = a; i <= b; i++) {\n         \
    \   //     if (BigInteger.valueOf(i).isProbablePrime(16)) {\n            //  \
    \       return \"YES\";\n            //     }\n            // }\n            //\
    \ return \"NO\";\n        } else {\n            return \"NO\";\n        }", " \
    \       if (interval1.getValue0() > interval1.getValue1()) {\n            long\
    \ temp = interval1.getValue0();\n            interval1 = Pair.with(interval1.getValue1(),\
    \ temp);\n        }\n        if (interval2.getValue0() > interval2.getValue1())\
    \ {\n            long temp = interval2.getValue0();\n            interval2 = Pair.with(interval2.getValue1(),\
    \ temp);\n        }\n        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        if\
    \ (start == end) {\n            if (start == 1) {\n                return \"YES\"\
    ;\n            }\n            return \"NO\";\n        }\n        long len = end\
    \ - start + 1;\n        if (len == 1) {\n            return \"YES\";\n       \
    \ }\n        if (len == 2) {\n            return \"NO\";\n        }\n        for\
    \ (long i = 2; i <= len / 2; i++) {\n            if (len % i == 0) {\n       \
    \         return \"NO\";\n            }\n        }\n        return \"YES\";",
  "        long max1 = interval1.getValue0();\n        long min1 = interval1.getValue1();\n\
    \        long max2 = interval2.getValue0();\n        long min2 = interval2.getValue1();\n\
    \        long min_max = Math.max(min1, min2);\n        long max_min = Math.min(max1,\
    \ max2);\n        if (min_max > max_min) {\n            return \"NO\";\n     \
    \   }\n        long diff = max_min - min_max + 1;\n        if (diff == 1) {\n\
    \            return \"YES\";\n        }\n        if (diff == 2) {\n          \
    \  return \"NO\";\n        }\n        for (long i = 2; i <= diff / 2; i++) {\n\
    \            if (diff % i == 0) {\n                return \"NO\";\n          \
    \  }\n        }\n        return \"YES\";", "        long largest = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long smallest = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long length = largest - smallest;\n       \
    \ if (length == 0) {\n            return \"NO\";\n        }\n        if (length\
    \ == 1) {\n            return \"NO\";\n        }\n        if (length == 2) {\n\
    \            return \"YES\";\n        }\n        if (length == 3) {\n        \
    \    return \"YES\";\n        }\n        return \"NO\";", "        long i1_s =\
    \ interval1.getValue0();\n        long i1_e = interval1.getValue1();\n       \
    \ long i2_s = interval2.getValue0();\n        long i2_e = interval2.getValue1();\n\
    \        if (i1_s > i1_e) {\n            long tmp = i1_s;\n            i1_s =\
    \ i1_e;\n            i1_e = tmp;\n        }\n        if (i2_s > i2_e) {\n    \
    \        long tmp = i2_s;\n            i2_s = i2_e;\n            i2_e = tmp;\n\
    \        }\n        long s = Math.max(i1_s, i2_s);\n        long e = Math.min(i1_e,\
    \ i2_e);\n        if (s > e) {\n            return \"NO\";\n        }\n      \
    \  return (isPrime(e - s + 1)) ? \"YES\" : \"NO\";", "        long a1 = interval1.getValue0();\n\
    \        long a2 = interval1.getValue1();\n        long b1 = interval2.getValue0();\n\
    \        long b2 = interval2.getValue1();\n        if (a1 > a2) {\n          \
    \  long temp = a1;\n            a1 = a2;\n            a2 = temp;\n        }\n\
    \        if (b1 > b2) {\n            long temp = b1;\n            b1 = b2;\n \
    \           b2 = temp;\n        }\n        System.out.println(a1 + \" \" + a2\
    \ + \" \" + b1 + \" \" + b2);\n        if (a2 < b1 || b2 < a1) {\n           \
    \ return \"NO\";\n        }\n        long c1 = max(a1, b1);\n        long c2 =\
    \ min(a2, b2);\n        long len = c2 - c1 + 1;\n        if (prime(len)) {\n \
    \           return \"YES\";\n        }\n        return \"NO\";", "        if (interval1.getValue0()\
    \ < interval2.getValue0()) {\n            return intersection(interval2, interval1);\n\
    \        }\n        if (interval1.getValue0() < interval2.getValue1()) {\n   \
    \         if (interval1.getValue1() < interval2.getValue1()) {\n             \
    \   return \"NO\";\n            }\n            long a = interval1.getValue0()\
    \ - interval2.getValue0();\n            long b = interval1.getValue1() - interval2.getValue1();\n\
    \            return isPrime(a + b + 1) ? \"YES\" : \"NO\";\n        }\n      \
    \  return \"NO\";", "        long a = interval1.getValue0();\n        long b =\
    \ interval1.getValue1();\n        long c = interval2.getValue0();\n        long\
    \ d = interval2.getValue1();\n        long e = Math.max(a, c);\n        long f\
    \ = Math.min(b, d);\n        if (f < e) {\n            return \"NO\";\n      \
    \  }\n        long diff = f - e + 1;\n        return isPrime(diff) ? \"YES\" :\
    \ \"NO\";", "        long max_start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long min_end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long length = min_end - max_start;\n        if (length <= 0) {\n    \
    \        return \"NO\";\n        }\n        boolean isPrime = true;\n        for\
    \ (long i = 2; i < length; i++) {\n            if (length % i == 0) {\n      \
    \          isPrime = false;\n                break;\n            }\n        }\n\
    \        return isPrime ? \"YES\" : \"NO\";", "        long a = interval1.getValue0();\n\
    \        long b = interval1.getValue1();\n        long c = interval2.getValue0();\n\
    \        long d = interval2.getValue1();\n        long s = Math.max(a, c);\n \
    \       long t = Math.min(b, d);\n        if (s <= t) {\n            return isPrime(t\
    \ - s + 1) ? \"YES\" : \"NO\";\n        }\n        return \"NO\";", "        long\
    \ start = Math.max(interval1.getValue0(), interval2.getValue0());\n        long\
    \ end = Math.min(interval1.getValue1(), interval2.getValue1());\n        long\
    \ distance = end - start;\n        if (distance <= 0) {\n            return \"\
    NO\";\n        }\n        for (long i = 2; i < distance; i++) {\n            if\
    \ (distance % i == 0) {\n                return \"NO\";\n            }\n     \
    \   }\n        return \"YES\";", "        final long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        final long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        final long length = end - start + 1;\n    \
    \    if (length <= 0) {\n            return \"NO\";\n        }\n        if (length\
    \ == 1) {\n            return \"YES\";\n        }\n        return Stream.iterate(2l,\
    \ i -> i + 1)\n            .limit(length)\n            .allMatch(l -> length %\
    \ l != 0) ? \"YES\" : \"NO\";", "        // write your code here\n        long\
    \ start = Math.max(interval1.getValue0(), interval2.getValue0());\n        long\
    \ end = Math.min(interval1.getValue1(), interval2.getValue1());\n        if (start\
    \ >= end) {\n            return \"NO\";\n        }\n        long length = end\
    \ - start + 1;\n        if (length <= 1) {\n            return \"NO\";\n     \
    \   }\n        if (length <= 3) {\n            return \"YES\";\n        }\n  \
    \      if (length % 2 == 0) {\n            return \"NO\";\n        }\n       \
    \ if (length % 3 == 0) {\n            return \"NO\";\n        }\n        for (long\
    \ i = 5; i * i <= length; i += 6) {\n            if (length % i == 0) {\n    \
    \            return \"NO\";\n            }\n            if (length % (i + 2) ==\
    \ 0) {\n                return \"NO\";\n            }\n        }\n        return\
    \ \"YES\";", "        if (interval1.getValue0() > interval1.getValue1()) {\n \
    \           Long tmp = interval1.getValue0();\n            interval1 = Pair.with(interval1.getValue1(),\
    \ tmp);\n        }\n        if (interval2.getValue0() > interval2.getValue1())\
    \ {\n            Long tmp = interval2.getValue0();\n            interval2 = Pair.with(interval2.getValue1(),\
    \ tmp);\n        }\n        // if the intervals don't intersect at all\n     \
    \   if (interval1.getValue1() < interval2.getValue0() || interval2.getValue1()\
    \ < interval1.getValue0()) {\n            return \"NO\";\n        }\n        //\
    \ get the start and end of the intersection\n        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long length = end - start + 1;\n        //\
    \ check if the length is prime\n        boolean isPrime = true;\n        for (long\
    \ i = 2; i <= Math.sqrt(length); i++) {\n            if (length % i == 0) {\n\
    \                isPrime = false;\n                break;\n            }\n   \
    \     }\n        return isPrime ? \"YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        return isPrime(end - start + 1) ? \"YES\" :\
    \ \"NO\";", "        final long lowerBound = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        final long upperBound = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (lowerBound > upperBound) {\n            return \"NO\";\n        }\n\
    \        final long diff = upperBound - lowerBound + 1;\n        return isPrime(diff)\
    \ ? \"YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        return isPrime(end - start + 1) ? \"YES\" :\
    \ \"NO\";", "        Long left = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        Long right = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        Long length = right - left + 1;\n        if (length > 0) {\n        \
    \    if (isPrime(length)) {\n                return \"YES\";\n            }\n\
    \        }\n        return \"NO\";", '        return null;', "        // Your\
    \ code here\n        long x1 = interval1.getValue0();\n        long y1 = interval1.getValue1();\n\
    \        long x2 = interval2.getValue0();\n        long y2 = interval2.getValue1();\n\
    \        long x3 = Math.max(x1, x2);\n        long y3 = Math.min(y1, y2);\n  \
    \      long diff = y3 - x3;\n        if (diff <= 0) {\n            return \"NO\"\
    ;\n        }\n        long[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n        for (long\
    \ prime : primes) {\n            if (diff == prime) {\n                return\
    \ \"YES\";\n            }\n        }\n        return \"NO\";", "        // your\
    \ code here\n        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        long\
    \ diff = end - start + 1;\n        int i = 2;\n        while (i <= diff) {\n \
    \           if (diff % i == 0) {\n                return \"NO\";\n           \
    \ }\n            i++;\n        }\n        return \"YES\";", "        Long min\
    \ = max(interval1.getValue0(), interval2.getValue0());\n        Long max = min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (min > max) {\n            return \"NO\"\
    ;\n        }\n        long diff = max - min + 1;\n        return isPrime(diff)\
    \ ? \"YES\" : \"NO\";", "        long min = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long max = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long length = max - min + 1;\n        if (length <= 0) return \"NO\"\
    ;\n        if (length == 1) return \"NO\";\n        if (length == 2) return \"\
    YES\";\n        if (length == 3) return \"YES\";\n        if (length % 2 == 0)\
    \ return \"NO\";\n        if (length % 3 == 0) return \"NO\";\n        boolean\
    \ isPrime = true;\n        for (long i = 5; i <= Math.sqrt(length); i += 6) {\n\
    \            if (length % i == 0) {\n                isPrime = false;\n      \
    \          break;\n            }\n            if (length % (i + 2) == 0) {\n \
    \               isPrime = false;\n                break;\n            }\n    \
    \    }\n        return isPrime ? \"YES\" : \"NO\";", "        // check for intersection\n\
    \        if(interval1.getValue0() > interval2.getValue1() || interval2.getValue0()\
    \ > interval1.getValue1()) {\n            return \"NO\";\n        }\n        long\
    \ start = Math.max(interval1.getValue0(), interval2.getValue0());\n        long\
    \ end = Math.min(interval1.getValue1(), interval2.getValue1());\n        long\
    \ diff = end - start + 1;\n        return (isPrime(diff)) ? \"YES\" : \"NO\";",
  "        // YOUR CODE HERE\n        long min = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long max = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long diff = max - min;\n        if (diff < 1) {\n            return \"\
    NO\";\n        }\n        return isPrime(diff) ? \"YES\" : \"NO\";", "       \
    \ long start = Math.max(interval1.getValue0(), interval2.getValue0());\n     \
    \   long end = Math.min(interval1.getValue1(), interval2.getValue1());\n     \
    \   long length = end - start + 1;\n        if (length < 0) {\n            return\
    \ \"NO\";\n        }\n        if (length == 1) {\n            return \"NO\";\n\
    \        }\n        return isPrime(length) ? \"YES\" : \"NO\";", "        Long\
    \ inter_first = Math.max(interval1.getValue0(), interval2.getValue0());\n    \
    \    Long inter_second = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (inter_first > inter_second) {\n            return \"NO\";\n     \
    \   }\n        Long length = Math.abs(inter_second - inter_first) + 1;\n     \
    \   return isPrime(length) ? \"YES\" : \"NO\";", "        long maxStart = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long minEnd = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long length = Math.max(minEnd - maxStart, 0);\n\
    \        if (length == 0) {\n            return \"NO\";\n        }\n        for\
    \ (long i = 2; i <= Math.sqrt(length); i++) {\n            if (length % i == 0)\
    \ {\n                return \"NO\";\n            }\n        }\n        return\
    \ \"YES\";", "        // Difficulties: 1\n        // Parameters: interval1 - a\
    \ pair of integers where the first element is less or equal\n        // the second\
    \ element\n        // interval2 - a pair of integers where the first element is\
    \ less or equal\n        // the second element\n        // Returns: \"YES\" if\
    \ the length of the intersection of interval1 and interval2\n        // is a prime\
    \ number.\n        // \"NO\" if the length of the intersection of interval1 and\
    \ interval2\n        // is not a prime number or if the two intervals don't intersect.\n\
    \        // Example:\n        // >>> intersection((Pair.with(1l, 2l)), (Pair.with(2l,\
    \ 3l)))\n        // (\"NO\")\n        // >>> intersection((Pair.with(-1l, 1l)),\
    \ (Pair.with(0l, 4l)))\n        // (\"NO\")\n        // >>> intersection((Pair.with(-3l,\
    \ -1l)), (Pair.with(-5l, 5l)))\n        // (\"YES\")\n        // Implementation:\n\
    \        // if the intervals don't intersect, return \"NO\"\n        // get the\
    \ intersection of interval1 and interval2\n        // get the length of the intersection\n\
    \        // return \"YES\" if the length is a prime number, otherwise, return\
    \ \"NO\"\n        // if the intervals don't intersect, return \"NO\"\n       \
    \ long start = Math.max(interval1.getValue0(), interval2.getValue0());\n     \
    \   long end = Math.min(interval1.getValue1(), interval2.getValue1());\n     \
    \   if (start > end) {\n            return \"NO\";\n        }\n        // get\
    \ the length of the intersection\n        long length = end - start + 1;\n   \
    \     // return \"YES\" if the length is a prime number, otherwise, return \"\
    NO\"\n        return LongStream.rangeClosed(2, length / 2).noneMatch(i -> length\
    \ % i == 0) ? \"YES\" : \"NO\";", "        // should be in the form Pair.with(start,\
    \ end)\n        long start1 = interval1.getValue0();\n        long end1 = interval1.getValue1();\n\
    \        long start2 = interval2.getValue0();\n        long end2 = interval2.getValue1();\n\
    \        long start = Math.max(start1, start2);\n        long end = Math.min(end1,\
    \ end2);\n        return (start > end) ? \"NO\" : (isPrime(end - start + 1)) ?\
    \ \"YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        if\
    \ (start == end) {\n            return (isPrime(start)) ? \"YES\" : \"NO\";\n\
    \        }\n        return (isPrime(end - start + 1)) ? \"YES\" : \"NO\";", " \
    \       long start1 = interval1.getValue0();\n        long end1 = interval1.getValue1();\n\
    \        long start2 = interval2.getValue0();\n        long end2 = interval2.getValue1();\n\
    \        if (end1 < start2 || end2 < start1) {\n            return \"NO\";\n \
    \       }\n        long intersectionStart = Math.max(start1, start2);\n      \
    \  long intersectionEnd = Math.min(end1, end2);\n        long length = intersectionEnd\
    \ - intersectionStart + 1;\n        if (isPrime(length)) {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";", "        long a = interval1.getValue0(),\
    \ b = interval1.getValue1();\n        long c = interval2.getValue0(), d = interval2.getValue1();\n\
    \        if (a > b) {\n            long temp = a;\n            a = b;\n      \
    \      b = temp;\n        }\n        if (c > d) {\n            long temp = c;\n\
    \            c = d;\n            d = temp;\n        }\n        if (b < c || a\
    \ > d) {\n            return \"NO\";\n        }\n        long start = Math.max(a,\
    \ c);\n        long end = Math.min(b, d);\n        if (Math.abs(end - start) <\
    \ 2) {\n            return \"NO\";\n        }\n        List<Long> primes = new\
    \ ArrayList<Long>();\n        for (long i = 2; i <= Math.abs(end - start); i++)\
    \ {\n            boolean isPrime = true;\n            for (long prime : primes)\
    \ {\n                if (i % prime == 0) {\n                    isPrime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ (isPrime) {\n                primes.add(i);\n            }\n        }\n    \
    \    return primes.contains(Math.abs(end - start)) ? \"YES\" : \"NO\";", "   \
    \     long intersection_start = Math.max(interval1.getValue0(), interval2.getValue0());\n\
    \        long intersection_end = Math.min(interval1.getValue1(), interval2.getValue1());\n\
    \        long intersection_length = intersection_end - intersection_start + 1;\n\
    \        if (intersection_length <= 0) {\n            return \"NO\";\n       \
    \ }\n        for (long i = 2; i <= intersection_length / 2; i++) {\n         \
    \   if (intersection_length % i == 0) {\n                return \"NO\";\n    \
    \        }\n        }\n        return \"YES\";", "        // your code here\n\
    \        long s1 = interval1.getValue0();\n        long e1 = interval1.getValue1();\n\
    \        long s2 = interval2.getValue0();\n        long e2 = interval2.getValue1();\n\
    \        long start = Math.max(s1, s2);\n        long end = Math.min(e1, e2);\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        long\
    \ diff = end - start + 1;\n        boolean isPrime = true;\n        for (long\
    \ i = 2; i < diff; i++) {\n            if (diff % i == 0) {\n                isPrime\
    \ = false;\n                break;\n            }\n        }\n        if (isPrime)\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";", "      \
    \  long inf = Math.max(interval1.getValue0(), interval2.getValue0());\n      \
    \  long sup = Math.min(interval1.getValue1(), interval2.getValue1());\n      \
    \  if (inf > sup) {\n            return \"NO\";\n        }\n        long len =\
    \ sup - inf + 1;\n        if (isPrime(len)) {\n            return \"YES\";\n \
    \       }\n        return \"NO\";", "        Long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        Long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        Long length = end - start + 1;\n        if\
    \ (length > 0) {\n            if (isPrime(length)) {\n                return \"\
    YES\";\n            }\n        }\n        return \"NO\";", "        long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        long end\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        long length\
    \ = end - start + 1;\n        boolean isPrime = true;\n        if (length <= 1)\
    \ {\n            isPrime = false;\n        } else {\n            for (long i =\
    \ 2; i <= length / 2; i++) {\n                if (length % i == 0) {\n       \
    \             isPrime = false;\n                    break;\n                }\n\
    \            }\n        }\n        if (isPrime) {\n            return \"YES\"\
    ;\n        } else {\n            return \"NO\";\n        }", "        BigInteger\
    \ max1 = BigInteger.valueOf(Math.max(interval1.getValue0(), interval2.getValue0()));\n\
    \        BigInteger min1 = BigInteger.valueOf(Math.min(interval1.getValue1(),\
    \ interval2.getValue1()));\n        BigInteger max2 = BigInteger.valueOf(Math.max(interval1.getValue0(),\
    \ interval2.getValue0()));\n        BigInteger min2 = BigInteger.valueOf(Math.min(interval1.getValue1(),\
    \ interval2.getValue1()));\n        BigInteger range1 = max1.subtract(min1);\n\
    \        BigInteger range2 = max2.subtract(min2);\n        if (range1.signum()\
    \ == -1 || range2.signum() == -1) {\n            return \"NO\";\n        }\n \
    \       else {\n            return (range1.isProbablePrime(10) && range2.isProbablePrime(10))\
    \ ? \"YES\" : \"NO\";\n        }", "        BigInteger inter_start, inter_end;\n\
    \        BigInteger len;\n        // boundary checks\n        if (interval1.getValue0().compareTo(interval2.getValue0())\
    \ > 0) {\n            if (interval1.getValue0().compareTo(interval2.getValue1())\
    \ > 0) {\n                return \"NO\";\n            }\n            inter_start\
    \ = interval1.getValue0();\n        } else {\n            if (interval2.getValue0().compareTo(interval1.getValue1())\
    \ > 0) {\n                return \"NO\";\n            }\n            inter_start\
    \ = interval2.getValue0();\n        }\n        if (interval1.getValue1().compareTo(interval2.getValue1())\
    \ > 0) {\n            inter_end = interval2.getValue1();\n        } else {\n \
    \           inter_end = interval1.getValue1();\n        }\n        len = inter_end.subtract(inter_start).add(BigInteger.ONE);\n\
    \        return len.isProbablePrime(50) ? \"YES\" : \"NO\";", "        long start\
    \ = Math.max(interval1.getValue0(), interval2.getValue0());\n        long end\
    \ = Math.min(interval1.getValue1(), interval2.getValue1());\n        long length\
    \ = Math.max(end - start + 1, 0);\n        boolean answer = false;\n        if\
    \ (length > 1) {\n            for (long i = 2; i < length; i++) {\n          \
    \      if (length % i == 0) {\n                    answer = false;\n         \
    \           break;\n                } else {\n                    answer = true;\n\
    \                }\n            }\n        }\n        return answer ? \"YES\"\
    \ : \"NO\";", "        //max(interval1.getValue0(), interval2.getValue0());\n\
    \        //min(interval1.getValue1(), interval2.getValue1());\n        Long a\
    \ = interval1.getValue0();\n        Long b = interval1.getValue1();\n        Long\
    \ c = interval2.getValue0();\n        Long d = interval2.getValue1();\n      \
    \  Long result1 = (a > c) ? a : c;\n        Long result2 = (b < d) ? b : d;\n\
    \        if (result1 > result2) return \"NO\";\n        Long result = result2\
    \ - result1 + 1;\n        // return \"NO\";\n        boolean prime = isPrime(result);\n\
    \        return prime ? \"YES\" : \"NO\";", "        long start = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long end = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        if (start > end) {\n            return \"NO\"\
    ;\n        }\n        BigInteger length = BigInteger.valueOf(end - start + 1);\n\
    \        return length.isProbablePrime(100) ? \"YES\" : \"NO\";", "        Long\
    \ start = Math.max(interval1.getValue0(), interval2.getValue0());\n        Long\
    \ end = Math.min(interval1.getValue1(), interval2.getValue1());\n        return\
    \ start >= end ? \"NO\" : isPrime(end - start) ? \"YES\" : \"NO\";", "       \
    \ long start1 = interval1.getValue0();\n        long end1 = interval1.getValue1();\n\
    \        long start2 = interval2.getValue0();\n        long end2 = interval2.getValue1();\n\
    \        long start = Math.max(start1, start2);\n        long end = Math.min(end1,\
    \ end2);\n        if (start > end) return \"NO\";\n        if (isPrime(end - start\
    \ + 1)) return \"YES\";\n        return \"NO\";", "        if(interval1.getValue0()\
    \ >= interval2.getValue1() || interval2.getValue0() >= interval1.getValue1())\
    \ {\n            return \"NO\";\n        }\n        long lower = Math.max(interval1.getValue0(),\
    \ interval2.getValue0());\n        long upper = Math.min(interval1.getValue1(),\
    \ interval2.getValue1());\n        long result = lower > upper ? 0 : upper - lower\
    \ + 1;\n        return isPrime(result) ? \"YES\" : \"NO\";", "        long start1\
    \ = interval1.getValue0();\n        long end1 = interval1.getValue1();\n     \
    \   long start2 = interval2.getValue0();\n        long end2 = interval2.getValue1();\n\
    \        long length1 = end1 - start1 + 1;\n        long length2 = end2 - start2\
    \ + 1;\n        long maxStart = Math.max(start1, start2);\n        long minEnd\
    \ = Math.min(end1, end2);\n        long intersection = minEnd - maxStart + 1;\n\
    \        if (intersection < 0) {\n            return \"NO\";\n        }\n    \
    \    int result = 0;\n        for (int i = 2; i <= Math.sqrt(intersection); i++)\
    \ {\n            if (intersection % i == 0) {\n                result = 1;\n \
    \               break;\n            }\n        }\n        if (result == 0) {\n\
    \            return \"YES\";\n        } else {\n            return \"NO\";\n \
    \       }"]
stop_tokens:
- "\n    }\n"
