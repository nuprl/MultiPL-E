name: HumanEval_49_modp
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>>\
  \ modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n\
  \    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    //\
  \ (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    public static long modp(long\
  \ n, long p) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(modp((3l),\
  \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
  \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
  \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
  \ (5l)) == (3l));\n    }\n\n}\n"
completions: ['        return BigInteger.valueOf(n).modPow(BigInteger.valueOf(2),
    BigInteger.valueOf(p)).longValue();', "        long r = 1;\n        while (n >\
    \ 0) {\n            if ((n & 1) != 0)\n                r = r * 2 % p;\n      \
    \      n >>= 1;\n        }\n        return r;", "        // Base case.\n     \
    \   if (n == 0) return 1;\n        // Recursion.\n        long sqrt = modp(n /\
    \ 2, p);\n        sqrt = (sqrt * sqrt) % p;\n        // Even case.\n        if\
    \ (n % 2 == 0) {\n            return sqrt;\n        }\n        // Odd case.\n\
    \        return (sqrt * 2) % p;", "        if (n == 0) return 1;\n        if (n\
    \ % 2 == 0) {\n            long r = modp(n / 2, p);\n            return r * r\
    \ % p;\n        } else {\n            return n * modp(n - 1, p) % p;\n       \
    \ }", "        n = n % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;\n        n = (2 * n) % p;\n        n = (2 * n) % p;\n\
    \        n = (2 * n) % p;", "        long ret = 1;\n        while (n > 0) {\n\
    \            if ((n & 1) != 0) {\n                ret = (ret * 2) % p;\n     \
    \       }\n            n /= 2;\n        }\n        return ret;", "        if (n\
    \ == 0) {\n            return 1l;\n        }\n        if (n == 1) {\n        \
    \    return n;\n        }\n        if (n % 2 == 0) {\n            long r = modp(n\
    \ / 2, p);\n            return (r * r) % p;\n        } else {\n            return\
    \ (n * modp(n - 1, p)) % p;\n        }", "        long r = 1;\n        long m\
    \ = n;\n        while (p > 0) {\n            if ((p & 1) == 1) {\n           \
    \     r = (r * m) % MOD;\n            }\n            m = (m * m) % MOD;\n    \
    \        p >>= 1;\n        }\n        return r;", "        if (n == 0) {\n   \
    \         return 1;\n        }\n        if (n % 2 == 0) {\n            return\
    \ modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n            return modp(n\
    \ / 2, p) * modp(n / 2, p) * 2 % p;\n        }", "        assert p > 0;\n    \
    \    assert n >= 0;\n        assert n < p;\n        if (n == 0) {\n          \
    \  return 1;\n        }\n        long half = modp(n / 2, p);\n        if (n %\
    \ 2 == 0) {\n            return (half * half) % p;\n        } else {\n       \
    \     return (half * half * 2) % p;\n        }", "        if (n == 0) {\n    \
    \        return 1;\n        }\n        long s = modp(n / 2, p);\n        s = s\
    \ * s % p;\n        if (n % 2 == 1) {\n            s = s * 2 % p;\n        }\n\
    \        return s;", "        if (n == 0) {\n            return 1;\n        }\n\
    \        if (n % 2 == 0) {\n            long val = modp(n / 2, p);\n         \
    \   return (val * val) % p;\n        } else {\n            return (2 * modp(n\
    \ - 1, p)) % p;\n        }", '        return BigInteger.valueOf(n).modPow(BigInteger.valueOf(2),
    BigInteger.valueOf(p)).longValue();', '        return (new BigInteger(String.valueOf(n))).modPow(BigInteger.ONE,
    new BigInteger(String.valueOf(p))).longValue();', "        long ret = 1l;\n  \
    \      for (int i = 0; i < n; i++)\n            ret = (ret * 2l) % p;\n      \
    \  return ret;", "        long r = 1;\n        while (n > 0) {\n            long\
    \ b = (n & 1);\n            if (b == 1) {\n                r = (r * 2) % p;\n\
    \            }\n            n = n >> 1;\n        }\n        return r;", "    \
    \    long r = 1l;\n        long i = 0l;\n        long x = n;\n        while (((1l\
    \ << i) & n) != 0l) {\n            if ((i & 1l) == 0l) {\n                x =\
    \ (x * x) % p;\n            }\n            r = (r * x) % p;\n            i = i\
    \ + 1l;\n        }\n        return r;", "        long res = 1l;\n        long\
    \ pow = n;\n        while (p > 0) {\n            if ((p & 1) != 0) res = (res\
    \ * pow) % p;\n            pow = (pow * pow) % p;\n            p = p >> 1;\n \
    \       }\n        return res;", "        if (n == 0) {\n            return 1;\n\
    \        }\n        long res = modp(n / 2, p);\n        res = (res * res) % p;\n\
    \        if (n % 2 == 1) {\n            res = (res * 2) % p;\n        }\n    \
    \    return res;", "        long ret = 1l;\n        long base = 2l;\n        while\
    \ (n > 0) {\n            if ((n & 1) == 1) {\n                ret = ret * base\
    \ % p;\n            }\n            base = base * base % p;\n            n = n\
    \ >> 1;\n        }\n        return ret;", "        int bits = (int)n;\n      \
    \  long res = 1;\n        while (bits > 0) {\n            if ((bits & 1) == 1)\
    \ {\n                res = (res * 2) % p;\n            }\n            bits >>=\
    \ 1;\n        }\n        return res;", "        long result = 1;\n        for\
    \ (long i = 0; i < n; i++) {\n            result = (result * 2) % p;\n       \
    \ }\n        return result;", "        // Insert your code here.\n        if (n==0)\
    \ {\n            return 1;\n        }\n        else {\n            long k = modp(n/2,\
    \ p);\n            long ans = (2*k)%p;\n            if (n%2==1) {\n          \
    \      ans = (ans*3)%p;\n            }\n            return ans;\n        }", " \
    \       long result = 1;\n        for (long i = 0; i < n; i++)\n            result\
    \ = (result * 2) % p;\n        return result;", "        if (n == 0) return 1;\n\
    \        if (n == 1) return 2;\n        long half = modp(n / 2, p);\n        long\
    \ res = half * half % p;\n        if (n % 2 == 1) res = res * 2 % p;\n       \
    \ return res;", '        return ((BigInteger.valueOf(n).modPow(BigInteger.valueOf(2),
    BigInteger.valueOf(p))).longValue());', '        return BigInteger.valueOf(n).modPow(BigInteger.valueOf(2),
    BigInteger.valueOf(p)).longValue();', "        // >>> x = 1l\n        // >>> for\
    \ i in range(n):\n        // >>> x = (x * 2) % p\n        // >>> x\n        long\
    \ x = 1;\n        for (int i = 0; i < n; i++) {\n            x = (x * 2) % p;\n\
    \        }\n        return x;", "        long ans = 1l;\n        long b = 2l;\n\
    \        while (n > 0) {\n            if ((n & 1) == 1)\n                ans =\
    \ (ans * b) % p;\n            b = (b * b) % p;\n            n >>= 1;\n       \
    \ }\n        return ans;", "        // Compute n % p.\n        n %= p;\n     \
    \   // If n is not in the range 0..p-1, fix it.\n        if ((n < 0) || (n >=\
    \ p)) {\n            n = (n % p + p) % p;\n        }\n        return n;", "  \
    \      if (n < 0)\n            return modp(p - (Math.abs(n) % p), p);\n      \
    \  else if (n < p)\n            return n;\n        else\n            return modp(n\
    \ % p, p);", "        assert(p != 0);\n        return n % p;", "        long a\
    \ = 1;\n        long c = 1;\n        for (int i = 0; i < n; i++) {\n         \
    \   c = c * a % p;\n            a = a * 2 % p;\n        }\n        return c;",
  "        long ret = 1;\n        long x = n % p;\n        while (n > 0) {\n     \
    \       if ((n & 1) == 1) {\n                ret = (ret * x) % p;\n          \
    \  }\n            x = (x * x) % p;\n            n = n >> 1;\n        }\n     \
    \   return ret;", "        long result = 1;\n        for (int i = 0; i < n; i++)\
    \ {\n            result = (result * 2) % p;\n        }\n        return result;",
  "        // print((n) + (' ') + (p))\n        if (n == 0)\n            return 1;\n\
    \        if (n == 1)\n            return n;\n        long t = modp(n / 2, p);\n\
    \        if (n % 2 == 0)\n            return t * t % p;\n        else\n      \
    \      return (t * t % p) * n % p;", "        if (n == 0) {\n            return\
    \ 1;\n        }\n        long z = modp(n / 2, p);\n        z = z * z % p;\n  \
    \      if (n % 2 == 1) {\n            z = z * 2 % p;\n        }\n        return\
    \ z;", "        if (n == 0) {\n            return 1;\n        }\n        if (n\
    \ % 2 == 0) {\n            return modp(n / 2, p) * modp(n / 2, p) % p;\n     \
    \   } else {\n            return modp(n / 2, p) * modp(n / 2, p) * 3 % p;\n  \
    \      }", '        return BigInteger.valueOf(n).modPow(BigInteger.valueOf(2),
    BigInteger.valueOf(p)).longValue();', '        return pow(2, n, p);', "      \
    \  if (n == 0) {\n            return 1;\n        }\n        else if (n % 2 ==\
    \ 0) {\n            long res = modp(n / 2, p);\n            return (res * res)\
    \ % p;\n        }\n        else {\n            return (modp(n - 1, p) * n) % p;\n\
    \        }", "        // >>> 2 ** 100 % 101\n        // 1\n        long result\
    \ = 1;\n        for (long power = n; power > 0; power >>= 1) {\n            if\
    \ ((power & 1) != 0) {\n                result = result * n % p;\n           \
    \ }\n            n = n * n % p;\n        }\n        return result;", "       \
    \ long result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n\
    \                result = (result * 2) % p;\n            }\n            n >>=\
    \ 1;\n        }\n        return result;", "        if (n == 0) {\n           \
    \ return 1;\n        }\n        if (n % 2 == 0) {\n            long t = modp(n\
    \ / 2, p);\n            return (t * t) % p;\n        } else {\n            return\
    \ (2 * modp(n - 1, p)) % p;\n        }", "        long res = 1;\n        for (long\
    \ i = 0; i < n; i++) {\n            res = (res * 2) % p;\n        }\n        return\
    \ res;", "        if(n < 0)\n            return modp(p + n, p);\n        if(n\
    \ < p)\n            return n;\n        if(n == 0)\n            return 1;\n   \
    \     long result = 1;\n        long cur = 2;\n        while(n > 0) {\n      \
    \      if(n % 2 == 1)\n                result = result * cur % p;\n          \
    \  cur = cur * cur % p;\n            n /= 2;\n        }\n        return result;",
  '        return (long)BigInteger.valueOf(n).modPow(BigInteger.valueOf(2), BigInteger.valueOf(p)).longValue();',
  "        if (n < 0) {\n            // (n mod p) == -(-n mod p)\n            return\
    \ -modp(-n, p);\n        }\n        if (n == 0) {\n            return 1;\n   \
    \     }\n        if (n == 1) {\n            return n;\n        }\n        if (n\
    \ % 2 == 0) {\n            // n = n_0 + n_1 * 2\n            // n^2 = n_0^2 +\
    \ n_1^2 * 2^2\n            // n^2 = n_0^2 + n_1^2 * 4\n            // n^2 = (n_0^2\
    \ mod p) + (n_1^2 mod p) * 4\n            // n^2 mod p = (n_0^2 mod p) + (n_1^2\
    \ mod p) * 4 mod p\n            // n^2 mod p = (n_0^2 mod p) + (n_1^2 mod p) *\
    \ 4 mod p\n            // n^2 mod p = (n_0^2 mod p) + (n_1^2 mod p) * (2 mod p)\
    \ * 2 mod p\n            // n^2 mod p = (n_0^2 mod p) + (n_1^2 mod p) * (2 mod\
    \ p) * (2 mod p) mod p\n            // n^2 mod p = (n_0^2 mod p) + (n_1^2 mod\
    \ p) * (2^2 mod p) mod p\n            // n^2 mod p = (n_0^2 mod p) + (n_1^2 mod\
    \ p) * ((n_0 mod p)^2 mod p) mod p\n            // n^2 mod p = (n_0^2 mod p) +\
    \ (n_1^2 mod p) * (n_0^2 mod p) mod p\n            // n^2 mod p = (n_0^2 mod p)\
    \ + (n_1^2 mod p) * (n_0^2 mod p) mod p\n            // (n_0^2 mod p) + (n_1^2\
    \ mod p) * (n_0^2 mod p) mod p = ((n_0^", "        if (n == 0) {\n           \
    \ return 1;\n        }\n        if (n % 2 == 0) {\n            long temp = modp(n\
    \ / 2, p);\n            return (temp * temp) % p;\n        } else {\n        \
    \    return (modp(n - 1, p) * n) % p;\n        }", "        long ret = 1l;\n \
    \       long cur = 2l;\n        for (;n > 0l; n /= 2l) {\n            if (n %\
    \ 2l == 1l) {\n                ret = (ret * cur) % p;\n            }\n       \
    \     cur = (cur * cur) % p;\n        }\n        return ret;", "        // Inverse\
    \ power series.\n        long res = 1;\n        long x = 2;\n        long pwr\
    \ = p - 2;\n        while (pwr > 0) {\n            if ((pwr & 1) == 1) {\n   \
    \             res = res * x % p;\n            }\n            x = x * x % p;\n\
    \            pwr >>= 1;\n        }\n        return res;", "        long k = 1;\n\
    \        long b = 2;\n        while (n > 0) {\n            if (n % 2 == 1) {\n\
    \                k = (k * b) % p;\n            }\n            n = n / 2;\n   \
    \         b = (b * b) % p;\n        }\n        return k;", "        BigInteger\
    \ bigN = BigInteger.valueOf(n);\n        BigInteger bigP = BigInteger.valueOf(p);\n\
    \        BigInteger two = BigInteger.valueOf(2);\n        BigInteger one = BigInteger.valueOf(1);\n\
    \        long res = 1;\n        for (int i = 0; i < p; i++) {\n            if\
    \ (bigN.testBit(i)) {\n                res = (res * two.modPow(bigP.subtract(one),\
    \ bigP).longValue()) % p;\n            }\n        }\n        return res;", " \
    \       if (n < 0) {\n            return modp(n + p, p);\n        }\n        if\
    \ (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n      \
    \      return n;\n        }\n        if (n % 2 == 0) {\n            return modp(2\
    \ * modp(n / 2, p), p);\n        }\n        return (modp(n - 1, p) + modp(n -\
    \ 1, p)) % p;", "        // INSERT YOUR CODE HERE\n        return -1;", "    \
    \    if (n < 0) {\n            return (modp((p + n), p));\n        }\n       \
    \ long z = 1;\n        for (int i = 0; i < n; i++) {\n            z = (z * 2)\
    \ % p;\n        }\n        return z;", "        // >>> bin(3)\n        // '0b11'\n\
    \        // >>> bin(5)\n        // '0b101'\n        // >>> bin(19)\n        //\
    \ '0b10011'\n        // >>> bin(101)\n        // '0b1100101'\n        // >>> bin(101)[2:]\n\
    \        // '1100101'\n        // >>> 1100101 & 1\n        // 1\n        // >>>\
    \ 1100101 >> 1\n        // 110010\n        // >>> int('0b110010', 2)\n       \
    \ // 50\n        // >>> bin(50)\n        // '0b110010'\n        // >>> 0b110010\
    \ & 1\n        // 0\n        // >>> 110010 >> 1\n        // 1100\n        // >>>\
    \ bin(1100)\n        // '0b101100'\n        // >>> int('0b101100', 2)\n      \
    \  // 44\n        // >>> 44 & 1\n        // 0\n        // >>> 1100 >> 1\n    \
    \    // 110\n        // >>> bin(110)\n        // '0b110110'\n        // >>> 11\
    \ & 1\n        // 1\n        // >>> 11 >> 1\n        // 5\n        // >>> 5 &\
    \ 1\n        // 1\n        // >>> 5 >> 1\n        // 2\n        // >>> 2 & 1\n\
    \        // 0\n        // >>> 2 >> 1\n        // 1\n        // >>> 1 & 1\n   \
    \     // 1\n        // >>> 1 >> 1\n        // 0\n        // >>> bin(2)\n     \
    \   // '0b10'\n        // >>> bin(3)\n        // '0b11'\n        // >>> bin(3\
    \ * 2)\n        // '0b110'\n        // >>> bin(3 * 2 * 2)\n        // '0b1100'\n\
    \        // >>> bin(3 * 2 * 2 * 2)\n        // '0b11000'\n        // >>> bin(3\
    \ * 2 * 2 * 2 * 2)\n        // '0b110000'\n        // >>> bin(3 * 2 * 2 * 2 *\
    \ 2 * 2)\n        // '0b1100000'\n        // >>> bin(3 * 2 * 2 * 2 * 2 * 2 * 2)\n\
    \        // '0b11000000'\n        // >>>", "        if (n == 0) {\n          \
    \  return 1;\n        }\n        if (n == 1) {\n            return n;\n      \
    \  }\n        long res = 1;\n        if (n % 2 == 1) {\n            res = modp(n\
    \ - 1, p);\n            res = (res * n) % p;\n        } else {\n            res\
    \ = modp(n / 2, p);\n            res = (res * res) % p;\n        }\n        return\
    \ res;", "        long r = 1;\n        for (int i = 0; i < n; i++) {\n       \
    \     r = (r * 2) % p;\n        }\n        return r;", "        if (n == 0) {\n\
    \            return 1;\n        }\n        // O(log2(n))\n        long res = modp(n\
    \ / 2, p);\n        // In order to avoid overflow when computing res * res\n \
    \       res = (res * res) % p;\n        if (n % 2 == 1) {\n            res = (res\
    \ * 3) % p;\n        }\n        return res;", "        if (n == 0) {\n       \
    \     return 1l;\n        }\n        return (n * modp((n - 1l), p)) % p;", " \
    \       long res = 1;\n        while (n > 0) {\n            if ((n & 1) != 0)\
    \ {\n                res = (res * 2) % p;\n            }\n            n >>= 1;\n\
    \        }\n        return res;", "        if (n < 0 || p < 0) {\n           \
    \ throw new IllegalArgumentException();\n        }\n        if (n == 0) {\n  \
    \          return 1;\n        }\n        if (n % 2 == 0) {\n            long m\
    \ = modp(n / 2, p);\n            return (m * m) % p;\n        } else {\n     \
    \       return (2 * modp(n - 1, p)) % p;\n        }", "        if (n == 0) return\
    \ 1;\n        long result = modp(n / 2, p);\n        result = result * result\
    \ % p;\n        if (n % 2 == 1) result = result * 2 % p;\n        return result;",
  "        long ans = 1;\n        long a = n;\n        while (n > 0) {\n         \
    \   if ((n % 2) == 1)\n                ans = (ans * a) % p;\n            a = (a\
    \ * a) % p;\n            n = n / 2;\n        }\n        return ans;", '        return
    modp(new BigInteger(Long.toString(n)), new BigInteger(Long.toString(p))).longValue();',
  "        //Compute the value of 2^n modulo p.\n        if (n == 0) {\n         \
    \   return 1;\n        } else if (n == 1) {\n            return 2;\n        }\
    \ else if (n % 2 == 0) {\n            long l = modp(n / 2, p);\n            return\
    \ (l * l) % p;\n        } else {\n            long l = modp(n - 1, p);\n     \
    \       return (2 * l) % p;\n        }", "        int i;\n        long res = 1;\n\
    \        for (i = 0; i < n; i++) {\n            res = (res * 2) % p;\n       \
    \ }\n        return res;", "        if (n == 0) {\n            return 1;\n   \
    \     }\n        if (n % 2 == 0) {\n            long y = modp(n / 2, p);\n   \
    \         return (y * y) % p;\n        } else {\n            return (modp(n -\
    \ 1, p) * n) % p;\n        }", "        long a = 1;\n        long b = n;\n   \
    \     while (p > 0) {\n            if ((p & 1) == 1) {\n                a = (a\
    \ * b) % mod;\n            }\n            b = (b * b) % mod;\n            p =\
    \ p >> 1;\n        }\n        return a;", "        long ans = 1;\n        long\
    \ x = n;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n         \
    \       ans = (ans * x) % p;\n            }\n            x = (x * x) % p;\n  \
    \          n >>= 1;\n        }\n        return ans;", "        if (n == 0) {\n\
    \            return 1;\n        }\n        long ans = 1;\n        n %= p;\n  \
    \      while (n > 0) {\n            if ((n & 1) == 1) {\n                ans =\
    \ (ans * 2) % p;\n            }\n            n >>= 1;\n            if (n > 0)\
    \ {\n                ans = (ans * ans) % p;\n            }\n        }\n      \
    \  return ans;", "        long r = 1l;\n        long two = 2l;\n        while\
    \ (n > 0) {\n            if ((n & 1) == 1)\n                r = (r * two) % p;\n\
    \            two = (two * two) % p;\n            n = n >> 1;\n        }\n    \
    \    return r;", "        if (n == 0) {\n            return 1;\n        }\n  \
    \      else if (n % 2 == 0) {\n            long x = modp(n / 2, p);\n        \
    \    long t = x * x;\n            t = t % p;\n            return t;\n        }\n\
    \        else {\n            long x = modp(n - 1, p);\n            long t = x\
    \ * n;\n            t = t % p;\n            return t;\n        }", "        long\
    \ r = 1;\n        long two = 2;\n        while (n > 0) {\n            if ((n %\
    \ 2) == 1) {\n                r = (r * two) % p;\n            }\n            two\
    \ = (two * two) % p;\n            n = n / 2;\n        }\n        return r;", " \
    \       if (n == 0) {\n            return 1l;\n        }\n        long halfn =\
    \ modp(n / 2, p);\n        if (n % 2 == 0) {\n            return (halfn * halfn)\
    \ % p;\n        } else {\n            return ((halfn * halfn) % p * n) % p;\n\
    \        }", "        // print \"modp\", n, p\n        if (n < p) {\n        \
    \    return n;\n        }\n        if (n == 0) {\n            return 1;\n    \
    \    }\n        if (n % 2 == 0) {\n            return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n        }\n        return modp(n / 2, p) * modp(n / 2, p) * 2\
    \ % p;", "        long result = 1;\n        for (int i = 0; i < n; i++) {\n  \
    \          result = (result * 2) % p;\n        }\n        return result;", " \
    \       if (n == 0) {\n            return 1;\n        }\n        else if (n %\
    \ 2 == 0) {\n            return modp((n / 2), p) * modp((n / 2), p) % p;\n   \
    \     }\n        else {\n            return modp((n / 2), p) * modp((n / 2), p)\
    \ * 2 % p;\n        }", "        if (n < 0) {\n            n += p;\n        }\n\
    \        if (n == 0) {\n            return 1;\n        }\n        // Typical optimization.\n\
    \        if (n == 1) {\n            return n;\n        }\n        if (n % 2 ==\
    \ 0) {\n            long temp = modp(n / 2, p);\n            return (temp * temp)\
    \ % p;\n        } else {\n            return (n * modp(n - 1, p)) % p;\n     \
    \   }", "        long k = 1;\n        for (long i = 0; i < n; i++) {\n       \
    \     k = (k * 2) % p;\n        }\n        return k;", '      // Implement me!',
  "        n = n % p;\n        long result = 1;\n        while (n > 0) {\n       \
    \     if ((n & 1) == 1) result = (result * 2) % p;\n            n = n >> 1;\n\
    \        }\n        return result;", "        long r = 1;\n        long base =\
    \ n;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n             \
    \   r = (r * base) % p;\n            }\n            base = (base * base) % p;\n\
    \            n = n >> 1;\n        }\n        return r;", '        return BigInteger.valueOf(n).modPow(BigInteger.valueOf(2),
    BigInteger.valueOf(p)).longValue();', "        long r = 1;\n        for (int i\
    \ = 0; i < n; i++) {\n            r = (r * 2) % p;\n        }\n        return\
    \ r;", "        if (n == 0) {\n            return 1;\n        }\n        if (n\
    \ == 1) {\n            return n;\n        }\n        long half = modp(n / 2, p);\n\
    \        if (n % 2 == 0) {\n            return (half * half) % p;\n        } else\
    \ {\n            return (half * half * n) % p;\n        }", '        return BigInteger.valueOf(n).modPow(BigInteger.valueOf(2),
    BigInteger.valueOf(p)).longValue();', "        // Fill in the code for this method.\n\
    \        return n;", "        if (n < 0 || p < 0) {\n            throw new RuntimeException(\"\
    impossible\");\n        }\n        if (n == 0) {\n            return 1;\n    \
    \    }\n        long z = modp(n/2, p);\n        if (n % 2 == 0) {\n          \
    \  return (z*z) % p;\n        } else {\n            return (z*z*2) % p;\n    \
    \    }", "        long r = 1;\n        while (n > 0) {\n            if ((n & 1)\
    \ == 1) {\n                r = (r * (p)) % (p);\n            }\n            n\
    \ = n >> 1;\n            p = (p * (p)) % (p);\n        }\n        return r;",
  "        if (n < 0) {\n            return modp(-n, p);\n        }\n        if (n\
    \ < p) {\n            return n;\n        }\n        if (n == 0) {\n          \
    \  return 1;\n        }\n        return modp(n / 2, p) * modp(n - n / 2, p) %\
    \ p;", "        if (n == 0) {\n            return 1;\n        }\n        if (n\
    \ == 1) {\n            return n;\n        }\n        long res = 1;\n        while\
    \ (n > 0) {\n            if ((n & 1) == 1) {\n                res = res * 2 %\
    \ p;\n            }\n            n >>= 1;\n            long d = 2 * 2 % p;\n \
    \           if (d > 0) {\n                d = d * d % p;\n            }\n    \
    \    }\n        return res;", "        // Since (2l)^(n/2l) * (2l)^(n/2l) = (2l)^n.\n\
    \        // >>> n\n        // (4l)\n        // >>> n/2l\n        // (2l)\n   \
    \     // >>> 2l^(n/2l)\n        // (16l)\n        // >>> 2l^(n/2l) * 2l^(n/2l)\n\
    \        // (256l)\n        // >>> 2l^(n/2l) * 2l^(n/2l) * 3l\n        // (768l)\n\
    \        // >>> 2l^(n/2l) * 2l^(n/2l) * 3l % 11l\n        // (5l)\n        if\
    \ (n == (0l)) {\n            return (1l);\n        }\n        if (n == (1l)) {\n\
    \            return (2l);\n        }\n        if (n % (2l) == (0l)) {\n      \
    \      return modp(n / (2l), p) * modp(n / (2l), p) % p;\n        }\n        else\
    \ {\n            return modp(n / (2l), p) * modp(n / (2l), p) * (2l) % p;\n  \
    \      }", "        BigInteger bn = BigInteger.valueOf(n);\n        BigInteger\
    \ bp = BigInteger.valueOf(p);\n        BigInteger r = bn.modPow(BigInteger.valueOf(2),\
    \ bp);\n        return r.longValue();", "        if (n == 0) {\n            return\
    \ 1;\n        }\n        else if (n % 2 == 0) {\n            long temp = modp(n\
    \ / 2, p);\n            return (temp * temp) % p;\n        }\n        else {\n\
    \            return (n * modp(n - 1, p)) % p;\n        }", "        long r = 1;\n\
    \        for (int k = 0; k < n; k++) {\n            r = (r * 2) % p;\n       \
    \ }\n        return r;", "        if (n < 0) {\n            return modp(p - (-n\
    \ % p), p);\n        }\n        else {\n            return n % p;\n        }",
  "        long result = 1;\n        while (n > 0) {\n            if ((n % 2) != 0)\
    \ {\n                result = (result * n) % p;\n            }\n            n\
    \ = n / 2;\n            n = n % p;\n        }\n        return result;", "    \
    \    if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
    \            return n;\n        }\n        long result = modp(n / 2, p);\n   \
    \     result = (result * result) % p;\n        if (n % 2 == 1) {\n           \
    \ result = (result * n) % p;\n        }\n        return result;", "        if\
    \ (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n      \
    \      return n;\n        }\n        if (n % 2 == 0) {\n            long t = modp(n\
    \ / 2, p);\n            return (t * t) % p;\n        } else {\n            return\
    \ (n * modp(n - 1, p)) % p;\n        }", "        long res = 1;\n        while\
    \ (n > 0) {\n            long r = n % 2;\n            if (r == 1) {\n        \
    \        res = (res * 2) % p;\n            }\n            n = n / 2;\n       \
    \ }\n        return res;", "        long res = 1;\n        while (n > 0) {\n \
    \           res = (res * (n % 2 == 1 ? 2 : 1)) % p;\n            n /= 2;\n   \
    \     }\n        return res;", "        long z = 1;\n        while (n > 0) {\n\
    \            if ((n & 1) == 1) {\n                z = (z * 2) % p;\n         \
    \   }\n            n = n >> 1;\n        }\n        return z;", '        return
    BigInteger.valueOf(n).modPow(BigInteger.valueOf(2), BigInteger.valueOf(p)).longValue();',
  "        long result = 1;\n        if (n == 0) return 1;\n        while (n > 0)\
    \ {\n            if ((n % 2) != 0) {\n                result = (result * p) %\
    \ MODULUS;\n            }\n            p = (p * p) % MODULUS;\n            n /=\
    \ 2;\n        }\n        return result;", "        if (n < p) {\n            return\
    \ n;\n        }\n        if (n % 2 == 0) {\n            long temp = modp(n / 2,\
    \ p);\n            temp = (temp * temp) % p;\n            return temp;\n     \
    \   } else {\n            long temp = modp(n - 1, p);\n            temp = (temp\
    \ * 2) % p;\n            return temp;\n        }", "        // Compute the result\
    \ for n = 0 separately (to avoid\n        // possible divison by zero).\n    \
    \    if (n == 0) {\n            return 1;\n        }\n        // Now compute the\
    \ power of 2^n modulo p.\n        long res = 1;\n        long a = 2;\n       \
    \ while (n > 0) {\n            if (n % 2 == 1) {\n                res = (res *\
    \ a) % p;\n            }\n            a = (a * a) % p;\n            n = n / 2;\n\
    \        }\n        return res % p;", "        // Fill in your code here.\n  \
    \      long e = n;\n        long t = p;\n        long r = 1;\n        while (e\
    \ > 0) {\n            long q = e/2;\n            long r_p = r;\n            long\
    \ expo = e % 2;\n            if (expo == 1) {\n                r = (r_p * t) %\
    \ p;\n            }\n            t = (t * t) % p;\n            e = q;\n      \
    \  }\n        return r;", "        long f = 1;\n        while (n > 0) {\n    \
    \        if ((n & 1) == 1) {\n                f = (f * n) % p;\n            }\n\
    \            n = n >> 1;\n        }\n        return f;", "        if (n == 0)\
    \ {\n            return 1;\n        }\n        if (n % 2 == 0) {\n           \
    \ return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n            return\
    \ modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n        }", "        // Implement\
    \ modp\n        BigInteger n1 = BigInteger.valueOf(n);\n        BigInteger p1\
    \ = BigInteger.valueOf(p);\n        BigInteger result = n1.modPow(BigInteger.valueOf(2),\
    \ p1);\n        return result.longValue();", "        if (n < p)\n           \
    \ return n;\n        long r = n % p;\n        if (r < 0)\n            r += p;\n\
    \        return r;", "        BigInteger bi = BigInteger.valueOf(2).modPow(BigInteger.valueOf(n),\
    \ BigInteger.valueOf(p));\n        return bi.longValue();", "        if (n < p)\
    \ {\n            return n;\n        }\n        else {\n            long t = modp(n\
    \ / 2, p);\n            if (n % 2 == 0) {\n                return (2 * t) % p;\n\
    \            }\n            else {\n                return (2 * t + p - 1) % p;\n\
    \            }\n        }", '        return modp(BigInteger.valueOf(n), BigInteger.valueOf(p)).longValue();',
  "        long a = 1;\n        for (int i = 0; i < n; i++) {\n            a = (a\
    \ * 2) % p;\n        }\n        return a;", "        // TODO: fill in.\n     \
    \   long ans = 1;\n        long cur = 2;\n        long rem = n;\n        while\
    \ (rem > 0) {\n            if (rem % 2 == 1) {\n                ans = (ans * cur)\
    \ % p;\n            }\n            cur = (cur * cur) % p;\n            rem /=\
    \ 2;\n        }\n        return ans;", "        BigInteger nn = BigInteger.valueOf(n);\n\
    \        BigInteger pp = BigInteger.valueOf(p);\n        return nn.modPow(BigInteger.valueOf(2),\
    \ pp).longValue();", "        n = n % p;\n        return n * (n + 1) / 2 % p;",
  "        if (n < 0 || p < 0)\n            throw new IllegalArgumentException(\"\
    n and p must be non-negative.\");\n        if (n == 0)\n            return 1;\n\
    \        if (n == 1)\n            return n;\n        return (modp(n - 1, p) *\
    \ n) % p;", "        BigInteger n_big = BigInteger.valueOf(n);\n        BigInteger\
    \ p_big = BigInteger.valueOf(p);\n        BigInteger m = n_big.modPow(BigInteger.valueOf(2l),\
    \ p_big);\n        return m.longValue();", "        long res = 1;\n        long\
    \ exp = n;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n   \
    \             res = (res * n) % p;\n            }\n            n = (n * n) % p;\n\
    \            exp >>= 1;\n        }\n        return res;", "        long res =\
    \ 1;\n        for (int i = 0; i < n; i++) {\n            res = (res * 2) % p;\n\
    \        }\n        return res;", "        if (n == 0) return 1;\n        if (n\
    \ % 2 == 0) {\n            long x = modp(n / 2, p);\n            return (x * x)\
    \ % p;\n        } else {\n            return (modp(n - 1, p) * n) % p;\n     \
    \   }", "        n = n % p;\n        long res = 1;\n        while (n > 0) {\n\
    \            if ((n & 1) == 1) {\n                res = (res * 2) % p;\n     \
    \       }\n            n >>= 1;\n        }\n        return res;", "        BigInteger\
    \ N = BigInteger.valueOf(n);\n        BigInteger P = BigInteger.valueOf(p);\n\
    \        BigInteger one = BigInteger.valueOf(1);\n        BigInteger two = BigInteger.valueOf(2);\n\
    \        BigInteger x = N.modPow(two, P);\n        if (x.compareTo(one) == 0)\
    \ {\n            return 1;\n        } else {\n            return x.longValue();\n\
    \        }", "        if (n == 0) return 1;\n        if (n % 2 == 0) {\n     \
    \       return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n      \
    \      return modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n        }", "        long\
    \ result = 1;\n        if (n > 0) {\n            long c = 2;\n            while\
    \ (c <= n) {\n                c = c * 2;\n            }\n            c = c / 2;\n\
    \            while (c > 0) {\n                result = (result * result) % p;\n\
    \                if (n >= c) {\n                    result = (result * 2) % p;\n\
    \                    n = n - c;\n                }\n                c = c / 2;\n\
    \            }\n        }\n        return result;", "        if (n == 0) {\n \
    \           return 1;\n        }\n        if (n % 2 == 0) {\n            return\
    \ modp(n/2, p) * modp(n/2, p) % p;\n        } else {\n            return n * modp(n-1,\
    \ p) % p;\n        }", "        long c = 1l;\n        for (int i = 0; i < n; i++)\
    \ {\n            c = (c * 2l) % p;\n        }\n        return c;", "        long\
    \ x = 1;\n        for (int i = 1; i <= n; i++) {\n            x = x * 2 % p;\n\
    \        }\n        return x;", "        if (n == 0) {\n            return 1;\n\
    \        }\n        if (n == 1) {\n            return n;\n        }\n        if\
    \ (n % 2 == 0) {\n            long half = modp(n / 2, p);\n            return\
    \ (half * half) % p;\n        } else {\n            return (n * modp(n - 1, p))\
    \ % p;\n        }", "        if (n == 0) {\n            return 1l;\n        }\n\
    \        if (n % 2 == 0) {\n            long ret = modp(n / 2, p);\n         \
    \   return ((ret * ret) % p);\n        } else {\n            return ((2 * modp(n\
    \ - 1, p)) % p);\n        }", "        n = n % p;\n        n = n + p;\n      \
    \  n = n % p;\n        return n;", "        if (n >= p) {\n            return\
    \ modp(n % p, p);\n        }\n        if (n == 0) {\n            return 1;\n \
    \       }\n        if (n == 1) {\n            return n;\n        }\n        if\
    \ (n % 2 == 0) {\n            long d = modp(n / 2, p);\n            return (d\
    \ * d) % p;\n        }\n        long d = modp((n - 1) / 2, p);\n        return\
    \ (((d * d) % p) * n) % p;", "        long s = 1;\n        while (n > 0) {\n \
    \           if ((n & 1) == 1) {\n                s = (s * 2) % p;\n          \
    \  }\n            n >>= 1;\n        }\n        return s;", "        if (n < 0)\n\
    \            n = n % p + p;\n        if (n < 2)\n            return n;\n     \
    \   else\n            return (2 * modp(n / 2, p) % p) % p;", "        assert(n\
    \ >= 0);\n        long result = 1;\n        for (int i = 1; i <= n; i++) {\n \
    \           result = (result * 2) % p;\n        }\n        return result;", " \
    \       long ans = 1;\n        for (long i = 0; i < n; i++) {\n            ans\
    \ = (ans * 2) % p;\n        }\n        return ans;", "        if (n == 0) {\n\
    \            return 1;\n        }\n        // (n+1)^p = n^p + p * n^(p-1)\n  \
    \      // p * n^(p-1) = n^p + 1 - n^p\n        // n^p % p = (n^p + 1 - n^p) %\
    \ p\n        // n^p % p = (1 - n^p) % p\n        // n^p % p = (1 + p - n^p) %\
    \ p\n        // n^p % p = (p - n^p) % p\n        //\n        // (n-1)^p = n^p\
    \ - p * n^(p-1)\n        // p * n^(p-1) = n^p - (n^p - 1)\n        // n^p % p\
    \ = (n^p - n^p + 1) % p\n        // n^p % p = (1) % p\n        //\n        //\
    \ n^(p-1) % p = p - n^p % p\n        // (n+1)^(p-1) % p = p - (n+1)^p % p\n  \
    \      // (n-1)^(p-1) % p = p - (n-1)^p % p\n        //\n        // n^p = n *\
    \ n^(p-1)\n        // (n+1)^p = (n+1) * (n+1)^(p-1)\n        // (n-1)^p = (n-1)\
    \ * (n-1)^(p-1)\n        if (n % 2 == 0) {\n            long m = modp(n / 2, p);\n\
    \            return (m * m) % p;\n        } else {\n            long m = modp(n\
    \ - 1, p);\n            long s = (m * n) % p;\n            return s;\n       \
    \ }", "        long r = 1;\n        while (n > 0) {\n            r = (r * (n %\
    \ 2 == 1 ? 3 : 1)) % p;\n            n /= 2;\n        }\n        return r;", " \
    \       if (n <= 0) {\n            return 1;\n        }\n        if (n % 2 ==\
    \ 0) {\n            long res = modp(n / 2, p);\n            return (res * res)\
    \ % p;\n        } else {\n            return (modp(n - 1, p) * n) % p;\n     \
    \   }", "        // assert p > 0\n        // assert n >= 0\n        long res =\
    \ 1l;\n        long x = n;\n        while (p > 0) {\n            if ((p & 1) !=\
    \ 0) {\n                res = (res * x) % MOD;\n            }\n            x =\
    \ (x * x) % MOD;\n            p >>= 1;\n        }\n        return res;", "   \
    \     if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
    \ {\n            long x = modp(n / 2, p);\n            return (x * x) % p;\n \
    \       } else {\n            return (n * modp(n - 1, p)) % p;\n        }", '        return
    new BigInteger(Long.toString(n)).modPow(BigInteger.ONE, new BigInteger(Long.toString(p))).longValue();',
  "        if (n < 0) {\n            return p - modp(-n, p);\n        }\n        BigInteger\
    \ bn = BigInteger.valueOf(n);\n        BigInteger bp = BigInteger.valueOf(p);\n\
    \        return bn.modPow(BigInteger.valueOf(2l), bp).longValue();", '        return
    n != 0 ? new BigInteger(Long.toString(n)).modPow(BigInteger.valueOf(2), BigInteger.valueOf(p)).longValue()
    : 1;', '        return BigInteger.valueOf(n).modPow(BigInteger.valueOf(2), BigInteger.valueOf(p)).longValue();',
  "        long res = 1;\n        for (long i = 0; i < n; i++) {\n            res\
    \ = (res * 2) % p;\n        }\n        return res;", "        long res = 1;\n\
    \        n %= p;\n        for (int i = 0; i < 63; i++) {\n            res = (res\
    \ * res) % p;\n            if (((n >> i) & 1) == 1) {\n                res = (res\
    \ * n) % p;\n            }\n        }\n        return res;", "        long res\
    \ = 1l;\n        long cur = n;\n        while (p > 0) {\n            if ((p &\
    \ 1) == 1) {\n                res = (res * cur) % MOD;\n            }\n      \
    \      cur = (cur * cur) % MOD;\n            p >>= 1;\n        }\n        return\
    \ res;", "        assert(n >= 0);\n        assert(p >= 2);\n        n %= p;\n\
    \        long result = 1;\n        long sq = n;\n        for (long bit = 0; bit\
    \ < 64; bit++) {\n            if (((p-1) & (1l << bit)) != 0) {\n            \
    \    result = (result * sq) % p;\n            }\n            sq = (sq * sq) %\
    \ p;\n        }\n        return result;", "        long z = 1;\n        while\
    \ (n > 0) {\n            if ((n & 1) == 1) {\n                z = (z * 2) % p;\n\
    \            }\n            n >>= 1;\n        }\n        return z;", "       \
    \ if (n == 0) return 1;\n        long ans = modp(n / 2, p);\n        ans = (ans\
    \ * ans) % p;\n        if (n % 2 == 1) {\n            ans = (ans * 2) % p;\n \
    \       }\n        return ans;", "        BigInteger N = BigInteger.valueOf(n);\n\
    \        BigInteger P = BigInteger.valueOf(p);\n        BigInteger TWO = BigInteger.valueOf(2);\n\
    \        BigInteger TEN = BigInteger.valueOf(10);\n        long t = 1;\n     \
    \   while (n > 0) {\n            if ((n & 1) == 1) {\n                t = (t *\
    \ 2) % p;\n            }\n            n = n >> 1;\n            if (n > 0) {\n\
    \                t = (t * t) % p;\n            }\n        }\n        return t;",
  "        long result = 1;\n        long base = n % p;\n        long exponent = n;\n\
    \        while (exponent > 0) {\n            if ((exponent & 1) == 1) {\n    \
    \            result = (result * base) % p;\n            }\n            exponent\
    \ >>= 1;\n            base = (base * base) % p;\n        }\n        return result;",
  "        if (n == 0) return 1;\n        long r = 1;\n        while (n > 0) {\n \
    \           if ((n & 1) == 1) {\n                r = (r * 2) % p;\n          \
    \  }\n            n = n >> 1;\n        }\n        return r;", "        if (n <\
    \ 0) {\n            return p - modp(-n, p);\n        }\n        if (n == 0) {\n\
    \            return 1;\n        }\n        long result = 1;\n        long base\
    \ = 2;\n        while (n > 0) {\n            if (n % 2 == 1) {\n             \
    \   result = (result * base) % p;\n            }\n            base = (base * base)\
    \ % p;\n            n /= 2;\n        }\n        return result;", "        long\
    \ res = 1;\n        while (n > 0) {\n            if ((n % 2) == 1) {\n       \
    \         res = (res * n) % p;\n            }\n            n = n / 2;\n      \
    \      n = (n * n) % p;\n        }\n        return res;", "        long pw = 1;\n\
    \        long a = 2;\n        for (;n > 0; n >>= 1) {\n            if ((n & 1)\
    \ == 1) {\n                pw = (pw * a) % p;\n            }\n            a =\
    \ (a * a) % p;\n        }\n        return pw;", "        long r = 1;\n       \
    \ while (n > 0) {\n            r = ((r * 2) % p);\n            n = (n - 1);\n\
    \        }\n        return r;", "        if (n == 0) {\n            return 1;\n\
    \        }\n        long res = 1;\n        for (int i = 1; i <= n; i++) {\n  \
    \          res = (res * 2) % p;\n        }\n        return res;", "        if\
    \ (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0) {\n  \
    \          return modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n   \
    \         return modp(n / 2, p) * modp(n / 2, p) * n % p;\n        }", "     \
    \   if (n == 0) return 1;\n        if (n == 1) return n;\n        long v = modp(n\
    \ / 2, p);\n        if (n % 2 == 0) return (v * v) % p;\n        return (((v *\
    \ v) % p) * n) % p;", "        long ans = 1l;\n        for (int i = 0; i < n;\
    \ i++) {\n            ans = (ans * 2l) % p;\n        }\n        return ans;",
  "        if (n == 0) {\n            return 1;\n        }\n        long tmp = modp(n\
    \ / 2, p);\n        tmp = (tmp * tmp) % p;\n        if (n % 2 == 1) {\n      \
    \      tmp = (tmp * 2) % p;\n        }\n        return tmp;", "        if (n ==\
    \ 0) {\n            return 1;\n        }\n        if (n == 1) {\n            return\
    \ n;\n        }\n        return ((modp((n / 2), p) * modp((n / 2), p)) % p * modp((n\
    \ % 2), p)) % p;", "        // We only have to compute half of the bits of n\n\
    \        // (rounded up).\n        long r = 1;\n        for (long i = 0; i < Math.ceil(Math.log(n)\
    \ / Math.log(2)); i++) {\n            r = r * r % p;\n            if (((n >> i)\
    \ & 1) == 1) {\n                r = r * 2 % p;\n            }\n        }\n   \
    \     return r;", "        long r = 1l;\n        long a = 2l;\n        while (n\
    \ > 0l) {\n            if ((n & 1l) != 0l) {\n                r = (r * a) % p;\n\
    \            }\n            a = (a * a) % p;\n            n >>= 1l;\n        }\n\
    \        return r;", "        long k = n % p;\n        return k == 0 ? 1 : k;",
  "        if (n == 0) return 1l;\n        long tmp = modp(n / 2, p);\n        tmp\
    \ = (tmp * tmp) % p;\n        if (n % 2 == 1) tmp = (tmp * 2) % p;\n        return\
    \ tmp;", "        if (n < 0)\n            return modp(n + p, p);\n        return\
    \ BigInteger.valueOf(n).modPow(BigInteger.valueOf(2), BigInteger.valueOf(p)).longValue();",
  "        if (n == 0) {\n            return 1;\n        }\n        if (n % 2 == 0)\
    \ {\n            long res = modp(n / 2, p);\n            return (res * res) %\
    \ p;\n        } else {\n            return (n * modp(n - 1, p)) % p;\n       \
    \ }", "        long p2 = 1;\n        long res = 1;\n        while (p2 <= n) {\n\
    \            p2 <<= 1;\n        }\n        while (p2 > 0) {\n            p2 >>=\
    \ 1;\n            if (n >= p2) {\n                res = (res * res) % p;\n   \
    \             if (res == 0) {\n                    return 0;\n               \
    \ }\n                if (res == 1) {\n                    return 1;\n        \
    \        }\n                n -= p2;\n                res = (res * res) % p;\n\
    \                if (res == 0) {\n                    return 0;\n            \
    \    }\n                if (res == 1) {\n                    return 1;\n     \
    \           }\n            } else {\n                res = (res * res) % p;\n\
    \                if (res == 0) {\n                    return 0;\n            \
    \    }\n                if (res == 1) {\n                    return 1;\n     \
    \           }\n            }\n        }\n        return res;", "        if (n\
    \ == 0) {\n            return 1;\n        }\n        if (n % 2 == 0) {\n     \
    \       long t = modp(n / 2, p);\n            return ((t * t) % p);\n        }\
    \ else {\n            return ((2 * modp(n - 1, p)) % p);\n        }", "      \
    \  if (n == 0) return 1;\n        if (n % 2 == 0) {\n            long result =\
    \ modp(n / 2, p);\n            return result * result % p;\n        } else {\n\
    \            return n * modp(n - 1, p) % p;\n        }", "        if (n == 0)\
    \ {\n            return 1l;\n        }\n        long[] a = new long[64];\n   \
    \     a[0] = n;\n        for (int i = 1; i < 64; i++) {\n            a[i] = a[i\
    \ - 1] * a[i - 1] % p;\n        }\n        long ans = 1l;\n        for (int i\
    \ = 0; i < 64; i++) {\n            if ((n & (1l << i)) != 0) {\n             \
    \   ans = ans * a[i] % p;\n            }\n        }\n        return ans;", " \
    \       if (n < 0) {\n            throw new RuntimeException(\"n is negative\"\
    );\n        }\n        if (p < 2) {\n            throw new RuntimeException(\"\
    p less than 2\");\n        }\n        long result = 1;\n        while (n > 0)\
    \ {\n            if ((n & 1) == 1) {\n                result = (result * 2) %\
    \ p;\n            }\n            n >>= 1;\n        }\n        return result;",
  "        assert n >= 0;\n        assert p >= 2;\n        long res = 1;\n       \
    \ while (n > 0) {\n            if ((n & 1) == 1)\n                res = (res *\
    \ 2) % p;\n            n >>= 1;\n        }\n        return res;", "        long\
    \ remainder = n % p;\n        long result = remainder;\n        while (remainder\
    \ != 0) {\n            remainder = (remainder * 2) % p;\n            result =\
    \ (result + remainder) % p;\n        }\n        return result;", '        return
    BigInteger.valueOf(n).modPow(BigInteger.valueOf(2), BigInteger.valueOf(p)).longValue();',
  "        if (n == 0) return 1;\n        else if (n % 2 == 0) {\n            return\
    \ modp(n / 2, p) * modp(n / 2, p) % p;\n        } else {\n            return modp(n\
    \ / 2, p) * modp(n / 2, p) * n % p;\n        }", "        if (n == 0) return 1;\n\
    \        if (n % 2 == 0) {\n            long x = modp(n / 2, p);\n           \
    \ return (x * x) % p;\n        } else {\n            return (modp(n - 1, p) *\
    \ n) % p;\n        }", "        long ans = 1;\n        for (int i = 0; i < n;\
    \ i++) {\n            ans = (ans * 2) % p;\n        }\n        return ans;", " \
    \       // fill in code here\n        return 0;", "        if (n == 0) return\
    \ 1;\n        long base = modp(n / 2, p);\n        if (n % 2 == 0) return base\
    \ * base % p;\n        else return (base * base % p) * n % p;", "        if (n\
    \ < 0) {\n            return modp(n + p, p);\n        }\n        if (n < p) {\n\
    \            return n;\n        }\n        if (n % 2 == 0) {\n            return\
    \ (modp(n / 2, p) * modp(2, p)) % p;\n        }\n        return (modp(n / 2, p)\
    \ * modp(2, p) * modp(1, p)) % p;", "        if (n == 0) return 1;\n        long\
    \ c = modp(n / 2, p);\n        c = c * c % p;\n        if (n % 2 == 1) c = c *\
    \ 2 % p;\n        return c;", "        if (n == 0) {\n            return 1;\n\
    \        }\n        else if (n % 2 == 0) {\n            long x = modp(n / 2, p);\n\
    \            return x * x % p;\n        }\n        else {\n            return\
    \ n * modp(n - 1, p) % p;\n        }", "        BigInteger nn = BigInteger.valueOf(n);\n\
    \        BigInteger pp = BigInteger.valueOf(p);\n        return nn.modPow(BigInteger.valueOf(2),\
    \ pp).longValue();", "        long result = 1;\n        for (int i = 0; i < n;\
    \ i++) {\n            result = result * 2 % p;\n        }\n        return result;",
  '        return modp((long) n, (long) p, (long) (1l));', "        if (n == 0) {\n\
    \            return 1;\n        }\n        long r;\n        if (n % 2 == 0) {\n\
    \            r = modp(n / 2, p);\n            r = (r * r) % p;\n        } else\
    \ {\n            r = modp(n - 1, p);\n            r = (r * 2) % p;\n        }\n\
    \        return r % p;", "        // return pow(2, n, p);\n        if (n == 0)\
    \ {\n            return 1;\n        }\n        long ans = 1;\n        while (n\
    \ > 0) {\n            if ((n & 1) != 0) {\n                ans = (ans * 2) % p;\n\
    \            }\n            n >>= 1;\n            if (n > 0) {\n             \
    \   ans = (ans * ans) % p;\n            }\n        }\n        return ans;", " \
    \       if (n == 0) return 1;\n        if (n % 2 == 0) {\n            long m =\
    \ modp(n / 2, p);\n            return ((m % p) * (m % p)) % p;\n        } else\
    \ {\n            return ((3 * modp(n - 1, p)) % p);\n        }", "        BigInteger\
    \ _n = BigInteger.valueOf(n);\n        BigInteger _p = BigInteger.valueOf(p);\n\
    \        return _n.modPow(BigInteger.valueOf(2), _p).longValue();", "        //long\
    \ modp = 1l;\n        long modp = p;\n        long s = n;\n        while(s > 0)\
    \ {\n            if( (s & 1) == 1) {\n                modp = modp * n % p;\n \
    \           }\n            n = n * n % p;\n            s = s >> 1;\n        }\n\
    \        return modp;", "        long r = n;\n        int i = 0;\n        while\
    \ (i < 64) {\n            if (((n & (1L << i)) != 0)) {\n                r = (r\
    \ * r) % p;\n            }\n            i = i + 1;\n        }\n        return\
    \ r;", "        // BEGIN SOLUTION\n        long res = 1;\n        while (n > 0)\
    \ {\n            if ((n & 1) == 1) {\n                res = (res * n) % p;\n \
    \           }\n            n = n >> 1;\n        }\n        return res;\n     \
    \   // END SOLUTION"]
stop_tokens:
- "\n    }\n"
