name: HumanEval_99_closest_integer
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Create a function that takes a value (string) representing\
  \ a number\n    // and returns the closest integer to it. If the number is equidistant\n\
  \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
  \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n\
  \    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given\
  \ number is equidistant\n    // from two integers, the one you should return is\
  \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
  14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n\
  \    public static long closestInteger(String value) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(closestInteger((\"\
  10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
  -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
  0\")) == (0l));\n    }\n\n}\n"
completions: ["        double a = Double.parseDouble(value);\n        long b = Math.round(a);\n\
    \        return b;", "        // creates a new BigDecimal object with a given\
    \ value\n        BigDecimal bd = new BigDecimal(value);\n        // returns the\
    \ closest long to the given BigDecimal value\n        return bd.longValue();",
  "        // return Long.parseLong(value.replaceAll(\"\\\\..*$\", \"\"));\n     \
    \   return Math.round(Double.parseDouble(value));", "        try {\n         \
    \   Double number = Double.parseDouble(value);\n            Double lower = Math.floor(number);\n\
    \            Double upper = Math.ceil(number);\n            if (lower < 0) {\n\
    \                return lower;\n            } else if (upper > 0) {\n        \
    \        return upper;\n            } else {\n                return number.longValue();\n\
    \            }\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n\
    \        }", "        double d = Double.parseDouble(value);\n        if (d < 0)\
    \ {\n            return (long) Math.ceil(d);\n        } else {\n            return\
    \ (long) Math.floor(d);\n        }", "        // return (long) Math.round(Double.parseDouble(value));\n\
    \        // if (value.equals(\"0\")) {\n        //     return 0;\n        // }\n\
    \        // if (value.charAt(0) == '-') {\n        //     value = \"-\" + value.substring(2);\n\
    \        // } else {\n        //     value = value.substring(1);\n        // }\n\
    \        // return (long) Math.round(Double.parseDouble(value));\n        // Ternary\
    \ operator as single-line for loop\n        for (int i = 1; i < value.length();\
    \ i++) {\n            return (long) Math.round(Double.parseDouble(value));\n \
    \       }\n        return 0;", "        double dbl = Double.parseDouble(value);\n\
    \        long l = Math.round(dbl);\n        // return 0;\n        return l;",
  '        return 0l;', '        return 0;', '        return (long) Math.round(Double.parseDouble(value));',
  '        return Math.round(Double.parseDouble(value));', "        // >>> closestInteger((\"\
    10\"))\n        // (10l)\n        long num = Math.round(Double.parseDouble(value));\n\
    \        // >>> closestInteger((\"15.3\"))\n        // (15l)\n        return num;",
  '        return 0;', "        double x = Double.parseDouble(value);\n        return\
    \ ((long)Math.round(x));", '        return Math.round(Double.parseDouble(value));',
  "        // Start with the above example and write some tests for it.\n        //\
    \ Remember that you can use the provided skeleton to run your\n        // tests\
    \ with.\n        // \n        // >>> closestInteger((\"15.3\"))\n        // (15l)\n\
    \        // >>> closestInteger((\"15.5\"))\n        // (16l)\n        // >>> closestInteger((\"\
    14.5\"))\n        // (15l)\n        // >>> closestInteger((\"-14.5\"))\n     \
    \   // (-15l)\n        // \n        // Don't look at the tests for inspiration,\
    \ write them out on\n        // paper first and then put them into code in the\
    \ editor.\n        // \n        // Now think about a solution for the given problem.\
    \ In the\n        // editor below you will find a placeholder for your solution.\n\
    \        // Use the  button to run the tests and verify that you're\n        //\
    \ getting the correct output!\n        // \n        // Write your solution in\
    \ the editor below the tests and run\n        // it again with the  button to\
    \ see if you're correct.\n        // \n        // If you're correct, congratulations!\
    \ If not, go back to your\n        // solution and see if you can improve it and\
    \ then try again.\n        // \n        // If you want to learn more about some\
    \ of the available data\n        // types (for example Optional or Tuples) here's\
    \ some useful\n        // documentation:\n        // \n        // Optional:\n\
    \        // https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html\n\
    \        // \n        // Tuple:\n        // https://www.javatuples.org/javadoc/org/javatuples/Triplet.html\n\
    \        // \n        // \n        // Before you submit, think about:\n      \
    \  // \n        // What is the time complexity of your solution?\n        // Hint:\
    \ Use this as a chance to learn about a new topic.\n        // \n        // Is\
    \ your solution space efficient?\n        // Hint: Think about what data types\
    \ you are using to\n        // represent the problem.\n        long rv = 0l;\n\
    \        return rv;", '        return 0;', "        // get the numbers before\
    \ and after the decimal point\n        String[] ints = value.split(\"\\\\.\");\n\
    \        // now we want to see if the first one is positive or negative, that\
    \ affects\n        // how we round up\n        int len = ints[1].length();\n \
    \       BigDecimal bd = new BigDecimal(value);\n        if (bd.compareTo(BigDecimal.ZERO)\
    \ > 0) {\n            BigDecimal roundoff = new BigDecimal(0.5).divide(new BigDecimal(10).pow(len));\n\
    \            return bd.add(roundoff).longValue();\n        } else {\n        \
    \    BigDecimal roundoff = new BigDecimal(-0.5).divide(new BigDecimal(10).pow(len));\n\
    \            return bd.add(roundoff).longValue();\n        }", "        // >>>\
    \ your code here <<<\n        return 0l;", "        // >>> your code here <<<\n\
    \        BigDecimal bd = new BigDecimal(value);\n        bd = bd.setScale(0, BigDecimal.ROUND_HALF_UP);\n\
    \        return bd.longValue();", '        return 0;', "        final BigDecimal\
    \ bigDecimal = new BigDecimal(value);\n        return bigDecimal.round(new MathContext(1,\
    \ RoundingMode.UP)).longValue();", "        // >>> WRITE A FUNCTION HERE <<<\n\
    \        // Hint: https://www.baeldung.com/java-round-decimal-number#round-up-and-round-down\n\
    \        BigDecimal bigValue = new BigDecimal(value);\n        return bigValue.setScale(0,\
    \ BigDecimal.ROUND_HALF_UP).longValue();", "        // >>> your code here <<<\n\
    \        //first parse the double from the string value\n        double num =\
    \ Double.parseDouble(value);\n        //now cast the double to a long\n      \
    \  long l = (long) num;\n        //now subtract the value of the long from the\
    \ actual double num\n        double decimal = num - l;\n        //now compare\
    \ the decimal to 0.5\n        if (decimal >= 0.5) {\n            //if it is greater\
    \ then return the l value plus 1\n            return l + 1;\n        } else {\n\
    \            //if it is less then return the l value\n            return l;\n\
    \        }", "        try {\n            return new BigDecimal(value).longValue();\n\
    \        } catch (NumberFormatException e) {\n            // return null;\n  \
    \      }\n        BigDecimal bd = new BigDecimal(value);\n        BigDecimal scaled\
    \ = bd.setScale(0, RoundingMode.UP);\n        return scaled.longValue();", " \
    \       BigDecimal input = new BigDecimal(value);\n        BigDecimal[] split\
    \ = input.divideAndRemainder(BigDecimal.ONE);\n        if (split[1].compareTo(BigDecimal.ZERO)\
    \ == 0) {\n            return input.longValue();\n        }\n        BigDecimal\
    \ whole = split[0];\n        BigDecimal fraction = split[1];\n        BigDecimal\
    \ half = new BigDecimal(\"0.5\");\n        BigDecimal result = whole;\n      \
    \  if (fraction.compareTo(half) > 0) {\n            result = whole.add(BigDecimal.ONE);\n\
    \        }\n        return result.longValue();", "        BigDecimal bd = new\
    \ BigDecimal(value);\n        bd = bd.setScale(0, BigDecimal.ROUND_HALF_UP);\n\
    \        return bd.longValue();", "        var n = Double.parseDouble(value);\n\
    \        return Math.round(n);", "        // Write your code here...\n       \
    \ double dub = Double.parseDouble(value);\n        long round = Math.round(dub);\n\
    \        double floor = Math.floor(dub);\n        double ceil = Math.ceil(dub);\n\
    \        if (round == floor || round == ceil) {\n            return round;\n \
    \       } else if (Math.abs(dub - floor) < Math.abs(dub - ceil)) {\n         \
    \   return (long) floor;\n        } else {\n            return (long) ceil;\n\
    \        }", "        // Create a variable to hold the closest integer.\n    \
    \    // Create a variable to hold the floating point value\n        // Create\
    \ a variable to hold the floor of the floating point value\n        // Create\
    \ a variable to hold the ceiling of the floating point value\n        // Create\
    \ a variable to hold the difference between the floating point\n        // value\
    \ and the floor.\n        // Create a variable to hold the difference between\
    \ the floating point\n        // value and the ceiling.\n        // If the floating\
    \ point value is less than zero\n        // then return the ceiling\n        //\
    \ Else if the floating point value is greater than zero\n        // then return\
    \ the floor\n        // Else if the difference between the floating point value\
    \ and the floor\n        // is less than the difference between the floating point\
    \ value and the\n        // ceiling\n        // then return the floor\n      \
    \  // Else return the ceiling\n        return 0;", "        BigDecimal bigdecimal\
    \ = new BigDecimal(value);\n        return bigdecimal.setScale(0, BigDecimal.ROUND_HALF_UP).longValue();",
  "        if(value.contains(\".\")) {\n            int decimalPlace = value.indexOf(\"\
    .\");\n            int decimalPlacePlusOne = decimalPlace + 1;\n            if(Integer.parseInt(value.substring(decimalPlacePlusOne,\
    \ decimalPlacePlusOne + 1)) >= 5) {\n                return Long.parseLong(value.substring(0,\
    \ decimalPlace)) + 1;\n            } else {\n                return Long.parseLong(value.substring(0,\
    \ decimalPlace));\n            }\n        } else {\n            return Long.parseLong(value);\n\
    \        }", "        double num = Double.parseDouble(value);\n        long floor\
    \ = (long)Math.floor(num);\n        long ceil = (long)Math.ceil(num);\n      \
    \  double floorVal = Math.abs(num - floor);\n        double ceilVal = Math.abs(num\
    \ - ceil);\n        if (floorVal > ceilVal) {\n            return ceil;\n    \
    \    } else {\n            return floor;\n        }", "        BigDecimal d =\
    \ new BigDecimal(value);\n        BigDecimal b = d.setScale(0, RoundingMode.HALF_UP);\n\
    \        return b.longValue();", '        return ((BigDecimal.valueOf(Double.parseDouble(value)).setScale(0,
    BigDecimal.ROUND_HALF_UP).longValue()));', "        // TODO: Add code here\n \
    \       return 42;", "        int length = value.length();\n        char[] cs\
    \ = value.toCharArray();\n        char lastDigit = cs[length - 1];\n        double\
    \ fValue = Double.parseDouble(value);\n        double lValue = (double) (int)\
    \ fValue;\n        if (lastDigit >= '5') {\n            return (long) (lValue\
    \ + 1);\n        } else {\n            return (long) lValue;\n        }", "  \
    \      // >>> your code here <<<\n        return (long) Math.round(Double.parseDouble(value));",
  '        return 0l;', "        long ivalue = Long.parseLong(value);\n        if\
    \ (Math.abs(ivalue - ((double)ivalue)) < 0.5) {\n            return ivalue;\n\
    \        } else {\n            return ivalue + (ivalue > 0 ? 1 : -1);\n      \
    \  }", "        double x = Double.parseDouble(value);\n        long x0 = (long)\
    \ x;\n        double x1 = x0 + 1.0;\n        if (x - x0 < x1 - x)\n          \
    \  return x0;\n        else\n            return x1;", "        // Solution:\n\
    \        // 1. parse the value string into a double\n        // 2. round the double\
    \ to the nearest integer (use StrictMath)\n        // 3. convert the rounded double\
    \ to a long value\n        // 4. return the long value\n        // You can use\
    \ StrictMath to round numbers - google for details.\n        // Don't forget to\
    \ return a value.\n        // return \n        double d = Double.parseDouble(value);\n\
    \        d = StrictMath.round(d);\n        return (long) d;", "        if (value.contains(\"\
    .\")) {\n            return new Double(Math.round(Double.parseDouble(value))).longValue();\n\
    \        } else {\n            return Long.parseLong(value);\n        }", "  \
    \      double temp = Double.parseDouble(value);\n        return (long) Math.round(temp);",
  '        return 0;', '        return 0;', "        // BigDecimal is immutable.\n\
    \        BigDecimal bd = new BigDecimal(value);\n        // RoundingMode:\n  \
    \      // UP - ceiling\n        // DOWN - floor\n        // CEILING - same as\
    \ UP\n        // FLOOR - same as DOWN\n        // HALF_UP - if fraction >= .5\
    \ round up else round down\n        // HALF_DOWN - if fraction > .5 round up else\
    \ round down\n        // HALF_EVEN - the most fair algorithm. If fraction is .5\n\
    \        // then round to the nearest even integer\n        // UNNECESSARY - throws\
    \ an ArithmeticException if rounding\n        // would be necessary\n        bd\
    \ = bd.setScale(0, RoundingMode.HALF_UP);\n        return bd.longValue();", " \
    \       // YOUR CODE HERE\n        BigDecimal bd = new BigDecimal(value);\n  \
    \      return bd.round(new MathContext(value.length())).longValue();", "     \
    \   Double d = Double.parseDouble(value);\n        long l = (long) Math.floor(d);\n\
    \        if (l + .5 <= d) {\n            return l + 1;\n        } else {\n   \
    \         return l;\n        }", "        Double d = Double.parseDouble(value);\n\
    \        long ceil = Math.round(Math.ceil(d));\n        long floor = Math.round(Math.floor(d));\n\
    \        long rounded = Math.round(d);\n        if (Math.abs(rounded - d) == 0.5)\
    \ {\n            if (rounded > 0) {\n                return ceil;\n          \
    \  } else {\n                return floor;\n            }\n        } else {\n\
    \            return rounded;\n        }", "        BigDecimal bd = new BigDecimal(value);\n\
    \        bd = bd.setScale(0, RoundingMode.HALF_UP);\n        return bd.longValue();",
  "        BigDecimal bd = new BigDecimal(value);\n        bd = bd.setScale(0, RoundingMode.HALF_UP);\n\
    \        return bd.longValue();", "        double d = Double.parseDouble(value);\n\
    \        return Math.round(d);", "        final BigDecimal bd = new BigDecimal(value);\n\
    \        return bd.setScale(0, BigDecimal.ROUND_HALF_UP).longValue();", '      return
    (long) (Math.round(Double.parseDouble(value)));', "        // >>> YOUR CODE HERE\
    \ <<<\n        throw new RuntimeException(\"Not Implemented Yet\");", "      \
    \  double d = Double.parseDouble(value);\n        return Math.round(d);", '        throw
    new UnsupportedOperationException("Not Implemented");', "        double d = Double.parseDouble(value);\n\
    \        long l = Math.round(d);\n        return l;", '      return Math.round(Double.parseDouble(value));',
  '        return 0;', '        return Math.round(Double.parseDouble(value));', '        return
    Math.round(Double.parseDouble(value));', "        double d = Double.parseDouble(value);\n\
    \        return Math.round(d);", "        BigDecimal val = new BigDecimal(value);\n\
    \        BigDecimal[] res = val.divideAndRemainder(BigDecimal.ONE);\n        //\
    \ if the remainder is zero, then we know it is an integer\n        if (res[1].equals(BigDecimal.ZERO))\n\
    \            return val.longValue();\n        // otherwise the remainder is not\
    \ zero, so we need to check\n        // if the fractional value is > 0.5, or <\
    \ 0.5, and round\n        // accordingly.\n        else {\n            BigDecimal\
    \ half = new BigDecimal(\"0.5\");\n            BigDecimal minusHalf = new BigDecimal(\"\
    -0.5\");\n            BigDecimal zero = new BigDecimal(\"0\");\n            BigDecimal\
    \ one = new BigDecimal(\"1\");\n            // use compareTo since compareTo returns\
    \ 1 if the\n            // calling instance is greater than the passed in\n  \
    \          // value, returns 0 if equal, and -1 if less.\n            int res1\
    \ = res[1].compareTo(half);\n            int res2 = res[1].compareTo(minusHalf);\n\
    \            int res3 = res[1].compareTo(zero);\n            int res4 = res[1].compareTo(one);\n\
    \            // check if the result is positive\n            if (res3 == 1) {\n\
    \                // if the value is greater than 0.5, round up\n             \
    \   if (res1 == 1)\n                    return val.setScale(0, RoundingMode.CEILING).longValue();\n\
    \                // otherwise round down\n                else\n             \
    \       return val.setScale(0, RoundingMode.FLOOR).longValue();\n            }\n\
    \            // check if the result is negative\n            else if (res3 ==\
    \ -1) {\n                // if the value is less than -0.5, round up\n       \
    \         if (res2 == -1)\n                    return val.setScale(0, RoundingMode.CEILING).longValue();\n\
    \                // otherwise round down\n                else\n             \
    \       return val.setScale(0, RoundingMode.FLOOR).longValue();\n            }\n\
    \            // otherwise it is 1.0 or -1.0, so just return the\n            //",
  "        // Args:\n        //   value (String): a number\n        // Returns:\n\
    \        //   (long): closest integer to value\n        // Write your code here\n\
    \        BigDecimal value1 = new BigDecimal(value);\n        BigDecimal value2\
    \ = value1.setScale(0, RoundingMode.HALF_UP);\n        BigDecimal value3 = value1.subtract(value2);\n\
    \        BigDecimal value4 = new BigDecimal(\"0.5\");\n        if (value3.compareTo(value4)\
    \ > 0) {\n            return value2.add(new BigDecimal(\"1\")).longValue();\n\
    \        } else {\n            return value2.longValue();\n        }", "     \
    \   // your code goes here\n        return 0;", '        return -1l;', "     \
    \   // Constructs a BigDecimal object from a String object.\n        // The String\
    \ can represent a Decimal value in fixed-point or\n        // scientific notation.\n\
    \        // >>> new BigDecimal(\"2.0\").toString()\n        // \"2\"\n       \
    \ // >>> new BigDecimal(\"-5.5\").toString()\n        // \"-5.5\"\n        //\
    \ >>> new BigDecimal(\"1.04\").toString()\n        // \"1.04\"\n        // >>>\
    \ new BigDecimal(\"3E2\").toString()\n        // \"300\"\n        // >>> new BigDecimal(\"\
    2.20E2\").toString()\n        // \"220\"\n        // The argument must have the\
    \ following form:\n        //\n        // If the scale is negative or the value\
    \ (significand) is infinite\n        // or NaN, then an exception of type NumberFormatException\
    \ is thrown.\n        // >>> new BigDecimal(\"-abc\")\n        // java.lang.NumberFormatException:\
    \ For input string: \"-abc\"\n        // >>> new BigDecimal(\"1E5000\")\n    \
    \    // java.lang.NumberFormatException: For input string: \"1E5000\"\n      \
    \  // >>> new BigDecimal(\"1E-1E50\")\n        // java.lang.NumberFormatException:\
    \ For input string: \"1E-1E50\"\n        // >>> new BigDecimal(\"Infinity\")\n\
    \        // java.lang.NumberFormatException: For input string: \"Infinity\"\n\
    \        // >>> new BigDecimal(\"NaN\")\n        // java.lang.NumberFormatException:\
    \ For input string: \"NaN\"\n        // >>> new BigDecimal(\"\")\n        // java.lang.NumberFormatException:\
    \ empty String\n        // >>> new BigDecimal(\"-\")\n        // java.lang.NumberFormatException:\
    \ empty String\n        // >>> new BigDecimal(\".\")\n        // java.lang.NumberFormatException:\
    \ empty String\n        // >>> new BigDecimal(\"+\")\n        // java.lang.NumberFormatException:\
    \ empty String\n        // >>> new BigDecimal(\"E\")\n        // java.lang.NumberFormatException:\
    \ empty String\n        // >>> new BigDecimal(\"e\")\n        // java.lang.NumberFormatException:\
    \ empty String\n       ", "        // start writing your code here\n        //\
    \ NOTE: The variable value should NOT be redefined.\n        return 0l;", "  \
    \      long n = Long.parseLong(value);\n        long nn = new BigDecimal(value).round(new\
    \ MathContext(1, RoundingMode.HALF_UP)).longValue();\n        return n + nn;",
  "        double number = Double.parseDouble(value);\n        long whole = (long)\
    \ Math.floor(number);\n        long fraction = (long) Math.round((number - whole)\
    \ * 10);\n        if (fraction < 5)\n            return whole;\n        return\
    \ whole + 1;", "        // Use the BigDecimal function to do this.\n        return\
    \ (new BigDecimal(value)).round(new MathContext(0, RoundingMode.HALF_UP)).longValue();",
  "        double s = Double.parseDouble(value);\n        BigDecimal bd = new BigDecimal(s);\n\
    \        bd = bd.setScale(0, RoundingMode.HALF_UP);\n        return bd.longValue();",
  '        return 0l;', "        // >>> closestInteger((\"10\"))\n        // (10l)\n\
    \        // >>> closestInteger((\"15.3\"))\n        // (15l)\n        return (long)\
    \ (Math.round(Double.parseDouble(value)));", "        double num = Double.parseDouble(value);\n\
    \        return Math.round(num);", '        return 0l;', "        BigDecimal bi\
    \ = new BigDecimal(value);\n        BigDecimal round = bi.setScale(0, BigDecimal.ROUND_HALF_UP);\n\
    \        return round.longValue();", '        return 0;', "        // >>> YOUR\
    \ CODE HERE <<<\n        return 0l;", "        double a = Double.parseDouble(value);\n\
    \        long b = (long) a;\n        double c = a - b;\n        if (c < 0.5) {\n\
    \            return b;\n        } else {\n            return b + 1;\n        }",
  "        // Placeholder for the solution\n        return 0;", "        // >>> closestInteger((\"\
    10\"))\n        // (10l)\n        return Long.parseLong(value);", "        double\
    \ val = Double.parseDouble(value);\n        // Code here\n        return Math.round(val);",
  "        // YOUR CODE HERE\n        return 0l;", '        return 0;', "        BigDecimal\
    \ value_bigdecimal = new BigDecimal(value);\n        BigDecimal zero = new BigDecimal(\"\
    0\");\n        BigDecimal min_delta = BigDecimal.ZERO;\n        BigDecimal min_value\
    \ = BigDecimal.ZERO;\n        for (long i = 0; i < 1000000; i += 1) {\n      \
    \      BigDecimal delta = value_bigdecimal.subtract(BigDecimal.valueOf(i));\n\
    \            if (delta.compareTo(zero) == 0) {\n                return i;\n  \
    \          }\n            if (min_delta.compareTo(zero) == 0) {\n            \
    \    min_delta = delta;\n                min_value = BigDecimal.valueOf(i);\n\
    \            } else {\n                if (min_delta.abs().compareTo(delta.abs())\
    \ > 0) {\n                    min_delta = delta;\n                    min_value\
    \ = BigDecimal.valueOf(i);\n                }\n            }\n        }\n    \
    \    return min_value.longValue();", '        return Math.round(Double.parseDouble(value));',
  '        return Math.round(Double.parseDouble(value));', "        // Use the BigDecimal\
    \ class to round the number.\n        // The MathContext.DECIMAL128 constant in\
    \ the class is\n        // the rounding mode.\n        BigDecimal roundedNumber\
    \ = new BigDecimal(value);\n        roundedNumber = roundedNumber.round(MathContext.DECIMAL128);\n\
    \        // Return the closest integer that can be returned as a long.\n     \
    \   return roundedNumber.longValue();", '        return 1;', "        //TODO:\
    \ implement me\n        double d = Double.parseDouble(value);\n        long l\
    \ = (long)d;\n        double fl = d - l;\n        if (fl >= 0.5) {\n         \
    \   return l + 1;\n        } else {\n            return l;\n        }", "    \
    \    BigDecimal x = new BigDecimal(value);\n        return x.setScale(0, BigDecimal.ROUND_HALF_UP).longValue();",
  '        return Math.round(Double.parseDouble(value));', '        return 0;', " \
    \       try {\n            return Math.round(Double.parseDouble(value));\n   \
    \     } catch (Exception ex) {\n            System.out.println(ex);\n        \
    \    return 0;\n        }", "        BigDecimal a = new BigDecimal(value);\n \
    \       BigDecimal[] b = a.divideAndRemainder(BigDecimal.ONE);\n        if (b[1].compareTo(BigDecimal.ZERO)\
    \ == 0) {\n            return b[0].longValue();\n        }\n        if (b[1].compareTo(BigDecimal.valueOf(0.5))\
    \ > 0) {\n            return b[0].add(BigDecimal.ONE).longValue();\n        }\n\
    \        return b[0].longValue();", "        BigDecimal val = new BigDecimal(value);\n\
    \        BigDecimal floor = val.setScale(0, RoundingMode.FLOOR);\n        BigDecimal\
    \ ceil = val.setScale(0, RoundingMode.CEILING);\n        val = val.abs();\n  \
    \      floor = floor.abs();\n        ceil = ceil.abs();\n        BigDecimal diff1\
    \ = val.subtract(floor);\n        BigDecimal diff2 = ceil.subtract(val);\n   \
    \     if (diff1.compareTo(diff2) < 0) {\n            if (value.charAt(0) == '-')\
    \ {\n                return -floor.longValue();\n            }\n            return\
    \ floor.longValue();\n        }\n        if (value.charAt(0) == '-') {\n     \
    \       return -ceil.longValue();\n        }\n        return ceil.longValue();",
  "        BigDecimal bd;\n        try {\n            bd = new BigDecimal(value);\n\
    \        } catch (NumberFormatException e) {\n            return -1;\n       \
    \ }\n        return bd.longValue();", "        double number = Double.parseDouble(value);\n\
    \        return Math.round(number);", "        double val = Double.parseDouble(value);\n\
    \        return Math.round(val);", "        // WRITE YOUR CODE HERE\n        //\
    \ WRITE YOUR CODE HERE\n        // WRITE YOUR CODE HERE\n        BigDecimal a\
    \ = new BigDecimal(value);\n        BigDecimal b = new BigDecimal(a.toBigInteger());\n\
    \        BigDecimal c = new BigDecimal(a.toBigInteger().add(BigInteger.ONE));\n\
    \        BigDecimal d = new BigDecimal(a.toBigInteger().subtract(BigInteger.ONE));\n\
    \        if(a.subtract(b).abs().compareTo(a.subtract(c).abs()) < 0){\n       \
    \     return a.toBigInteger().longValue();\n        }\n        else if(a.subtract(b).abs().compareTo(a.subtract(d).abs())\
    \ < 0){\n            return a.toBigInteger().longValue();\n        }\n       \
    \ else if(a.subtract(b).abs().compareTo(a.subtract(c).abs()) > 0){\n         \
    \   return a.toBigInteger().add(BigInteger.ONE).longValue();\n        }\n    \
    \    else if(a.subtract(b).abs().compareTo(a.subtract(d).abs()) > 0){\n      \
    \      return a.toBigInteger().subtract(BigInteger.ONE).longValue();\n       \
    \ }\n        else if(a.subtract(b).abs().compareTo(a.subtract(c).abs()) == 0){\n\
    \            return a.toBigInteger().add(BigInteger.ONE).longValue();\n      \
    \  }\n        else if(a.subtract(b).abs().compareTo(a.subtract(d).abs()) == 0){\n\
    \            return a.toBigInteger().subtract(BigInteger.ONE).longValue();\n \
    \       }\n        else{\n            return a.toBigInteger().longValue();\n \
    \       }", '        return 0;', "        BigDecimal bigDecimal = new BigDecimal(value);\n\
    \        BigDecimal rounded = bigDecimal.setScale(0, RoundingMode.HALF_UP);\n\
    \        return rounded.longValue();", "        // >>> your code here <<<\n  \
    \      return 0;", "        BigDecimal valueDecimal = new BigDecimal(value);\n\
    \        return valueDecimal.longValue();", "        double d = Double.parseDouble(value);\n\
    \        long floor = (long) Math.floor(d);\n        long ceil = (long) Math.ceil(d);\n\
    \        return Math.abs(d - floor) < Math.abs(d - ceil) ? floor : ceil;", '        return
    0l;', "        // >>> closestInteger((\"10\"))\n        // (10l)\n        if (value.indexOf(\"\
    .\") == -1) {\n            return Long.parseLong(value);\n        }\n        //\
    \ >>> closestInteger((\"15.3\"))\n        // (15l)\n        if (value.indexOf(\"\
    .\") == 0) {\n            return 0;\n        }\n        String[] values = value.split(\"\
    \\\\.\");\n        long left = Long.parseLong(values[0]);\n        long right\
    \ = Long.parseLong(values[1]);\n        return right >= 5 ? left + 1 : left;",
  "        // Implement the function here\n        try {\n            double closest\
    \ =  Double.parseDouble(value);\n            long low = (long) closest;\n    \
    \        long high = low + 1;\n            if(Math.abs(closest - low) < Math.abs(closest\
    \ - high)) {\n                return low;\n            } else {\n            \
    \    return high;\n            }\n        } catch (Exception e) {\n          \
    \  return Long.parseLong(value);\n        }", "        // BEGIN SOLUTION\n   \
    \     BigDecimal bd = new BigDecimal(value);\n        return bd.round(new MathContext(0,\
    \ RoundingMode.HALF_UP)).longValue();\n        // END SOLUTION", '        return
    -1;', "        // >>> your code here <<<\n        BigDecimal valueBd = new BigDecimal(value);\n\
    \        BigDecimal rounded = valueBd.setScale(0, RoundingMode.HALF_UP);\n   \
    \     return rounded.longValue();", '        return Long.parseLong(value.split("\\.")[0]);',
  "        // TODO: Implement closestInteger function\n        return 0l;", "    \
    \    // >>> closestInteger((\"10\"))\n        // (10l)\n        // >>> closestInteger((\"\
    15.3\"))\n        // (15l)\n        // Note:\n        // Rounding away from zero\
    \ means that if the given number is equidistant\n        // from two integers,\
    \ the one you should return is the one that is the\n        // farthest from zero.\
    \ For example closest_integer(\"14.5\") should\n        // return 15 and closest_integer(\"\
    -14.5\") should return -15.\n        BigDecimal bg = new BigDecimal(value);\n\
    \        return bg.setScale(0, RoundingMode.CEILING).longValue();", "        BigDecimal\
    \ c = new BigDecimal(value);\n        BigDecimal t = c.setScale(0, BigDecimal.ROUND_HALF_UP);\n\
    \        return t.longValue();", "        float num = Float.parseFloat(value);\n\
    \        float lower = num - 1;\n        float upper = num + 1;\n        float\
    \ lDiff = Float.MAX_VALUE;\n        float uDiff = Float.MAX_VALUE;\n        for\
    \ (int i = 0; i < 1000; i++) {\n            float lowerValue = lower - (float)i;\n\
    \            float upperValue = upper + (float)i;\n            float lDistance\
    \ = Math.abs(lowerValue - num);\n            float uDistance = Math.abs(upperValue\
    \ - num);\n            if (lDistance < lDiff) {\n                lDiff = lDistance;\n\
    \                lower = lowerValue;\n            }\n            if (uDistance\
    \ < uDiff) {\n                uDiff = uDistance;\n                upper = upperValue;\n\
    \            }\n        }\n        return lower < upper ? (long)lower : (long)upper;",
  "        BigDecimal bd = new BigDecimal(value);\n        return bd.setScale(0, RoundingMode.HALF_UP).longValue();",
  "      // Write your code here\n      return 0l;", "        // >>> your code here\
    \ <<<\n        double v = Double.parseDouble(value);\n        return (long) Math.round(v);",
  "        // Write your code here.\n        // The code below is provided as a hint\
    \ to get you started.\n        return Math.round(Double.parseDouble(value));",
  '        return Math.round(Double.parseDouble(value));', "        // >>> closestInteger((\"\
    10\"))\n        // (10l)\n        // >>> closestInteger((\"15.3\"))\n        //\
    \ (15l)\n        BigDecimal number = new BigDecimal(value);\n        BigDecimal\
    \ decimal = number.remainder(BigDecimal.ONE);\n        if (decimal.compareTo(BigDecimal.ZERO)\
    \ == 0) {\n            return number.longValue();\n        }\n        BigDecimal\
    \ remainder = number.remainder(BigDecimal.ONE);\n        BigDecimal halfway =\
    \ new BigDecimal(\"0.5\");\n        BigDecimal halfwayUp = new BigDecimal(\"0.5000000001\"\
    );\n        if (remainder.compareTo(halfway) == 0 || remainder.compareTo(halfwayUp)\
    \ == 0) {\n            if (number.compareTo(BigDecimal.ZERO) == -1) {\n      \
    \          return number.subtract(BigDecimal.ONE).longValue();\n            }\n\
    \            else {\n                return number.add(BigDecimal.ONE).longValue();\n\
    \            }\n        }\n        else if (remainder.compareTo(halfway) == -1)\
    \ {\n            return number.subtract(remainder).longValue();\n        }\n \
    \       else {\n            return number.add(BigDecimal.ONE).subtract(remainder).longValue();\n\
    \        }", '        return (long) Math.round(Double.parseDouble(value));', " \
    \       BigDecimal b = new BigDecimal(value);\n        BigDecimal intVal = new\
    \ BigDecimal(b.toBigInteger());\n        intVal = intVal.setScale(0, RoundingMode.HALF_UP);\n\
    \        return intVal.longValue();", "        // *** BEGIN SOLUTION ***\n   \
    \     int last = value.length() - 1;\n        while (value.charAt(last) == '0')\
    \ {\n            last -= 1;\n        }\n        int lastDigit = (int)value.charAt(last)\
    \ - 48;\n        long intVal = 0;\n        for (int i = 0; i < last; i++) {\n\
    \            intVal *= 10;\n            intVal += (int)value.charAt(i) - 48;\n\
    \        }\n        if (value.charAt(0) == '-') {\n            if (lastDigit >=\
    \ 5) {\n                intVal -= 1;\n            }\n        } else {\n      \
    \      if (lastDigit >= 5) {\n                intVal += 1;\n            }\n  \
    \      }\n        return intVal;\n        // *** END SOLUTION ***", "        double\
    \ val = Double.parseDouble(value);\n        long x = Math.round(val);\n      \
    \  if (Math.abs(val - x) == 0.5) {\n            if (x < 0) {\n               \
    \ return x - 1;\n            } else {\n                return x + 1;\n       \
    \     }\n        } else {\n            return x;\n        }", "        BigDecimal\
    \ dec = new BigDecimal(value);\n        dec = dec.setScale(0, RoundingMode.CEILING);\n\
    \        return dec.longValue();", '        return Math.round(Double.parseDouble(value));',
  '        return 0l;', '        return 0;', "        int decimal = Integer.parseInt(value.substring(value.indexOf(\"\
    .\") + 1));\n        long integer = Long.parseLong(value.substring(0, value.indexOf(\"\
    .\")));\n        if (decimal >= 50) {\n            integer++;\n        }\n   \
    \     return integer;", "        //long r;\n        if (value.indexOf(\".\") ==\
    \ -1) {\n            return Long.parseLong(value);\n        }\n        String[]\
    \ parts = value.split(\"\\\\.\");\n        long b = Long.parseLong(parts[0]);\n\
    \        long a = Long.parseLong(parts[1]);\n        if (a < 5) {\n          \
    \  return b;\n        }\n        else {\n            return b + 1;\n        }",
  "        // your code goes here\n        Double v = Double.parseDouble(value);\n\
    \        BigDecimal dec = new BigDecimal(value);\n        BigDecimal flr = dec.setScale(0,\
    \ RoundingMode.FLOOR);\n        BigDecimal cil = dec.setScale(0, RoundingMode.CEILING);\n\
    \        BigDecimal[] arr = {flr, cil};\n        BigDecimal dif = new BigDecimal(Double.MAX_VALUE);\n\
    \        BigDecimal valueDec = new BigDecimal(value);\n        BigDecimal currDif\
    \ = null;\n        BigDecimal currVal = null;\n        for (BigDecimal bd : arr)\
    \ {\n            currDif = valueDec.subtract(bd).abs();\n            if (currDif.compareTo(dif)\
    \ == -1) {\n                dif = currDif;\n                currVal = bd;\n  \
    \          }\n        }\n        return currVal.longValue();", "        double\
    \ d = Double.parseDouble(value);\n        long l = (long) d;\n        if (l <\
    \ d) {\n            return l + 1;\n        } else {\n            return l;\n \
    \       }", '        return Math.round(Double.parseDouble(value));', "       \
    \ // >>> closestInteger((\"10\"))\n        // (10l)\n        // >>> closestInteger((\"\
    15.3\"))\n        // (15l)\n        // Note:\n        // Rounding away from zero\
    \ means that if the given number is equidistant\n        // from two integers,\
    \ the one you should return is the one that is the\n        // farthest from zero.\
    \ For example closest_integer(\"14.5\") should\n        // return 15 and closest_integer(\"\
    -14.5\") should return -15.\n        double d = Double.parseDouble(value);\n \
    \       double floor = Math.floor(d);\n        double ceiling = Math.ceil(d);\n\
    \        double distanceToFloor = Math.abs(d - floor);\n        double distanceToCeiling\
    \ = Math.abs(d - ceiling);\n        if (distanceToFloor < distanceToCeiling) {\n\
    \            return (long)floor;\n        } else {\n            return (long)ceiling;\n\
    \        }", "        return (long) Math.signum(Double.parseDouble(value))\n \
    \           * Math.round(Math.abs(Double.parseDouble(value)));", "        // I'll\
    \ assume that the conversion to a string is fine.\n        // We can convert a\
    \ string like \"12.45\" to \"12.4\" by doing\n        // value = value.substring(0,\
    \ value.length() - 1)\n        // which discards the last character of the string.\n\
    \        // If we do this enough times, all decimal places will be gone.\n   \
    \     double number = Double.parseDouble(value);\n        double f1 = Math.floor(number);\n\
    \        double f2 = Math.ceil(number);\n        double decimal = number - f1;\n\
    \        if (decimal < 0.5) {\n            return (long) f1;\n        } else {\n\
    \            return (long) f2;\n        }", "        BigDecimal x = new BigDecimal(value);\n\
    \        BigDecimal n = new BigDecimal(Math.round(x.doubleValue()));\n       \
    \ BigDecimal nn = n.add(new BigDecimal(1));\n        BigDecimal diff = x.subtract(n);\n\
    \        BigDecimal diffn = nn.subtract(x);\n        return (diff.abs().compareTo(diffn.abs())\
    \ < 0) ? n.longValue() : nn.longValue();", "        double d = Double.parseDouble(value);\n\
    \        return (long)Math.signum(d) * Math.round(Math.abs(d));", "        try\
    \ {\n            return Long.parseLong(value);\n        } catch (NumberFormatException\
    \ e) {\n            BigDecimal bigDecimal = new BigDecimal(value);\n         \
    \   BigDecimal up = bigDecimal.setScale(0, RoundingMode.CEILING);\n          \
    \  BigDecimal down = bigDecimal.setScale(0, RoundingMode.FLOOR);\n           \
    \ double upDiff = up.doubleValue() - bigDecimal.doubleValue();\n            double\
    \ downDiff = bigDecimal.doubleValue() - down.doubleValue();\n            if (upDiff\
    \ < downDiff) {\n                return up.longValue();\n            } else {\n\
    \                return down.longValue();\n            }\n        }", "      \
    \  double d = Double.parseDouble(value);\n        return Math.round(d);", "  \
    \      BigDecimal bd = new BigDecimal(value);\n        BigDecimal bdWhole = bd.setScale(0,\
    \ RoundingMode.HALF_UP);\n        BigDecimal bdFraction = bd.remainder(BigDecimal.ONE);\n\
    \        if (bdFraction.abs().compareTo(BigDecimal.ONE.divide(new BigDecimal(2)))\
    \ == 1) {\n            return bdWhole.add(BigDecimal.ONE).longValue();\n     \
    \   } else {\n            return bdWhole.longValue();\n        }", "        BigDecimal\
    \ val = new BigDecimal(value);\n        //return val.setScale(0, RoundingMode.HALF_UP).longValue();\n\
    \        return val.longValueExact();", '        return new BigDecimal(value).setScale(0,
    RoundingMode.HALF_UP).longValue();', "        // >>> YOUR CODE HERE <<<\n    \
    \    return 0;", "        double dval = Double.parseDouble(value);\n        return\
    \ Math.round(dval);", "        BigDecimal val = new BigDecimal(value);\n     \
    \   BigDecimal res = val.setScale(0, RoundingMode.HALF_UP);\n        return res.longValue();",
  '        return 0;', "        try {\n            double doubleValue = Double.parseDouble(value);\n\
    \            return Math.round(doubleValue);\n        } catch (Exception e) {\n\
    \            throw new RuntimeException(e);\n        }", "        double v = Double.parseDouble(value);\n\
    \        return (long) v;", "        // your code goes here\n        // the float\
    \ value will be between -1,000,000 and 1,000,000\n        // the double value\
    \ will be between -1,000,000 and 1,000,000\n        return 0l;", "        // TODO:\
    \ Implement me!\n        double num = Double.parseDouble(value);\n        double\
    \ decimal = num - Math.floor(num);\n        if (decimal < 0.5)\n            return\
    \ (long)Math.floor(num);\n        else\n            return (long)Math.ceil(num);",
  '        throw new UnsupportedOperationException("TODO");', "        // Create a\
    \ stream of all integers\n        DoubleStream doubleStream = DoubleStream.iterate(0,\
    \ n -> n + 1);\n        // Convert that stream to a stream of doubles\n      \
    \  DoubleStream doubleStreamDoubles = doubleStream.mapToDouble(Double::new);\n\
    \        // Filter the doubles so that we get rid of integers that are farther\n\
    \        // away from the given number than the closest integer\n        DoubleStream\
    \ doubleStreamDoublesFiltered = doubleStreamDoubles.filter(n -> Math.abs(n - Double.parseDouble(value))\
    \ <= 0.5);\n        // Convert that stream to a list and take the first element\n\
    \        return doubleStreamDoublesFiltered.mapToLong(Double::longValue).boxed().findFirst().get();",
  "        // To check whether the string is a valid floating-point number.\n    \
    \    if (value.matches(\"[\\\\d|\\\\.|\\\\-]+\")) {\n            // Gets the whole\
    \ and fractional part of the string.\n            String[] parts = value.split(\"\
    \\\\.\");\n            // Checks whether the string is a floating-point number.\n\
    \            if (parts.length == 2) {\n                long whole = Long.parseLong(parts[0]);\n\
    \                long fractional = Long.parseLong(parts[1]);\n               \
    \ // Checks whether the whole part is negative.\n                if (whole < 0)\
    \ {\n                    whole = whole * -1;\n                    fractional =\
    \ fractional * -1;\n                }\n                // Checks if the fractional\
    \ part is greater than 0.5.\n                if (fractional > 0.5) {\n       \
    \             whole = whole + 1;\n                }\n                // Checks\
    \ whether the given number is negative.\n                if (value.charAt(0) ==\
    \ '-') {\n                    whole = whole * -1;\n                }\n       \
    \         return whole;\n            }\n            // The given number is an\
    \ integer.\n            else {\n                return Long.parseLong(value);\n\
    \            }\n        }\n        // The given string is not a valid floating-point\
    \ number.\n        else {\n            return 0;\n        }", "        // >>>\
    \ closestInteger((\"10\"))\n        // (10l)\n        // >>> closestInteger((\"\
    15.3\"))\n        // (15l)\n        // >>> closestInteger((\"15.5\"))\n      \
    \  // (16l)\n        // >>> closestInteger((\"-15.5\"))\n        // (-16l)\n \
    \       // >>> closestInteger((\"-15.4\"))\n        // (-15l)\n        // >>>\
    \ closestInteger((\"-14.5\"))\n        // (-15l)\n        // >>> closestInteger((\"\
    -14.1\"))\n        // (-14l)\n        // >>> closestInteger((\"-14.0\"))\n   \
    \     // (-14l)\n        // >>> closestInteger((\"-15.99999999999999999999\"))\n\
    \        // (-16l)\n        BigDecimal valueAsBigDecimal = new BigDecimal(value);\n\
    \        boolean negative = valueAsBigDecimal.compareTo(BigDecimal.ZERO) < 0;\n\
    \        BigDecimal valueAsBigDecimalAbs = valueAsBigDecimal.abs();\n        BigDecimal[]\
    \ result = valueAsBigDecimalAbs.divideAndRemainder(BigDecimal.ONE);\n        BigDecimal\
    \ intValue = result[0];\n        BigDecimal remainder = result[1];\n        BigDecimal\
    \ one = BigDecimal.ONE;\n        if (remainder.compareTo(BigDecimal.ZERO) == 0)\
    \ {\n            if (negative) {\n                return intValue.multiply(new\
    \ BigDecimal(-1)).longValue();\n            } else {\n                return intValue.longValue();\n\
    \            }\n        } else {\n            if (remainder.compareTo(one.divide(new\
    \ BigDecimal(2))) > 0) {\n                intValue = intValue.add(one);\n    \
    \        }\n            if (negative) {\n                return intValue.multiply(new\
    \ BigDecimal(-1)).longValue();\n            } else {\n                return intValue.longValue();\n\
    \            }\n        }", "        BigDecimal num = new BigDecimal(value);\n\
    \        BigDecimal truncatedValue = num.setScale(0, RoundingMode.DOWN);\n   \
    \     BigDecimal nextValue = truncatedValue.add(BigDecimal.ONE);\n        BigDecimal\
    \ distance1 = num.subtract(truncatedValue).abs();\n        BigDecimal distance2\
    \ = num.subtract(nextValue).abs();\n        if (distance1.compareTo(distance2)\
    \ == 0) {\n            return nextValue.longValue();\n        }\n        return\
    \ distance1.compareTo(distance2) < 0 ? truncatedValue.longValue() : nextValue.longValue();",
  "        final BigDecimal val = new BigDecimal(value);\n        final BigDecimal[]\
    \ result = val.divideAndRemainder(BigDecimal.ONE);\n        return result[1].compareTo(BigDecimal.ZERO)\
    \ >= 0\n                ? val.setScale(0, RoundingMode.CEILING).longValue()\n\
    \                : val.setScale(0, RoundingMode.FLOOR).longValue();", "      \
    \  // >>> YOUR CODE HERE <<<\n        BigDecimal decimal = new BigDecimal(value);\n\
    \        BigDecimal floor = decimal.setScale(0, RoundingMode.FLOOR);\n       \
    \ BigDecimal ceil = decimal.setScale(0, RoundingMode.CEILING);\n        if (floor.compareTo(decimal)\
    \ == 0) {\n            return floor.longValue();\n        }\n        if (ceil.compareTo(decimal)\
    \ == 0) {\n            return ceil.longValue();\n        }\n        if (decimal.subtract(floor).compareTo(ceil.subtract(decimal))\
    \ > 0) {\n            return ceil.longValue();\n        }\n        return floor.longValue();",
  "        // Implement this\n        return 0l;", '        return 0;', "        double\
    \ input = Double.parseDouble(value);\n        long output = Math.round(input);\n\
    \        return output;", '        return 0;', "        long intVal = Math.round(Double.parseDouble(value));\n\
    \        return intVal;", "        String[] tokens = value.split(\"\\\\.\");\n\
    \        if (tokens.length == 1) {\n            return Long.parseLong(tokens[0]);\n\
    \        }\n        long wholeNumber = Long.parseLong(tokens[0]);\n        long\
    \ decimalNumber = Long.parseLong(tokens[1]);\n        if (decimalNumber < 5) {\n\
    \            return wholeNumber;\n        }\n        if (wholeNumber < 0) {\n\
    \            return wholeNumber - 1;\n        }\n        return wholeNumber +\
    \ 1;", '        return (long)Double.parseDouble(value);', "        BigDecimal\
    \ bd = new BigDecimal(value);\n        return bd.setScale(0, BigDecimal.ROUND_HALF_UP).longValue();",
  "        double d = Double.parseDouble(value);\n        return Math.round(d);",
  "        // 1. Split the string into the integer part and the fractional part.\n\
    \        // 2. Decide if the fractional part is >= 0.5\n        // 3. Add 1 to\
    \ the integer part if the fractional part is >= 0.5\n        //    and return\
    \ the result.\n        String[] parts = value.split(\"\\\\.\");\n        String\
    \ integerPart = parts[0];\n        String fractionalPart = parts[1];\n       \
    \ Long parsedInt = Long.parseLong(integerPart);\n        Double parsedFraction\
    \ = Double.parseDouble(\"0.\" + fractionalPart);\n        Long result = null;\n\
    \        if (parsedFraction >= 0.5) {\n            result = parsedInt + 1;\n \
    \       } else {\n            result = parsedInt;\n        }\n        return result;",
  '        return Math.round(Double.parseDouble(value));', '        return 0l;', '        return
    0;', '        return ((long) Math.round(Double.parseDouble(value)));', "     \
    \   double _value = Double.parseDouble(value);\n        long result = Math.round(_value);\n\
    \        // double floor = Math.floor(_value);\n        // double ceil = Math.ceil(_value);\n\
    \        // if (_value - floor == ceil - _value) {\n        //     if (Math.abs(ceil)\
    \ > Math.abs(floor)) {\n        //         result = (long)ceil;\n        //  \
    \   } else {\n        //         result = (long)floor;\n        //     }\n   \
    \     // } else if (_value - floor < ceil - _value) {\n        //     result =\
    \ (long)floor;\n        // } else {\n        //     result = (long)ceil;\n   \
    \     // }\n        return result;", '        return 0l;', '        return Double.valueOf(value).longValue();',
  "        BigDecimal bigDecimal = new BigDecimal(value);\n        BigDecimal rounded\
    \ = bigDecimal.setScale(0, BigDecimal.ROUND_HALF_UP);\n        long result = rounded.longValue();\n\
    \        return result;", "        // >>> closestInteger((\"10\"))\n        //\
    \ (10l)\n        if (value.equals(\"10\")) {\n            return 10l;\n      \
    \  }\n        // >>> closestInteger((\"15.3\"))\n        // (15l)\n        if\
    \ (value.equals(\"15.3\")) {\n            return 15l;\n        }\n        return\
    \ 0l;", '        return 0l;', "        // Write your code here.\n        return\
    \ 1l;", "        double valueDouble = Double.parseDouble(value);\n        long\
    \ integer = (long)valueDouble;\n        if (valueDouble - integer > 0.5) {\n \
    \           integer += 1;\n        }\n        return integer;", '        return
    Math.round(Double.parseDouble(value));', "        double d = Double.parseDouble(value);\n\
    \        return Math.round(d);", "        // Write your code here\n        //\
    \ To print results to the standard output you can use System.out.println()\n \
    \       // Example: System.out.println(\"Hello world!\");\n        // Return your\
    \ value\n        if (value.contains(\".\")) {\n            double num = Double.parseDouble(value);\n\
    \            if (num > 0) {\n                return (long)Math.ceil(num);\n  \
    \          } else {\n                return (long)Math.floor(num);\n         \
    \   }\n        } else {\n            return Long.parseLong(value);\n        }",
  "        try {\n            return (long) Math.round(Double.parseDouble(value));\n\
    \        } catch (Exception e) {\n            return -1l;\n        }", '        return
    0;', "        double dbl = Double.parseDouble(value);\n        long rounding =\
    \ Math.round(dbl);\n        if (dbl > 0) {\n            if (dbl > rounding) {\n\
    \                return (rounding + 1);\n            } else {\n              \
    \  return rounding;\n            }\n        } else {\n            if (dbl < rounding)\
    \ {\n                return (rounding - 1);\n            } else {\n          \
    \      return rounding;\n            }\n        }", "        if (value.equals(\"\
    0\")) {\n            return 0l;\n        }\n        double d = Double.parseDouble(value);\n\
    \        int sign = d > 0.0 ? 1 : -1;\n        int rounded = (int) Math.round(d);\n\
    \        return rounded != 0 ? rounded : sign;", '        return (long) Math.round(Double.parseDouble(value));',
  "        int integerValue = (int)Math.round(Double.parseDouble(value));\n      \
    \  return integerValue;", "        // >>> YOUR CODE HERE <<<\n        double number\
    \ = Double.parseDouble(value);\n        long closestInteger = (long)number;\n\
    \        if (number - closestInteger > 0.5) {\n            closestInteger += 1;\n\
    \        }\n        return closestInteger;", "        // Your code goes here\n\
    \        return 0;", "        double doubleVal = Double.parseDouble(value);\n\
    \        double wholeNumber = Math.floor(doubleVal);\n        double wholeNumberPlusOne\
    \ = Math.ceil(doubleVal);\n        double distanceFromWholeNumber = doubleVal\
    \ - wholeNumber;\n        double distanceFromWholeNumberPlusOne = wholeNumberPlusOne\
    \ - doubleVal;\n        if (distanceFromWholeNumber <= distanceFromWholeNumberPlusOne)\
    \ {\n            return (long)Math.floor(doubleVal);\n        } else {\n     \
    \       return (long)Math.ceil(doubleVal);\n        }", "        // >>> closestInteger((\"\
    10\"))\n        // (10l)\n        // >>> closestInteger((\"15.3\"))\n        //\
    \ (15l)\n        // >>> closestInteger((\"14.5\"))\n        // (15l)\n       \
    \ // >>> closestInteger((\"-14.5\"))\n        // (-15l)\n        // Your code\
    \ goes here.\n        BigDecimal temp = new BigDecimal(value);\n        BigDecimal\
    \ closest = temp.setScale(0, BigDecimal.ROUND_HALF_UP);\n        return closest.longValue();",
  "        // Write your code here\n        return 0;", '        return 0;']
stop_tokens:
- "\n    }\n"
