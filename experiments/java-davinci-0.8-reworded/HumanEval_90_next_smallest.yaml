name: HumanEval_90_next_smallest
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // You are given an array array list of integers.\n    // Write\
  \ a function next_smallest() that returns the 2nd smallest element of the array\
  \ list.\n    // Return null if there is no such element.\n    // >>> nextSmallest((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))\n\
  \    // 2l\n    // >>> nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l,\
  \ (long)1l, (long)4l, (long)3l, (long)2l))))\n    // 2l\n    // >>> nextSmallest((new\
  \ ArrayList<Long>(Arrays.asList())))\n    // Optional.empty()\n    // >>> nextSmallest((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))\n    // Optional.empty()\n\
  \    public static Optional<Long> nextSmallest(ArrayList<Long> lst) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(nextSmallest((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l)))).equals(2l));\n\
  \    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)5l, (long)1l,\
  \ (long)4l, (long)3l, (long)2l)))).equals(2l));\n    assert(nextSmallest((new ArrayList<Long>(Arrays.asList()))).equals(Optional.empty()));\n\
  \    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l)))).equals(Optional.empty()));\n\
  \    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l,\
  \ (long)1l, (long)1l, (long)0l)))).equals(1l));\n    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)1l)))).equals(Optional.empty()));\n    assert(nextSmallest((new ArrayList<Long>(Arrays.asList((long)-35l,\
  \ (long)34l, (long)12l, (long)-45l)))).equals(-35l));\n    }\n\n}\n"
completions: ["        // Type your solution here\n        return null;", "      \
    \  // We use a list to ensure that we don't have duplicates\n        // and that\
    \ the output is sorted.\n        ArrayList<Long> uniques = new ArrayList<Long>();\n\
    \        for (Long el : lst) {\n            if (!uniques.contains(el)) {\n   \
    \             uniques.add(el);\n            }\n        }\n        Collections.sort(uniques);\n\
    \        if (uniques.size() <= 1) {\n            return Optional.empty();\n  \
    \      }\n        return Optional.of(uniques.get(1));", '        return Optional.empty();',
  "        // Replace with actual implementation\n        return Optional.empty();",
  "        // YOUR CODE HERE\n        if (lst.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        long min = lst.get(0);\n        long secondMin = lst.get(1);\n\
    \        if (min > secondMin) {\n            min = secondMin;\n            secondMin\
    \ = lst.get(0);\n        }\n        for (int i = 2; i < lst.size(); i++) {\n \
    \           if (lst.get(i) < min) {\n                secondMin = min;\n      \
    \          min = lst.get(i);\n            } else if (lst.get(i) < secondMin) {\n\
    \                secondMin = lst.get(i);\n            }\n        }\n        return\
    \ Optional.of(secondMin);", '        return null;', "        // Replace pass with\
    \ the solution.\n        pass", '        return lst.stream().sorted().distinct().skip(1).findFirst();',
  "        if (lst.size() < 2) return Optional.empty();\n        int minIdx = 0;\n\
    \        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i) <\
    \ lst.get(minIdx)) {\n                minIdx = i;\n            }\n        }\n\
    \        int secondIdx = minIdx;\n        for (int i = 0; i < lst.size(); i++)\
    \ {\n            if (i == minIdx) continue;\n            if (lst.get(i) < lst.get(secondIdx))\
    \ {\n                secondIdx = i;\n            }\n        }\n        return\
    \ (secondIdx == minIdx) ? Optional.empty() : Optional.of(lst.get(secondIdx));",
  '        return null;', '        return null;', "        // PUT YOUR CODE HERE\n\
    \        return Optional.empty();", "        // your code goes here\n        if\
    \ (lst.size() == 0 || lst.size() == 1) return Optional.empty();\n        return\
    \ Optional.of(\n                Collections.min(\n                    lst.stream()\n\
    \                    .sorted()\n                    .collect(Collectors.toList())\n\
    \                    .subList(1, lst.size())\n                )\n            );",
  "        long smallest = Long.MAX_VALUE;\n        long smallest2 = Long.MAX_VALUE;\n\
    \        boolean success = false;\n        for (long l : lst) {\n            if\
    \ (l < smallest) {\n                smallest2 = smallest;\n                smallest\
    \ = l;\n                success = true;\n            } else if (l < smallest2)\
    \ {\n                smallest2 = l;\n                success = true;\n       \
    \     }\n        }\n        if (success) {\n            return Optional.of(smallest2);\n\
    \        } else {\n            return Optional.empty();\n        }", "       \
    \ Long min = Collections.min(lst);\n        Long second_min = null;\n        Long\
    \ next = null;\n        for (Long el : lst) {\n            if (el != min) {\n\
    \                if (second_min == null) {\n                    second_min = el;\n\
    \                } else {\n                    if (second_min > el) {\n      \
    \                  second_min = el;\n                    }\n                }\n\
    \            }\n        }\n        return Optional.ofNullable(second_min);", " \
    \       Long res = null;\n        Long previous = null;\n        boolean multiple\
    \ = false;\n        for (int i = 0; i < lst.size(); i++) {\n            Long current\
    \ = lst.get(i);\n            if (previous != null) {\n                if (current\
    \ > previous) {\n                    if (res == null) {\n                    \
    \    res = current;\n                    } else {\n                        if\
    \ (current < res) {\n                            res = current;\n            \
    \            }\n                    }\n                } else {\n            \
    \        multiple = true;\n                }\n            }\n            previous\
    \ = current;\n        }\n        if (multiple) {\n            return Optional.of(res);\n\
    \        } else {\n            return Optional.empty();\n        }", '        return
    null;', "        Long min = Long.MAX_VALUE;\n        Long secondMin = Long.MAX_VALUE;\n\
    \        for (Long l : lst) {\n            if (l < min) {\n                secondMin\
    \ = min;\n                min = l;\n            } else if (l < secondMin && l\
    \ != min) {\n                secondMin = l;\n            }\n        }\n      \
    \  if (secondMin != Long.MAX_VALUE) {\n            return Optional.of(secondMin);\n\
    \        } else {\n            return Optional.empty();\n        }", '        throw
    new UnsupportedOperationException("TODO: implement nextSmallest(ArrayList<Long>
    lst)");', "        Optional<Long> result = Optional.empty();\n        // Check\
    \ for an empty list\n        if (lst.size() == 0) {\n            return result;\n\
    \        }\n        // Initialize the minimum to the first element of the list\n\
    \        Long min = lst.get(0);\n        // Initialize the second-minimum to the\
    \ maximum long\n        Long min2 = Long.MAX_VALUE;\n        // Iterate over the\
    \ array\n        for (Long elem : lst) {\n            // Set the minimum\n   \
    \         if (elem < min) {\n                min2 = min;\n                min\
    \ = elem;\n            }\n            // Set the second-minimum\n            else\
    \ if (elem < min2) {\n                min2 = elem;\n            }\n        }\n\
    \        // Check if the second-minimum is the maximum long\n        if (min2\
    \ == Long.MAX_VALUE) {\n            return result;\n        }\n        else {\n\
    \            result = Optional.of(min2);\n            return result;\n       \
    \ }", "        // IMPLEMENTATION GOES HERE\n        return Optional.empty();",
  "        Long smallest = Long.MAX_VALUE;\n        Long secondSmallest = Long.MAX_VALUE;\n\
    \        for (Long i : lst) {\n            if (i < smallest) {\n             \
    \   secondSmallest = smallest;\n                smallest = i;\n            } else\
    \ if (i < secondSmallest && i != smallest) {\n                secondSmallest =\
    \ i;\n            }\n        }\n        if (secondSmallest == Long.MAX_VALUE)\
    \ {\n            return Optional.empty();\n        }\n        return Optional.of(secondSmallest);",
  "        if (lst.size() < 2) return Optional.empty();\n        if (lst.size() ==\
    \ 2) {\n            if (lst.get(0) == lst.get(1)) return Optional.empty();\n \
    \           else return Optional.of(Math.min(lst.get(0), lst.get(1)));\n     \
    \   }\n        long current_min = Long.MAX_VALUE;\n        long current_second_min\
    \ = Long.MAX_VALUE;\n        for (long l : lst) {\n            if (l < current_min)\
    \ {\n                current_second_min = current_min;\n                current_min\
    \ = l;\n            } else if (l < current_second_min) {\n                current_second_min\
    \ = l;\n            }\n        }\n        if (current_second_min == Long.MAX_VALUE)\
    \ return Optional.empty();\n        else return Optional.of(current_second_min);",
  "        if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        long min = Long.MAX_VALUE;\n        long min2 = Long.MAX_VALUE;\n   \
    \     for (long l : lst) {\n            if (l < min) {\n                min2 =\
    \ min;\n                min = l;\n            } else if (l > min && l < min2)\
    \ {\n                min2 = l;\n            }\n        }\n        if (min2 ==\
    \ Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n       \
    \ return Optional.of(min2);", '        return lst.stream().distinct().sorted().skip(1).findFirst();',
  "        if (lst.size() < 2) return Optional.empty();\n        lst.sort(Long::compareTo);\n\
    \        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i) !=\
    \ lst.get(i - 1)) return Optional.of(lst.get(i));\n        }\n        return Optional.empty();",
  "        if (lst.size() < 2) return Optional.empty();\n        Collections.sort(lst);\n\
    \        Long prev = lst.get(0);\n        for (int i = 1; i < lst.size(); i++)\
    \ {\n            Long curr = lst.get(i);\n            if (curr != prev) return\
    \ Optional.of(curr);\n            prev = curr;\n        }\n        return Optional.empty();",
  '        return null;', "        // Write your code here.\n        return Optional.empty();",
  "        if (lst.size() == 0) {\n            return Optional.empty();\n        }\n\
    \        if (lst.size() == 1) {\n            return Optional.empty();\n      \
    \  }\n        Long first = lst.get(0);\n        Long second = lst.get(1);\n  \
    \      for (Long item : lst) {\n            if (item < first) {\n            \
    \    second = first;\n                first = item;\n            } else if (item\
    \ < second) {\n                second = item;\n            }\n        }\n    \
    \    if (first == second) {\n            return Optional.empty();\n        }\n\
    \        return Optional.of(second);", '        return lst.stream().sorted().distinct().skip(1).findFirst();',
  "        // Function nextSmallest: ArrayList<Long> -> Optional<Long>\n        //\
    \ Examples:\n        // ((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l, (long)5l)))\n        // -> 2l\n        // ((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)1l, (long)4l, (long)3l, (long)2l)))\n        // -> 2l\n        // ((new\
    \ ArrayList<Long>(Arrays.asList())))\n        // -> Optional.empty()\n       \
    \ // ((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l))))\n        // ->\
    \ Optional.empty()\n        // Template:\n        // lst.size()\n        // lst.get(i)\n\
    \        // lst.set(i, val)\n        // lst.add(val)\n        // Local Variables:\n\
    \        // mn: Long = Long.MAX_VALUE\n        // mn2: Long = Long.MAX_VALUE\n\
    \        // i: int\n        // val: Long\n        // Return: Optional<Long>\n\
    \        // Sub Problem A:\n        // Sub Problem B:\n        // Sub Problem\
    \ C:\n        // Sub Problem D:\n        // Sub Problem E:\n        // Sub Problem\
    \ F:\n        // Sub Problem G:\n        // Sub Problem H:\n        // Sub Problem\
    \ I:\n        // Sub Problem J:\n        // Sub Problem K:\n        // Sub Problem\
    \ L:\n        // Sub Problem M:\n        // Sub Problem N:\n        // Sub Problem\
    \ O:\n        // Sub Problem P:\n        // Sub Problem Q:\n        // Sub Problem\
    \ R:\n        // Sub Problem S:\n        // Sub Problem T:\n        // Sub Problem\
    \ U:\n        // Sub Problem V:\n        // Sub Problem W:\n        // Sub Problem\
    \ X:\n        // Sub Problem Y:\n        // Sub Problem Z:\n        // Template:\n\
    \        // lst.size()\n        // lst.get(i)\n        // lst.set(i, val)\n  \
    \      // lst.add(val)", "        ArrayList<Long> newList = new ArrayList<>(lst);\n\
    \        Collections.sort(newList);\n        if (newList.size() < 2) return Optional.empty();\n\
    \        return Optional.of(newList.get(1));", "        if (lst.size() <= 1) {\n\
    \            return Optional.empty();\n        }\n        long smallest = Long.MAX_VALUE;\n\
    \        long secondSmallest = Long.MAX_VALUE;\n        for (long elem : lst)\
    \ {\n            if (elem < smallest) {\n                secondSmallest = smallest;\n\
    \                smallest = elem;\n            } else if (elem < secondSmallest)\
    \ {\n                secondSmallest = elem;\n            }\n        }\n      \
    \  if (secondSmallest == Long.MAX_VALUE) {\n            return Optional.empty();\n\
    \        }\n        return Optional.of(secondSmallest);", "        // write your\
    \ code here\n        // lines 7 - 21\n        long min = Long.MAX_VALUE;\n   \
    \     long second_min = Long.MAX_VALUE;\n        for (int index = 0; index < lst.size();\
    \ index++) {\n            if (lst.get(index) < min) {\n                second_min\
    \ = min;\n                min = lst.get(index);\n            } else if (lst.get(index)\
    \ < second_min && lst.get(index) != min) {\n                second_min = lst.get(index);\n\
    \            }\n        }\n        if (second_min == Long.MAX_VALUE) {\n     \
    \       return Optional.empty();\n        } else {\n            return Optional.of(second_min);\n\
    \        }", "        ArrayList<Long> sortedLst = new ArrayList<Long>(lst);\n\
    \        Collections.sort(sortedLst);\n        for (int i = 0; i < sortedLst.size()\
    \ - 1; i++) {\n            if (sortedLst.get(i).equals(sortedLst.get(i + 1)))\
    \ {\n                continue;\n            }\n            return Optional.of(sortedLst.get(i\
    \ + 1));\n        }\n        return Optional.empty();", "        if (lst.size()\
    \ < 2) {\n            return Optional.empty();\n        }\n        long min =\
    \ Long.MAX_VALUE;\n        long smin = Long.MAX_VALUE;\n        for (Long x :\
    \ lst) {\n            if (x < min) {\n                smin = min;\n          \
    \      min = x;\n            } else if (x < smin) {\n                smin = x;\n\
    \            }\n        }\n        if (smin == Long.MAX_VALUE) {\n           \
    \ return Optional.empty();\n        }\n        return Optional.of(smin);", " \
    \       if (lst.size() <= 1) {\n            return Optional.empty();\n       \
    \ }\n        Collections.sort(lst);\n        return (lst.get(0) == lst.get(1))\
    \ ? Optional.empty() : Optional.of(lst.get(1));", "        // return null;\n \
    \       if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        ArrayList<Long> sLst = new ArrayList<Long>(lst);\n        Collections.sort(sLst);\n\
    \        Long base = sLst.get(0);\n        for (int i = 1; i < sLst.size(); i++)\
    \ {\n            if (sLst.get(i) > base) {\n                return Optional.of(sLst.get(i));\n\
    \            }\n        }\n        return Optional.empty();", "        if (lst.size()\
    \ < 2) {\n            return Optional.empty();\n        } else {\n           \
    \ ArrayList<Long> t = new ArrayList<Long>(lst);\n            t.sort(Comparator.naturalOrder());\n\
    \            t.remove(0);\n            return Optional.of(t.get(0));\n       \
    \ }", '        throw new NotImplementedException();', '        return null;',
  "        if (lst.size() == 0) {\n            return Optional.empty();\n        }\n\
    \        if (lst.size() == 1) {\n            return Optional.empty();\n      \
    \  }\n        TreeSet<Long> treeSet = new TreeSet<Long>(lst);\n        Long smallest\
    \ = treeSet.first();\n        Long secondSmallest = treeSet.higher(smallest);\n\
    \        return Optional.of(secondSmallest);", '        return null;', "     \
    \   if (lst.size() < 2) {\n            return Optional.empty();\n        }\n \
    \       int n = lst.size();\n        if (n == 2) {\n            return Optional.of(lst.get(1));\n\
    \        }\n        // Find the smallest by sorting.\n        Collections.sort(lst);\n\
    \        long smallest = lst.get(0);\n        long secondSmallest = Long.MAX_VALUE;\n\
    \        for (long e : lst) {\n            if (e == smallest) {\n            \
    \    continue;\n            }\n            secondSmallest = Math.min(secondSmallest,\
    \ e);\n        }\n        if (secondSmallest == Long.MAX_VALUE) {\n          \
    \  return Optional.empty();\n        }\n        return Optional.of(secondSmallest);",
  "        if (lst.size() <= 1) {\n            return Optional.empty();\n        }\n\
    \        ArrayList<Long> _lst = (ArrayList<Long>)lst.clone();\n        Long min\
    \ = Collections.min(_lst);\n        Collections.sort(_lst);\n        _lst.remove(_lst.indexOf(min));\n\
    \        return Optional.of(Collections.min(_lst));", "        PriorityQueue<Long>\
    \ pq = new PriorityQueue<Long>();\n        pq.addAll(lst);\n        Long x = pq.poll();\n\
    \        Long y = pq.poll();\n        if (y == null) return Optional.empty();\n\
    \        while (!pq.isEmpty() && pq.peek().equals(y)) y = pq.poll();\n       \
    \ if (y == null) return Optional.empty();\n        return Optional.of(y);", " \
    \       if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        Long max = Long.MAX_VALUE;\n        Long secondMax = Long.MAX_VALUE;\n\
    \        for (Long l : lst) {\n            if (l < max) {\n                secondMax\
    \ = max;\n                max = l;\n            } else if (l < secondMax) {\n\
    \                secondMax = l;\n            }\n        }\n        if (secondMax\
    \ == Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n    \
    \    return Optional.of(secondMax);", "        if (lst.size() < 2) return Optional.empty();\n\
    \        Long first = lst.get(0);\n        Long second = null;\n        for (Long\
    \ l : lst) {\n            if (l < first) {\n                second = first;\n\
    \                first = l;\n            } else if (l != first && (second == null\
    \ || l < second)) {\n                second = l;\n            }\n        }\n \
    \       return Optional.ofNullable(second);", "        // Locate the smallest\
    \ element.\n        if (lst.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        var minInd = 0;\n        for (var i = 1; i < lst.size(); i++)\
    \ {\n            if (lst.get(i) < lst.get(minInd)) {\n                minInd =\
    \ i;\n            }\n        }\n        // Locate the next smallest element.\n\
    \        var nextMinInd = 0;\n        for (var i = 0; i < lst.size(); i++) {\n\
    \            if (i == minInd) {\n                continue;\n            }\n  \
    \          if (nextMinInd == minInd || lst.get(i) < lst.get(nextMinInd)) {\n \
    \               nextMinInd = i;\n            }\n        }\n        return Optional.of(lst.get(nextMinInd));",
  '        throw new UnsupportedOperationException("Waiting to be implemented.");',
  "        try {\n            if (lst.size() <= 1) {\n                return Optional.empty();\n\
    \            }\n            ArrayList<Long> sorted = new ArrayList<Long>(lst);\n\
    \            Collections.sort(sorted);\n            int k = 1;\n            while\
    \ (k < sorted.size() && sorted.get(k) == sorted.get(k - 1)) {\n              \
    \  k++;\n            }\n            if (k == sorted.size()) {\n              \
    \  return Optional.empty();\n            }\n            return Optional.of(sorted.get(k));\n\
    \        } catch (Exception e) {\n            System.out.println(\"Caught Exception:\
    \ \" + e.getClass() + \" \" + e.getMessage());\n            StackTraceElement[]\
    \ trace = e.getStackTrace();\n            for (StackTraceElement frame : trace)\
    \ {\n                System.out.println(frame.toString());\n            }\n  \
    \          return Optional.empty();\n        }", "        // Your Code Here.\n\
    \        if (lst.size() < 2) return Optional.empty();\n        long smallest =\
    \ Integer.MAX_VALUE;\n        long nextSmallest = Integer.MAX_VALUE;\n       \
    \ for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < smallest)\
    \ {\n                nextSmallest = smallest;\n                smallest = lst.get(i);\n\
    \            } else if (lst.get(i) > smallest && lst.get(i) < nextSmallest) {\n\
    \                nextSmallest = lst.get(i);\n            }\n        }\n      \
    \  if (nextSmallest == Integer.MAX_VALUE) return Optional.empty();\n        return\
    \ Optional.of(nextSmallest);", "        // Write your code here\n        // To\
    \ print results to the standard output you can use System.out.println()\n    \
    \    // Example: System.out.println(\"Hello world!\");\n        Collections.sort(lst);\n\
    \        long prev = -1;\n        for (long l : lst) {\n            if (l != prev)\
    \ {\n                if (prev != -1) {\n                    return Optional.of(prev);\n\
    \                }\n                prev = l;\n            }\n        }\n    \
    \    return Optional.empty();", "        Long ans = null;\n        return ans;",
  "      // Good luck!\n      return Optional.empty();", '        return null;', '        return
    null;', "        if (lst.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        Long minimum = lst.get(0);\n        Long secondMinimum = null;\n\
    \        for (Long i: lst) {\n            if (i <= minimum) {\n              \
    \  minimum = i;\n            } else if (secondMinimum == null || i < secondMinimum)\
    \ {\n                secondMinimum = i;\n            }\n        }\n        return\
    \ Optional.ofNullable(secondMinimum);", '        return Optional.empty();', " \
    \       // remove duplicates and sort\n        ArrayList<Long> a = new ArrayList<Long>(new\
    \ HashSet<Long>(lst));\n        Collections.sort(a);\n        // return if list\
    \ contains < 2 elements\n        if (a.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        return Optional.of(a.get(1));", "        Optional<Long> ans\
    \ = Optional.empty();\n        if (lst.size() == 0) {\n            return ans;\n\
    \        }\n        long first = Long.MAX_VALUE;\n        long second = Long.MAX_VALUE;\n\
    \        for (long i : lst) {\n            if (i <= first) {\n               \
    \ second = first;\n                first = i;\n            } else if (i < second\
    \ && i != first) {\n                second = i;\n            }\n        }\n  \
    \      if (second == Long.MAX_VALUE) {\n            return ans;\n        }\n \
    \       return Optional.of(second);", '        return null;', "        try {\n\
    \            if (lst.size() < 2) {\n                return Optional.empty();\n\
    \            }\n            for (int i = 0; i < lst.size(); i++) {\n         \
    \       for (int j = i + 1; j < lst.size(); j++) {\n                    if (lst.get(i)\
    \ > lst.get(j)) {\n                        long temp = lst.get(i);\n         \
    \               lst.set(i, lst.get(j));\n                        lst.set(j, temp);\n\
    \                    }\n                }\n            }\n            return Optional.of(lst.get(1));\n\
    \        } catch (Exception e) {\n            throw new AssertionError(\"Hint:\
    \ See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\"\
    );\n        }", "        // Your code here.\n        long smallest = Long.MAX_VALUE;\n\
    \        long secondSmallest = Long.MAX_VALUE;\n        for (long val : lst) {\n\
    \            if (val < smallest) {\n                secondSmallest = smallest;\n\
    \                smallest = val;\n            } else if (val < secondSmallest\
    \ && val != smallest) {\n                secondSmallest = val;\n            }\n\
    \        }\n        if (secondSmallest == Long.MAX_VALUE) {\n            return\
    \ Optional.empty();\n        }\n        return Optional.of(secondSmallest);",
  "        // BEGIN SOLUTION\n        if (lst.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        Collections.sort(lst);\n        return Optional.of(lst.get(1));\n\
    \        // END SOLUTION", "        if (lst.size() == 0) {\n            return\
    \ Optional.empty();\n        }\n        long smallest = lst.get(0);\n        long\
    \ nextSmallest = -1;\n        for (int i = 1; i < lst.size(); i++) {\n       \
    \     long item = lst.get(i);\n            if (item < smallest) {\n          \
    \      nextSmallest = smallest;\n                smallest = item;\n          \
    \  } else if (item < nextSmallest || nextSmallest == -1) {\n                nextSmallest\
    \ = item;\n            }\n        }\n        if (nextSmallest == -1) {\n     \
    \       return Optional.empty();\n        }\n        return Optional.of(nextSmallest);",
  "        if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        Long smallest = lst.get(0);\n        Long next_smallest = lst.get(1);\n\
    \        for (Long el : lst) {\n            if (el < smallest) {\n           \
    \     next_smallest = smallest;\n                smallest = el;\n            }\
    \ else if (el < next_smallest) {\n                next_smallest = el;\n      \
    \      }\n        }\n        return Optional.of(next_smallest);", "        //\
    \ return null;\n        // Your code here\n        Collections.sort(lst);\n  \
    \      for(Long i : lst){\n            if(Collections.frequency(lst, i) == 1){\n\
    \                return Optional.of(i);\n            }\n        }\n        return\
    \ Optional.empty();", "        // ENTER CODE HERE\n        return null;", "  \
    \      // Write your code here\n        // To print results to the standard output\
    \ you can use System.out.println()\n        // Example: System.out.println(\"\
    Hello world!\");", "        if (lst.size() <= 1) {\n            return Optional.empty();\n\
    \        }\n        long smallest = Long.MAX_VALUE;\n        long secondSmallest\
    \ = Long.MAX_VALUE;\n        for (Long x : lst) {\n            if (x < smallest)\
    \ {\n                secondSmallest = smallest;\n                smallest = x;\n\
    \            } else if (x < secondSmallest) {\n                secondSmallest\
    \ = x;\n            }\n        }\n        if (secondSmallest == Long.MAX_VALUE)\
    \ {\n            return Optional.empty();\n        }\n        return Optional.of(secondSmallest);",
  "        Optional<Long> ans = Optional.empty();\n        if(lst.size() >= 2) {\n\
    \            Collections.sort(lst);\n            ans = Optional.of(lst.get(1));\n\
    \        }\n        return ans;", "        if (lst.size() <= 1) {\n          \
    \  return Optional.empty();\n        }\n        lst.sort(Comparator.naturalOrder());\n\
    \        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i) !=\
    \ lst.get(i - 1)) {\n                return Optional.of(lst.get(i));\n       \
    \     }\n        }\n        return Optional.empty();", "        // Your code goes\
    \ here.\n        if (lst.size() == 0) {\n            return Optional.empty();\n\
    \        }\n        if (lst.size() == 1) {\n            return Optional.empty();\n\
    \        }\n        ArrayList<Long> list = new ArrayList<Long>(lst);\n       \
    \ if (list.size() == 2) {\n            if (list.get(0) > list.get(1)) {\n    \
    \            return Optional.of(list.get(1));\n            } else {\n        \
    \        return Optional.empty();\n            }\n        }\n        Collections.sort(list);\n\
    \        for (int i = 1; i < list.size(); i++) {\n            if (list.get(i)\
    \ != list.get(i - 1)) {\n                return Optional.of(list.get(i));\n  \
    \          }\n        }\n        return Optional.empty();", "        ArrayList<Long>\
    \ sortedLst = new ArrayList<Long>(lst);\n        Collections.sort(sortedLst);\n\
    \        for (int i = 0; i < lst.size() - 1; i++) {\n            if (sortedLst.get(i)\
    \ != sortedLst.get(i + 1)) {\n                return Optional.of(sortedLst.get(i\
    \ + 1));\n            }\n        }\n        return Optional.empty();", "     \
    \   // Your code goes here!\n        return null;", "        if (lst.size() ==\
    \ 0) return Optional.empty();\n        else if (lst.size() == 1) return Optional.empty();\n\
    \        else {\n            // return Optional.of(lst.stream().distinct().filter(x\
    \ -> x != Collections.min(lst)).findFirst().get());\n            Long min = Collections.min(lst);\n\
    \            Long minCount = lst.stream().filter(x -> x == min).count();\n   \
    \         Long secondMin = Collections.min(lst.stream().filter(x -> x != min).collect(Collectors.toList()));\n\
    \            Long secondMinCount = lst.stream().filter(x -> x == secondMin).count();\n\
    \            if (minCount > 1) return Optional.empty();\n            else if (secondMinCount\
    \ > 1) return Optional.empty();\n            else return Optional.of(secondMin);\n\
    \        }", "        if (lst.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        Collections.sort(lst);\n        return Optional.of((long)lst.get(1));",
  "        Collections.sort(lst);\n        long prev = Long.MIN_VALUE;\n        for\
    \ (long elem : lst) {\n            if (elem > prev) {\n                return\
    \ Optional.of(elem);\n            }\n            prev = elem;\n        }\n   \
    \     return Optional.empty();", "        Optional<Long> nextSmallest;\n     \
    \   long curSmallest = Long.MAX_VALUE;\n        long curSmallest2 = Long.MAX_VALUE;\n\
    \        for (Long l : lst) {\n            if (l < curSmallest) {\n          \
    \      curSmallest2 = curSmallest;\n                curSmallest = l;\n       \
    \     } else if (l < curSmallest2) {\n                curSmallest2 = l;\n    \
    \        }\n        }\n        if (curSmallest2 == Long.MAX_VALUE) {\n       \
    \     nextSmallest = Optional.empty();\n        } else {\n            nextSmallest\
    \ = Optional.of(curSmallest2);\n        }\n        return nextSmallest;", '        return
    null;', '        return null;', "        Optional<Long> nextSmallest;\n      \
    \  if (lst.size() < 2) {\n            nextSmallest = Optional.empty();\n     \
    \   } else {\n            long min1 = Long.MAX_VALUE;\n            long min2 =\
    \ Long.MAX_VALUE;\n            for (Long x : lst) {\n                if (x < min1)\
    \ {\n                    min2 = min1;\n                    min1 = x;\n       \
    \         } else if (x < min2) {\n                    min2 = x;\n            \
    \    }\n            }\n            if (min2 != Long.MAX_VALUE) {\n           \
    \     nextSmallest = Optional.of(min2);\n            } else {\n              \
    \  nextSmallest = Optional.empty();\n            }\n        }\n        return\
    \ nextSmallest;", '        return Optional.empty();', '        return new Optional<Long>();',
  "        ArrayList<Long> distinct = new ArrayList<>();\n        for (Long e : lst)\
    \ {\n            if (!distinct.contains(e)) {\n                distinct.add(e);\n\
    \            }\n        }\n        Collections.sort(distinct);\n        if (distinct.size()\
    \ < 2) {\n            return Optional.empty();\n        }\n        return Optional.of(distinct.get(1));",
  "        Long min = lst.stream().min(Long::compare).orElse(null);\n        if (min\
    \ == null) {\n            return Optional.empty();\n        }\n        Long result\
    \ = null;\n        boolean found = false;\n        for (Long l : lst) {\n    \
    \        if (l > min) {\n                if (!found) {\n                    result\
    \ = l;\n                    found = true;\n                } else {\n        \
    \            result = Math.min(result, l);\n                }\n            }\n\
    \        }\n        return found ? Optional.of(result) : Optional.empty();", " \
    \       Optional<Long> ret = Optional.empty();\n        return ret;", "      \
    \  // Your code here\n        return Optional.empty();", "        if (lst.size()\
    \ == 0) {\n            return Optional.empty();\n        }\n        else if (lst.size()\
    \ == 1) {\n            return Optional.empty();\n        }\n        else {\n \
    \           long min1 = (long)0l;\n            long min2 = (long)0l;\n       \
    \     boolean firstRun = true;\n            for (Long i : lst) {\n           \
    \     if (firstRun) {\n                    min1 = i;\n                    min2\
    \ = i;\n                    firstRun = false;\n                }\n           \
    \     else {\n                    if (i < min1) {\n                        min2\
    \ = min1;\n                        min1 = i;\n                    }\n        \
    \            else if (i < min2) {\n                        min2 = i;\n       \
    \             }\n                }\n            }\n            if (min1 == min2)\
    \ {\n                return Optional.empty();\n            }\n            else\
    \ {\n                return Optional.of(min2);\n            }\n        }", " \
    \       // >>> Enter solution here\n        return null;", "        if (lst.size()\
    \ <= 1) return Optional.empty();\n        long min = Long.MAX_VALUE;\n       \
    \ long nextMin = Long.MAX_VALUE;\n        for (Long l : lst) {\n            if\
    \ (l < min) {\n                nextMin = min;\n                min = l;\n    \
    \        } else if (l > min && l < nextMin) {\n                nextMin = l;\n\
    \            }\n        }\n        if (nextMin == Long.MAX_VALUE) return Optional.empty();\n\
    \        return Optional.of(nextMin);", "        lst.sort(null);\n        Long\
    \ lastVal = null;\n        boolean foundSecond = false;\n        for (Long l :\
    \ lst) {\n            if (lastVal == null) {\n                lastVal = l;\n \
    \           } else if (l != lastVal) {\n                if (foundSecond) {\n \
    \                   return Optional.of(l);\n                } else {\n       \
    \             foundSecond = true;\n                }\n            }\n        }\n\
    \        return Optional.empty();", "        if (lst.size() < 2) {\n         \
    \   return Optional.empty();\n        }\n        Long smallest = null;\n     \
    \   Long smallest2 = null;\n        for (Long el : lst) {\n            if (smallest\
    \ == null) {\n                smallest = el;\n            } else if (el < smallest)\
    \ {\n                smallest2 = smallest;\n                smallest = el;\n \
    \           } else if (smallest2 == null || el < smallest2) {\n              \
    \  smallest2 = el;\n            }\n        }\n        return Optional.ofNullable(smallest2);",
  "        Long min1 = null;\n        Long min2 = null;\n        for (Long x : lst)\
    \ {\n            if (min1 == null || x < min1) {\n                min2 = min1;\n\
    \                min1 = x;\n            } else if (min2 == null || x < min2) {\n\
    \                min2 = x;\n            }\n        }\n        return Optional.ofNullable(min2);",
  "        if (lst.size() <= 1) {\n            return Optional.empty();\n        }\n\
    \        long smallest = lst.get(0);\n        long smallestButOne = smallest;\n\
    \        for (int i = 1; i < lst.size(); i++) {\n            long current = lst.get(i);\n\
    \            if (current < smallest) {\n                smallestButOne = smallest;\n\
    \                smallest = current;\n            } else if (current < smallestButOne)\
    \ {\n                smallestButOne = current;\n            }\n        }\n   \
    \     if (smallest == smallestButOne) {\n            return Optional.empty();\n\
    \        }\n        return Optional.of(smallestButOne);", '        return null;',
  '        return null;', "        ArrayList<Long> lst2 = new ArrayList<Long>(lst);\n\
    \        lst2.sort(null);\n        Long min = lst2.get(0);\n        for (Long\
    \ i: lst2) {\n            if (i > min) {\n                return Optional.of(i);\n\
    \            }\n        }\n        return Optional.empty();", '        return
    Optional.empty();', "        if (lst.size() == 0) {\n            return Optional.empty();\n\
    \        }\n        if (lst.size() == 1) {\n            return Optional.empty();\n\
    \        }\n        Long min = Collections.min(lst);\n        lst.remove(min);\n\
    \        Long min2 = Collections.min(lst);\n        return Optional.of(min2);",
  "        //return Optional.empty();\n        //return Optional.of((long)1l);\n \
    \       //return Optional.of((long)2l);\n        //return Optional.of((long)3l);\n\
    \        //return Optional.of((long)4l);\n        //return Optional.of((long)5l);\n\
    \        //return Optional.of((long)6l);\n        //return Optional.of((long)7l);\n\
    \        //return Optional.of((long)8l);\n        //return Optional.of((long)9l);\n\
    \        //return Optional.of((long)10l);\n        //return Optional.of((long)11l);\n\
    \        //return Optional.of((long)12l);\n        //return Optional.of((long)13l);\n\
    \        //return Optional.of((long)14l);\n        //return Optional.of((long)15l);\n\
    \        //return Optional.of((long)16l);\n        //return Optional.of((long)17l);\n\
    \        //return Optional.of((long)18l);\n        //return Optional.of((long)19l);\n\
    \        //return Optional.of((long)20l);\n        //return Optional.of((long)21l);\n\
    \        //return Optional.of((long)22l);\n        //return Optional.of((long)23l);\n\
    \        //return Optional.of((long)24l);\n        //return Optional.of((long)25l);\n\
    \        //return Optional.of((long)26l);\n        //return Optional.of((long)27l);\n\
    \        //return Optional.of((long)28l);\n        //return Optional.of((long)29l);\n\
    \        //return Optional.of((long)30l);\n        //return Optional.of((long)31l);\n\
    \        //return Optional.of((long)32l);\n        //return Optional.of((long)33l);\n\
    \        //return Optional.of((long)34l);\n        //return Optional.of((long)35l);\n\
    \        //return Optional.of((long)36l);\n        //return Optional.of((long)37l);\n\
    \        //return Optional.of((long)38l);\n        //return Optional.of((long)",
  "        if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        // Initialize a variable with a positive infinity value.\n        long\
    \ min = Long.MAX_VALUE;\n        // Initialize a variable with a positive infinity\
    \ value.\n        long secondMin = Long.MAX_VALUE;\n        // Iterate over the\
    \ list.\n        for (long i : lst) {\n            // If the number is less than\
    \ min, update secondMin with the current min value, then update min with the current\
    \ i value.\n            if (i < min) {\n                secondMin = min;\n   \
    \             min = i;\n            }\n            // If the number is less than\
    \ secondMin, update secondMin with the current i value.\n            else if (i\
    \ < secondMin) {\n                secondMin = i;\n            }\n        }\n \
    \       // Check if secondMin was ever updated and return an optional of secondMin\
    \ or empty.\n        return (secondMin != Long.MAX_VALUE) ? Optional.of(secondMin)\
    \ : Optional.empty();", "        ArrayList<Long> lst_cpy = (ArrayList<Long>)lst.clone();\n\
    \        HashSet<Long> hset = new HashSet<Long>();\n        hset.addAll(lst_cpy);\n\
    \        lst_cpy.clear();\n        lst_cpy.addAll(hset);\n        Collections.sort(lst_cpy);\n\
    \        if (lst_cpy.size() <= 1) {\n            return Optional.empty();\n  \
    \      }\n        else {\n            return Optional.of(lst_cpy.get(1));\n  \
    \      }", '        return null;', "        // TODO: add your code here to implement\
    \ the function\n        if (lst.size() <= 1) return Optional.empty();\n      \
    \  long min = lst.get(0);\n        long min2 = min;\n        for (int i = 1; i\
    \ < lst.size(); i++) {\n            long e = lst.get(i);\n            if (e <=\
    \ min) {\n                min2 = min;\n                min = e;\n            }\
    \ else if (e <= min2) {\n                min2 = e;\n            }\n        }\n\
    \        if (min2 == min) return Optional.empty();\n        return Optional.of(min2);",
  "        if (lst.size() <= 1) return Optional.empty();\n        long n = 0l;\n \
    \       long m = Long.MAX_VALUE;\n        for (long x : lst) {\n            if\
    \ (x < m) {\n                n = m;\n                m = x;\n            } else\
    \ if (x < n) {\n                n = x;\n            }\n        }\n        if (n\
    \ == Long.MAX_VALUE) return Optional.empty();\n        return Optional.of(n);",
  "        if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        long min = Long.MAX_VALUE;\n        long secondMin = Long.MAX_VALUE;\n\
    \        for (Long l : lst) {\n            if (l <= min) {\n                secondMin\
    \ = min;\n                min = l;\n            } else if (l < secondMin) {\n\
    \                secondMin = l;\n            }\n        }\n        if (secondMin\
    \ == Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n    \
    \    return Optional.of(secondMin);", "        if (lst.size() < 2) return Optional.empty();\n\
    \        return Optional.of(lst.stream().distinct().sorted().limit(2).reduce((a,\
    \ b) -> b));", "        // Your code goes here\n        if (lst.size() <= 1) {\n\
    \            return Optional.empty();\n        }\n        long min = lst.get(0);\n\
    \        long secondMin = Long.MAX_VALUE;\n        for (int i = 1; i < lst.size();\
    \ i++) {\n            if (lst.get(i) < min) {\n                secondMin = min;\n\
    \                min = lst.get(i);\n            } else if (lst.get(i) < secondMin\
    \ && lst.get(i) != min) {\n                secondMin = lst.get(i);\n         \
    \   }\n        }\n        if (secondMin == Long.MAX_VALUE) {\n            return\
    \ Optional.empty();\n        }\n        return Optional.of(secondMin);", '        return
    null;', '        return Optional.empty();', '        return null;', "        Optional<Long>\
    \ min;\n        min = lst.stream().min(Long::compare);\n        lst.remove(min.get());\n\
    \        return lst.stream().min(Long::compare);", "        // TODO: Fill in the\
    \ body\n        if (lst.size() == 0) {\n            return Optional.empty();\n\
    \        }\n        if (lst.size() == 1) {\n            return Optional.empty();\n\
    \        }\n        ArrayList<Long> copy = new ArrayList<Long>(lst);\n       \
    \ Collections.sort(copy);\n        if (copy.get(0) == copy.get(1)) {\n       \
    \     return Optional.empty();\n        }\n        return Optional.of(copy.get(1));",
  "        // return the 2nd smallest element of lst\n        if (lst.size() < 2)\
    \ {\n            return Optional.empty();\n        }\n        long smallest =\
    \ Long.MAX_VALUE;\n        long nextSmallest = Long.MAX_VALUE;\n        for (long\
    \ x : lst) {\n            if (x < smallest) {\n                nextSmallest =\
    \ smallest;\n                smallest = x;\n            } else if (x < nextSmallest)\
    \ {\n                nextSmallest = x;\n            }\n        }\n        if (nextSmallest\
    \ == Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n    \
    \    return Optional.of(nextSmallest);", "        // Write your code here.\n \
    \       return null;", '        return null;', "        if (lst.size() < 2) {\n\
    \            return Optional.empty();\n        }\n        TreeSet<Long> sorted\
    \ = new TreeSet<Long>(lst);\n        Iterator<Long> iterator = sorted.iterator();\n\
    \        iterator.next();\n        return Optional.of(iterator.next());", "  \
    \      Collections.sort(lst);\n        Long previous = null;\n        Long current\
    \ = null;\n        for (Long l : lst) {\n            if (previous == null) {\n\
    \                previous = l;\n            } else {\n                current\
    \ = l;\n                if (previous < current) {\n                    return\
    \ Optional.of(current);\n                }\n                previous = current;\n\
    \            }\n        }\n        return Optional.empty();", "        Optional<Long>\
    \ result = Optional.empty();\n        if (lst.size() > 1) {\n            lst.sort(Comparator.naturalOrder());\n\
    \            Long smallest = lst.get(0);\n            Long secondSmallest = smallest;\n\
    \            for (Long l : lst) {\n                if (l > smallest) {\n     \
    \               secondSmallest = l;\n                    break;\n            \
    \    }\n            }\n            if (secondSmallest > smallest) {\n        \
    \        result = Optional.of(secondSmallest);\n            }\n        }\n   \
    \     return result;", "        Optional<Long> _min = null;\n        Optional<Long>\
    \ _min2 = null;\n        for (Long x : lst) {\n            if (_min == null) {\n\
    \                _min = Optional.of(x);\n            } else if (x < _min.get())\
    \ {\n                _min2 = _min;\n                _min = Optional.of(x);\n \
    \           } else if (_min2 == null) {\n                _min2 = Optional.of(x);\n\
    \            } else if (x < _min2.get()) {\n                _min2 = Optional.of(x);\n\
    \            }\n        }\n        return _min2;", "        // throw new UnsupportedOperationException(\"\
    Method not implemented yet!\");\n        Optional<Long> small = Optional.empty();\n\
    \        Optional<Long> next_small = Optional.empty();\n        Iterator<Long>\
    \ iter = lst.iterator();\n        while (iter.hasNext()) {\n            Optional<Long>\
    \ val = Optional.of(iter.next());\n            if (small.isEmpty()) {\n      \
    \          small = val;\n            } else if (small.get() > val.get()) {\n \
    \               next_small = small;\n                small = val;\n          \
    \  } else if (next_small.isEmpty() || small.get() < val.get() && next_small.get()\
    \ > val.get()) {\n                next_small = val;\n            }\n        }\n\
    \        return next_small;", '        return lst.stream().sorted(Comparator.naturalOrder()).distinct().skip(1).findFirst();',
  "        ArrayList<Long> sorted = (ArrayList<Long>) lst.clone();\n        Collections.sort(sorted);\n\
    \        // remove duplicates\n        HashSet<Long> hs = new HashSet<>();\n \
    \       hs.addAll(sorted);\n        ArrayList<Long> norepeats = new ArrayList<>(hs);\n\
    \        // return 2nd smallest\n        if (norepeats.size() >= 2) {\n      \
    \      return Optional.of(norepeats.get(1));\n        } else {\n            return\
    \ Optional.empty();\n        }", "        Long smallest = null;\n        Long\
    \ secondSmallest = null;\n        for (Long i : lst) {\n            if (smallest\
    \ == null) {\n                smallest = i;\n            } else if (i < smallest)\
    \ {\n                secondSmallest = smallest;\n                smallest = i;\n\
    \            } else if (secondSmallest == null || i < secondSmallest) {\n    \
    \            secondSmallest = i;\n            }\n        }\n        return Optional.ofNullable(secondSmallest);",
  "        if (lst.size() < 2) return Optional.empty();\n        long min1 = lst.get(0);\n\
    \        long min2 = lst.get(1);\n        if (min1 > min2) {\n            long\
    \ tmp = min1;\n            min1 = min2;\n            min2 = tmp;\n        }\n\
    \        for (int i = 2; i < lst.size(); i++) {\n            long cur = lst.get(i);\n\
    \            if (cur < min1) {\n                min2 = min1;\n               \
    \ min1 = cur;\n            } else if (cur < min2) {\n                min2 = cur;\n\
    \            }\n        }\n        return Optional.of(min2);", "        if (lst.size()\
    \ == 0) {\n            return Optional.empty();\n        }\n        Long min =\
    \ lst.get(0);\n        Long secondMin = Long.MAX_VALUE;\n        for (Long l :\
    \ lst) {\n            if (l < min) {\n                secondMin = min;\n     \
    \           min = l;\n            } else if (l > min && l < secondMin) {\n   \
    \             secondMin = l;\n            }\n        }\n        if (secondMin\
    \ == Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n    \
    \    return Optional.of(secondMin);", "        Optional<Long> result = Optional.empty();\n\
    \        // We know n is the smallest number in the list, so we can make a safe\n\
    \        // guard against it to make sure we get the second smallest number.\n\
    \        Long n = lst.get(0);\n        for (Long num : lst) {\n            if\
    \ (num < n) {\n                result = Optional.of(num);\n                break;\n\
    \            }\n        }\n        // If there was no smaller number than our\
    \ first one, we return empty\n        return result;", "        if (lst.size()\
    \ < 2) {\n            return Optional.empty();\n        }\n        else {\n  \
    \          return Optional.of(Collections.min(lst.stream().filter(x -> x != Collections.min(lst)).collect(Collectors.toList())));\n\
    \        }", "        // your code goes here.\n        return Optional.empty();",
  '        return Optional.empty();', "        Optional<Long> min1 = Optional.empty();\n\
    \        Optional<Long> min2 = Optional.empty();\n        for (Long x : lst) {\n\
    \            if (!min1.isPresent() || x < min1.get()) {\n                min2\
    \ = min1;\n                min1 = Optional.of(x);\n            } else if (!min2.isPresent()\
    \ || x < min2.get()) {\n                min2 = Optional.of(x);\n            }\n\
    \        }\n        return min2;", '        return Optional.empty();', '        return
    lst.stream().sorted().distinct().skip(1).findFirst();', '        throw new RuntimeException("Not
    implemented yet");', "        if (lst.size() < 2) return Optional.empty();\n \
    \       ArrayList<Long> seen = new ArrayList<Long>();\n        seen.add(lst.get(0));\n\
    \        for (Long i: lst) {\n            if (i < seen.get(0)) {\n           \
    \     seen.add(0, i);\n            } else if (i > seen.get(0) && i < seen.get(1))\
    \ {\n                seen.add(1, i);\n            }\n        }\n        if (seen.size()\
    \ == 2) return Optional.of(seen.get(1));\n        return Optional.empty();", " \
    \       // Just a placeholder so code compiles.\n        return Optional.empty();",
  "        // Write your code here\n        return null;", "        // int[] counts\
    \ = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        // for (int i = 0; i < lst.size();\
    \ i++) {\n        //     // counts[(int) lst.get(i)] += 1;\n        //     counts[lst.get(i).intValue()]\
    \ += 1;\n        // }\n        // for (int i = 0; i < counts.length; i++) {\n\
    \        //     if (counts[i] >= 2) {\n        //         return Optional.of((long)\
    \ i);\n        //     }\n        // }\n        // return Optional.empty();\n \
    \       Collections.sort(lst);\n        for (int i = 0; i < lst.size() - 1; i++)\
    \ {\n            if (lst.get(i).equals(lst.get(i + 1))) {\n                return\
    \ Optional.of(lst.get(i));\n            }\n        }\n        return Optional.empty();",
  "        long min = Collections.min(lst);\n        lst.remove(min);\n        if\
    \ (lst.size() > 0) {\n            long min2 = Collections.min(lst);\n        \
    \    return Optional.of(min2);\n        } else {\n            return Optional.empty();\n\
    \        }", "        // REPLACE THE BODY OF THIS METHOD WITH YOUR OWN IMPLEMENTATION\n\
    \        return Optional.empty();", "        if (lst.size() <= 1) return Optional.empty();\n\
    \        else {\n            Collections.sort(lst);\n            ArrayList<Long>\
    \ unique_lst = new ArrayList<Long>();\n            for (int i = 0; i < lst.size();\
    \ i++) {\n                if (i == 0 || lst.get(i) != lst.get(i - 1)) {\n    \
    \                unique_lst.add(lst.get(i));\n                }\n            }\n\
    \            if (unique_lst.size() == 1) return Optional.empty();\n          \
    \  else return Optional.of(unique_lst.get(1));\n        }", "        Optional<Long>\
    \ ret = Optional.empty();\n        if (lst.size() > 1) {\n            List<Long>\
    \ lstSorted = new ArrayList<Long>(lst);\n            Collections.sort(lstSorted);\n\
    \            for (int i = 0; i < lstSorted.size() - 1; i++) {\n              \
    \  if (lstSorted.get(i).longValue() != lstSorted.get(i + 1).longValue()) {\n \
    \                   ret = Optional.of(lstSorted.get(i + 1));\n               \
    \     break;\n                }\n            }\n        }\n        return ret;",
  "        lst.sort(Long::compareTo);\n        int n = lst.size();\n        int prev\
    \ = Integer.MIN_VALUE;\n        long ans = -1;\n        for (int i = 0; i < n;\
    \ i++) {\n            long curr = lst.get(i);\n            if (curr > prev) {\n\
    \                ans = curr;\n                break;\n            }\n        \
    \    prev = curr;\n        }\n        if (ans == -1) return Optional.empty();\n\
    \        return Optional.of(ans);", "        if (lst.size() < 2) {\n         \
    \   return Optional.empty();\n        }\n        Set<Long> uniques = new HashSet<Long>(lst);\n\
    \        if (uniques.size() < 2) {\n            return Optional.empty();\n   \
    \     }\n        Long min = lst.get(0);\n        Long min2 = null;\n        for\
    \ (Long n : lst) {\n            if (n < min) {\n                min2 = min;\n\
    \                min = n;\n            } else if (n < min2 || min2 == null) {\n\
    \                min2 = n;\n            }\n        }\n        return Optional.of(min2);",
  "        if (lst.size() < 2) {\n            return Optional.empty();\n        }\
    \ else {\n            Long min = lst.get(0);\n            Long second_min = null;\n\
    \            for (Long e : lst) {\n                if (e < min) {\n          \
    \          second_min = min;\n                    min = e;\n                }\
    \ else if (second_min == null || e < second_min) {\n                    second_min\
    \ = e;\n                }\n            }\n            return Optional.of(second_min);\n\
    \        }", "        Long secondSmallest = null;\n        return Optional.ofNullable(secondSmallest);",
  "        if (lst.size() > 1) {\n            long min = Math.min(lst.get(0), lst.get(1));\n\
    \            long second = Math.max(lst.get(0), lst.get(1));\n            for\
    \ (int i = 2; i < lst.size(); i++) {\n                if (lst.get(i) < min) {\n\
    \                    second = min;\n                    min = lst.get(i);\n  \
    \              } else if (lst.get(i) < second) {\n                    second =\
    \ lst.get(i);\n                }\n            }\n            if (min == second)\
    \ {\n                return Optional.empty();\n            } else {\n        \
    \        return Optional.of(second);\n            }\n        } else {\n      \
    \      return Optional.empty();\n        }", '        return lst.stream().sorted().skip(1).findFirst();',
  "        if (lst.size() < 2) return Optional.empty();\n        List<Long> lst2 =\
    \ new ArrayList<Long>(lst);\n        Collections.sort(lst2);\n        Long tmp\
    \ = lst2.get(0);\n        for (Long l : lst2) {\n            if (l > tmp) return\
    \ Optional.of(l);\n            tmp = l;\n        }\n        return Optional.empty();",
  "        // Fill this in.\n        // Optional<Long> answer = null;\n        if\
    \ (lst.size() < 2) {\n            return Optional.empty();\n        }\n      \
    \  long min = Long.MAX_VALUE;\n        long second = Long.MAX_VALUE;\n       \
    \ for (long x : lst) {\n            if (x < min) {\n                second = min;\n\
    \                min = x;\n            } else if (x < second && x != min) {\n\
    \                second = x;\n            }\n        }\n        if (second ==\
    \ Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n       \
    \ return Optional.of(second);", "        // BEGIN\n        return null;\n    \
    \    // END", "        // fill in your code here\n        return Optional.empty();",
  "        // Your code here.\n        return Optional.empty();", "        Collections.sort(lst);\n\
    \        long min = lst.get(0);\n        long nextSmallest = Long.MAX_VALUE;\n\
    \        for (long i : lst) {\n            if (i > min && i < nextSmallest) {\n\
    \                nextSmallest = i;\n            }\n        }\n        if (nextSmallest\
    \ == Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n    \
    \    return Optional.of(nextSmallest);", "        if (lst.size() == 0) {\n   \
    \         return Optional.empty();\n        }\n        if (lst.size() == 1) {\n\
    \            return Optional.empty();\n        }\n        ArrayList<Long> unique\
    \ = new ArrayList<Long>();\n        for (Long n : lst) {\n            if (!(unique.contains(n)))\
    \ {\n                unique.add(n);\n            }\n        }\n        Collections.sort(unique);\n\
    \        if (unique.size() == 1) {\n            return Optional.empty();\n   \
    \     }\n        return Optional.of(unique.get(1));", "        if (lst.size()\
    \ == 0) {\n            return Optional.empty();\n        }\n        if (lst.size()\
    \ == 1) {\n            return Optional.empty();\n        }\n        Collections.sort(lst);\n\
    \        long[] l = (long[])lst.stream().distinct().limit(2).toArray(size -> new\
    \ long[size]);\n        if (l.length == 1) {\n            return Optional.empty();\n\
    \        }\n        return Optional.of(l[1]);", "        if (lst.size() <= 1)\
    \ return Optional.empty();\n        Collections.sort(lst);\n        long min =\
    \ lst.get(0);\n        long second_min = Long.MAX_VALUE;\n        for (int i =\
    \ 1; i < lst.size(); i++) {\n            if (lst.get(i) > min && lst.get(i) <\
    \ second_min) {\n                second_min = lst.get(i);\n            }\n   \
    \     }\n        if (second_min == Long.MAX_VALUE) return Optional.empty();\n\
    \        return Optional.of(second_min);", "        Optional<Long> smallest =\
    \ Optional.empty();\n        Optional<Long> secondSmallest = Optional.empty();\n\
    \        for (int i = 0; i < lst.size(); i++) {\n            Long value = lst.get(i);\n\
    \            if (!smallest.isPresent() || value < smallest.get()) {\n        \
    \        secondSmallest = smallest;\n                smallest = Optional.of(value);\n\
    \            } else if (!secondSmallest.isPresent() || value < secondSmallest.get())\
    \ {\n                secondSmallest = Optional.of(value);\n            }\n   \
    \     }\n        return secondSmallest;", "        if (lst.size() < 2) {\n   \
    \         return Optional.empty();\n        }\n        return lst.stream().sorted().skip(1).findFirst();",
  "        long maxVal = Long.MAX_VALUE;\n        long smlVal = maxVal;\n        for\
    \ (long elem : lst) {\n            if (smlVal > elem) {\n                smlVal\
    \ = elem;\n            }\n        }\n        for (long elem : lst) {\n       \
    \     if (elem > smlVal && elem < maxVal) {\n                maxVal = elem;\n\
    \            }\n        }\n        if (maxVal == Long.MAX_VALUE) {\n         \
    \   return Optional.empty();\n        }\n        return Optional.of(maxVal);",
  "        Long min = (long)100000000000000000l;\n        Long min2 = (long)100000000000000000l;\n\
    \        if (lst.size() == 0) {\n            return Optional.empty();\n      \
    \  }\n        if (lst.size() == 1) {\n            return Optional.empty();\n \
    \       }\n        for (Long num : lst) {\n            if (num < min) {\n    \
    \            min2 = min;\n                min = num;\n            }\n        \
    \    else if (num < min2) {\n                min2 = num;\n            }\n    \
    \    }\n        if (min2 == 1000000000000000000l) {\n            return Optional.empty();\n\
    \        }\n        return Optional.of(min2);", "        //Your code here!\n \
    \       Long smallest = Long.MAX_VALUE;\n        Long secondSmallest = Long.MAX_VALUE;\n\
    \        for (Long i : lst) {\n            if (i < smallest) {\n             \
    \   secondSmallest = smallest;\n                smallest = i;\n            } else\
    \ if (i < secondSmallest && i != smallest) {\n                secondSmallest =\
    \ i;\n            }\n        }\n        if (secondSmallest == Long.MAX_VALUE)\
    \ {\n            return Optional.empty();\n        }\n        return Optional.of(secondSmallest);",
  "        if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        Long smallest = lst.get(0);\n        Long secondSmallest = lst.get(1);\n\
    \        for (Long value : lst) {\n            if (value < smallest) {\n     \
    \           secondSmallest = smallest;\n                smallest = value;\n  \
    \          } else if (value < secondSmallest) {\n                secondSmallest\
    \ = value;\n            }\n        }\n        return Optional.of(secondSmallest);",
  "        if (lst.size() < 2) return Optional.empty();\n        // IMPLEMENT THIS\n\
    \        return Optional.empty();", "        ArrayList<Long> newlst = (ArrayList<Long>)lst.clone();\n\
    \        Collections.sort(newlst);\n        Collections.reverse(newlst);\n   \
    \     long prev = newlst.get(0);\n        for (int i = 1; i < newlst.size(); i++)\
    \ {\n            long curr = newlst.get(i);\n            if (curr != prev) {\n\
    \                return Optional.of(curr);\n            }\n        }\n       \
    \ return Optional.empty();", "        // 2 pts for solution with nested for loops\n\
    \        // 4 pts for solution with 2 for loops\n        // 4 pts for solution\
    \ with 1 for loop\n        return null;", "        if (lst.size() < 2) return\
    \ Optional.empty();\n        long firstSmallest = lst.get(0);\n        long secondSmallest\
    \ = Long.MAX_VALUE;\n        for (int i = 1; i < lst.size(); i++) {\n        \
    \    if (lst.get(i) <= firstSmallest) {\n                secondSmallest = firstSmallest;\n\
    \                firstSmallest = lst.get(i);\n            } else if (lst.get(i)\
    \ < secondSmallest) {\n                secondSmallest = lst.get(i);\n        \
    \    }\n        }\n        if (secondSmallest == Long.MAX_VALUE) return Optional.empty();\n\
    \        return Optional.of(secondSmallest);", "        // Write code here to\
    \ return the next smallest element from lst.\n        // If no such element exists,\
    \ return Optional.empty() instead.\n        return null;", '        return null;',
  "        if (lst.size() == 0) {\n            return Optional.empty();\n        }\n\
    \        long min1 = Long.MAX_VALUE;\n        long min2 = Long.MAX_VALUE;\n  \
    \      for (long e : lst) {\n            if (e < min1) {\n                min2\
    \ = min1;\n                min1 = e;\n            } else if (e < min2) {\n   \
    \             min2 = e;\n            }\n        }\n        if (min2 == Long.MAX_VALUE)\
    \ {\n            return Optional.empty();\n        }\n        return Optional.of(min2);",
  "        if (lst.size() == 0) {\n            return Optional.empty();\n        }\n\
    \        if (lst.size() == 1) {\n            return Optional.empty();\n      \
    \  }\n        Collections.sort(lst);\n        long smallest = lst.get(0);\n  \
    \      long smallest2 = lst.get(1);\n        if (smallest == smallest2) {\n  \
    \          return Optional.empty();\n        }\n        return Optional.of(smallest2);",
  "        // your code here\n        return Optional.empty();", "        int temp\
    \ = Integer.MAX_VALUE;\n        for (int i = 0; i < lst.size(); i++) {\n     \
    \       if (lst.get(i) < temp) {\n                temp = lst.get(i);\n       \
    \     }\n        }\n        if (temp == Integer.MAX_VALUE) {\n            return\
    \ Optional.empty();\n        }\n        int temp2 = Integer.MAX_VALUE;\n     \
    \   for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < temp2\
    \ && lst.get(i) > temp) {\n                temp2 = lst.get(i);\n            }\n\
    \        }\n        if (temp2 == Integer.MAX_VALUE) {\n            return Optional.empty();\n\
    \        }\n        return Optional.of((long)temp2);", "        Optional<Long>\
    \ result = Optional.empty();\n        return result;", "        Long min = Long.MAX_VALUE;\n\
    \        Long min2 = Long.MAX_VALUE;\n        Long result = null;\n        for\
    \ (Long num : lst) {\n            if (num < min) {\n                min2 = min;\n\
    \                min = num;\n            } else if (num < min2) {\n          \
    \      min2 = num;\n            }\n        }\n        if (min2 == Long.MAX_VALUE)\
    \ {\n            return Optional.empty();\n        }\n        return Optional.of(min2);",
  "        if (lst.size() < 2) {\n            return Optional.empty();\n        }\n\
    \        long min = Long.MAX_VALUE;\n        long secondMin = Long.MAX_VALUE;\n\
    \        for (Long l : lst) {\n            if (l < min) {\n                secondMin\
    \ = min;\n                min = l;\n            } else if (l < secondMin) {\n\
    \                secondMin = l;\n            }\n        }\n        if (secondMin\
    \ == Long.MAX_VALUE) {\n            return Optional.empty();\n        }\n    \
    \    return Optional.of(secondMin);", "        long[] arr = lst.stream().mapToLong(i\
    \ -> i).toArray();\n        if (arr.length <= 1) {\n            return Optional.empty();\n\
    \        }\n        Arrays.sort(arr);\n        long lowest = arr[0];\n       \
    \ int index = 1;\n        while (index < arr.length && arr[index] == lowest) {\n\
    \            index += 1;\n        }\n        if (index >= arr.length) {\n    \
    \        return Optional.empty();\n        }\n        return Optional.of(arr[index]);",
  '        return null;', '        return null;', "        if (lst.size() == 0) {\n\
    \            return Optional.empty();\n        }\n        if (lst.size() == 1)\
    \ {\n            return Optional.empty();\n        }\n        lst.sort(null);\n\
    \        Long[] arr = new Long[lst.size()];\n        lst.toArray(arr);\n     \
    \   for (int i = 0; i < lst.size() - 1; i++) {\n            if (arr[i + 1] !=\
    \ arr[i]) {\n                return Optional.of(arr[i + 1]);\n            }\n\
    \        }\n        return Optional.empty();", "        // YOUR CODE HERE\n  \
    \      return Optional.empty();", "        // WRITE YOUR CODE HERE\n        List<Long>\
    \ temp = new ArrayList<Long>(lst);\n        temp.sort(Comparator.naturalOrder());\n\
    \        temp.removeIf(x -> x.equals(temp.get(0)));\n        if (temp.size() ==\
    \ 0) {\n            return Optional.empty();\n        }\n        return Optional.of(temp.get(0));",
  "        // Write your code here.\n        return Optional.empty();", "        //\
    \ Insert your code here:\n        return null;", "        if (lst.size() < 2)\
    \ return Optional.empty();\n        else {\n            Collections.sort(lst);\n\
    \            return Optional.of(lst.get(1));\n        }", "        if (lst.size()\
    \ < 2) return Optional.empty();\n        long max = Collections.max(lst);\n  \
    \      List<Long> sub = lst.stream().filter(element -> element != max).collect(Collectors.toList());\n\
    \        return Optional.of(Collections.max(sub));", "        ArrayList<Long>\
    \ newLst = (ArrayList<Long>)lst.clone();\n        long smallest = Collections.min(newLst);\n\
    \        newLst.remove(smallest);\n        long nextSmallest = Collections.min(newLst);\n\
    \        return Optional.of(nextSmallest);", '        return Optional.empty();',
  "        try {\n            return Optional.ofNullable(Stream.concat(lst.stream(),\
    \ lst.stream()).filter(x -> Collections.frequency(lst, x) == 1).sorted().skip(1).findFirst().get());\n\
    \        } catch (NoSuchElementException e) {\n            return Optional.empty();\n\
    \        }", "        long currentSmallest = Long.MAX_VALUE;\n        long nextSmallest\
    \ = Long.MAX_VALUE;\n        for (Long item : lst) {\n            if (item < currentSmallest)\
    \ {\n                nextSmallest = currentSmallest;\n                currentSmallest\
    \ = item;\n            } else if (item < nextSmallest) {\n                nextSmallest\
    \ = item;\n            }\n        }\n        if (nextSmallest == Long.MAX_VALUE)\
    \ {\n            return Optional.empty();\n        } else {\n            return\
    \ Optional.of(nextSmallest);\n        }", "        Optional<Long> nextSmallest\
    \ = Optional.empty();\n        if (lst.size() >= 2) {\n            int count =\
    \ 0;\n            for (int i = 0; i < lst.size(); i++) {\n                for\
    \ (int j = 0; j < lst.size(); j++) {\n                    if (i != j && lst.get(i)\
    \ < lst.get(j)) {\n                        count += 1;\n                    }\n\
    \                }\n                if (count == lst.size() - 1) {\n         \
    \           nextSmallest = Optional.of(lst.get(i));\n                    break;\n\
    \                }\n                count = 0;\n            }\n        }\n   \
    \     return nextSmallest;", '        throw new UnsupportedOperationException("Problem.nextSmallest(ArrayList<Long>
    lst)");', "        if (lst.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        long min = Collections.min(lst);\n        ArrayList<Long>\
    \ without_smallest = new ArrayList<Long>();\n        for (long x : lst) {\n  \
    \          if (x != min) {\n                without_smallest.add(x);\n       \
    \     }\n        }\n        long second_smallest = Collections.min(without_smallest);\n\
    \        return Optional.of(second_smallest);", "        if (lst.size() < 2) {\n\
    \            return Optional.empty();\n        }\n        // find min\n      \
    \  long min = lst.get(0);\n        for (int i = 1; i < lst.size(); i++) {\n  \
    \          if (lst.get(i) < min) {\n                min = lst.get(i);\n      \
    \      }\n        }\n        // search list for second smallest\n        Long\
    \ smallest = null;\n        for (int i = 0; i < lst.size(); i++) {\n         \
    \   if (lst.get(i) > min) {\n                if (smallest == null || lst.get(i)\
    \ < smallest) {\n                    smallest = lst.get(i);\n                }\n\
    \            }\n        }\n        if (smallest == null) {\n            return\
    \ Optional.empty();\n        }\n        return Optional.of(smallest);", "    \
    \    // begin answer\n        if (lst.size() <= 1) {\n            return Optional.empty();\n\
    \        }\n        Long nextSmallest = null;\n        for (int i = 0; i < lst.size();\
    \ i++) {\n            Long first = lst.get(i);\n            for (int j = 0; j\
    \ < lst.size(); j++) {\n                if (i == j) {\n                    continue;\n\
    \                }\n                Long second = lst.get(j);\n              \
    \  if (first < second) {\n                    if (nextSmallest == null || second\
    \ < nextSmallest) {\n                        nextSmallest = second;\n        \
    \            }\n                }\n            }\n        }\n        return Optional.ofNullable(nextSmallest);\n\
    \        // end answer", "        if (lst.size() < 2) {\n            return Optional.empty();\n\
    \        }\n        Collections.sort(lst);\n        return Optional.of(lst.get(1));",
  "        // delete this line and implement the method!\n        if (lst.size() ==\
    \ 0) {\n            return Optional.empty();\n        }\n        if (lst.size()\
    \ == 1) {\n            return Optional.empty();\n        }\n        // Your code:\n\
    \        long min = lst.get(0);\n        long min2 = -1;\n        for (long i\
    \ : lst) {\n            if (i < min) {\n                min2 = min;\n        \
    \        min = i;\n            } else if (i < min2 || min2 == -1) {\n        \
    \        min2 = i;\n            }\n        }\n        if (min2 == -1) {\n    \
    \        return Optional.empty();\n        }\n        return Optional.of(min2);"]
stop_tokens:
- "\n    }\n"
