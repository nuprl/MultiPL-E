name: HumanEval_43_pairs_sum_to_zero
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // pairs_sum_to_zero takes an array array list of integers\
  \ as an input.\n    // it returns true if there are two distinct elements in the\
  \ array list that\n    // sum to zero, and false otherwise.\n    // >>> pairsSumToZero((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l))))\n   \
  \ // (false)\n    // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)3l, (long)-2l, (long)1l))))\n    // (false)\n    // >>> pairsSumToZero((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)7l))))\n   \
  \ // (false)\n    // >>> pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)4l, (long)-5l, (long)3l, (long)5l, (long)7l))))\n    // (true)\n    // >>>\
  \ pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))\n    // (false)\n\
  \    public static boolean pairsSumToZero(ArrayList<Long> l) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(pairsSumToZero((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)3l, (long)5l, (long)0l)))) == (false));\n\
  \    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l, (long)3l,\
  \ (long)-2l, (long)1l)))) == (false));\n    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)2l, (long)3l, (long)7l)))) == (false));\n    assert(pairsSumToZero((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)-5l, (long)3l, (long)5l,\
  \ (long)7l)))) == (true));\n    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)1l))))\
  \ == (false));\n    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)-3l,\
  \ (long)9l, (long)-1l, (long)3l, (long)2l, (long)30l)))) == (true));\n    assert(pairsSumToZero((new\
  \ ArrayList<Long>(Arrays.asList((long)-3l, (long)9l, (long)-1l, (long)3l, (long)2l,\
  \ (long)31l)))) == (true));\n    assert(pairsSumToZero((new ArrayList<Long>(Arrays.asList((long)-3l,\
  \ (long)9l, (long)-1l, (long)4l, (long)2l, (long)30l)))) == (false));\n    assert(pairsSumToZero((new\
  \ ArrayList<Long>(Arrays.asList((long)-3l, (long)9l, (long)-1l, (long)4l, (long)2l,\
  \ (long)31l)))) == (false));\n    }\n\n}\n"
completions: ["        for (int i = 0; i < l.size(); i++) {\n            for (int\
    \ j = i + 1; j < l.size(); j++) {\n                if (l.get(i) + l.get(j) ==\
    \ 0) {\n                    return true;\n                }\n            }\n \
    \       }\n        return false;", "        HashSet<Long> hs = new HashSet<Long>();\n\
    \        for (Long item : l) {\n            if (hs.contains(item)) {\n       \
    \         return true;\n            }\n            hs.add(-item);\n        }\n\
    \        return false;", '        return true;', "        if (l.size()<2) {\n\
    \            return false;\n        }\n        HashSet<Long> hs = new HashSet<Long>();\n\
    \        for (int i=0; i<l.size(); i++) {\n            if (hs.contains(l.get(i))\
    \ || hs.contains(l.get(i)*-1)) {\n                return true;\n            }\n\
    \            hs.add(l.get(i));\n        }\n        return false;", "        if\
    \ (l.size() < 2) {\n            return false;\n        }\n        Collections.sort(l);\n\
    \        int i = 0;\n        int j = l.size() - 1;\n        while (i < j) {\n\
    \            if (l.get(i) + l.get(j) == 0) {\n                return true;\n \
    \           }\n            if (l.get(i) + l.get(j) < 0) {\n                i++;\n\
    \            } else {\n                j--;\n            }\n        }\n      \
    \  return false;", "        if (l.size() == 0) {\n            return false;\n\
    \        }\n        else {\n            if (l.size() == 1) {\n               \
    \ return false;\n            }\n            else {\n                if (l.size()\
    \ == 2) {\n                    return ((l.get(0) + l.get(1)) == 0);\n        \
    \        }\n                else {\n                    if (l.size() > 2) {\n\
    \                        HashSet<Long> h = new HashSet<Long>();\n            \
    \            for (Long x : l) {\n                            if (h.contains(-x))\
    \ {\n                                return true;\n                          \
    \  }\n                            else {\n                                h.add(x);\n\
    \                            }\n                        }\n                  \
    \      return false;\n                    }\n                    else {\n    \
    \                    return false;\n                    }\n                }\n\
    \            }\n        }", "        HashSet<Long> s = new HashSet<Long>();\n\
    \        for (Long i : l) {\n            if (s.contains((long)0l - i)) {\n   \
    \             return true;\n            }\n            s.add(i);\n        }\n\
    \        return false;", "        if (l.size() < 2) {\n            return false;\n\
    \        }\n        else {\n            Collections.sort(l);\n            if (l.get(0)\
    \ + l.get(l.size() - 1) == 0) {\n                return true;\n            }\n\
    \            else {\n                l.remove(0);\n                return pairsSumToZero(l);\n\
    \            }\n        }", "        Set<Long> s = new HashSet<Long>();\n    \
    \    for (Long i : l) {\n            s.add(i);\n        }\n        for (Long i\
    \ : l) {\n            if (s.contains(i*-1l)) {\n                return true;\n\
    \            }\n        }\n        return false;", "        // start by sorting\
    \ the array list.\n        Collections.sort(l);\n        // keep track of the\
    \ leftmost and rightmost indices in the array list.\n        int left = 0;\n \
    \       int right = l.size() - 1;\n        // keep track of the sum at the leftmost\
    \ and rightmost indices.\n        long left_val = l.get(left);\n        long right_val\
    \ = l.get(right);\n        // go through the list, checking the sum and incrementing\
    \ the left or right\n        // index as appropriate.\n        while (left < right)\
    \ {\n            // if left_val + right_val = 0, return true.\n            if\
    \ (left_val + right_val == 0) {\n                return true;\n            }\n\
    \            // if left_val + right_val > 0, then we need to decrement right.\n\
    \            else if (left_val + right_val > 0) {\n                right -= 1;\n\
    \                right_val = l.get(right);\n            }\n            // otherwise,\
    \ we must increment left.\n            else {\n                left += 1;\n  \
    \              left_val = l.get(left);\n            }\n        }\n        // if\
    \ we have gone through the whole list without finding a pair, then we return false.\n\
    \        return false;", "        HashSet<Long> h = new HashSet<Long>();\n   \
    \     for (int i = 0; i < l.size(); i++) {\n            if (h.contains(l.get(i)))\
    \ {\n                return true;\n            }\n            else {\n       \
    \         h.add(-l.get(i));\n            }\n        }\n        return false;",
  "        int c = 0;\n        Collections.sort(l);\n        for (int i = 0; i < l.size();\
    \ i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n             \
    \   if (l.get(i) + l.get(j) == 0) {\n                    c++;\n              \
    \  }\n            }\n        }\n        if (c == 0) {\n            return false;\n\
    \        } else {\n            return true;\n        }", "\t\tint lSize = l.size();\n\
    \t\tint j = 0;\n\t\tfor (int i = 0; i < lSize; i++) {\n\t\t\tj = i + 1;\n\t\t\t\
    while (j < lSize) {\n\t\t\t\tif (l.get(i) + l.get(j) == 0) {\n\t\t\t\t\treturn\
    \ true;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn false;", "      \
    \  if (l.size() <= 1) {\n            return false;\n        }\n        // The\
    \ loop invariant is that we have not seen any matching pairs.\n        // Initialization:\
    \ We haven't looked at any numbers, so we haven't seen any matching pairs.\n \
    \       // Maintenance: We know that we haven't seen any matching pairs up to\
    \ and including the current index,\n        // and we check all the remaining\
    \ elements to see if they match the current element.\n        // Termination:\
    \ We've looked at all the numbers, so we're done.\n        for (int i = 0; i <\
    \ l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n   \
    \             if (l.get(i) + l.get(j) == 0) {\n                    return true;\n\
    \                }\n            }\n        }\n        return false;", '        throw
    new UnsupportedOperationException("Problem.pairsSumToZero");', "        // look\
    \ at each entry, starting with the first.\n        int i = 0;\n        while (i\
    \ < l.size()) {\n            // check each subsequent entry, starting with the\
    \ next.\n            int j = i + 1;\n            while (j < l.size()) {\n    \
    \            // if they sum to zero, we are done.\n                if (l.get(i)\
    \ + l.get(j) == 0) {\n                    return true;\n                }\n  \
    \              j = j + 1;\n            }\n            i = i + 1;\n        }\n\
    \        // if we get here, no pairs summed to zero.\n        return false;",
  "        ArrayList<Long> comp = new ArrayList<Long>();\n        for (Long num :\
    \ l) {\n            if (comp.contains(num)) {\n                return true;\n\
    \            }\n            comp.add(0L - num);\n        }\n        return false;",
  "        l.sort(new Comparator<Long>() {\n            public int compare(Long a,\
    \ Long b) {\n                if (a > b) {\n                    return 1;\n   \
    \             } else if (a < b) {\n                    return -1;\n          \
    \      } else {\n                    return 0;\n                }\n          \
    \  }\n        });\n        for (int i = 0; i < l.size(); i++) {\n            Long\
    \ elem = l.get(i);\n            Long diff = -elem;\n            int diff_idx =\
    \ Collections.binarySearch(l, diff);\n            if (diff_idx >= 0 && diff_idx\
    \ != i) {\n                return true;\n            }\n        }\n        return\
    \ false;", '        return false;', "        if (l.size() < 2) {\n           \
    \ return false;\n        }\n        for (int i = 0; i < l.size(); i++) {\n   \
    \         for (int j = i + 1; j < l.size(); j++) {\n                if (l.get(i)\
    \ + l.get(j) == 0) {\n                    return true;\n                }\n  \
    \          }\n        }\n        return false;", "        boolean[] flag = new\
    \ boolean[l.size()];\n        for (int i = 0; i < l.size(); i++) {\n         \
    \   flag[i] = false;\n        }\n        for (int i = 0; i < l.size(); i++) {\n\
    \            if (flag[i]) {\n                continue;\n            }\n      \
    \      if (l.indexOf((long) (l.get(i) * (-1))) != -1) {\n                flag[i]\
    \ = true;\n                flag[l.indexOf((long) (l.get(i) * (-1)))] = true;\n\
    \                return true;\n            }\n        }\n        return false;",
  "        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j\
    \ < l.size(); j++) {\n                if (l.get(i) + l.get(j) == 0) {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \     return false;", "        HashSet<Long> set = new HashSet<Long>();\n    \
    \    for (int i = 0; i < l.size(); i++) {\n            if (set.contains(l.get(i)))\
    \ {\n                return true;\n            }\n            set.add(-l.get(i));\n\
    \        }\n        return false;", '        throw new UnsupportedOperationException("Problem.pairsSumToZero()");',
  "        boolean output = false;\n        for (int i = 0; i < l.size(); i++) {\n\
    \            for (int j = i + 1; j < l.size(); j++) {\n                if (l.get(i)\
    \ + l.get(j) == 0) {\n                    output = true;\n                }\n\
    \            }\n        }\n        return output;", "        // BEGIN SOLUTION\n\
    \        return false;\n        // END SOLUTION", "        ArrayList<Long> a =\
    \ new ArrayList<Long>();\n        for (int i = 0; i < l.size(); i++) {\n     \
    \       a.add(l.get(i));\n        }\n        if (a.size() < 2) {\n           \
    \ return false;\n        }\n        Collections.sort(a);\n        int i = 0;\n\
    \        int j = a.size() - 1;\n        while (i < j) {\n            long sum\
    \ = a.get(i) + a.get(j);\n            if (sum == 0) {\n                return\
    \ true;\n            } else if (sum < 0) {\n                i += 1;\n        \
    \    } else {\n                j -= 1;\n            }\n        }\n        return\
    \ false;", "        if (l.size() < 2) {\n            return false;\n        }\n\
    \        HashSet<Long> s = new HashSet<Long>();\n        for (int i = 0; i < l.size();\
    \ i++) {\n            long a = l.get(i);\n            if (s.contains(a)) {\n \
    \               return true;\n            }\n            s.add(-a);\n        }\n\
    \        return false;", "        Set<Long> set = new HashSet<>();\n        for\
    \ (long i : l) {\n            set.add(i);\n        }\n        return set.contains(0l);",
  '        return l.stream().mapToLong(i -> i).boxed().collect(Collectors.toSet()).stream().filter(i
    -> l.contains(-i)).count() > 1;', "        HashSet<Long> set = new HashSet<Long>();\n\
    \        for (Long e : l) {\n            if (set.contains(e)) {\n            \
    \    return true;\n            }\n            set.add(-e);\n        }\n      \
    \  return false;", '        return false;', "        for (int i = 0; i < l.size();\
    \ i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n             \
    \   if (l.get(i) + l.get(j) == 0) {\n                    return true;\n      \
    \          }\n            }\n        }\n        return false;", "        int length\
    \ = l.size();\n        Set<Long> set = new HashSet<>();\n        for (int i =\
    \ 0; i < length; i++) {\n            long t = l.get(i);\n            if (set.contains(-t))\
    \ {\n                return true;\n            }\n            set.add(t);\n  \
    \      }\n        return false;", '        throw new NotImplementedException();',
  "        // replace \"return false;\" with your code\n        return false;", " \
    \       int i, j;\n        boolean ret = false;\n        for (i = 0; i < l.size();\
    \ i++) {\n            for (j = i + 1; j < l.size(); j++) {\n                if\
    \ (l.get(i) + l.get(j) == 0l) {\n                    ret = true;\n           \
    \     }\n            }\n        }\n        return ret;", "        Set<Long> set\
    \ = new HashSet<>();\n        for (long elem : l) {\n            if (set.contains(-elem))\
    \ {\n                return true;\n            }\n            set.add(elem);\n\
    \        }\n        return false;", "        boolean res = false;\n        //\
    \ write your code below this line\n        res = false;\n        for (int i =\
    \ 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++)\
    \ {\n                if (l.get(i) + l.get(j) == 0) {\n                    res\
    \ = true;\n                }\n            }\n        }\n        // write your\
    \ code above this line\n        return res;", "        int x = l.size();\n   \
    \     for (int i = 0; i < x; i++) {\n            for (int j = i + 1; j < x; j++)\
    \ {\n                if (l.get(i) + l.get(j) == 0) {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;",
  '        return !(((new HashSet<Long>(l)).size()) == (l.size()));', "        ArrayList<Long>\
    \ l2 = new ArrayList<Long>();\n        for (Long n : l) {\n            l2.add(n);\n\
    \        }\n        for (Long n : l) {\n            l2.remove(n);\n          \
    \  if (l2.contains(-n)) {\n                return true;\n            }\n     \
    \       l2.add(n);\n        }\n        return false;", "        // {e1, e2 : l\
    \ | (e1 + e2) == 0 }\n        for (int i = 0; i < l.size(); i += 1) {\n      \
    \      for (int j = i + 1; j < l.size(); j += 1) {\n                if (l.get(i)\
    \ + l.get(j) == 0) {\n                    return true;\n                }\n  \
    \          }\n        }\n        return false;", "        if (l.size() < 2) {\n\
    \            return false;\n        }\n        Set<Long> s = new HashSet<Long>();\n\
    \        for (Long x : l) {\n            if (s.contains(-x)) {\n             \
    \   return true;\n            }\n            s.add(x);\n        }\n        return\
    \ false;", "        // arraylist is empty\n        if (l.size() <= 1) {\n    \
    \        return false;\n        }\n        long[] arr = new long[l.size()];\n\
    \        for (int i = 0; i < l.size(); i++) {\n            arr[i] = l.get(i);\n\
    \        }\n        Arrays.sort(arr);\n        int left = 0;\n        int right\
    \ = arr.length - 1;\n        while (left < right) {\n            long sum = arr[left]\
    \ + arr[right];\n            if (sum == 0) {\n                return true;\n \
    \           } else if (sum < 0) {\n                left++;\n            } else\
    \ {\n                right--;\n            }\n        }\n        return false;",
  "        //choose(l.size(), 2)\n        long c = l.size() * (l.size() - 1) / 2;\n\
    \        ArrayList<Long> sumList = new ArrayList<Long>();\n        for (long i\
    \ = 0; i < c; i++) {\n            sumList.add((long)0l);\n        }\n        long\
    \ x = 0;\n        long y = 0;\n        for (long i = 0; i < l.size(); i++) {\n\
    \            for (long j = i + 1; j < l.size(); j++) {\n                long k\
    \ = i * (l.size() - 1) + j - 1;\n                long t = 0;\n               \
    \ while (k > 0) {\n                    t += l.get((int)(k % l.size()));\n    \
    \                k /= l.size();\n                }\n                sumList.set((int)k,\
    \ t);\n            }\n        }\n        for (long i = 0; i < sumList.size();\
    \ i++) {\n            if (sumList.get((int)i) == 0) {\n                return\
    \ true;\n            }\n        }\n        return false;", "        // Implement\
    \ this placeholder.\n        return true;", "        // write your code in Java\
    \ SE 8\n        if (l.size() < 2) {\n            return false;\n        }\n  \
    \      Collections.sort(l);\n        int left = 0;\n        int right = l.size()\
    \ - 1;\n        while (left < right) {\n            long sum = l.get(left) + l.get(right);\n\
    \            if (sum == 0) {\n                return true;\n            } else\
    \ if (sum < 0) {\n                left++;\n            } else {\n            \
    \    right--;\n            }\n        }\n        return false;", "        long\
    \ left = 0;\n        int right = l.size() - 1;\n        while (left < right) {\n\
    \            long sum = l.get((int)left) + l.get(right);\n            if (sum\
    \ == 0) {\n                return true;\n            } else if (sum < 0) {\n \
    \               left = left + 1;\n            } else {\n                right\
    \ = right - 1;\n            }\n        }\n        return false;", "        Set<Long>\
    \ set = new HashSet<Long>();\n        for (Long v : l) {\n            if (set.contains(0l\
    \ - v)) {\n                return true;\n            }\n            set.add(v);\n\
    \        }\n        return false;", "        return l.stream().distinct().filter(x\
    \ -> x == (long)0l).count() >= 2\n            || l.stream().distinct().filter(x\
    \ -> x != (long)0l).map(x -> (long)0l - x).filter(x -> l.contains(x)).count()\
    \ >= 1;", "        // stub\n        return false;", "        Set<Long> s = new\
    \ HashSet<Long>();\n        for (Long l2 : l) {\n            if (s.contains(l2)\
    \ || s.contains(-l2)) {\n                return true;\n            }\n       \
    \     s.add(l2);\n        }\n        return false;", "        // return true if\
    \ there are two distinct elements in l that sum to zero, and false otherwise.\n\
    \        //\n        // for example, if l = [3, 2, -2, 1, -3]\n        // then\
    \ return true, since -3 and 3 sum to zero.\n        //\n        // you can modify\
    \ the contents of l.\n        // your algorithm must run in O(n log n) time, where\
    \ n is the number of elements in l.\n        // you may use O(n) space, in addition\
    \ to the space needed to store l.\n        //\n        // do not use any library\
    \ functions other than those in java.lang and java.util.\n        Collections.sort(l);\n\
    \        int i = 0;\n        int j = l.size() - 1;\n        while (i < j) {\n\
    \            long sum = l.get(i) + l.get(j);\n            if (sum == 0) return\
    \ true;\n            if (sum < 0) i++;\n            else j--;\n        }\n   \
    \     return false;", "        int n = l.size();\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if\
    \ (l.get(i) + l.get(j) == 0) {\n                    return true;\n           \
    \     }\n            }\n        }\n        return false;", "        boolean flag\
    \ = false;\n        for (int i = 0; i < l.size(); i++) {\n            for (int\
    \ j = i + 1; j < l.size(); j++) {\n                if (l.get(i) + l.get(j) ==\
    \ 0) {\n                    flag = true;\n                }\n            }\n \
    \       }\n        return flag;", "        if (l.size() < 2) {\n            return\
    \ false;\n        }\n        ArrayList<Long> l2 = new ArrayList<Long>(l);\n  \
    \      // System.out.println(l2);\n        for (int i = 0; i < l.size(); i++)\
    \ {\n            // System.out.println(l2);\n            if (l2.contains(-l.get(i)))\
    \ {\n                return true;\n            }\n            l2.remove(l.get(i));\n\
    \        }\n        return false;", "        Set<Long> s = new HashSet<Long>();\n\
    \        for (int i = 0; i < l.size(); i++) {\n            if (s.contains(l.get(i)))\
    \ {\n                return true;\n            }\n            else {\n       \
    \         s.add(0l - l.get(i));\n            }\n        }\n        return false;",
  "        if (l.size() <= 1) {\n            return false;\n        }\n        Set<Long>\
    \ seen = new HashSet<Long>();\n        for (Long x : l) {\n            if (seen.contains(0\
    \ - x)) {\n                return true;\n            }\n            seen.add(x);\n\
    \        }\n        return false;", "        // {write your code here\n      \
    \  HashSet<Long> set = new HashSet<Long>();\n        for (int i = 0; i < l.size();\
    \ i++) {\n            if (set.contains(-(l.get(i)))) {\n                return\
    \ true;\n            }\n            set.add(l.get(i));\n        }\n        return\
    \ false;\n        //}", "        // your code here\n        return false;", " \
    \       if (l.size() <= 1) {\n            return false;\n        }\n        else\
    \ {\n            if (l.size() == 2) {\n                return l.get(0) + l.get(1)\
    \ == 0;\n            }\n            else {\n                HashSet<Long> s =\
    \ new HashSet<Long>();\n                for (Long e : l) {\n                 \
    \   if (s.contains(e)) {\n                        return true;\n             \
    \       }\n                    else {\n                        s.add(e);\n   \
    \                 }\n                }\n                return false;\n      \
    \      }\n        }", "        if (l.size() <= 1) {\n            return false;\n\
    \        } else {\n            for (int i = 0; i < l.size(); i++) {\n        \
    \        for (int j = i + 1; j < l.size(); j++) {\n                    if (l.get(i)\
    \ + l.get(j) == 0) {\n                        return true;\n                 \
    \   }\n                }\n            }\n            return false;\n        }",
  '        throw new UnsupportedOperationException("Problem.pairsSumToZero is currently
    not implemented.");', '        return false;', "        if (l.size() > 2) {\n\
    \            long start = 0l;\n            long end = l.size() - 1;\n        \
    \    long sum = 0l;\n            while (start < end) {\n                sum =\
    \ l.get((int)start) + l.get((int)end);\n                if (sum == 0l) {\n   \
    \                 return true;\n                }\n                else if (sum\
    \ > 0l) {\n                    end = end - 1;\n                }\n           \
    \     else {\n                    start = start + 1;\n                }\n    \
    \        }\n        }\n        return false;", "        HashSet<Long> set = new\
    \ HashSet<Long>();\n        for (Long elem : l) {\n            if (set.contains(elem))\
    \ {\n                return true;\n            }\n            set.add(-elem);\n\
    \        }\n        return false;", "        ArrayList<Long> seen = new ArrayList<Long>();\n\
    \        for (int i = 0; i < l.size(); i++) {\n            if (seen.contains(l.get(i)))\
    \ {\n                return true;\n            }\n            else {\n       \
    \         seen.add(0-l.get(i));\n            }\n        }\n        return false;",
  "        if (l.size() < 2) return false;\n        for (int i = 0; i < l.size();\
    \ i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n             \
    \   if (l.get(i) + l.get(j) == 0) return true;\n            }\n        }\n   \
    \     return false;", "        HashSet<Long> s = new HashSet<Long>();\n      \
    \  for (Long n : l) {\n            if (s.contains(-n)) {\n                return\
    \ true;\n            }\n            s.add(n);\n        }\n        return false;",
  "        if (l.size() < 2) {\n            return false;\n        }\n        ArrayList<Long>\
    \ set = new ArrayList<Long>();\n        for (int i = 0; i < l.size(); i++) {\n\
    \            if (set.contains(new Long(0 - l.get(i)))) {\n                return\
    \ true;\n            }\n            set.add(l.get(i));\n        }\n        return\
    \ false;", "        // we use a hash set for storing elements in the array list.\n\
    \        HashSet<Long> s = new HashSet<Long>();\n        // iterate through the\
    \ array list.\n        for (Long elem : l) {\n            // if the element is\
    \ in the hash set, return true.\n            if (s.contains(-elem)) {\n      \
    \          return true;\n            }\n            // if the element is not in\
    \ the hash set, add it to the hash set.\n            else {\n                s.add(elem);\n\
    \            }\n        }\n        // if we reach the end of the array list without\
    \ finding two elements that\n        // sum to zero, then return false.\n    \
    \    return false;", "        if (l.size() == 0) {\n            return false;\n\
    \        }\n        boolean _returnValue = false;\n        _returnValue = l.stream().map(c\
    \ -> l.stream().map(d -> (c + d)).collect(Collectors.toList())).flatMap(e -> e.stream()).filter(f\
    \ -> (f == (long)0l)).findFirst().isPresent();\n        return _returnValue;",
  "        // your code here\n        return false;", '        throw new Error("Not
    yet implemented");', "        HashSet<Long> s = new HashSet<Long>();\n       \
    \ for (Long x : l) {\n            if (s.contains(x)) {\n                return\
    \ true;\n            }\n            s.add(-(x));\n        }\n        return false;",
  "        // YOUR CODE HERE\n        return false;", '        return false;', " \
    \       // this function uses a hashset to store what numbers have already been\n\
    \        // seen in the array list. for each element in the array list we check\n\
    \        // if its opposite has already been seen, and if so return true. otherwise\n\
    \        // we add the current number to the set, and move on to the next.\n \
    \       // if we reach the end of the array list then we return false.\n     \
    \   HashSet<Long> set = new HashSet<Long>();\n        for (Long elem : l) {\n\
    \            if (set.contains(-elem)) {\n                return true;\n      \
    \      }\n            set.add(elem);\n        }\n        return false;", "   \
    \     if (l.size() <= 1) {\n            return false;\n        }\n        HashSet<Long>\
    \ hashset = new HashSet<Long>();\n        for (Long ln : l) {\n            if\
    \ (hashset.contains(ln)) {\n                return true;\n            }\n    \
    \        else {\n                hashset.add(-ln);\n            }\n        }\n\
    \        return false;", "        HashSet<Long> s = new HashSet<Long>();\n   \
    \     for (Long x : l) {\n            if (s.contains(x))\n                return\
    \ true;\n            s.add(-x);\n        }\n        return false;", "        //\
    \ REPLACE WITH YOUR CODE\n        return false;", "        for (int i = 0; i <\
    \ l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n   \
    \             if (l.get(i) + l.get(j) == 0) {\n                    return true;\n\
    \                }\n            }\n        }\n        return false;", "      \
    \  HashSet<Long> seen = new HashSet<Long>();\n        for (Long num : l) {\n \
    \           if (seen.contains(num * -1)) {\n                return true;\n   \
    \         }\n            seen.add(num);\n        }\n        return false;", "\t\t\
    return (new HashSet<Long>(l)).size() != l.size();", "        HashSet<Long> s =\
    \ new HashSet<Long>();\n        for (Long n : l) {\n            if (s.contains(n)\
    \ || s.contains(-n)) {\n                return true;\n            }\n        \
    \    s.add(n);\n        }\n        return false;", "        // >>> your code here\
    \ <<<\n        return false;", "        long len = (long)l.size();\n        for\
    \ (long i = (long)0l; i < len; i++) {\n            long t = (long)0l;\n      \
    \      for (long j = (long)0l; j < len; j++) {\n                if (j != i) {\n\
    \                    t = t + l.get((int)j);\n                }\n            }\n\
    \            if (t == (long)0l) {\n                return true;\n            }\n\
    \        }\n        return false;", "        boolean b = false;\n        Iterator<Long>\
    \ it = l.iterator();\n        while(it.hasNext()) {\n            Long e = it.next();\n\
    \            Iterator<Long> it2 = l.iterator();\n            while(it2.hasNext())\
    \ {\n                Long e2 = it2.next();\n                if (e.equals(e2))\
    \ {\n                    continue;\n                }\n                if (e +\
    \ e2 == 0) {\n                    b = true;\n                }\n            }\n\
    \        }\n        return b;", '        throw new java.lang.UnsupportedOperationException("Not
    implemented.");', "        // generates all possible pairs of the input array\
    \ list l\n        Pair<Long, Long>[] pairs = l.stream().map(x -> l.stream().map(y\
    \ -> new Pair<Long, Long>(x, y))).flatMap(x -> x).distinct().toArray(Pair[]::new);\n\
    \        // maps all the pairs to the sum of their two elements\n        // sums\
    \ = array of sums of each pair\n        Long[] sums = Arrays.stream(pairs).map(p\
    \ -> p.getValue0() + p.getValue1()).toArray(Long[]::new);\n        // checks if\
    \ the array of sums contains zero\n        // if the array of sums contains zero,\n\
    \        // there exists a pair of distinct elements that sum to zero\n      \
    \  return Arrays.asList(sums).contains((long)0l);", "        if (l.size() < 2)\
    \ return false;\n        Set<Long> s = new HashSet<Long>();\n        for (Long\
    \ i : l) {\n            if (s.contains(0 - i)) {\n                return true;\n\
    \            }\n            s.add(i);\n        }\n        return false;", "  \
    \      if (l.size() == 0) {\n            return false;\n        }\n        else\
    \ {\n            if (l.size() == 1) {\n                return false;\n       \
    \     }\n            else {\n                if (l.size() == 2) {\n          \
    \          if (l.get(0) + l.get(1) == 0) {\n                        return true;\n\
    \                    }\n                    else {\n                        return\
    \ false;\n                    }\n                }\n                else {\n \
    \                   long a = l.get(0);\n                    long b = l.get(1);\n\
    \                    ArrayList<Long> c = new ArrayList<Long>(l.subList(2, l.size()));\n\
    \                    if (a + b == 0) {\n                        return true;\n\
    \                    }\n                    else {\n                        return\
    \ pairsSumToZero(c);\n                    }\n                }\n            }\n\
    \        }", "        if (l.size() < 2) {\n            return false;\n       \
    \ } else {\n            for (int i = 0; i < l.size(); i++) {\n               \
    \ for (int j = i + 1; j < l.size(); j++) {\n                    if (l.get(i) +\
    \ l.get(j) == 0l) {\n                        return true;\n                  \
    \  }\n                }\n            }\n            return false;\n        }",
  "        //YOUR CODE HERE\n        return false;", "        HashSet<Long> m = new\
    \ HashSet<Long>();\n        for (Long i : l) {\n            m.add(i);\n      \
    \  }\n        for (Long i : l) {\n            Long result = (Long)(-i);\n    \
    \        if (m.contains(result)) {\n                return true;\n           \
    \ }\n        }\n        return false;", "        // write your code here\n   \
    \     Collections.sort(l);\n        int left = 0;\n        int right = l.size()\
    \ - 1;\n        while (left < right) {\n            if (l.get(left) + l.get(right)\
    \ == 0) {\n                return true;\n            } else if (l.get(left) +\
    \ l.get(right) < 0) {\n                left++;\n            } else {\n       \
    \         right--;\n            }\n        }\n        return false;", "      \
    \  HashSet<Long> unique_elements = new HashSet<Long>();\n        for (Long element\
    \ : l) {\n            if (unique_elements.contains(0 - element)) {\n         \
    \       return true;\n            }\n            unique_elements.add(element);\n\
    \        }\n        return false;", '        return l.stream().distinct().collect(Collectors.groupingBy(e
    -> e)).values().stream().flatMap(x -> x.stream().map(a -> Pair.with(a, (long)
    (a * -1)))).filter(x -> l.contains(x.getValue0()) && l.contains(x.getValue1())).findFirst().isPresent();',
  "        if (l.size() < 2) {\n            return false;\n        }\n        else\
    \ {\n            for (int i = 0; i < l.size(); i++) {\n                for (int\
    \ j = i + 1; j < l.size(); j++) {\n                    if (l.get(i) + l.get(j)\
    \ == 0) {\n                        return true;\n                    }\n     \
    \           }\n            }\n            return false;\n        }", "       \
    \ HashSet<Long> set = new HashSet<Long>();\n        for (Long a: l) {\n      \
    \      if (set.contains(-a)) {\n                return true;\n            }\n\
    \            set.add(a);\n        }\n        return false;", "        if (l.size()\
    \ <= 1) {\n            return false;\n        }\n        // Build a HashMap of\
    \ the list of nums mapping each number to the\n        // frequency it appears\
    \ in the list.\n        HashMap<Long, Integer> m = new HashMap<Long, Integer>();\n\
    \        for (Long x : l) {\n            if (m.containsKey(x)) {\n           \
    \     m.put(x, m.get(x) + 1);\n            } else {\n                m.put(x,\
    \ 1);\n            }\n        }\n        // Check the number of times each number\
    \ appears in the list of nums.\n        // If a number appears an even number\
    \ of times, then we can pair it\n        // with itself for a sum of zero. So\
    \ we check for this case.\n        for (Long x : m.keySet()) {\n            if\
    \ (m.get(x) % 2 == 0) {\n                return true;\n            }\n       \
    \ }\n        // If no number appeared an even number of times, then we check if\
    \ there\n        // is a negative version of each number. If the negative version\
    \ of a\n        // number exists in the map, then we can pair the two numbers\
    \ for a sum\n        // of zero. So we check for this case.\n        for (Long\
    \ x : m.keySet()) {\n            if (m.containsKey(-x)) {\n                return\
    \ true;\n            }\n        }\n        // If neither of the two cases above\
    \ were true, then we can conclude\n        // that there are no pairs that sum\
    \ to zero.\n        return false;", "        ArrayList<Long> nl = new ArrayList<>();\n\
    \        for (Long i : l) {\n            if (i != 0) {\n                nl.add(i);\n\
    \            }\n        }\n        for (int i = 0; i < nl.size(); i++) {\n   \
    \         for (int j = i + 1; j < nl.size(); j++) {\n                if (nl.get(i)\
    \ + nl.get(j) == 0) {\n                    return true;\n                }\n \
    \           }\n        }\n        return false;", "        // Implement this placeholder.\n\
    \        return true;", "        if (l.size() == 0) {\n            return false;\n\
    \        }\n        HashSet<Long> set = new HashSet<Long>();\n        for (Long\
    \ element : l) {\n            if (set.contains(-element)) {\n                return\
    \ true;\n            }\n            set.add(element);\n        }\n        return\
    \ false;", "        if (l.size() > 1) {\n            for (int i = 0; i < l.size();\
    \ i++) {\n                for (int j = 0; j < l.size(); j++) {\n             \
    \       if (i != j && l.get(i) + l.get(j) == 0) {\n                        return\
    \ true;\n                    }\n                }\n            }\n        }\n\
    \        return false;", '        throw new NotImplementedException();', "   \
    \     // Your code here\n        for (int i = 0; i < l.size(); i++) {\n      \
    \      for (int j = i + 1; j < l.size(); j++) {\n                if (l.get(i)\
    \ + l.get(j) == 0) {\n                    return true;\n                }\n  \
    \          }\n        }\n        return false;", "        HashSet<Long> set =\
    \ new HashSet<Long>();\n        for (Long i : l) {\n            if (set.contains(-i))\
    \ {\n                return true;\n            }\n            set.add(i);\n  \
    \      }\n        return false;", "        // Your code here\n        return false;",
  "        if (l.size() == 0) {\n            return false;\n        }\n        else\
    \ {\n            if (l.size() == 1) {\n                return false;\n       \
    \     }\n            else {\n                for (Long i : l) {\n            \
    \        for (Long j : l) {\n                        if (!(i.equals(j))) {\n \
    \                           if ((i + j) == 0) {\n                            \
    \    return true;\n                            }\n                        }\n\
    \                    }\n                }\n                return false;\n   \
    \         }\n        }", "        // your code here\n        return false;", " \
    \       if (l.size() < 2) {\n            return false;\n        } else {\n   \
    \         for (int i = 0; i < l.size(); i++) {\n                for (int j = i\
    \ + 1; j < l.size(); j++) {\n                    if (l.get(i) + l.get(j) == 0)\
    \ {\n                        return true;\n                    }\n           \
    \     }\n            }\n            return false;\n        }", "        HashSet<Long>\
    \ s = new HashSet<Long>();\n        for (int i = 0; i < l.size(); i++) {\n   \
    \         if (s.contains(-l.get(i))) {\n                return true;\n       \
    \     }\n            s.add(l.get(i));\n        }\n        return false;", "  \
    \      // solution without using sorting or a hash table\n        for (Long i\
    \ : l) {\n            for (Long j : l) {\n                if (i != j && i + j\
    \ == 0l) {\n                    return true;\n                }\n            }\n\
    \        }\n        return false;", "        // your implementation goes here!\n\
    \        return true;", "        Set<Long> h = new HashSet<Long>();\n        for\
    \ (int i = 0; i < l.size(); i++) {\n            long currentNumber = l.get(i);\n\
    \            if (h.contains(0 - currentNumber)) {\n                return true;\n\
    \            }\n            h.add(currentNumber);\n        }\n        return false;",
  "        //\n        // YOUR CODE HERE\n        //\n        if (l.size() <= 1) {\n\
    \            return false;\n        }\n        HashSet<Long> negs = new HashSet<Long>();\n\
    \        HashSet<Long> pos = new HashSet<Long>();\n        for (int i = 0; i <\
    \ l.size(); i++) {\n            Long x = l.get(i);\n            if (x < 0) {\n\
    \                negs.add(x);\n            } else {\n                pos.add(x);\n\
    \            }\n        }\n        for (int i = 0; i < l.size(); i++) {\n    \
    \        Long x = l.get(i);\n            if (x < 0) {\n                if (pos.contains(x\
    \ * -1)) {\n                    return true;\n                }\n            }\
    \ else {\n                if (negs.contains(x * -1)) {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;",
  "        if (l.size() < 2) {\n            return false;\n        }\n        HashSet<Long>\
    \ s = new HashSet<Long>();\n        for (Long i : l) {\n            if (s.contains(-i))\
    \ {\n                return true;\n            }\n            s.add(i);\n    \
    \    }\n        return false;", '        return false;', "        // create an\
    \ array list that has all of the negative numbers\n        // in l and their respective\
    \ positions\n        ArrayList<Integer> negativeNumbers = new ArrayList<Integer>();\n\
    \        // create an array list that has all of the positive numbers\n      \
    \  // in l and their respective positions\n        ArrayList<Integer> positiveNumbers\
    \ = new ArrayList<Integer>();\n        // for each number in l, if the number\
    \ is greater than 0, add it to the\n        // array list of positive numbers\
    \ and its position. if the number is less\n        // than 0, add it to the array\
    \ list of negative numbers and its position.\n        for (int i = 0; i < l.size();\
    \ i++) {\n            if (l.get(i) > 0) {\n                positiveNumbers.add(i);\n\
    \            } else if (l.get(i) < 0) {\n                negativeNumbers.add(i);\n\
    \            }\n        }\n        // for each number in the array list of negative\
    \ numbers and its position\n        for (int i = 0; i < negativeNumbers.size();\
    \ i++) {\n            // for each number in the array list of positive numbers\
    \ and its position\n            for (int j = 0; j < positiveNumbers.size(); j++)\
    \ {\n                // if the number that is at the negative number's position\
    \ in l\n                // plus the number that is at the positive number's position\
    \ in l\n                // is 0, return true\n                if (l.get(negativeNumbers.get(i))\
    \ + l.get(positiveNumbers.get(j)) == 0) {\n                    return true;\n\
    \                }\n            }\n        }\n        // return false\n      \
    \  return false;", "        Set<Long> map = new HashSet<Long>();\n        for\
    \ (int i = 0; i < l.size(); i++) {\n            if (map.contains(0 - l.get(i)))\
    \ {\n                return true;\n            }\n            map.add(l.get(i));\n\
    \        }\n        return false;", "        return l.contains((long)0l) ||\n\
    \                l.stream().map(x -> l.stream().map(y -> y + x).filter(z -> l.contains(z)).count()\
    \ > 0)\n                        .reduce(false, (x, y) -> x || y);", "        HashSet<Long>\
    \ set = new HashSet<Long>();\n        for (Long el : l) {\n            if (set.contains(el))\
    \ {\n                return true;\n            }\n            set.add(el);\n \
    \       }\n        return false;", "        HashSet<Long> seen = new HashSet<Long>();\n\
    \        for (Long x : l) {\n            seen.add(x);\n        }\n        for\
    \ (Long x : l) {\n            if (seen.contains(-x)) {\n                return\
    \ true;\n            }\n        }\n        return false;", "        for (int i\
    \ = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++)\
    \ {\n                if (l.get(i) + l.get(j) == 0) {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;",
  '        // Your code here', "        HashSet<Long> m = new HashSet<Long>();\n \
    \       for (Long i : l) {\n            if (m.contains(-i)) {\n              \
    \  return true;\n            }\n            m.add(i);\n        }\n        return\
    \ false;", '        throw new UnsupportedOperationException("Replace this line
    with your solution.");', "        Set<Long> set = new HashSet<Long>();\n     \
    \   for (Long i : l) {\n            if (set.contains(-i)) {\n                return\
    \ true;\n            }\n            set.add(i);\n        }\n        return false;",
  "        boolean result = false;\n        HashSet<Long> visited = new HashSet<Long>();\n\
    \        for (Long x : l) {\n            if (visited.contains(-x)) {\n       \
    \         result = true;\n                break;\n            }\n            visited.add(x);\n\
    \        }\n        return result;", "        if (l.size() < 2) {\n          \
    \  return false;\n        }\n        HashSet<Long> nums = new HashSet<Long>();\n\
    \        for (Long num : l) {\n            if (nums.contains(num)) {\n       \
    \         return true;\n            }\n            nums.add(num);\n        }\n\
    \        for (Long num : l) {\n            if (nums.contains(-num)) {\n      \
    \          return true;\n            }\n        }\n        return false;", " \
    \       HashSet<Long> s = new HashSet<Long>();\n        for (int i = 0; i < l.size();\
    \ i++) {\n            Long complement = l.get(i) * -1l;\n            if (s.contains(complement))\
    \ {\n                return true;\n            }\n            s.add(l.get(i));\n\
    \        }\n        return false;", '        return true;', "        HashSet<Long>\
    \ s = new HashSet<Long>();\n        for (Long el: l) {\n            if (s.contains(el))\
    \ {\n                return true;\n            }\n            s.add(-el);\n  \
    \      }\n        return false;", "        // Your code here.\n        return\
    \ false;", '        throw new RuntimeException("Not implemented");', "       \
    \ HashSet<Long> set = new HashSet<Long>();\n        for (Long e : l) {\n     \
    \       if (set.contains(-e)) {\n                return true;\n            }\n\
    \            set.add(e);\n        }\n        return false;", "        Set<Long>\
    \ temp_set = new HashSet<Long>();\n        for (Long i : l) {\n            if\
    \ (temp_set.contains(i)) {\n                return true;\n            }\n    \
    \        temp_set.add(-i);\n        }\n        return false;", "        // first,\
    \ sort the input array list\n        Collections.sort(l);\n        // next, iterate\
    \ over it to find if there are any pairs that sum to zero\n        int i = 0;\n\
    \        int j = l.size() - 1;\n        while (i < j) {\n            if (l.get(i)\
    \ + l.get(j) == 0) {\n                return true;\n            } else if (l.get(i)\
    \ + l.get(j) < 0) {\n                i += 1;\n            } else {\n         \
    \       j -= 1;\n            }\n        }\n        return false;", "        for\
    \ (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size();\
    \ j++) {\n                if (l.get(i) + l.get(j) == 0l) {\n                 \
    \   return true;\n                }\n            }\n        }\n        return\
    \ false;", "        l.sort(null);\n        int len = l.size();\n        int i\
    \ = 0;\n        int j = len - 1;\n        while (i < j) {\n            long sum\
    \ = l.get(i) + l.get(j);\n            if (sum < 0) {\n                i++;\n \
    \           } else if (sum > 0) {\n                j--;\n            } else {\n\
    \                return true;\n            }\n        }\n        return false;",
  "        // REPLACE WITH YOUR CODE\n        return false;", '        return false;',
  '        throw new UnsupportedOperationException("Solution not yet implemented");',
  "        HashSet<Long> set = new HashSet<Long>();\n        for (Long i : l) {\n\
    \            if (set.contains(-i)) {\n                return true;\n         \
    \   }\n            set.add(i);\n        }\n        return false;", "        //\
    \ Your code here.\n        boolean result = false;\n        Collections.sort(l);\n\
    \        System.out.println(l);\n        for (long i : l) {\n            for (long\
    \ j : l) {\n                if (i + j == 0) {\n                    result = true;\n\
    \                }\n            }\n        }\n        return result;", '        throw
    new RuntimeException("implement me");', "        Set<Long> hashset = new HashSet<Long>();\n\
    \        for (Long elt : l) {\n            if (hashset.contains(elt))\n      \
    \          return true;\n            hashset.add(-elt);\n        }\n        return\
    \ false;", "      if (l.size() < 2) {\n        return false;\n      }\n      HashSet<Long>\
    \ seen = new HashSet<Long>();\n      for (int i = 0; i < l.size(); i++) {\n  \
    \      long cur = l.get(i);\n        if (seen.contains(-cur)) {\n          return\
    \ true;\n        }\n        seen.add(cur);\n      }\n      return false;", '        return
    false;', "        if (l.size() < 2) {\n            return false;\n        } else\
    \ {\n            ArrayList<Long> xs = new ArrayList<Long>(l);\n            ArrayList<Long>\
    \ ys = new ArrayList<Long>(l);\n            while (xs.size() > 0) {\n        \
    \        long x = xs.get(0);\n                xs.remove(0);\n                for\
    \ (int yi = 0; yi < ys.size(); yi++) {\n                    long y = ys.get(yi);\n\
    \                    if (x + y == 0) {\n                        return true;\n\
    \                    }\n                }\n            }\n            return false;\n\
    \        }", "        // get the length of the list.\n        int n = l.size();\n\
    \        // if the list has length 0, then the answer is false.\n        if (n==0)\
    \ {\n            return false;\n        }\n        // for every possible pair\
    \ of elements of the list:\n        for (int i=0; i<n; i++) {\n            for\
    \ (int j=i+1; j<n; j++) {\n                // if the pair sum to zero, then the\
    \ answer is true.\n                if (l.get(i)+l.get(j)==0) {\n             \
    \       return true;\n                }\n            }\n        }\n        //\
    \ if we don't find a pair that sums to zero, then the answer is false.\n     \
    \   return false;", "        HashSet<Long> s = new HashSet<Long>();\n        for\
    \ (int i = 0; i < l.size(); i++) {\n            long curr = l.get(i);\n      \
    \      if (s.contains(curr) && curr != 0) {\n                return true;\n  \
    \          }\n            else {\n                s.add(0 - curr);\n         \
    \   }\n        }\n        return false;", "        if (l.size() <= 1) return false;\n\
    \        boolean has_zero = false;\n        boolean has_positive = false;\n  \
    \      boolean has_negative = false;\n        long min_positive = Long.MAX_VALUE;\n\
    \        long max_negative = Long.MIN_VALUE;\n        HashSet<Long> positives\
    \ = new HashSet<Long>();\n        HashSet<Long> negatives = new HashSet<Long>();\n\
    \        long zero = 0l;\n        long min_positive_s = min_positive;\n      \
    \  long max_negative_s = max_negative;\n        for (long x: l) {\n          \
    \  if (x == zero) {\n                has_zero = true;\n            } else if (x\
    \ > zero) {\n                has_positive = true;\n                positives.add(x);\n\
    \                if (x < min_positive) {\n                    min_positive = x;\n\
    \                }\n            } else {\n                has_negative = true;\n\
    \                negatives.add(x);\n                if (x > max_negative) {\n\
    \                    max_negative = x;\n                }\n            }\n   \
    \     }\n        if (has_zero && has_positive && has_negative) {\n           \
    \ return true;\n        }\n        if (!has_zero && has_positive && has_negative)\
    \ {\n            long first = 0l;\n            long second = 0l;\n           \
    \ long current_min_positive = min_positive;\n            long current_max_negative\
    \ = max_negative;\n            if (current_min_positive > current_max_negative\
    \ * -1) {\n                first = current_min_positive;\n                second\
    \ = current_max_negative;\n            } else {\n                first = current_max_negative;\n\
    \                second = current_min_positive;\n            }\n            positives.remove(first);\n\
    \            negatives.remove(second);\n            boolean found = false;\n \
    \           while (!found && positives.size() > 0 && negatives.size() > 0) {\n\
    \                if (first - second > 0) {\n                    current_max_negative\
    \ = second;\n                    current_min_positive = first;\n             \
    \       if (current_min_positive > current_max_negative * -1) {\n            \
    \            first = current_min", "        boolean result = false;\n        //\
    \ INSERT YOUR CODE HERE\n        return result;", "        HashSet<Long> set =\
    \ new HashSet<Long>();\n        for (int i = 0; i < l.size(); i++) {\n       \
    \     long value = l.get(i);\n            if (set.contains(-value)) {\n      \
    \          return true;\n            }\n            set.add(value);\n        }\n\
    \        return false;", '        throw new UnsupportedOperationException("Problem.pairsSumToZero
    has not been implemented yet.");', "        ArrayList<Long> a = (new ArrayList<Long>(l));\n\
    \        long max = Collections.max(a);\n        long min = Collections.min(a);\n\
    \        boolean[] m = new boolean[(int)(max-min+1)];\n        for (long e : a)\
    \ {\n            m[(int)(e-min)] = true;\n        }\n        for (long e : a)\
    \ {\n            if (e==0 && m[(int)(-e-min)]) {\n                return true;\n\
    \            }\n            if (e!=0 && m[(int)(-e-min)]) {\n                return\
    \ true;\n            }\n        }\n        return false;", "        l.sort(null);\n\
    \        int i = 0;\n        int j = l.size() - 1;\n        while (i < j) {\n\
    \            if (l.get(i) + l.get(j) == 0) {\n                return true;\n \
    \           } else if (l.get(i) + l.get(j) < 0) {\n                i += 1;\n \
    \           } else {\n                j -= 1;\n            }\n        }\n    \
    \    return false;", "        // your code here\n        Set<Long> set = new HashSet<>();\n\
    \        set.addAll(l);\n        for (Long x : l) {\n            if (set.contains(-x))\
    \ {\n                return true;\n            }\n        }\n        return false;",
  "        for (Long l1 : l) {\n            for (Long l2 : l) {\n                if\
    \ (l1 != l2 && l1 + l2 == 0) {\n                    return true;\n           \
    \     }\n            }\n        }\n        return false;", '        return false;',
  "        return l.size() != 0 &&\n            l.parallelStream().distinct().filter(i\
    \ -> {\n                return i != 0l &&\n                    l.contains(-i);\n\
    \            }).count() > 0;", "        for (int i = 0; i < l.size(); i++) {\n\
    \            for (int j = i + 1; j < l.size(); j++) {\n                if (l.get(i)\
    \ + l.get(j) == 0) {\n                    return true;\n                }\n  \
    \          }\n        }\n        return false;", "        // your code here\n\
    \        return false;", "        //int size = l.size();\n        //System.out.println(size);\n\
    \        //System.out.println(l.get(2));\n        //System.out.println(Arrays.toString(l.toArray()));\n\
    \        //Collections.sort(l);\n        //System.out.println(Arrays.toString(l.toArray()));\n\
    \        //System.out.println(l.get(2));\n        //while(!l.isEmpty()){\n   \
    \     //    System.out.println(l.get(0));\n        //    l.remove(0);\n      \
    \  //}\n        //System.out.println(l.get(0));\n        for(int i = 0; i < l.size();\
    \ i++){\n            for(int j = i+1; j < l.size(); j++){\n                if(l.get(i)\
    \ + l.get(j) == 0){\n                    return true;\n                }\n   \
    \         }\n        }\n        return false;", "        HashSet<Long> hs = new\
    \ HashSet<Long>();\n        for (int i = 0; i < l.size(); i++) {\n           \
    \ if (hs.contains(l.get(i))) {\n                return true;\n            }\n\
    \            hs.add(-l.get(i));\n        }\n        return false;", '        return
    true;', "        for (int i = 0; i < l.size(); i++) {\n            for (int j\
    \ = i + 1; j < l.size(); j++) {\n                if (l.get(i) + l.get(j) == 0)\
    \ {\n                    return true;\n                }\n            }\n    \
    \    }\n        return false;", "        int n = l.size();\n        for (int i\
    \ = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n        \
    \        if (l.get(i) + l.get(j) == 0) {\n                    return true;\n \
    \               }\n            }\n        }\n        return false;", '        return
    false;', "        HashSet<Long> set = new HashSet<Long>();\n        for (int i\
    \ = 0; i < l.size(); i++) {\n            if (set.contains(l.get(i) * (long)-1l))\
    \ {\n                return true;\n            }\n            set.add(l.get(i));\n\
    \        }\n        return false;", "        HashSet<Long> set = new HashSet<Long>();\n\
    \        for (Long e : l) {\n            if (set.contains(0 - e)) {\n        \
    \        return true;\n            }\n            set.add(e);\n        }\n   \
    \     return false;", "        if (l.size()<2) {\n            return false;\n\
    \        }\n        HashSet<Long> s = new HashSet<Long>();\n        for (Long\
    \ n : l) {\n            if (s.contains(n)) {\n                return true;\n \
    \           }\n            s.add(0-n);\n        }\n        return false;", " \
    \       l.sort(Comparator.naturalOrder());\n        for (int i = 0; i < l.size();\
    \ i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n             \
    \   if (l.get(i) + l.get(j) == 0) {\n                    return true;\n      \
    \          }\n            }\n        }\n        return false;", "        long\
    \ target = 0l;\n        long current = 0l;\n        long diff = 0l;\n        boolean[]\
    \ seen = new boolean[l.size()];\n        for (int i = 0; i < l.size(); i++) {\n\
    \            current = l.get(i);\n            diff = target - current;\n     \
    \       for (int j = 0; j < l.size(); j++) {\n                if (j != i && seen[j]\
    \ == false && l.get(j) == diff) {\n                    return true;\n        \
    \        }\n            }\n            seen[i] = true;\n        }\n        return\
    \ false;", "        // REPLACE THE CODE BELOW WITH YOUR IMPLEMENTATION\n     \
    \   // using a hash table to check if the complement of a number exists\n    \
    \    HashMap<Long, Long> map = new HashMap<Long, Long>();\n        for (Long e\
    \ : l) {\n            if (map.containsKey(e)) {\n                return true;\n\
    \            } else {\n                map.put(-e, e);\n            }\n      \
    \  }\n        return false;", "        // YOUR CODE HERE\n        return false;",
  "        HashSet<Long> hs = new HashSet<Long>();\n        for (int i = 0; i < l.size();\
    \ i++) {\n            if (hs.contains(-l.get(i))) {\n                return true;\n\
    \            }\n            hs.add(l.get(i));\n        }\n        return false;",
  "        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j\
    \ < l.size(); j++) {\n                if (l.get(i) + l.get(j) == 0) {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \     return false;", "        for (Long i : l) {\n            if (l.contains(-i))\
    \ {\n                return true;\n            }\n        }\n        return false;",
  "        // REPLACE THE LINE BELOW WITH YOUR CODE\n        boolean b = false;\n\
    \        int c = 0;\n        while (c < l.size()) {\n            int d = 0;\n\
    \            while (d < l.size()) {\n                if (l.get(c) + l.get(d) ==\
    \ 0 && c != d) {\n                    b = true;\n                }\n         \
    \       d += 1;\n            }\n            c += 1;\n        }\n        return\
    \ b;", "        int i = 0;\n        while (i < l.size()) {\n            int j\
    \ = i + 1;\n            while (j < l.size()) {\n                if (l.get(i) +\
    \ l.get(j) == 0l) {\n                    return true;\n                }\n   \
    \             j = j + 1;\n            }\n            i = i + 1;\n        }\n \
    \       return false;", "        HashSet<Long> nums = new HashSet<Long>();\n \
    \       for (int i = 0; i < l.size(); i++) {\n            long x = l.get(i);\n\
    \            if (nums.contains(x) || nums.contains(-x)) {\n                return\
    \ true;\n            }\n            nums.add(x);\n        }\n        return false;",
  "        // arrayListToArraySet takes an array list of integers and\n        //\
    \ returns a set containing all of the distinct integers in the array list.\n \
    \       // >>> arrayListToArraySet((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)3l, (long)2l, (long)3l, (long)1l))))\n        // {1, 2, 3}\n        //\
    \ >>> arrayListToArraySet((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l,\
    \ (long)1l, (long)1l, (long)1l))))\n        // {1}\n        // >>> arrayListToArraySet((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l, (long)5l))))\n\
    \        // {1, 2, 3, 4, 5}\n        // >>> arrayListToArraySet((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)2l, (long)1l))))\n        // {1, 2, 3}\n        //\
    \ >>> arrayListToArraySet((new ArrayList<Long>(Arrays.asList((long)1l, (long)1l,\
    \ (long)2l, (long)3l, (long)2l, (long)1l))))\n        // {1, 2, 3}\n        Function<ArrayList<Long>,\
    \ HashSet<Long>> arrayListToArraySet = (ArrayList<Long> l2) -> {\n           \
    \ HashSet<Long> l3 = new HashSet<Long>();\n            l2.forEach((Long x) ->\
    \ {\n                l3.add(x);\n            });\n            return l3;\n   \
    \     };\n        // linearSearch takes an array list and a value\n        //\
    \ and returns true if there is an element in the array list that is equal to the\
    \ value\n        // and false otherwise.\n        // >>> linearSearch((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l, (long)5l", "        HashSet<Long> positives =\
    \ new HashSet<Long>();\n        HashSet<Long> negatives = new HashSet<Long>();\n\
    \        for (int i = 0; i < l.size(); i++) {\n            Long number = l.get(i);\n\
    \            if (number > 0) {\n                positives.add(number);\n     \
    \       } else if (number < 0) {\n                negatives.add(number);\n   \
    \         } else {\n                if (positives.contains((long)0)) {\n     \
    \               return true;\n                } else {\n                    positives.add((long)0);\n\
    \                }\n            }\n        }\n        for (Long element : positives)\
    \ {\n            if (negatives.contains(0 - element)) {\n                return\
    \ true;\n            }\n        }\n        return false;", "        Set<Long>\
    \ set = new HashSet<Long>();\n        for (Long a : l) {\n            if (set.contains(a)\
    \ || set.contains(-a)) {\n                return true;\n            }\n      \
    \      set.add(a);\n        }\n        return false;", '        return false;',
  "        // Your code here\n        return false;", "        // we want to iterate\
    \ over each element and ask if there is a\n        // compatible element in the\
    \ array list\n        for (int i = 0; i < l.size(); i++) {\n            // we\
    \ want to extract element at index i\n            Long element_i = l.get(i);\n\
    \            // we want to find the index of a compatible element\n          \
    \  // we use the index of method to find the index\n            int index_j =\
    \ l.indexOf(0 - element_i);\n            // if the index is not equal to -1 and\
    \ is not equal to i, then we have\n            // found a compatible element\n\
    \            if (index_j != -1 && index_j != i) {\n                return true;\n\
    \            }\n        }\n        // there are no compatible elements if we get\
    \ here\n        return false;", "        for (Long l1 : l) {\n            for\
    \ (Long l2 : l) {\n                if (!l1.equals(l2) && (l1 + l2) == 0l) {\n\
    \                    return true;\n                }\n            }\n        }\n\
    \        return false;", "        Set<Long> s = new HashSet<Long>();\n       \
    \ for (Long item : l) {\n            if (s.contains(item)) {\n               \
    \ return true;\n            }\n            else {\n                s.add(-item);\n\
    \            }\n        }\n        return false;", '        return false;', " \
    \       HashSet<Long> h = new HashSet<Long>();\n        for (Long x : l) {\n \
    \           h.add(x);\n        }\n        for (Long x : l) {\n            if (h.contains((-1)\
    \ * x)) {\n                return true;\n            }\n        }\n        return\
    \ false;", '        return false;', "        // Your code here.\n        ArrayList<Long>\
    \ sortedList = mergeSort(l);\n        int i = 0;\n        int j = sortedList.size()\
    \ - 1;\n        while (i < j) {\n            if (sortedList.get(i) + sortedList.get(j)\
    \ == 0) {\n                return true;\n            } else if (sortedList.get(i)\
    \ + sortedList.get(j) < 0) {\n                i++;\n            } else {\n   \
    \             j--;\n            }\n        }\n        return false;", "      \
    \  HashSet<Long> s = new HashSet<Long>();\n        for (Long n : l) {\n      \
    \      if (s.contains(-n)) {\n                return true;\n            }\n  \
    \          s.add(n);\n        }\n        return false;", "        ArrayList<Long>\
    \ plus = new ArrayList<Long>();\n        ArrayList<Long> minus = new ArrayList<Long>();\n\
    \        boolean result = false;\n        Iterator<Long> itr = l.iterator();\n\
    \        while (itr.hasNext()) {\n            Long elt = itr.next();\n       \
    \     if (elt < 0) {\n                minus.add(elt);\n            } else {\n\
    \                plus.add(elt);\n            }\n        }\n        itr = plus.iterator();\n\
    \        while (itr.hasNext()) {\n            Long elt = itr.next();\n       \
    \     if (minus.contains(-elt)) {\n                result = true;\n          \
    \  }\n        }\n        return result;", "        HashSet<Long> s = new HashSet<Long>();\n\
    \        for (int i = 0; i < l.size(); i++) {\n            Long num = l.get(i);\n\
    \            if (s.contains(num * (long) -1)) {\n                return true;\n\
    \            }\n            else {\n                s.add(num);\n            }\n\
    \        }\n        return false;"]
stop_tokens:
- "\n    }\n"
