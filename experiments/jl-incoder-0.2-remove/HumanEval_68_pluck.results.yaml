language: jl
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \    smallest_value = arr[smallest_even_index]\n    return [smallest_value, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpgas8e_01.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpgas8e_01.jl:38\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgas8e_01.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgas8e_01.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgas8e_01.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpgas8e_01.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgas8e_01.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgas8e_01.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgas8e_01.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpgas8e_01.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,0,4,5]) == [2,2]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]\n\
    @assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100])\
    \ == [2,2]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbhfimlp8.jl:37\nin expression starting at\
    \ /tmp/tmpbhfimlp8.jl:37\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9c2ufflp.jl:36\nin expression starting at\
    \ /tmp/tmp9c2ufflp.jl:36\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time begin\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    plucked_arr = pluck(arr)\nend\n\
    </cell>\n<text>\nSolution 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvp1rmmhl.jl:37\nin expression starting at\
    \ /tmp/tmpvp1rmmhl.jl:37\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_even_value::Int64\
    \ = smallest_value\n    \n    for node in arr[2 : end]\n        if node.value\
    \ % 2 == 0\n            if smallest_even_value < node.value\n                smallest_even_value\
    \ = node.value\n                smallest_index = smallest_index + 1\n        \
    \    else\n                if smallest_even_value == node.value\n            \
    \        smallest_index = smallest_index + 1\n                end\n          \
    \  end\n        end\n    end\n    \n    if smallest_index == 1\n        smallest_index\n\
    \    else\n        smallest_index\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpkf2m1sf7.jl:52

    '
  stdout: "test set: Error During Test at /tmp/tmpkf2m1sf7.jl:55\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpkf2m1sf7.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkf2m1sf7.jl:55 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkf2m1sf7.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpkf2m1sf7.jl:56\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpkf2m1sf7.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkf2m1sf7.jl:56 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkf2m1sf7.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpkf2m1sf7.jl:57\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpkf2m1sf7.jl:27\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkf2m1sf7.jl:57 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkf2m1sf7.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpkf2m1sf7.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014767
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 3, 6, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3tkqf1e9.jl:36\nin expression starting at\
    \ /tmp/tmp3tkqf1e9.jl:36\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,4,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,90,0,92,0,94,0,96,0,98,0,100,0,102,0,104,0,106,0,108,0,110,0,112,0,114,0,116,0,118,0,120,0,122,0,124,0,126,0,128,0,130,0,132,0,134,0,136,0,138,0,140,0,142,0,144,0,146,0,148,0,150,0,152,0,154,0,156,0,158,0,160,0,162,0,164,0,166,0,168,0,170,0,172,0,174,0,176,0,178,0,180,0,182,0,184,0,186,0,188,0,190,0,192,0,194,0,196,0,198,0,200,0,202,0,204,0,206,0,208,0,210,0,212,0,214,0,216,0,218,0,220,0,222,0,224,0,226,0,228,0,230,0,232,0,234,0,236,0,238,0,240,0,242,0,244,0,246,0,248,0,250,0,252,0,254,0,256,0,258,0,260,0,262,0,264,0,266,0,268,0,270,0,272,0,274,0,276,0,278,0,280,0,282,0,284,0,286,0,288,0,290,0,292,0,294,0,296,0,298,0,300,0,302,0,304,0,306,0,308,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpld5y_kqt.jl:36\nin expression starting at\
    \ /tmp/tmpld5y_kqt.jl:36\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ smallest_value, smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpbcxu17_1.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmpbcxu17_1.jl:40\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Tuple{Int64, Int64} to an object of type Vector{Int64}\n \
    \ Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbcxu17_1.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbcxu17_1.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbcxu17_1.jl:39\ntest set:\
    \ Error During Test at /tmp/tmpbcxu17_1.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Tuple{Int64, Int64} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbcxu17_1.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbcxu17_1.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ "
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return smallest_value,\
    \ smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n# Test your\
    \ function with the examples below:\n@test pluck([2, 0, 1, 0, 3]) == [2, 0]\n\
    @test pluck([2, 0, 1, 0, 3, 0]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1])\
    \ == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 0]) == [2, 0]\n@test pluck([2,\
    \ 0, 1, 0, 3, 0, 1, 0, 1]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0])\
    \ == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0, 1]) == [2, 0]\n@test pluck([2,\
    \ 0, 1, 0, 3, 0, 1, 2, 0, 1, 0]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1,\
    \ 2, 0, 1, 0, 1]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0])\
    \ == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1]) == [2, 0]\n\
    @test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 0]) == [2, 0]\n@test pluck([2,\
    \ 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1]) == [2, 0]\n@test pluck([2, 0, 1,\
    \ 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3,\
    \ 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0,\
    \ 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 0]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0,\
    \ 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3,\
    \ 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0]) == [2, 0]\n@test pluck([2, 0, 1, 0,\
    \ 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1]) == [2, 0]\n@test pluck([2, 0,\
    \ 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 0]) == [2, 0]\n@test pluck([2,\
    \ 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1]) == [2, 0]\n@test\
    \ pluck([2, 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0]) == [2,\
    \ 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2,\
    \ 0, 1]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\
    \ 1, 2, 0, 1, 2, 0, 1, 0]) == [2, 0]\n@test pluck([2, 0, 1, 0, 3, 0, 1, 2, 0,\
    \ 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1]) == [2, 0]\n@test pluck([2, 0,\
    \ 1, 0, 3, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0]) == [2, 0]\n\
    @test pluck([\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3gscnntp.jl:38\nin expression starting at\
    \ /tmp/tmp3gscnntp.jl:38\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value = smallest_value % 2\n    smallest_index = smallest_index\
    \ - 1\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptx5cpvoj.jl:40\nin expression starting at\
    \ /tmp/tmptx5cpvoj.jl:40\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smalest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value = Int64(0)\n \
    \   smallest_index = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index\
    \ = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index = Int64(0)\n \
    \   smallest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value = Int64(0)\n \
    \   smallest_index = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index\
    \ = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index = Int64(0)\n \
    \   smallest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value = Int64(0)\n \
    \   smallest_index = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index\
    \ = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index = Int64(0)\n \
    \   smallest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value = Int64(0)\n \
    \   smallest_index = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index\
    \ = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index = Int64(0)\n \
    \   smallest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value = Int64(0)\n \
    \   smallest_index = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index\
    \ = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index = Int64(0)\n \
    \   smallest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value = Int64(0)\n \
    \   smallest_index = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index\
    \ = Int64(0)\n    smallest_value = Int64(0)\n    smallest_index = Int64(0)\n \
    \   smallest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = Int64(0)\n    smallest_index = Int64(0)\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppki9h_3h.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppki9h_3h.jl:1\n\
    in expression starting at /tmp/tmppki9h_3h.jl:1\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \    smallest_value = arr[smallest_even_index]\n    return [smallest_value, smallest_even_index]\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,1,2,3]) == [2,2]\n\
    @assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert\
    \ pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3])\
    \ == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) ==\
    \ [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n\
    @assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert\
    \ pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3])\
    \ == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) ==\
    \ [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n\
    @assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert\
    \ pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3])\
    \ == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) ==\
    \ [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n\
    @assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert\
    \ pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@assert pluck([2,0,1,2,3])\
    \ == [2,2]\n@assert pluck([2,0,1,2,3]) == [2,2]\n@\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc02g22p1.jl:33\nin expression starting at\
    \ /tmp/tmpc02g22p1.jl:33\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<text>\nSolution\nLet's\
    \ see how we solve this problem. First we define the pluck function and test it\
    \ on some test cases. Then we define the pluck function and test it on some test\
    \ cases. Then we define the pluck function and test it on some test cases. Then\
    \ we define the pluck function and test it on some test cases. Then we define\
    \ the pluck function and test it on some test cases. Then we define the pluck\
    \ function and test it on some test cases. Then we define the pluck function and\
    \ test it on some test cases. Then we define the pluck function and test it on\
    \ some test cases. Then we define the pluck function and test it on some test\
    \ cases. Then we define the pluck function and test it on some test cases. Then\
    \ we define the pluck function and test it on some test cases. Then we define\
    \ the pluck function and test it on some test cases. Then we define the pluck\
    \ function and test it on some test cases. Then we define the pluck function and\
    \ test it on some test cases. Then we define the pluck function and test it on\
    \ some test cases. Then we define the pluck function and test it on some test\
    \ cases. Then we define the pluck function and test it on some test cases. Then\
    \ we define the pluck function and test it on some test cases. Then we define\
    \ the pluck function and test it on some test cases. Then we define the pluck\
    \ function and test it on some test cases. Then we define the pluck function and\
    \ test it on some test cases. Then we define the pluck function and test it on\
    \ some test cases. Then we define the pluck function and test it on some test\
    \ cases. Then we define the pluck function and test it on some test cases. Then\
    \ we define the pluck function and test it on some test cases. Then we define\
    \ the pluck function and test it on some test cases. Then we define the pluck\
    \ function and test it on some test cases. Then we define the pluck function and\
    \ test it on some test cases. Then we define the pluck function and test it on\
    \ some test cases. Then we define the pluck function and test it on some test\
    \ cases. \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp99dz1mbv.jl:38\nin expression starting at\
    \ /tmp/tmp99dz1mbv.jl:38\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smalest_value = Int64(0)\n    smalest_index = Int64(0)\n    \n    for\
    \ node in arr\n        if node.value % 2 == 0\n            if node.value < smalest_value\n\
    \                smalest_value = node.value\n                smalest_index = node.index\n\
    \            end\n        end\n    end\n    \n    if smalest_value == 0\n    \
    \    return Vector{Int64}()\n    end\n    \n    return [smalest_value, smalest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\n@test pluck([2,3,5,7,11,13,17,19]) ==\
    \ [2,2]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@test pluck([2,3,5,7,11,13,17,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwlisqprn.jl:45\nin expression starting at\
    \ /tmp/tmpwlisqprn.jl:45\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_value\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,4,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,90,0,92,0,94,0,96,0,98,0,100,0,102,0,104,0,106,0,108,0,110,0,112,0,114,0,116,0,118,0,120,0,122,0,124,0,126,0,128,0,130,0,132,0,134,0,136,0,138,0,140,0,142,0,144,0,146,0,148,0,150,0,152,0,154,0,156,0,158,0,160,0,162,0,164,0,166,0,168,0,170,0,172,0,174,0,176,0,178,0,180,0,182,0,184,0,186,0,188,0,190,0,192,0,194,0,196,0,198,0,200,0,202,0,204,0,206,0,208,0,210,0,212,0,214,0,216,0,218,0,220,0,222,0,224,0,226,0,228,0,230,0,232,0,234,0,236,0,238,0,240,0,242,0,244,0,246,0,248,0,250,0,252,0,254,0,256,0,258,0,260,0,262,0,264,0,266,0,268,0,270,0,272,0,274,0,276,0,278,0,280,0,282,0,284,0,286,0,288,0,290,0,292,0,294,0,296,0,298,0,300,0,302,0,304,0,306,0,308,0,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4uqpf_us.jl:37\nin expression starting at\
    \ /tmp/tmp4uqpf_us.jl:37\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Let's test your implementation\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps2h1ia9z.jl:37\nin expression starting at\
    \ /tmp/tmps2h1ia9z.jl:37\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Solution\nLet's see how we would solve this problem manually. We'll start by writing\
    \ a function that will find the smallest even value in a given array:\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwrxx1ahw.jl:37\nin expression starting at\
    \ /tmp/tmpwrxx1ahw.jl:37\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value =\
    \ min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    \n    return [smallest_value, smallest_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpqsfkuc1l.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpqsfkuc1l.jl:39\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqsfkuc1l.jl:29\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqsfkuc1l.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqsfkuc1l.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpqsfkuc1l.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqsfkuc1l.jl:29\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqsfkuc1l.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqsfkuc1l.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpqsfkuc1l.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2) == 0,arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_index = find(even_values == smallest_even_value)[1]\n\
    \        return [smallest_even_value,smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,3]\n@assert pluck([2,3,0,4,5,6,7,8,9,\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw_j1nhwt.jl:36\nin expression starting at\
    \ /tmp/tmpw_j1nhwt.jl:36\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = findfirst(x -> x == smallest_value, even_values)\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj161cir8.jl:38\nin expression starting at\
    \ /tmp/tmpj161cir8.jl:38\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == length(even_values)\n        return Vector{Int64}()\n    else\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpymzpfjzv.jl:36\nin expression starting at\
    \ /tmp/tmpymzpfjzv.jl:36\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || smallest_value == 0\n        return [] \n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@test pluck([2,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,57,0,58,0,59,0,60,0,61,0,62,0,63,0,64,0,65,0,66,0,67,0,68,0,69,0,70,0,71,0,72,0,73,0,74,0,75,0,76,0,77,0,78,0,79,0,80,0,81,0,82,0,83,0,84,0,85,0,86,0,87,0,88,0,89,0,90,0,91,0,92,0,93,0,94,0,95,0,96,0,97,0,98,0,99,0,100,0,101,0,102,0,103,0,104,0,105,0,106,0,107,0,108,0,109,0,110,0,111,0,112,0,113,0,114,0,115,0,116,0,117,0,118,0,119,0,120,0,121,0,122,0,123,0,124,0,125,0,126,0,127,0,128,0,129,0,130,0,131,0,132,0,133,0,134,0,135,0,136,0,137,0,138,0,139,0,140,0,141,0,142,0,143,0,144,0,145,0,146,0,147,0,148,0,149,0,150,0,151,0,152,0,153,0,154,0,155,0,156,0,157,0,158,0,159,0,160,0,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo_vy6gon.jl:37\nin expression starting at\
    \ /tmp/tmpo_vy6gon.jl:37\n"
  stdout: ''
  timestamp: 1660014765
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpfoggobpu.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpfoggobpu.jl:37\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpqek3on5l.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpqek3on5l.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqek3on5l.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqek3on5l.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqek3on5l.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpqek3on5l.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqek3on5l.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqek3on5l.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqek3on5l.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpqek3on5l.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014769
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return [ smallest_value,\
    \ index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n# Test your function\
    \ with the example in the docstring\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n# run your function\n\
    pluck(arr)\n</cell>\n<text>\n4.3 Plucking from a dictionary\nGiven a dictionary\
    \ representing a binary tree, pluck one of the nodes and return its value.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnh4u6di2.jl:36\nin expression starting at\
    \ /tmp/tmpnh4u6di2.jl:36\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw1bfgets.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw1bfgets.jl:1\n\
    in expression starting at /tmp/tmpw1bfgets.jl:1\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->x%2==0, arr)\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return []\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,2,0]) ==\
    \ [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2,\
    \ 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n\
    @assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0])\
    \ == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2,\
    \ 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n\
    @assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0])\
    \ == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2,\
    \ 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n\
    @assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0])\
    \ == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2,\
    \ 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n\
    @assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0])\
    \ == [2, 2]\n@assert pluck([2,0,2,0]) == [2, 2]\n@assert pluck([2,0,2,0]) == [2,\
    \ 2]\n@assert pluck([2,0,2,0]) == [2, \nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpksi_9iaa.jl:36\nin expression starting at\
    \ /tmp/tmpksi_9iaa.jl:36\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_value\
    \ == 0\n        return Vector{Int64}()\n    else\n        return smallest_value,\
    \ smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [1,\
    \ 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, \nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpekkaqzxm.jl:37\nin expression starting at\
    \ /tmp/tmpekkaqzxm.jl:37\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,4,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,90,0,92,0,94,0,96,0,98,0,100,0,102,0,104,0,106,0,108,0,110,0,112,0,114,0,116,0,118,0,120,0,122,0,124,0,126,0,128,0,130,0,132,0,134,0,136,0,138,0,140,0,142,0,144,0,146,0,148,0,150,0,152,0,154,0,156,0,158,0,160,0,162,0,164,0,166,0,168,0,170,0,172,0,174,0,176,0,178,0,180,0,182,0,184,0,186,0,188,0,190,0,192,0,194,0,196,0,198,0,200,0,202,0,204,0,206,0,208,0,210,0,212,0,214,0,216,0,218,0,220,0,222,0,224,0,226,0,228,0,230,0,232,0,234,0,236,0,238,0,240,0,242,0,244,0,246,0,248,0,250,0,252,0,254,0,256,0,258,0,260,0,262,0,264,0,266,0,268,0,270,0,272,0,274,0,276,0,278,0,280,0,282,0,284,0,286,0,288,0,290,0,292,0,294,0,296,0,298,0,300,0,302,0,304,0,306,0,308,0,310,0,312,0,314,0,316,0,318,0,320,0,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyuqlofkm.jl:37\nin expression starting at\
    \ /tmp/tmpyuqlofkm.jl:37\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp61wmra1b.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp61wmra1b.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61wmra1b.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61wmra1b.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61wmra1b.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp61wmra1b.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61wmra1b.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61wmra1b.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61wmra1b.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp61wmra1b.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014769
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgyujv2pt.jl:37\nin expression starting at\
    \ /tmp/tmpgyujv2pt.jl:37\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    elseif length(even_values) == 1\n        return\
    \ even_values\n    else\n        smallest_value = min(even_values)\n        smallest_index\
    \ = find(even_values == smallest_value)[1]\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\narr = [2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\n\
    Given an array representing a branch of a tree that has non-negative integer nodes\n\
    your task is to pluck one of the nodes and return it.\nThe plucked node should\
    \ be the node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd77xrr3w.jl:38\nin expression starting at\
    \ /tmp/tmpd77xrr3w.jl:38\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2:end]\n        if node.even\n            if smallest_value\
    \ == node.value\n                smallest_value = node.value\n               \
    \ smallest_index = smallest_index + 1\n            else\n                if smallest_value\
    \ < node.value\n                    smallest_value = node.value\n            \
    \        smallest_index = smallest_index + 1\n                end\n          \
    \  end\n        end\n    end\n    \n    return smallest_value, smallest_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpjx2fphbo.jl:49

    '
  stdout: "test set: Error During Test at /tmp/tmpjx2fphbo.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field even\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpjx2fphbo.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjx2fphbo.jl:52 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjx2fphbo.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpjx2fphbo.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field even\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpjx2fphbo.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjx2fphbo.jl:53 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjx2fphbo.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpjx2fphbo.jl:54\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpjx2fphbo.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjx2fphbo.jl:54 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjx2fphbo.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpjx2fphbo.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type In"
  timestamp: 1660014769
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\
    \ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,\
    \ 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\
    \ 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,\
    \ 97, 98, 99, 100]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5umm51qc.jl:36\nin expression starting at\
    \ /tmp/tmp5umm51qc.jl:36\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpfoggobpu.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpfoggobpu.jl:37\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if length(even_values)\
    \ == 0\n        return []\n    smallest_value = min(even_values)\n    smallest_index\
    \ = even_values.index(smallest_value)\n    return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpiyea9cy5.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpiyea9cy5.jl:1\n\
    in expression starting at /tmp/tmpiyea9cy5.jl:1\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    if length(evens) == 0\n        return Vector{Int64}()\n\
    \    else\n        return evens\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\
    \ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,\
    \ 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\
    \ 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,\
    \ 97, 98, 99, 100]\n</cell>\n<code language=julia-1.0>\narr\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw3rq8gsb.jl:36\nin expression starting at\
    \ /tmp/tmpw3rq8gsb.jl:36\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    if length(evens) == 0\n        return Vector{Int64}[]\n\
    \    else\n        return evens\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpro1w168r.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpro1w168r.jl:41\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpro1w168r.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpro1w168r.jl:40\ntest set: Test Failed at /tmp/tmpro1w168r.jl:42\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpro1w168r.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpro1w168r.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpro1w168r.jl:44\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2, 4] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpro1w168r.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpro1w168r.jl:40\ntest set: Test Failed at /tmp/tmpro1w168r.jl:45\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [2] == [0,\
    \ 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpro1w168r.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpro1w168r.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpro1w168r.jl:46\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 8, 8] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nSolution\n\
    Let's see how we would use pluck to solve the problem:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuh7vl027.jl:36\nin expression starting at\
    \ /tmp/tmpuh7vl027.jl:36\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = findall(x -> x % 2 == 0, arr)\n    \n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpocnhhv06.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpocnhhv06.jl:1\n\
    in expression starting at /tmp/tmpocnhhv06.jl:1\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return smallest_value, smallest_index\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [2, 3, 4, 0, 6, 8, 10, 12, 14,\
    \ 16, 18, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxhcg7283.jl:34\nin expression starting at\
    \ /tmp/tmpxhcg7283.jl:34\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmpm2g75_0j.jl:38\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpm2g75_0j.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm2g75_0j.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpm2g75_0j.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpm2g75_0j.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpm2g75_0j.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm2g75_0j.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpm2g75_0j.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpm2g75_0j.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp07fg5ud0.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp07fg5ud0.jl:1\n\
    in expression starting at /tmp/tmp07fg5ud0.jl:1\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return [] \n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpis7ucrye.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpis7ucrye.jl:1\n\
    in expression starting at /tmp/tmpis7ucrye.jl:1\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return smallest_value, smallest_index\n    end\nend\n</cell>\n<text>\nProblem\
    \ 3\nGiven an array representing a branch of a tree that has non-negative integer\
    \ nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node\
    \ should be the node with the smallest odd value.\nIf multiple nodes with the\
    \ same smallest odd value are found return the node that has smallest index.\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpukcan1tj.jl:38\nin expression starting at\
    \ /tmp/tmpukcan1tj.jl:38\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value = minimum(arr)\n    smallest_index = findfirst(x\
    \ -> x==smallest_value, arr)\n    \n    if smallest_index == -1 || smallest_value\
    \ == 0\n        return Vector{Int64}[]\n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index_even = findfirst(x -> x%2==0, arr)\n    \n    if smallest_index_even\
    \ == -1 || smallest_value == 0\n        return Vector{Int64}[]\n    end\n    \n\
    \    smallest_index_even = arr[smallest_index_even]\n    \n    if smallest_index_even\
    \ < smallest_index\n        smallest_value = arr[smallest_index_even]\n      \
    \  smallest_index = smallest_index_even\n    end\n    \n    arr[smallest_index]\
    \ = smallest_value\n    \n    return arr\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([2,0,2,0,1]) == [2, 2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2, 2]\n@assert pluck([\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwg010tz5.jl:54\nin expression starting at\
    \ /tmp/tmpwg010tz5.jl:54\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value =\
    \ min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    \n    if length(even_values) == 0 || smallest_value == 0\n        return\
    \ Vector{Int64}()\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,4,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,90,0,92,0,94,0,96,0,98,0,100,0,102,0,104,0,106,0,108,0,110,0,112,0,114,0,116,0,118,0,120,0,122,0,124,0,126,0,128,0,130,0,132,0,134,0,136,0,138,0,140,0,142,0,144,0,146,0,148,0,150,0,152,0,154,0,156,0,158,0,160,0,162,0,164,0,166,0,168,0,170,0,172,0,174,0,176,0,178,0,180,0,182,0,184,0,186,0,188,0,190,0,192,0,194,0,196,0,198,0,200,0,202,0,204,0,206,0,208,0,210,0,212,0,214,0,216,0,218,0,220,0,222,0,224,0,226,0,228,0,230,0,232,0,234,0,236,0,238,0,240,0,242,0,244,0,246,0,248,0,250,0,252,0,254,0,256,0,258,0,260,0,262,0,264,0,266,0,268,0,270,0,272,0,274,0,276,0,278,0,280,0,282,0,284,0,286,0,288,0,290,0,292,0,294,0,296,0,298,0,300,0,302,0,304,0,306,0,308,0,310,0,312,0,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqs5fuor0.jl:38\nin expression starting at\
    \ /tmp/tmpqs5fuor0.jl:38\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = arr.filter(x -> x % 2 == 0)\n    evens = evens[evens.argsort()]\n\
    \    evens = evens[2:end]\n    if evens.size == 0\n        return Vector{Int64}()\n\
    \    else\n        return evens\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,4,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,90,0,92,0,94,0,96,0,98,0,100,0,102,0,104,0,106,0,108,0,110,0,112,0,114,0,116,0,118,0,120,0,122,0,124,0,126,0,128,0,130,0,132,0,134,0,136,0,138,0,140,0,142,0,144,0,146,0,148,0,150,0,152,0,154,0,156,0,158,0,160,0,162,0,164,0,166,0,168,0,170,0,172,0,174,0,176,0,178,0,180,0,182,0,184,0,186,0,188,0,190,0,192,0,194,0,196,0,198,0,200,0,202,0,204,0,206,0,208,0,210,0,212,0,214,0,216,0,218,0,220,0,222,0,224,0,226,0,228,0,230,0,232,0,234,0,236,0,238,0,240,0,242,0,244,0,246,0,248,0,250,0,252,0,254,0,256,0,258,0,260,0,262,0,264,0,266,0,268,0,270,0,272,0,274,0,276,0,278,0,280,0,282,0,284,0,286,0,288,0,290,0,292,0,294,0,296,0,298,0,300,0,302,0,304,0,306,0,308,0,310,0,312,0,314,0,316\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyojt9hs4.jl:36\nin expression starting at\
    \ /tmp/tmpyojt9hs4.jl:36\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [\
    \ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19,23,29])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplz_ueik1.jl:38\nin expression starting at\
    \ /tmp/tmplz_ueik1.jl:38\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test\
    \ pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0]) == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,1]\n@test pluck([2,3,5,7,11,13,17,19,\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc9r1ngnm.jl:37\nin expression starting at\
    \ /tmp/tmpc9r1ngnm.jl:37\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp97x_nkyj.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp97x_nkyj.jl:1\n\
    in expression starting at /tmp/tmp97x_nkyj.jl:1\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == length(even_values)\n        return Vector{Int64}()\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpnpoverq6.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpnpoverq6.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnpoverq6.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnpoverq6.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnpoverq6.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpnpoverq6.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnpoverq6.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnpoverq6.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnpoverq6.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpnpoverq6.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014771
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,0]) == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1vi5xdy8.jl:37\nin expression starting at\
    \ /tmp/tmp1vi5xdy8.jl:37\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,0,1,2,3]) == [2,3]\n@assert pluck([2,3,0,1,2,3]) == [2,3]\n\
    @assert pluck([2,3,\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwzwd9vsu.jl:38\nin expression starting at\
    \ /tmp/tmpwzwd9vsu.jl:38\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return [] \n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 8, 0, 7, 1, 6, 3, 9, 4, 10, 2, 8, 5, 6, 1, 9, 3, 7, 4, 10, 1, 8,\
    \ 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4,\
    \ 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1,\
    \ 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8,\
    \ 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10,\
    \ 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2,\
    \ 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4,\
    \ 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10,\
    \ 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7,\
    \ 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5,\
    \ 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3,\
    \ 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9,\
    \ 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9,\
    \ 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3,\
    \ 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1,\
    \ 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6,\
    \ 3, 9, 5, 10, 2, 8, 4, 6, 1, 9, 3, 7, 4, 10, 1, 8, 6, 3, 9, 5, 10, 2, 8, 4, 6,\
    \ 1, 9, 3, 7, 4, 10, 1, 8, \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8awwdl2w.jl:37\nin expression starting at\
    \ /tmp/tmp8awwdl2w.jl:37\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpasgt9iub.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpasgt9iub.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpasgt9iub.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpasgt9iub.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpasgt9iub.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpasgt9iub.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpasgt9iub.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpasgt9iub.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpasgt9iub.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpasgt9iub.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_even_value\
    \ = min(even_values)\n    smallest_index = find(x -> x == smallest_even_value,\
    \ even_values)[1]\n    \n    plucked_value = arr[smallest_index]\n    return Vector{Int64}([plucked_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0rlv3vhd.jl:39\nin expression starting at\
    \ /tmp/tmp0rlv3vhd.jl:39\n"
  stdout: ''
  timestamp: 1660014769
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_even_value::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    for node in arr\n        if node\
    \ % 2 == 0\n            if smallest_even_value == 0\n                smallest_even_value\
    \ = node\n                smallest_even_index = smallest_index\n            else\n\
    \                if smallest_even_value < node\n                    smallest_even_value\
    \ = node\n                    smallest_even_index = smallest_index\n         \
    \       end\n            end\n        else\n            if smallest_even_value\
    \ < node\n                smallest_even_value = node\n                smallest_even_index\
    \ = smallest_index\n            end\n        end\n        smallest_index += 1\n\
    \    end\n    return [smallest_even_value, smallest_even_index]\nend\n</cell>\n\
    <code language=julia-1.5>\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test\
    \ pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) ==\
    \ [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@test pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@test pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphvzlha0t.jl:52\nin expression starting at\
    \ /tmp/tmphvzlha0t.jl:52\n"
  stdout: ''
  timestamp: 1660014769
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2 : end]\n        if node.value % 2 == 0\n        \
    \    if smallest_value % 2 == 0\n                smallest_value = node.value\n\
    \                smallest_index = smallest_index + 1\n            else\n     \
    \           if node.value < smallest_value\n                    smallest_value\
    \ = node.value\n                    smallest_index = smallest_index + 1\n    \
    \            end\n            end\n        end\n    end\n    \n    if smallest_value\
    \ == 0\n        smallest_value = arr[1]\n        smallest_index = 1\n    end\n\
    \    \n    return smallest_value, smallest_index\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp4vn_z4yk.jl:54

    '
  stdout: "test set: Error During Test at /tmp/tmp4vn_z4yk.jl:57\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp4vn_z4yk.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4vn_z4yk.jl:57 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4vn_z4yk.jl:56\ntest set:\
    \ Error During Test at /tmp/tmp4vn_z4yk.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp4vn_z4yk.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4vn_z4yk.jl:58 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4vn_z4yk.jl:56\ntest set:\
    \ Error During Test at /tmp/tmp4vn_z4yk.jl:59\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp4vn_z4yk.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4vn_z4yk.jl:59 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4vn_z4yk.jl:56\ntest set:\
    \ Error During Test at /tmp/tmp4vn_z4yk.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpfoggobpu.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpfoggobpu.jl:37\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2:end]\n        if node < smallest_value\n        \
    \    smallest_value = node\n            smallest_index = smallest_index + 1\n\
    \        elseif node == smallest_value\n            smallest_index = smallest_index\
    \ + 1\n        end\n    end\n    \n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,2,0]) == [2,1]\n@assert\
    \ pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0])\
    \ == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n\
    @assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert\
    \ pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0])\
    \ == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n\
    @assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert\
    \ pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0])\
    \ == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n\
    @assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert\
    \ pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0])\
    \ == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n\
    @assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert\
    \ pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0])\
    \ == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n@assert pluck([2,0,2,0]) == [2,1]\n\
    @assert pluck([2,0,2,0]) == [\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplikzxord.jl:42\nin expression starting at\
    \ /tmp/tmplikzxord.jl:42\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 6, 5, 8, 7, 4, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\
    \ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,\
    \ 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\
    \ 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,\
    \ 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\
    \ 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,\
    \ 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144,\
    \ 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,\
    \ 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,\
    \ 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192,\
    \ 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,\
    \ 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,\
    \ 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,\
    \ 241, 242, 243, 244, 245, 246, 247, 248, 249, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpghxfcmoe.jl:38\nin expression starting at\
    \ /tmp/tmpghxfcmoe.jl:38\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp1ccghza1.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp1ccghza1.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ccghza1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ccghza1.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ccghza1.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp1ccghza1.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ccghza1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ccghza1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ccghza1.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp1ccghza1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_index = find(x -> x == smallest_even_value, even_values)\n\
    \    if smallest_index == length(even_values)\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_even_value, smallest_index]\n    end\nend\n\
    </cell>\n<text>\nSolution\nLet's see how we could solve this problem using our\
    \ pluck() function defined above.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpejhnyuue.jl:36\nin expression starting at\
    \ /tmp/tmpejhnyuue.jl:36\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0 \n        return [] \n    else \n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [\
    \ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<text>\nSolution\n\
    Let's see how we would use pluck to solve the problem:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8vsoqi7l.jl:36\nin expression starting at\
    \ /tmp/tmp8vsoqi7l.jl:36\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpf6wlut_4.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpf6wlut_4.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpf6wlut_4.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpf6wlut_4.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpf6wlut_4.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpf6wlut_4.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpf6wlut_4.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpf6wlut_4.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpf6wlut_4.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpf6wlut_4.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    evens = evens[minimum(evens)]\n    evens = evens[2:end]\n\
    \    return evens\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,3,5,7,11,13,17]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,3,5,7,\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9bp602hj.jl:34\nin expression starting at\
    \ /tmp/tmp9bp602hj.jl:34\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,4,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck([2,0,4,3,0,3]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,3]) == [2,1]\n@assert pluck\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppv1sxpa9.jl:36\nin expression starting at\
    \ /tmp/tmppv1sxpa9.jl:36\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,24\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp55iqx59m.jl:36\nin expression starting at\
    \ /tmp/tmp55iqx59m.jl:36\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if length(evens) == 0\n    \
    \    return Vector{Int64}()\n    else\n        smalest_value = min(evens)\n  \
    \      index = find(x -> x == smalest_value, evens)\n        return [smalest_value,\
    \ index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n@assert \nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoyi9i5nw.jl:36\nin expression starting at\
    \ /tmp/tmpoyi9i5nw.jl:36\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return []\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmphfxe97gp.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmphfxe97gp.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphfxe97gp.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphfxe97gp.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphfxe97gp.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphfxe97gp.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphfxe97gp.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphfxe97gp.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphfxe97gp.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphfxe97gp.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpasgt9iub.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpasgt9iub.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpasgt9iub.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpasgt9iub.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpasgt9iub.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpasgt9iub.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpasgt9iub.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpasgt9iub.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpasgt9iub.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpasgt9iub.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014772
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return smallest_value,\
    \ smallest_index\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmpjawkdpuy.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjawkdpuy.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjawkdpuy.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjawkdpuy.jl:42\ntest set:\
    \ Test Failed at /tmp/tmpjawkdpuy.jl:44\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\n   Evaluated: [2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjawkdpuy.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpjawkdpuy.jl:42\ntest set: Error During Test\
    \ at /tmp/tmpjawkdpuy.jl:46\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjawkdpuy.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/j"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_even_value::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64\
    \ = 0\n    smallest_even_index::Int64 = 0\n    smallest_even_index::Int64 = 0\n\
    \    smallest_even_index::Int64 = 0\n    smalle\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbj2ymmbj.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbj2ymmbj.jl:1\n\
    in expression starting at /tmp/tmpbj2ymmbj.jl:1\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return []\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 1])\
    \ == [2, 1]\n@assert pluck([2, 3]) == [2, 3]\n@assert pluck([2, 4]) == [2, 4]\n\
    @assert pluck([2, 5]) == [2, 5]\n@assert pluck([2, 6]) == [2, 6]\n@assert pluck([2,\
    \ 7]) == [2, 7]\n@assert pluck([2, 8]) == [2, 8]\n@assert pluck([2, 9]) == [2,\
    \ 9]\n@assert pluck([2, 10]) == [2, 10]\n@assert pluck([2, 11]) == [2, 11]\n@assert\
    \ pluck([2, 12]) == [2, 12]\n@assert pluck([2, 13]) == [2, 13]\n@assert pluck([2,\
    \ 14]) == [2, 14]\n@assert pluck([2, 15]) == [2, 15]\n@assert pluck([2, 16]) ==\
    \ [2, 16]\n@assert pluck([2, 17]) == [2, 17]\n@assert pluck([2, 18]) == [2, 18]\n\
    @assert pluck([2, 19]) == [2, 19]\n@assert pluck([2, 20]) == [2, 20]\n@assert\
    \ pluck([2, 21]) == [2, 21]\n@assert pluck([2, 22]) == [2, 22]\n@assert pluck([2,\
    \ 23]) == [2, 23]\n@assert pluck([2, 24]) == [2, 24]\n@assert pluck([2, 25]) ==\
    \ [2, 25]\n@assert pluck([2, 26]) == [2, 26]\n@assert pluck([2, 27]) == [2, 27]\n\
    @assert pluck([2, 28]) == [2, 28]\n@assert pluck([2, 29]) == [2, 29]\n@assert\
    \ pluck([2, 30]) == [2, 30]\n@assert pluck([2, 31]) == [2, 31]\n@assert pluck([2,\
    \ 32]) == [2, 32]\n@assert pluck([2, 33]) == [2, 33]\n@assert pluck([2, 34]) ==\
    \ [2, 34]\n@assert pluck([2, 35]) == [2, 35]\n@assert pluck([2, 36]) == [2, 36]\n\
    @assert pluck([2, 37]) == [2, 37]\n@assert pluck([2, 38]) == [2, 38\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgyb2adhv.jl:37\nin expression starting at\
    \ /tmp/tmpgyb2adhv.jl:37\n"
  stdout: ''
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    smalest_value = min(even_values)\n    smalest_index\
    \ = find(even_values == smalest_value)[1]\n    \n    return [smalest_value, smalest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjdr1kh61.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjdr1kh61.jl:1\n\
    in expression starting at /tmp/tmpjdr1kh61.jl:1\n"
  stdout: ''
  timestamp: 1660014771
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    smallest_value\
    \ = arr[smallest_index]\n    return [smallest_value, smallest_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpnkpzgzt8.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpnkpzgzt8.jl:38\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnkpzgzt8.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnkpzgzt8.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnkpzgzt8.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpnkpzgzt8.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnkpzgzt8.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnkpzgzt8.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnkpzgzt8.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpnkpzgzt8.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014774
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if length(evens) == 0\n    \
    \    return Vector{Int64}()\n    else\n        smalest_value = minimum(evens)\n\
    \        index = find(evens == smalest_value)[1]\n        return [ smalest_value,\
    \ index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4ryu9tfz.jl:36\nin expression starting at\
    \ /tmp/tmp4ryu9tfz.jl:36\n"
  stdout: ''
  timestamp: 1660014771
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    smalest_value = arr[smallest_index]\n    \n    return smalest_value, smallest_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpxfmjiv27.jl:46

    '
  stdout: "test set: Error During Test at /tmp/tmpxfmjiv27.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxfmjiv27.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxfmjiv27.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxfmjiv27.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpxfmjiv27.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxfmjiv27.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxfmjiv27.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxfmjiv27.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpxfmjiv27.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014774
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert\
    \ pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,1]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpclmt1ner.jl:36\nin expression starting at\
    \ /tmp/tmpclmt1ner.jl:36\n"
  stdout: ''
  timestamp: 1660014771
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function with the examples from above\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n\
    @test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3,\
    \ 0, 0, 5, 1]) == [2, 1]\n@test pluck([2, 6, 0, 8, 3, 0, 0, 5, 1]\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbx14zte_.jl:38\nin expression starting at\
    \ /tmp/tmpbx14zte_.jl:38\n"
  stdout: ''
  timestamp: 1660014771
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2) == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_index = findfirst(x->mod(x,2) == 0, even_values)\n\
    \    \n    if smallest_index == -1 || smallest_even_value == 0\n        return\
    \ Vector{Int64}()\n    else\n        return [smallest_even_value,smallest_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@test pluck([2,0,4,2,0,1])==[2,1]\n\
    @test pluck([2,0,4,2,0,2])==[2,2]\n@test pluck([2,0,4,2,0,3])==[2,3]\n@test pluck([2,0,4,2,0,4])==[2,4]\n\
    @test pluck([2,0,4,2,0,5])==[2,5]\n@test pluck([2,0,4,2,0,6])==[2,6]\n@test pluck([2,0,4,2,0,7])==[2,7]\n\
    @test pluck([2,0,4,2,0,8])==[2,8]\n@test pluck([2,0,4,2,0,9])==[2,9]\n@test pluck([2,0,4,2,0,10])==[2,10]\n\
    @test pluck([2,0,4,2,0,11])==[2,11]\n@test pluck([2,0,4,2,0,12])==[2,12]\n@test\
    \ pluck([2,0,4,2,0,13])==[2,13]\n@test pluck([2,0,4,2,0,14])==[2,14]\n@test pluck([2,0,4,2,0,15])==[2,15]\n\
    @test pluck([2,0,4,2,0,16])==[2,16]\n@test pluck([2,0,4,2,0,17])==[2,17]\n@test\
    \ pluck([2,0,4,2,0,18])==[2,18]\n@test pluck([2,0,4,2,0,19])==[2,19]\n@test pluck([2,0,4,2,0,20])==[2,20]\n\
    @test pluck([2,0,4,2,0,21])==[2,21]\n@test pluck([2,0,4,2,0,22])==[2,22]\n@test\
    \ pluck([2,0,4,2,0,23])==[2,23]\n@test pluck([2,0,4,2,0,24])==[2,24]\n@test pluck([2,0,4,2,0,25])==[2,25]\n\
    @test pluck([2,0,4,2,0,26])==[2,\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnln3m7sz.jl:37\nin expression starting at\
    \ /tmp/tmpnln3m7sz.jl:37\n"
  stdout: ''
  timestamp: 1660014771
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == 0 \n        smallest_value = arr[1]\n        smallest_index\
    \ = 1\n    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpt_s074bc.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpt_s074bc.jl:1\n\
    in expression starting at /tmp/tmpt_s074bc.jl:1\n"
  stdout: ''
  timestamp: 1660014771
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_even_index = find(even_values == smallest_even_value)[1]\n \
    \       smallest_value = arr[smallest_even_index]\n        return [smallest_value,\
    \ smallest_even_index]\n    end\nend\n</cell>\n<text>\nLet's test your implementation\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpww8ufn54.jl:37\nin expression starting at\
    \ /tmp/tmpww8ufn54.jl:37\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_index = 1\n    end\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkdggssb4.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkdggssb4.jl:1\n\
    in expression starting at /tmp/tmpkdggssb4.jl:1\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0])\
    \ == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n\
    @assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2,\
    \ 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2,\
    \ 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert\
    \ pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2,\
    \ 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2,\
    \ 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert\
    \ pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2,\
    \ 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2,\
    \ 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert\
    \ pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2,\
    \ 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2,\
    \ 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert\
    \ pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2,\
    \ 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2,\
    \ 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert\
    \ pluck([2, 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2,\
    \ 0]) == [2, 0]\n@assert pluck([2, 0]) == [2, 0]\n\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprv773zso.jl:36\nin expression starting at\
    \ /tmp/tmprv773zso.jl:36\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmjsocaia.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmjsocaia.jl:1\n\
    in expression starting at /tmp/tmpmjsocaia.jl:1\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0 \n        return [] \n    \n    smallest_value = min(even_values)\n   \
    \ smallest_index = index(even_values, smallest_value)\n    \n    smallest_value_and_index\
    \ = Vector{Int64}([smallest_value, smallest_index])\n    \n    return smallest_value_and_index\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30]) == [2,4]\n\
    @assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]) == [2,4]\n\
    @assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2lmohk60.jl:38\nin expression starting at\
    \ /tmp/tmp2lmohk60.jl:38\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x -> x == smallest_value, even_values)\n \
    \       return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2, 0, 0, 0]) == [2, 0]\n@assert pluck([2, 0, 0, 1]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 2]) == [2, 0]\n@assert pluck([2, 0, 0, 3]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 4]) == [2, 0]\n@assert pluck([2, 0, 0, 5]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 6]) == [2, 0]\n@assert pluck([2, 0, 0, 7]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 8]) == [2, 0]\n@assert pluck([2, 0, 0, 9]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 10]) == [2, 0]\n@assert pluck([2, 0, 0, 11]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 12]) == [2, 0]\n@assert pluck([2, 0, 0, 13]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 14]) == [2, 0]\n@assert pluck([2, 0, 0, 15]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 16]) == [2, 0]\n@assert pluck([2, 0, 0, 17]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 18]) == [2, 0]\n@assert pluck([2, 0, 0, 19]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 20]) == [2, 0]\n@assert pluck([2, 0, 0, 21]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 22]) == [2, 0]\n@assert pluck([2, 0, 0, 23]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 24]) == [2, 0]\n@assert pluck([2, 0, 0, 25]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 26]) == [2, 0]\n@assert pluck([2, 0, 0, 27]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 28]) == [2, 0]\n@assert pluck([2, 0, 0, 29]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 30]) == [2, 0]\n@assert pluck([2, 0, 0, 31]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 32]) == [2, 0]\n@assert pluck([2, 0, 0, 33]) == [2, 0]\n\
    @assert pluck([2, 0, 0, 34]) == [2, 0]\n@assert pluck([2, 0, 0, 35]) == [2, 0]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbmshfxp7.jl:38\nin expression starting at\
    \ /tmp/tmpbmshfxp7.jl:38\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp97x_nkyj.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp97x_nkyj.jl:1\n\
    in expression starting at /tmp/tmp97x_nkyj.jl:1\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return []\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmphfxe97gp.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmphfxe97gp.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphfxe97gp.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphfxe97gp.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphfxe97gp.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphfxe97gp.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphfxe97gp.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphfxe97gp.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphfxe97gp.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphfxe97gp.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_value_index::Int64\
    \ = 1\n    smallest_value_index = 1\n    smallest_value = 1\n    smallest_index\
    \ = 1\n    \n    for node in arr\n        if node.value % 2 == 0\n           \
    \ if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_value_index = smallest_index\n            end\n    \
    \        if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_value_index = smallest_index\n            end\n    \
    \    end\n        smallest_index += 1\n    end\n    \n    if smallest_value ==\
    \ smallest_value_index\n        smallest_value_index = 1\n    end\n    \n    if\
    \ smallest_value == smallest_value_index\n        smallest_value_index = 1\n \
    \   end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_value_index\n        smallest_value_index\
    \ = 1\n    end\n    \n    if smallest_value == smallest_\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmyub04wr.jl:1\nin expression starting at /tmp/tmpmyub04wr.jl:1\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprvs5kdr1.jl:32\nin expression starting at\
    \ /tmp/tmprvs5kdr1.jl:32\n"
  stdout: ''
  timestamp: 1660014772
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2 : end]\n        if node.value % 2 == 0\n        \
    \    if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_index = node.index\n            end\n        end\n \
    \   end\n    \n    return [smallest_value, smallest_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp2kdprv4x.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmp2kdprv4x.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp2kdprv4x.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp2kdprv4x.jl:47 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp2kdprv4x.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp2kdprv4x.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp2kdprv4x.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp2kdprv4x.jl:48 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp2kdprv4x.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp2kdprv4x.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp2kdprv4x.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp2kdprv4x.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp2kdprv4x.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp2kdprv4x.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6jhrg8ef.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6jhrg8ef.jl:1\n\
    in expression starting at /tmp/tmp6jhrg8ef.jl:1\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = Inf \n    smallest_index::Int64 = Inf \n\
    \    \n    for index in 1:length(arr)\n        if arr[index] <= smallest_value\n\
    \            smallest_value = arr[index]\n            smallest_index = index\n\
    \        end\n    end\n    \n    if smallest_value == Inf || length(arr) == 0\n\
    \        return []\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n# Test your solution \n@assert\
    \ pluck([2,0,2,0]) == [2, 1]\n@assert pluck([2,0,2,1]) == [2, 1]\n@assert pluck([2,0,4,0])\
    \ == [2, 3]\n@assert pluck([2,0,4,1]) == [2, 3]\n@assert pluck([2,0,4,2]) == [2,\
    \ 3]\n@assert pluck([2,0,4,3]) == [2, 3]\n@assert pluck([2,0,4,4]) == [2, 3]\n\
    @assert pluck([2,0,4,5]) == [2, 3]\n@assert pluck([2,0,4,6]) == [2, 3]\n@assert\
    \ pluck([2,0,4,7]) == [2, 3]\n@assert pluck([2,0,4,8]) == [2, 3]\n@assert pluck([2,0,4,9])\
    \ == [2, 3]\n@assert pluck([2,0,4,10]) == [2, 3]\n@assert pluck([2,0,4,11]) ==\
    \ [2, 3]\n@assert pluck([2,0,4,12]) == [2, 3]\n@assert pluck([2,0,4,13]) == [2,\
    \ 3]\n@assert pluck([2,0,4,14]) == [2, 3]\n@assert pluck([2,0,4,15]) == [2, 3]\n\
    @assert pluck([2,0,4,16]) == [2, 3]\n@assert pluck([2,0,4,17]) == [2, 3]\n@assert\
    \ pluck([2,0,4,18]) == [2, 3]\n@assert pluck([2,0,4,19]) == [2, 3]\n@assert pluck([2,0,4,20])\
    \ == [2, 3]\n@assert pluck([2,0,4,21]) == [2, 3]\n@assert pluck([2,0,4,22]) ==\
    \ [2, 3]\n@assert pluck([2,0,4,23]) == [2, 3]\n@assert pluck([2,0,4,24]) == [2,\
    \ 3]\n@assert pluck([2,0,4,25]) == [2, 3]\n@assert pluck([2,0,4,26]) == [2, 3]\n\
    @assert pluck([2,0,4,27]) == [2, 3]\n@assert pluck([2,0,4,28]) == [2, 3]\n@assert\
    \ pluck([2,0,4,29]) == [2, 3]\n@assert pluck([2,0,4,30]\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp85w57nb3.jl:44\nin expression starting at\
    \ /tmp/tmp85w57nb3.jl:44\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    evens = evens[minimum(evens)]\n    evens = evens[2:end]\n\
    \    evens = evens[minimum(evens)]\n    return evens\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1])\
    \ == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n\
    @assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1])\
    \ == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n\
    @assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1])\
    \ == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n\
    @assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1])\
    \ == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n\
    @assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1])\
    \ == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n\
    @assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert\
    \ pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1]) == [2]\n@assert pluck([2,0,2,0,1])\
    \ == [2]\n@\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr4edw35c.jl:35\nin expression starting at\
    \ /tmp/tmpr4edw35c.jl:35\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x->mod(x,2)==0,arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values==smallest_value)[1]\n    \n    return [smallest_value,smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [2,1,0,4,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [2,1,0,4,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [2,1,0,4,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,1,0,4,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzwwm4yh5.jl:34\nin expression starting at\
    \ /tmp/tmpzwwm4yh5.jl:34\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(arr) == 0\n        return []\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.0>\n@test pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@test pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2synp3y8.jl:37\nin expression starting at\
    \ /tmp/tmp2synp3y8.jl:37\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpq6oj7en8.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpq6oj7en8.jl:37\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq6oj7en8.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq6oj7en8.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq6oj7en8.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpq6oj7en8.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq6oj7en8.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq6oj7en8.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq6oj7en8.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpq6oj7en8.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014776
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_index = find(even_values == smallest_even_value)[0]\n\
    \    \n    if smallest_index == -1\n        return Vector{Int64}()\n    else\n\
    \        return [ smallest_even_value, smallest_index ]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test your function with the examples from above\n\
    @test pluck([2,3,5,0,2,4,6,0,0])[1] == 2\n@test pluck([2,3,5,0,2,4,6,0,0])[2]\
    \ == 1\n@test pluck([2,3,5,0,2,4,6,0,0])[3] == 3\n@test pluck([2,3,5,0,2,4,6,0,0])[4]\
    \ == 4\n@test pluck([2,3,5,0,2,4,6,0,0])[5] == 5\n@test pluck([2,3,5,0,2,4,6,0,0])[6]\
    \ == 6\n@test pluck([2,3,5,0,2,4,6,0,0])[7] == 7\n@test pluck([2,3,5,0,2,4,6,0,0])[8]\
    \ == 8\n@test pluck([2,3,5,0,2,4,6,0,0])[9] == 9\n@test pluck([2,3,5,0,2,4,6,0,0])[10]\
    \ == 10\n@test pluck([2,3,5,0,2,4,6,0,0])[11] == 11\n@test pluck([2,3,5,0,2,4,6,0,0])[12]\
    \ == 12\n@test pluck([2,3,5,0,2,4,6,0,0])[13] == 13\n@test pluck([2,3,5,0,2,4,6,0,0])[14]\
    \ == 14\n@test pluck([2,3,5,0,2,4,6,0,0])[15] == 15\n@test pluck([2,3,5,0,2,4,6,0,0])[16]\
    \ == 16\n@test pluck([2,3,5,0,2,4,6,0,0])[17] == 17\n@test pluck([2,3,5,0,2,4,6,0,0])[18]\
    \ == 18\n@test pluck([2,3,5,0,2,4,6,0,0])[19] == 19\n@test pluck([2,3,5,0,2,4,6,0,0])[20]\
    \ == 20\n@test pluck([2,3,5,0,2,4,6,0,0])[21] == 21\n@test pluck([2,3,5,0,2,4,6,0,0])[22]\
    \ == 22\n@test pluck([2,3,5,0,2,4,6,0,0])[23] == 23\n@test pluck([2,3,5,0,2,4,6,0,0])[24]\
    \ == 24\n@test pluck([2,3,5,0,2,4,6,0,0])[25] == 25\n@test pluck([2,3,5,0,2,4,6,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnlo0sfdx.jl:37\nin expression starting at\
    \ /tmp/tmpnlo0sfdx.jl:37\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp96tibr75.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp96tibr75.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp96tibr75.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp96tibr75.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp96tibr75.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp96tibr75.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp96tibr75.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp96tibr75.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp96tibr75.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp96tibr75.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    end\n\
    \    \n    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    @time begin\n    arr = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time begin\n    arr = rand(1:10000, 10000)\n\
    \    plucked_arr = pluck(arr)\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ begin\n    arr = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nend\n</cell>\n\
    <code language=julia-1.5>\n@time begin\n    arr = rand(1:10000, 10000)\n    plucked_arr\
    \ = pluck(arr)\nend\n</cell>\n<code language=julia-1.5>\n@time begin\n    arr\
    \ = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time begin\n    arr = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time begin\n    arr = rand(1:10000, 10000)\n\
    \    plucked_arr = pluck(arr)\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ begin\n    arr = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nend\n</cell>\n\
    <code language=julia-1.5>\n@time begin\n    arr = rand(1:10000, 10000)\n    plucked_arr\
    \ = pluck(arr)\nend\n</cell>\n<code language=julia-1.5>\n@time begin\n    arr\
    \ = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time begin\n    arr = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time begin\n    arr = rand(1:10000, 10000)\n\
    \    plucked_arr = pluck(arr)\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ begin\n    arr = rand(1:10000, 10000)\n    plucked_arr = pluck(arr)\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp81v8zd_q.jl:37\nin expression starting at\
    \ /tmp/tmp81v8zd_q.jl:37\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    smallest_value = min(even_values)\n\
    \    smallest_index = even_values.index(smallest_value)\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmphr0sqg15.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmphr0sqg15.jl:37\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Array has no field filter\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmphr0sqg15.jl:27\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphr0sqg15.jl:37 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphr0sqg15.jl:36\ntest set:\
    \ Error During Test at /tmp/tmphr0sqg15.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmphr0sqg15.jl:27\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphr0sqg15.jl:38 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphr0sqg15.jl:36\ntest set:\
    \ Error During Test at /tmp/tmphr0sqg15.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  type Array has no field\
    \ filter\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n \
    \  [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphr0sqg15.jl:27\n   [3] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphr0sqg15.jl:39 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphr0sqg15.jl:36\ntest set:\
    \ Error During Test at /tmp/tmphr0sqg15.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Array has no field filter\n\
    \  Stackt"
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_index = 1\n    end\n    \n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0,\
    \ 3, 7, 4, 6, 9, 1, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc8xpv99e.jl:37\nin expression starting at\
    \ /tmp/tmpc8xpv99e.jl:37\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == length(even_values)\n        return Vector{Int64}[]\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpkdz7q0nl.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpkdz7q0nl.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkdz7q0nl.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkdz7q0nl.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkdz7q0nl.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpkdz7q0nl.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkdz7q0nl.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkdz7q0nl.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkdz7q0nl.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpkdz7q0nl.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014776
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smalest_value = Int64(0)\n    smalest_index = -1\n    \n    for node in\
    \ arr\n        if node.even\n            if smalest_value < node.value\n     \
    \           smalest_value = node.value\n                smalest_index = node\n\
    \            end\n        end\n    end\n    \n    if smalest_index == -1\n   \
    \     return []\n    else\n        return [smalest_value, smalest_index]\n   \
    \ end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19])\
    \ == [2,2]\n@assert pluck([\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzoowp769.jl:45\nin expression starting at\
    \ /tmp/tmpzoowp769.jl:45\n"
  stdout: ''
  timestamp: 1660014774
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2:end]\n        if smallest_value == node\n       \
    \     smallest_index += 1\n        elseif smallest_value == node*2\n         \
    \   smallest_index += 1\n        elseif smallest_value == node*3\n           \
    \ smallest_index += 1\n        elseif smallest_value == node*4\n            smallest_index\
    \ += 1\n        elseif smallest_value == node*5\n            smallest_index +=\
    \ 1\n        elseif smallest_value == node*6\n            smallest_index += 1\n\
    \        elseif smallest_value == node*7\n            smallest_index += 1\n  \
    \      elseif smallest_value == node*8\n            smallest_index += 1\n    \
    \    elseif smallest_value == node*9\n            smallest_index += 1\n      \
    \  elseif smallest_value == node*10\n            smallest_index += 1\n       \
    \ elseif smallest_value == node*11\n            smallest_index += 1\n        elseif\
    \ smallest_value == node*12\n            smallest_index += 1\n        elseif smallest_value\
    \ == node*13\n            smallest_index += 1\n        elseif smallest_value ==\
    \ node*14\n            smallest_index += 1\n        elseif smallest_value == node*15\n\
    \            smallest_index += 1\n        elseif smallest_value == node*16\n \
    \           smallest_index += 1\n        elseif smallest_value == node*17\n  \
    \          smallest_index += 1\n        elseif smallest_value == node*18\n   \
    \         smallest_index += 1\n        elseif smallest_value == node*19\n    \
    \        smallest_index += 1\n        elseif smallest_value == node*20\n     \
    \       smallest_index += 1\n        elseif smallest_value == node*21\n      \
    \      smallest_index += 1\n        elseif smallest_value == node*22\n       \
    \     smallest_index += 1\n        elseif smallest_value == node*23\n        \
    \    smallest_index += 1\n        elseif smallest_value == node*24\n         \
    \   smallest_index += 1\n        elseif smallest_value == node*25\n          \
    \  smallest_index += 1\n        elseif smallest_value == node*26\n           \
    \ smallest_index += 1\n        elseif smallest_value == node*27\n            smallest_index\
    \ += 1\n        elseif smallest_value == node*28\n            smallest_index +=\
    \ 1\n        elseif smallest_value == node*29\n            smallest_index += 1\n\
    \        elseif smallest_value == node*30\n            smallest_index += 1\n \
    \       elseif smallest_value == node*31\n            smallest_index += 1\n  \
    \      elseif smallest_value == node*32\n            smallest_index += 1\n   \
    \     elseif smallest_value == \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6cd9utru.jl:1\nin expression starting at /tmp/tmp6cd9utru.jl:1\n"
  stdout: ''
  timestamp: 1660014774
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_index = find(x -> x == smallest_even_value,\
    \ even_values)\n        return [smallest_even_value, smallest_index]\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your function with the examples\
    \ below:\n@assert pluck([0, 2, 3]) == [2, 1]\n@assert pluck([0, 2, -3]) == [2,\
    \ 1]\n@assert pluck([0, 2, 3]) == [2, 1]\n@assert pluck([0, 2, -3]) == [2, 1]\n\
    @assert pluck([0, 1, 2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert\
    \ pluck([0, 1, 2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0,\
    \ 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1,\
    \ -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2])\
    \ == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) ==\
    \ [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0,\
    \ 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n\
    @assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert\
    \ pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0,\
    \ 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1,\
    \ -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2])\
    \ == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) ==\
    \ [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0,\
    \ 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n\
    @assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert\
    \ pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0,\
    \ 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1,\
    \ -2]) == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2])\
    \ == [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\n@assert pluck([0, 1, -2]) ==\
    \ [0, 1]\n@assert pluck([0, 1, -2]) == [0, 1]\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_xuf4j24.jl:36\nin expression starting at\
    \ /tmp/tmp_xuf4j24.jl:36\n"
  stdout: ''
  timestamp: 1660014774
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(arr) == 0\n        return Vector{Int64}()\n \
    \   else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2,3,0,4,5]) == [2,1]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,1]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100])\
    \ == [2,1]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100])\
    \ == [2,1]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5zomeux5.jl:37\nin expression starting at\
    \ /tmp/tmp5zomeux5.jl:37\n"
  stdout: ''
  timestamp: 1660014774
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0 \n        return [] \n    end\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [2, 5, 6, 4,\
    \ 3, 7, 8, 1, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nProblem 7: Plucking Nodes\nGiven an array representing a branch of a tree\
    \ that has non-negative integer nodes\nyour task is to pluck one of the nodes\
    \ and return it.\nThe plucked node should be the node with the smallest odd value.\n\
    If multiple nodes with the same smallest odd value are found return the node that\
    \ has smallest index.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpegp4hbtl.jl:35\nin expression starting at\
    \ /tmp/tmpegp4hbtl.jl:35\n"
  stdout: ''
  timestamp: 1660014774
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    smallest_value\
    \ = arr[smallest_index]\n    return smallest_value, smallest_index\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp3usj4zgh.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp3usj4zgh.jl:38\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp3usj4zgh.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3usj4zgh.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3usj4zgh.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp3usj4zgh.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp3usj4zgh.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3usj4zgh.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3usj4zgh.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp3usj4zgh.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2 : end]\n        if node.value % 2 == 0\n        \
    \    if smallest_value < node.value\n                smallest_value = node.value\n\
    \                smallest_index = node.index\n            end\n        end\n \
    \   end\n    \n    return [smallest_value, smallest_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp12_0t537.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmp12_0t537.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp12_0t537.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp12_0t537.jl:47 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp12_0t537.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp12_0t537.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp12_0t537.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp12_0t537.jl:48 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp12_0t537.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp12_0t537.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp12_0t537.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp12_0t537.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp12_0t537.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp12_0t537.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    evens = evens[evens[1] .. end]\n    evens = evens[2:end]\n\
    \    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens\
    \ = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1]\
    \ .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n\
    \    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens\
    \ = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1]\
    \ .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n\
    \    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens\
    \ = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1]\
    \ .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n\
    \    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens\
    \ = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1]\
    \ .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n\
    \    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens\
    \ = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1]\
    \ .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n\
    \    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens\
    \ = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1]\
    \ .. end]\n    evens = evens[evens[1] .. end]\n    evens = evens[evens[1] .. end]\n\
    \    evens = even\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4qc6ymzp.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4qc6ymzp.jl:1\n\
    in expression starting at /tmp/tmp4qc6ymzp.jl:1\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkuy_xaix.jl:38\nin expression starting at\
    \ /tmp/tmpkuy_xaix.jl:38\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_even_value::Int64\
    \ = smallest_value % 2\n    \n    for node in arr[2 : end]\n        if smallest_value\
    \ % 2 == 0 && node % 2 == 0\n            smallest_value = node\n            smallest_index\
    \ = smallest_index + 1\n        elseif smallest_value % 2 == 0 && node % 2 !=\
    \ 0\n            smallest_value = node\n            smallest_index = smallest_index\
    \ + 1\n        elseif smallest_value % 2 != 0 && node % 2 == 0\n            smallest_value\
    \ = node\n            smallest_index = smallest_index + 1\n        elseif smallest_value\
    \ % 2 != 0 && node % 2 != 0\n            smallest_value = node\n            smallest_index\
    \ = smallest_index + 1\n        end\n    end\n    \n    if smallest_value == 0\n\
    \        return []\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpcjlwflm0.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmpcjlwflm0.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [3, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcjlwflm0.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcjlwflm0.jl:57\ntest set: Test Failed at /tmp/tmpcjlwflm0.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [3, 3] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcjlwflm0.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcjlwflm0.jl:57\ntest set: Error\
    \ During Test at /tmp/tmpcjlwflm0.jl:60\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpcjlwflm0.jl:27\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpcjlwflm0.jl:60 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpcjlwflm0.jl:57\ntest set:\
    \ Test Failed at /tmp/tmpcjlwflm0.jl:61\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcjlwflm0.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcjlwflm0.jl:57\ntest s"
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2,0,4,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,90,0,92,0,94,0,96,0,98,0,100,0,102,0,104,0,106,0,108,0,110,0,112,0,114,0,116,0,118,0,120,0,122,0,124,0,126,0,128,0,130,0,132,0,134,0,136,0,138,0,140,0,142,0,144,0,146,0,148,0,150,0,152,0,154,0,156,0,158,0,160,0,162,0,164,0,166,0,168,0,170,0,172,0,174,0,176,0,178,0,180,0,182,0,184,0,186,0,188,0,190,0,192,0,194,0,196,0,198,0,200,0,202,0,204,0,206,0,208,0,210,0,212,0,214,0,216,0,218,0,220,0,222,0,224,0,226,0,228,0,230,0,232,0,234,0,236,0,238,0,240,0,242,0,244,0,246,0,248,0,250,0,252,0,254,0,256,0,258,0,260,0,262,0,264,0,266,0,268,0,270,0,272,0,274,0,276,0,278,0,280,0,282,0,284,0,286,0,288,0,290,0,292,0,294,0,296,0,298,0,300,0,302,0,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9__tzy9t.jl:37\nin expression starting at\
    \ /tmp/tmp9__tzy9t.jl:37\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return smallest_value,\
    \ smallest_index\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Error During Test at /tmp/tmpjawkdpuy.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjawkdpuy.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjawkdpuy.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjawkdpuy.jl:42\ntest set:\
    \ Test Failed at /tmp/tmpjawkdpuy.jl:44\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\n   Evaluated: [2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjawkdpuy.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpjawkdpuy.jl:42\ntest set: Error During Test\
    \ at /tmp/tmpjawkdpuy.jl:46\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjawkdpuy.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/j"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    smallest_value\
    \ = arr[smallest_index]\n    return smallest_value, smallest_index\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp3usj4zgh.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp3usj4zgh.jl:38\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp3usj4zgh.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3usj4zgh.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3usj4zgh.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp3usj4zgh.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp3usj4zgh.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3usj4zgh.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3usj4zgh.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp3usj4zgh.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0,\
    \ 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,\
    \ 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppw1ivafn.jl:36\nin expression starting at\
    \ /tmp/tmppw1ivafn.jl:36\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpfoggobpu.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpfoggobpu.jl:37\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if even_values == []\n\
    \        return [] \n    smallest_value = min(even_values)\n    smallest_index\
    \ = even_values.index(smallest_value)\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,3,0,1]) == [2,1]\n@assert\
    \ pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1])\
    \ == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n\
    @assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert\
    \ pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1])\
    \ == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n\
    @assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert\
    \ pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1])\
    \ == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n\
    @assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert\
    \ pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1])\
    \ == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n\
    @assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert\
    \ pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1])\
    \ == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n@assert pluck([2,3,0,1]) == [2,1]\n\
    @assert pluck([2,3,0,1]\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg1lr6iei.jl:34\nin expression starting at\
    \ /tmp/tmpg1lr6iei.jl:34\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpfoggobpu.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpfoggobpu.jl:37\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfoggobpu.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfoggobpu.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfoggobpu.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpfoggobpu.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(x -> x == smallest_value, even_values)\n    if smallest_index == length(even_values)\n\
    \        return smallest_value\n    else\n        return smallest_value, smallest_index\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,2,0]) ==\
    \ [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2,\
    \ 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n\
    @assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert\
    \ pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0])\
    \ == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2,\
    \ 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n\
    @assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert\
    \ pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0])\
    \ == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2,\
    \ 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n\
    @assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert\
    \ pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0])\
    \ == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2,\
    \ 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n\
    @assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert\
    \ pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0])\
    \ == [2, 0]\n@assert pluck([2,0,2,0]) == [2, 0]\n@assert pluck([2,0,2,0]) == \n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe4kqmgld.jl:38\nin expression starting at\
    \ /tmp/tmpe4kqmgld.jl:38\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = min(arr)\n        smallest_index = find(arr\
    \ == smallest_value)[1]\n    end\n    \n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your solution \narr = [1, 2, 3,\
    \ 0, 0, 0]\npluck(arr)\n</cell>\n<text>\n4.2 Plucking All Nodes\nGiven an array\
    \ representing a branch of a tree that has non-negative integer nodes\nyour task\
    \ is to pluck all of the nodes and return them in a list.\nThe plucked nodes should\
    \ be returned in a list, [ smalest_value, its index ],\nIf there are no even values\
    \ or the given array is empty, return [].\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpip5t6198.jl:38\nin expression starting at\
    \ /tmp/tmpip5t6198.jl:38\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x->x%2==0)\n    smallest_value = min(even_values)\n\
    \    smallest_index = even_values.index(smallest_value)\n    \n    if smallest_index==0\n\
    \        return smallest_value\n    else\n        return smallest_value, smallest_index\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplez82cdm.jl:37\nin expression starting at\
    \ /tmp/tmplez82cdm.jl:37\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    if length(evens) == 0\n        return Vector{Int64}()\n\
    \    else\n        return evens\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqxlfhc0h.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpqxlfhc0h.jl:41\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqxlfhc0h.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqxlfhc0h.jl:40\ntest set: Test Failed at /tmp/tmpqxlfhc0h.jl:42\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxlfhc0h.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxlfhc0h.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqxlfhc0h.jl:44\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2, 4] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqxlfhc0h.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqxlfhc0h.jl:40\ntest set: Test Failed at /tmp/tmpqxlfhc0h.jl:45\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [2] == [0,\
    \ 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxlfhc0h.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxlfhc0h.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqxlfhc0h.jl:46\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 8, 8] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014777
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return [] \n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp1ddpjpl5.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp1ddpjpl5.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ddpjpl5.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ddpjpl5.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ddpjpl5.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp1ddpjpl5.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ddpjpl5.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ddpjpl5.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ddpjpl5.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp1ddpjpl5.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplj19ha3l.jl:38\nin expression starting at\
    \ /tmp/tmplj19ha3l.jl:38\n"
  stdout: ''
  timestamp: 1660014775
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64\
    \ = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int64 = 0\n    smallest_index::Int\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpel_ee06r.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpel_ee06r.jl:1\n\
    in expression starting at /tmp/tmpel_ee06r.jl:1\n"
  stdout: ''
  timestamp: 1660014776
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_even_value, even_values)\n    return\
    \ Vector{Int64}([smallest_even_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\
    \ 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,\
    \ 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\
    \ 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,\
    \ 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\
    \ 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,\
    \ 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144,\
    \ 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,\
    \ 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,\
    \ 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192,\
    \ 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,\
    \ 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,\
    \ 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,\
    \ 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 25\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ikwingv.jl:35\nin expression starting at\
    \ /tmp/tmp6ikwingv.jl:35\n"
  stdout: ''
  timestamp: 1660014776
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    evens = evens[evens[1] == evens[1]]\n    if length(evens)\
    \ == 0\n        return []\n    else\n        return evens\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n# Solution\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbbt7h5yw.jl:37\nin expression starting at\
    \ /tmp/tmpbbt7h5yw.jl:37\n"
  stdout: ''
  timestamp: 1660014776
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values_index = findfirst(x->mod(x,2)==0,\
    \ arr)\n    if length(even_values) == 0\n        return [] \n    elseif length(even_values)\
    \ == 1\n        return even_values\n    elseif even_values_index == -1\n     \
    \   return even_values\n    else\n        return even_values[even_values_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp11rwxxlh.jl:39\nin expression starting at\
    \ /tmp/tmp11rwxxlh.jl:39\n"
  stdout: ''
  timestamp: 1660014776
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smalest_value::Int64 = Inf \n    smallest_index::Int64 = Inf \n    \n\
    \    for i in arr \n        if i%2 == 0 \n            if smalest_value < i \n\
    \                smalest_value = i \n                smallest_index = i \n   \
    \         end \n        else \n            if smalest_value < i \n           \
    \     smallest_index = i \n            end \n        end \n    end \n    \n  \
    \  if smalest_value == Inf \n        return [] \n    else \n        return [smalest_value,\
    \ smallest_index] \n    end \nend \nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp8xtw7s8h.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmp8xtw7s8h.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] convert(#unused#::Type{Int64},\
    \ x::Float64)\n     @ Base ./number.jl:7\n   [3] pluck(arr::Vector{Int64})\n \
    \    @ Main /tmp/tmp8xtw7s8h.jl:27\n   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp8xtw7s8h.jl:54 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp8xtw7s8h.jl:53\ntest set:\
    \ Error During Test at /tmp/tmp8xtw7s8h.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] convert(#unused#::Type{Int64},\
    \ x::Float64)\n     @ Base ./number.jl:7\n   [3] pluck(arr::Vector{Int64})\n \
    \    @ Main /tmp/tmp8xtw7s8h.jl:27\n   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp8xtw7s8h.jl:55 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp8xtw7s8h.jl:53\ntest set:\
    \ Error During Test at /tmp/tmp8xtw7s8h.jl:56\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  InexactError: Int64(Inf)\n\
    \  Stacktrace:\n   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] convert(#unused#::Type{Int64},\
    \ x::Float64)\n     @ Base ./number.jl:7\n   [3] pluck(arr::Vector{Int64})\n \
    \    @ Main /tmp/tmp8xtw7s8h.jl:27\n   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp8xtw7s8h.jl:56 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n    "
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    if isempty(even_values)\n        return\
    \ Vector{Int64}()\n    else\n        return even_values\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpncmbujfu.jl:36\nin expression starting at\
    \ /tmp/tmpncmbujfu.jl:36\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return smallest_value,\
    \ smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,\
    \ 0]) == [2, 0]\n@assert pluck([2, 1]) == [2]\n@assert pluck([2, 2]) == [2]\n\
    @assert pluck([2, 3]) == [2]\n@assert pluck([2, 4]) == [2]\n@assert pluck([2,\
    \ 5]) == [2]\n@assert pluck([2, 6]) == [2]\n@assert pluck([2, 7]) == [2]\n@assert\
    \ pluck([2, 8]) == [2]\n@assert pluck([2, 9]) == [2]\n@assert pluck([2, 10]) ==\
    \ [2]\n@assert pluck([2, 11]) == [2]\n@assert pluck([2, 12]) == [2]\n@assert pluck([2,\
    \ 13]) == [2]\n@assert pluck([2, 14]) == [2]\n@assert pluck([2, 15]) == [2]\n\
    @assert pluck([2, 16]) == [2]\n@assert pluck([2, 17]) == [2]\n@assert pluck([2,\
    \ 18]) == [2]\n@assert pluck([2, 19]) == [2]\n@assert pluck([2, 20]) == [2]\n\
    @assert pluck([2, 21]) == [2]\n@assert pluck([2, 22]) == [2]\n@assert pluck([2,\
    \ 23]) == [2]\n@assert pluck([2, 24]) == [2]\n@assert pluck([2, 25]) == [2]\n\
    @assert pluck([2, 26]) == [2]\n@assert pluck([2, 27]) == [2]\n@assert pluck([2,\
    \ 28]) == [2]\n@assert pluck([2, 29]) == [2]\n@assert pluck([2, 30]) == [2]\n\
    @assert pluck([2, 31]) == [2]\n@assert pluck([2, 32]) == [2]\n@assert pluck([2,\
    \ 33]) == [2]\n@assert pluck([2, 34]) == [2]\n@assert pluck([2, 35]) == [2]\n\
    @assert pluck([2, 36]) == [2]\n@assert pluck([2, 37]) == [2]\n@assert pluck([2,\
    \ 38]) == [2]\n@assert pluck([2, 39]) == [2]\n@assert pluck([2, 40]) == [2]\n\
    @assert pluck([2, 41]) == [2]\n@assert pluck([2, 42]) == [2]\n@assert pluck([2,\
    \ 43]\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6sn72boe.jl:38\nin expression starting at\
    \ /tmp/tmp6sn72boe.jl:38\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [ smallest_value, smallest_index ]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmphe_rox0x.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmphe_rox0x.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphe_rox0x.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphe_rox0x.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphe_rox0x.jl:41\ntest set:\
    \ Error During Test at /tmp/tmphe_rox0x.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphe_rox0x.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphe_rox0x.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphe_rox0x.jl:41\ntest set:\
    \ Error During Test at /tmp/tmphe_rox0x.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2:end]\n        if node.value % 2 == 0\n          \
    \  if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_index = smallest_index + 1\n            end\n      \
    \  end\n    end\n    \n    return smallest_value, smallest_index\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpz3zlp1hc.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmpz3zlp1hc.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpz3zlp1hc.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpz3zlp1hc.jl:47 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpz3zlp1hc.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpz3zlp1hc.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpz3zlp1hc.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpz3zlp1hc.jl:48 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpz3zlp1hc.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpz3zlp1hc.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpz3zlp1hc.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpz3zlp1hc.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpz3zlp1hc.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpz3zlp1hc.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp1ccghza1.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp1ccghza1.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ccghza1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ccghza1.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ccghza1.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp1ccghza1.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ccghza1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ccghza1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ccghza1.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp1ccghza1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2:end]\n        if node.value % 2 == 0\n          \
    \  if smallest_value < node.value\n                smallest_value = node.value\n\
    \                smallest_index = node.index\n            end\n        end\n \
    \   end\n    \n    return [smallest_value, smallest_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpvx7q_ghx.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmpvx7q_ghx.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpvx7q_ghx.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpvx7q_ghx.jl:47 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpvx7q_ghx.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpvx7q_ghx.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpvx7q_ghx.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpvx7q_ghx.jl:48 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpvx7q_ghx.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpvx7q_ghx.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpvx7q_ghx.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpvx7q_ghx.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpvx7q_ghx.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpvx7q_ghx.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp1ccghza1.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp1ccghza1.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ccghza1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ccghza1.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ccghza1.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp1ccghza1.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ccghza1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ccghza1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ccghza1.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp1ccghza1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_value_index::Int64\
    \ = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 =\
    \ 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n\
    \    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n  \
    \  smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64\
    \ = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 =\
    \ 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n\
    \    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n  \
    \  smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64\
    \ = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 =\
    \ 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n\
    \    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n  \
    \  smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64\
    \ = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 =\
    \ 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n\
    \    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n  \
    \  smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64\
    \ = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 =\
    \ 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n\
    \    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n  \
    \  smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64\
    \ = 1\n    smallest_value_index::Int64 = 1\n    smallest_value_index::Int64 =\
    \ 1\n    smallest_value_index::Int64 = 1\n    smalle\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqzh5gza8.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqzh5gza8.jl:1\n\
    in expression starting at /tmp/tmpqzh5gza8.jl:1\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 7, 4, 3, 6, 8, 1, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<text>\nProblem 4\nGiven a binary tree and a node value, swap the node\
    \ value with the node that results from traveling down the tree starting from\
    \ the given node. Return the new tree.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_yvxd2lt.jl:43\nin expression starting at\
    \ /tmp/tmp_yvxd2lt.jl:43\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return smallest_value, smallest_index\n    end\nend\n</cell>\n<text>\nLet's\
    \ test your implementation\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo3go09lz.jl:38\nin expression starting at\
    \ /tmp/tmpo3go09lz.jl:38\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_oi_ras9.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_oi_ras9.jl:1\n\
    in expression starting at /tmp/tmp_oi_ras9.jl:1\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [] \n    end\n    smallest_value = min(even_values)\n    smallest_index\
    \ = findfirst(x->x==smallest_value, even_values)\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,4\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo5tbrvc2.jl:35\nin expression starting at\
    \ /tmp/tmpo5tbrvc2.jl:35\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpl1vdkmw8.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmpl1vdkmw8.jl:40\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpl1vdkmw8.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpl1vdkmw8.jl:39\ntest set: Test Failed at /tmp/tmpl1vdkmw8.jl:44\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl1vdkmw8.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl1vdkmw8.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,24\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdg9qny8g.jl:35\nin expression starting at\
    \ /tmp/tmpdg9qny8g.jl:35\n"
  stdout: ''
  timestamp: 1660014777
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2:end]\n        if node.value % 2 == 0\n          \
    \  smallest_value = node.value\n            smallest_index = smallest_index +\
    \ 1\n        end\n    end\n    \n    if smallest_index > 1\n        smallest_value\
    \ = arr[smallest_index].value\n    end\n    \n    return smallest_value, smallest_index\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [2, 2, 1, 0, 2, 2]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz724trm2.jl:44\nin expression starting at\
    \ /tmp/tmpz724trm2.jl:44\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == length(even_values)\n        return Vector{Int64}[]\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert pluck([2,3,5,7,11,13,17,19,23,29])\
    \ == [2,3]\n@assert pluck([2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97])\
    \ == [2,3]\n@assert pluck([2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997])\
    \ == [2,3]\n@\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd4y22s6v.jl:36\nin expression starting at\
    \ /tmp/tmpd4y22s6v.jl:36\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smalest_value::Int64 = arr[1]\n    smalest_index::Int64 = 1\n    \n  \
    \  for node in arr[2 : end]\n        if node.value % 2 == 0\n            if node.value\
    \ < smalest_value\n                smalest_value = node.value\n              \
    \  smalest_index = node.index\n            end\n        end\n    end\n    \n \
    \   return [ smalest_value, smalest_index ]\nend\n</cell>\n<text>\nLet's test\
    \ your implementation by running the cell below.\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp04h8top7.jl:41\nin expression starting at\
    \ /tmp/tmp04h8top7.jl:41\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = arr.filter(x -> x % 2 == 0)\n    if evens.size == 0\n        return\
    \ [] \n    smalest_value = evens[minimum(evens)]\n    smalest_index = minimum(evens.indices)\n\
    \    return [smalest_value, smalest_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpppz9tmk7.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpppz9tmk7.jl:1\n\
    in expression starting at /tmp/tmpppz9tmk7.jl:1\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,\
    \ 5, 8, 1, 4, 6, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 1, 4, 6, 3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2,\
    \ 5, 8, 1, 4, 6, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 1, 4, 6, 3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 1, 4, 6, 3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwj31v521.jl:43\nin expression starting at\
    \ /tmp/tmpwj31v521.jl:43\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6jhrg8ef.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6jhrg8ef.jl:1\n\
    in expression starting at /tmp/tmp6jhrg8ef.jl:1\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64\
    \ = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int64 = 1\n    smallest_index::Int\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp07fg5ud0.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp07fg5ud0.jl:1\n\
    in expression starting at /tmp/tmp07fg5ud0.jl:1\n"
  stdout: ''
  timestamp: 1660014768
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8tsn1bec.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8tsn1bec.jl:1\n\
    in expression starting at /tmp/tmp8tsn1bec.jl:1\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6jhrg8ef.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6jhrg8ef.jl:1\n\
    in expression starting at /tmp/tmp6jhrg8ef.jl:1\n"
  stdout: ''
  timestamp: 1660014773
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw1bfgets.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw1bfgets.jl:1\n\
    in expression starting at /tmp/tmpw1bfgets.jl:1\n"
  stdout: ''
  timestamp: 1660014766
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0 \n        return [] \n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 8, 0, 3, 6]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nWrite a function that takes an array and returns the number\
    \ of nodes in the tree.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxclaor20.jl:35\nin expression starting at\
    \ /tmp/tmpxclaor20.jl:35\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    evens = evens[findall(x -> x == 0, evens)]\n    if length(evens)\
    \ == 0\n        return Vector{Int64}()\n    else\n        return evens\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert pluck([2, 0, 0, 2, 0]) == [2,\
    \ 0]\n@assert pluck([2, 0, 0, 2, 1]) == [2, 1]\n@assert pluck([2, 0, 0, 2, 2])\
    \ == [2, 2]\n@assert pluck([2, 0, 0, 2, 3]) == [2, 3]\n@assert pluck([2, 0, 0,\
    \ 2, 4]) == [2, 4]\n@assert pluck([2, 0, 0, 2, 5]) == [2, 5]\n@assert pluck([2,\
    \ 0, 0, 2, 6]) == [2, 6]\n@assert pluck([2, 0, 0, 2, 7]) == [2, 7]\n@assert pluck([2,\
    \ 0, 0, 2, 8]) == [2, 8]\n@assert pluck([2, 0, 0, 2, 9]) == [2, 9]\n@assert pluck([2,\
    \ 0, 0, 2, 10]) == [2, 10]\n@assert pluck([2, 0, 0, 2, 11]) == [2, 11]\n@assert\
    \ pluck([2, 0, 0, 2, 12]) == [2, 12]\n@assert pluck([2, 0, 0, 2, 13]) == [2, 13]\n\
    @assert pluck([2, 0, 0, 2, 14]) == [2, 14]\n@assert pluck([2, 0, 0, 2, 15]) ==\
    \ [2, 15]\n@assert pluck([2, 0, 0, 2, 16]) == [2, 16]\n@assert pluck([2, 0, 0,\
    \ 2, 17]) == [2, 17]\n@assert pluck([2, 0, 0, 2, 18]) == [2, 18]\n@assert pluck([2,\
    \ 0, 0, 2, 19]) == [2, 19]\n@assert pluck([2, 0, 0, 2, 20]) == [2, 20]\n@assert\
    \ pluck([2, 0, 0, 2, 21]) == [2, 21]\n@assert pluck([2, 0, 0, 2, 22]) == [2, 22]\n\
    @assert pluck([2, 0, 0, 2, 23]) == [2, 23]\n@assert pluck([2, 0, 0, 2, 24]) ==\
    \ [2, 24]\n@assert pluck([2, 0, 0, 2, 25]) == [2, 25]\n@assert pluck([2, 0, 0,\
    \ 2, 26]) == [2, 26]\n@assert pluck([2, 0, 0, 2, 27]) == [2, 27]\n@assert pluck([2,\
    \ 0, 0, 2, 28]) == [2, 28]\n@assert pluck([2, 0, 0, 2, 29]) == [2, 29]\n@assert\
    \ pluck([2, 0, 0, 2, 30]) == [2, 30]\n@assert pluck([2, 0, 0, 2, 31]) == [2, 31]\n\
    @assert pluck([2, 0, 0, 2, 32]) == [2, 32\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgzfmey8s.jl:37\nin expression starting at\
    \ /tmp/tmpgzfmey8s.jl:37\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy4dpfrop.jl:36\nin expression starting at\
    \ /tmp/tmpy4dpfrop.jl:36\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [ smallest_value, smallest_index ]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmphe_rox0x.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmphe_rox0x.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphe_rox0x.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphe_rox0x.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphe_rox0x.jl:41\ntest set:\
    \ Error During Test at /tmp/tmphe_rox0x.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphe_rox0x.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphe_rox0x.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphe_rox0x.jl:41\ntest set:\
    \ Error During Test at /tmp/tmphe_rox0x.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm15yhx53.jl:36\nin expression starting at\
    \ /tmp/tmpm15yhx53.jl:36\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    return smallest_value, smallest_even_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp8bh7lz9d.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp8bh7lz9d.jl:38\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8bh7lz9d.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8bh7lz9d.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8bh7lz9d.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp8bh7lz9d.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8bh7lz9d.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8bh7lz9d.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8bh7lz9d.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp8bh7lz9d.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014782
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp61wmra1b.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp61wmra1b.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61wmra1b.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61wmra1b.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61wmra1b.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp61wmra1b.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61wmra1b.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61wmra1b.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61wmra1b.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp61wmra1b.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014769
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmpm2g75_0j.jl:38\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpm2g75_0j.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm2g75_0j.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpm2g75_0j.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpm2g75_0j.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpm2g75_0j.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm2g75_0j.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpm2g75_0j.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpm2g75_0j.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014770
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    if isempty(even_values)\n\
    \        return [];\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_even_value, even_values)\n\
    \        return [smallest_even_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,4]\n\
    @assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30]) == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260])\
    \ == [2,4]\n@assert pluck([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqle1uvdj.jl:36\nin expression starting at\
    \ /tmp/tmpqle1uvdj.jl:36\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ == [2,4,6,8,10,12,14,16,18,20]\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_6q4jib9.jl:37\nin expression starting at\
    \ /tmp/tmp_6q4jib9.jl:37\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiqfbm6hf.jl:35\nin expression starting at\
    \ /tmp/tmpiqfbm6hf.jl:35\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    evens = evens[minimum(evens)]\n    return evens\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert pluck([2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,25\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpztvs8qt0.jl:33\nin expression starting at\
    \ /tmp/tmpztvs8qt0.jl:33\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0,arr)\n    if length(even_values) ==\
    \ 0\n        return [] \n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values==smallest_value)[1]\n        return\
    \ [smallest_value,smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,4,5,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,90,0,92,0,94,0,96,0,98,0,100,0,102,0,104,0,106,0,108,0,110,0,112,0,114,0,116,0,118,0,120,0,122,0,124,0,126,0,128,0,130,0,132,0,134,0,136,0,138,0,140,0,142,0,144,0,146,0,148,0,150,0,152,0,154,0,156,0,158,0,160,0,162,0,164,0,166,0,168,0,170,0,172,0,174,0,176,0,178,0,180,0,182,0,184,0,186,0,188,0,190,0,192,0,194,0,196,0,198,0,200,0,202,0,204,0,206,0,208,0,210,0,212,0,214,0,216,0,218,0,220,0,222,0,224,0,226,0,228,0,230,0,232,0,234,0,236,0,238,0,240,0,242,0,244,0,246,0,248,0,250,0,252,0,254,0,256,0,258,0,260,0,262,0,264,0,266,0,268,0,270,0,272,0,274,0,276,0,278,0,280,0,282,0,284,0,286,0,288,0,290,0,292,0,294,0,296,0,298,0,300,0,302,0,304,0,306,0,308,0,310,0,312,0,314,0,316,0,318,0,320\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbdzc49_g.jl:36\nin expression starting at\
    \ /tmp/tmpbdzc49_g.jl:36\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    evens = sort(evens)\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[2:end]\n    evens = evens[2:end]\n    evens\
    \ = evens[2:end]\n    evens = evens[\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzzemapeq.jl:1\nin expression starting at /tmp/tmpzzemapeq.jl:1\n"
  stdout: ''
  timestamp: 1660014779
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2, 5, 8, 0, 3, 6, 9, 1, 4, 7]\n</cell>\n\
    <code language=julia-1.5>\npluck\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqfyenz49.jl:36\nin expression starting at\
    \ /tmp/tmpqfyenz49.jl:36\n"
  stdout: ''
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,\
    \ 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,\
    \ 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,\
    \ 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 0, 0, 4, 5]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1d5x3sy5.jl:36\nin expression starting at\
    \ /tmp/tmp1d5x3sy5.jl:36\n"
  stdout: ''
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 5, 3, 7, 8, 4, 6, 9, 1, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nProblem 3\nGiven a binary\
    \ tree, return the level order traversal of its nodes' values. (i.e., the in-order\
    \ traversal of its nodes' values.)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpywg_ggm7.jl:37\nin expression starting at\
    \ /tmp/tmpywg_ggm7.jl:37\n"
  stdout: ''
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2, 0]) == [2, 0]\n@assert pluck([2,\
    \ 1]) == [2, 1]\n@assert pluck([2, 3]) == [2, 3]\n@assert pluck([2, 4]) == [2,\
    \ 4]\n@assert pluck([2, 5]) == [2, 5]\n@assert pluck([2, 6]) == [2, 6]\n@assert\
    \ pluck([2, 7]) == [2, 7]\n@assert pluck([2, 8]) == [2, 8]\n@assert pluck([2,\
    \ 9]) == [2, 9]\n@assert pluck([2, 10]) == [2, 10]\n@assert pluck([2, 11]) ==\
    \ [2, 11]\n@assert pluck([2, 12]) == [2, 12]\n@assert pluck([2, 13]) == [2, 13]\n\
    @assert pluck([2, 14]) == [2, 14]\n@assert pluck([2, 15]) == [2, 15]\n@assert\
    \ pluck([2, 16]) == [2, 16]\n@assert pluck([2, 17]) == [2, 17]\n@assert pluck([2,\
    \ 18]) == [2, 18]\n@assert pluck([2, 19]) == [2, 19]\n@assert pluck([2, 20]) ==\
    \ [2, 20]\n@assert pluck([2, 21]) == [2, 21]\n@assert pluck([2, 22]) == [2, 22]\n\
    @assert pluck([2, 23]) == [2, 23]\n@assert pluck([2, 24]) == [2, 24]\n@assert\
    \ pluck([2, 25]) == [2, 25]\n@assert pluck([2, 26]) == [2, 26]\n@assert pluck([2,\
    \ 27]) == [2, 27]\n@assert pluck([2, 28]) == [2, 28]\n@assert pluck([2, 29]) ==\
    \ [2, 29]\n@assert pluck([2, 30]) == [2, 30]\n@assert pluck([2, 31]) == [2, 31]\n\
    @assert pluck([2, 32]) == [2, 32]\n@assert pluck([2, 33]) == [2, 33]\n@assert\
    \ pluck([2, 34]) == [2, 34]\n@assert pluck([2, 35]) == [2, 35]\n@assert pluck([2,\
    \ 36]) == [2, 36]\n@assert pluck([2, 37]) == [2, 37]\n@assert pluck([\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpketuqxmf.jl:37\nin expression starting at\
    \ /tmp/tmpketuqxmf.jl:37\n"
  stdout: ''
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,4,2,0,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9ihprx81.jl:38\nin expression starting at\
    \ /tmp/tmp9ihprx81.jl:38\n"
  stdout: ''
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert pluck([2,0,4,3]) == [2,1]\n@assert pluck([2,0,4,3,0])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5]) == [2,1]\n@assert pluck([2,0,4,3,0,5,0])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5]) == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5]) == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5]) == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5]) == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0,5]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0,5]) == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0,5,0])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0,5,0,5]) == [2,1]\n@assert\
    \ pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0]) == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5])\
    \ == [2,1]\n@assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0]) == [2,1]\n\
    @assert pluck([2,0,4,3,0,5,0,5,0,5,0,5,0,5,\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmx5vj6_h.jl:36\nin expression starting at\
    \ /tmp/tmpmx5vj6_h.jl:36\n"
  stdout: ''
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,3,0,4,0,5,6,0,7,8,0,9,10,0,11,12,0,13,14,0,15,16,0,17,18,0,19,20,0,21,22,0,23,24,0,25,26,0,27,28,0,29,30,0,31,32,0,33,34,0,35,36,0,37,38,0,39,40,0,41,42,0,43,44,0,45,46,0,47,48,0,49,50,0,51,52,0,53,54,0,55,56,0,57,58,0,59,60,0,61,62,0,63,64,0,65,66,0,67,68,0,69,70,0,71,72,0,73,74,0,75,76,0,77,78,0,79,80,0,81,82,0,83,84,0,85,86,0,87,88,0,89,90,0,91,92,0,93,94,0,95,96,0,97,98,0,99,100,0,101,102,0,103,104,0,105,106,0,107,108,0,109,110,0,111,112,0,113,114,0,115,116,0,117,118,0,119,120,0,121,122,0,123,124,0,125,126,0,127,128,0,129,130,0,131,132,0,133,134,0,135,136,0,137,138,0,139,140,0,141,142,0,143,144,0,145,146,0,147,148,0,149,150,0,151,152,0,153,154,0,155,156,0,157,158,0,159,160,0,161,162,0,163,164,0,165,166,0,167,168,0,169,170,0,171,172,0,173,174,0,175,176,0,177,178,0,179,180,0,181,182,0,183,184,0,185,186,0,187,188,0,189,190,0,191,192,0,193,194,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyuuabbfa.jl:37\nin expression starting at\
    \ /tmp/tmpyuuabbfa.jl:37\n"
  stdout: ''
  timestamp: 1660014780
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp35zckj08.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp35zckj08.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp35zckj08.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp35zckj08.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp35zckj08.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp35zckj08.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp35zckj08.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp35zckj08.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp35zckj08.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp35zckj08.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching min(::Vecto"
  timestamp: 1660014783
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_value = Int64(0)\n    smallest_index = Int64(0)\n    smallest_value\
    \ = arr[1]\n    smallest_index = Int64(1)\n    for node in arr[2:end]\n      \
    \  if node.value % 2 == 0\n            if node.value < smallest_value\n      \
    \          smallest_value = node.value\n                smallest_index = node.index\n\
    \            else\n                if node.value < smallest_value\n          \
    \          smallest_value = node.value\n                    smallest_index = node.index\n\
    \                end\n            end\n        end\n    end\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpve1op8aa.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpve1op8aa.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpve1op8aa.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpve1op8aa.jl:51 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpve1op8aa.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpve1op8aa.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpve1op8aa.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpve1op8aa.jl:52 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpve1op8aa.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpve1op8aa.jl:53\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpve1op8aa.jl:29\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpve1op8aa.jl:53 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpve1op8aa.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpve1op8aa.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014783
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvxxzmyxh.jl:38\nin expression starting at\
    \ /tmp/tmpvxxzmyxh.jl:38\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for index in 2:length(arr)\n        if arr[index] % 2 == 0 && arr[index]\
    \ < smallest_value\n            smallest_value = arr[index]\n            smallest_index\
    \ = index\n        end\n    end\n    \n    if smallest_value == 0\n        smallest_index\n\
    \    else\n        [smallest_value, smallest_index]\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: Timeout
  stderr: ''
  stdout: "test set: Test Failed at /tmp/tmpkhadx_rb.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkhadx_rb.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkhadx_rb.jl:48\ntest set: Test Failed at /tmp/tmpkhadx_rb.jl:50\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkhadx_rb.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkhadx_rb.jl:48\ntest set: Error\
    \ During Test at /tmp/tmpkhadx_rb.jl:51\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpkhadx_rb.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkhadx_rb.jl:51 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkhadx_rb.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpkhadx_rb.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: Cannot `convert` an\
    \ object of type Int64 to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray)"
  timestamp: 1660014784
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0])\
    \ == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n\
    @assert pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == [2,0]\n@assert\
    \ pluck([2,0,2,0]) == [2,0]\n@assert pluck([2,0,2,0]) == \nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl69h_243.jl:37\nin expression starting at\
    \ /tmp/tmpl69h_243.jl:37\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2 : end]\n        if node.value % 2 == 0\n        \
    \    if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_index = node.index\n            end\n        end\n \
    \   end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [2, 1, 2, 0, 2, 1]\n</\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr277nma6.jl:42\nin expression starting at\
    \ /tmp/tmpr277nma6.jl:42\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [\
    \ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpykbu1k49.jl:36\nin expression starting at\
    \ /tmp/tmpykbu1k49.jl:36\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if length(evens) == 0\n    \
    \    return Vector{Int64}[]\n    end\n    evens = sort(evens)\n    smalest_value\
    \ = evens[1]\n    smalest_index = find(x -> x == smalest_value, evens)[1]\n  \
    \  smalest_value = smalest_value\n    smalest_index = smalest_index\n    return\
    \ smalest_value, smalest_index\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmppr8p589b.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmppr8p589b.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmppr8p589b.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppr8p589b.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppr8p589b.jl:42\ntest set:\
    \ Error During Test at /tmp/tmppr8p589b.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: find not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmppr8p589b.jl:33\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppr8p589b.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppr8p589b.jl:42\ntest set:\
    \ Error During Test at /tmp/tmppr8p589b.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmppr8p589b.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppr8p589b.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppr8p589b.jl:42\ntest set:\
    \ Error During Test at /tmp/tmppr8p589b.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmppr8p589b.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1660014782
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for node in arr[2:end]\n        if node.value % 2 == 0\n          \
    \  if node.value < smallest_value\n                smallest_value = node.value\n\
    \                smallest_index = node.index\n            end\n        end\n \
    \   end\n    \n    return [smallest_value, smallest_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpnm8p5bfg.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmpnm8p5bfg.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field value\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpnm8p5bfg.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpnm8p5bfg.jl:47 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpnm8p5bfg.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpnm8p5bfg.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field value\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpnm8p5bfg.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpnm8p5bfg.jl:48 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpnm8p5bfg.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpnm8p5bfg.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpnm8p5bfg.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpnm8p5bfg.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpnm8p5bfg.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpnm8p5bfg.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type "
  timestamp: 1660014782
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value =\
    \ min(even_values)\n    smallest_index = find(x -> x == smallest_value, even_values)\n\
    \    \n    if smallest_index == -1 || smallest_value == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 6, 5, 7, 8, 4, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, \nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpel_8p5fv.jl:38\nin expression starting at\
    \ /tmp/tmpel_8p5fv.jl:38\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    if length(even_values) == 0\n     \
    \   return Vector{Int64}()\n    else\n        smallest_value = even_values[1]\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpt6xtu2s0.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpt6xtu2s0.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpt6xtu2s0.jl:34\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt6xtu2s0.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt6xtu2s0.jl:42\ntest set:\
    \ Test Failed at /tmp/tmpt6xtu2s0.jl:44\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt6xtu2s0.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt6xtu2s0.jl:42\ntest set: Error During Test\
    \ at /tmp/tmpt6xtu2s0.jl:46\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpt6xtu2s0.jl:34\n   [2]\
    \ macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt6xtu2s0.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt6xtu2s0.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpt6xtu2s0.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: find not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpt6xtu2s0.jl:34\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt6xtu2s0.jl:47 [inlined]\n\
    \   [4] macro expansion\n  "
  timestamp: 1660014783
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return []\n    else\n        smallest_even_value = min(even_values)\n\
    \        index = find(x -> x == smallest_even_value, even_values)\n        return\
    \ [smallest_even_value, index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20]) == [2,1]\n@assert pluck([2,4,6,8,10,12,14,16,18,20])\
    \ == [2,1]\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyab52kts.jl:36\nin expression starting at\
    \ /tmp/tmpyab52kts.jl:36\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_even_value, even_values)\n\
    \        return [smallest_even_value, smallest_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3p795lr3.jl:38\nin expression starting at\
    \ /tmp/tmp3p795lr3.jl:38\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8tsn1bec.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8tsn1bec.jl:1\n\
    in expression starting at /tmp/tmp8tsn1bec.jl:1\n"
  stdout: ''
  timestamp: 1660014778
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp61wmra1b.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp61wmra1b.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61wmra1b.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61wmra1b.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61wmra1b.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp61wmra1b.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61wmra1b.jl:31\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61wmra1b.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61wmra1b.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp61wmra1b.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n"
  timestamp: 1660014769
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    elseif length(even_values) == 1\n        return\
    \ even_values\n    else\n        smallest_value = min(even_values)\n        smallest_index\
    \ = find(even_values == smallest_value)[1]\n        return smallest_value, smallest_index\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert pluck([2,0,2,0]) == [ 2, 0 ]\n@assert pluck([2,0,2,0]) ==\
    \ [ 2, 0 ]\n@assert \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplanexr79.jl:38\nin expression starting at\
    \ /tmp/tmplanexr79.jl:38\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    \n    smalest_value = min(even_values)\n    smalest_index\
    \ = find(even_values == smalest_value)[1]\n    \n    return [smalest_value, smalest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [2,4,6,8,10,12,14,16,18,20]\n</cell>\n<code language=juli\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbnrqs_n7.jl:36\nin expression starting at\
    \ /tmp/tmpbnrqs_n7.jl:36\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert pluck([2,3,5,7,11,13,17,19]) == [2,2]\n@assert\
    \ pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0]) == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,0])\
    \ == [2,0]\n@assert pluck([2,3,5,7,11,13,17,19,\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjpdntf69.jl:37\nin expression starting at\
    \ /tmp/tmpjpdntf69.jl:37\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    smallest_value = min(even_values)\n\
    \    smallest_index = even_values.index(smallest_value)\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppcpiwua1.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppcpiwua1.jl:1\n\
    in expression starting at /tmp/tmppcpiwua1.jl:1\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [2,3,5,7,11,13,17,19]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values. (i.e., the in-order traversal).\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpivbcethb.jl:36\nin expression starting at\
    \ /tmp/tmpivbcethb.jl:36\n"
  stdout: ''
  timestamp: 1660014781
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpzt1d4gau.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpzt1d4gau.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n    min(::Any, !Matched::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzt1d4gau.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzt1d4gau.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzt1d4gau.jl:42\ntest set:\
    \ Test Failed at /tmp/tmpzt1d4gau.jl:44\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\n   Evaluated: [2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzt1d4gau.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzt1d4gau.jl:42\ntest set: Error During Test\
    \ at /tmp/tmpzt1d4gau.jl:46\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzt1d4gau.jl:33\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/j"
  timestamp: 1660014784
