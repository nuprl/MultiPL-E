name: HumanEval_37_sort_even
language: jl
prompt: "\"\"\"This function takes a list l and returns a list l' such that\n    l'\
  \ is identical to l in the odd indicies, while its values at the even indicies are\
  \ equal\n    to the values of the even indicies of l, but sorted.\n            \"\
  \"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
  \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
  \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
  \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
completions: ["    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x ->\
    \ x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(l)\n\
    \    odd = odd.(l)\n    return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a |>\nI wrote a Julia package that does this for you. \n<code>\nusing DataFrames\n\
    using DataFramesMeta", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n    even =\
    \ even.(sortperm(even))\n    odd = odd.(sortperm(odd))\n    return even ++ odd\n\
    end\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't seem to work\
    \ if there are duplicates in the list. For example, `sort_odd([1,1,2,3,5,5,5,6,7,8,9,10])`\
    \ returns `[1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` instead of `[1, 1, 2, 3, 4, 5,\
    \ 5, 6, 7, 8, 9, 10]`.\n<|/ c |>\n<| c |>\nI added a fix for duplicates.\n<|/\
    \ c |>\n<| c |>\nThis doesn't seem to work if there are duplicates in the list.\
    \ For example, `sort_odd([1,1,2,3,5,5,5,6,7,8,9,10])` returns `[1, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10]` instead of `[1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10]`.\n<|/\
    \ c |>\n<| c |>\nI added a fix for duplicates.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work if there are duplicates in the list. For example, `sort_odd([1,1,2,3,5,5,5,6,7,8,9,10])`\
    \ returns `[1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` instead of `[1, 1, 2, 3, 4, 5,\
    \ 5, 6, 7, 8, 9, 10]`.\n<|/ c |>\n<| a tags=julia,sorting |>\nI came up with a\
    \ solution that doesn't require any packages. I hope it helps.\n<code>", "   \
    \ even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(l)\n    odd\
    \ = odd.(l)\n    return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work if there are duplicate values in the input vector. For example,\
    \ `sort_even([1,2,2,3,4])` returns `[2,2,3,4]`.\n<|/ c |>\n<| c |>\nYes, I noticed\
    \ that after I posted it. I fixed it by adding `unique` to the `sort` calls. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a |>\nI wrote a function that does this\
    \ in Julia 1.5.\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    return\
    \ even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  \
    \  even = l[findall(x -> x % 2 == 0, l)]\n    even = sort(even)\n    even = even.(l)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\n\
    This doesn't work for me. `sort` doesn't seem to sort the even indices. I get\
    \ the following output: `[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\
    \ 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\
    \ 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73\
    \ 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99\
    \ 100]`\n<|/ c |>\n<| c |>\nI tested this on Julia 1.5.1 and it worked for me.\
    \ Are you sure you used the code exactly as I wrote it? I tested it on Julia 1.5.1\
    \ with Julia 1.5.1 on OS X and it worked for me.\n<|/ c |>\n<| c |>\nYes, I used\
    \ exactly the code you wrote. I also tested on Julia 1.5.1 on OS X and it worked\
    \ for me. Maybe you used the wrong version of Julia? I tested on Julia 1.5.1 on\
    \ Ubuntu 14.04 and it worked for me.\n<|/ c |>\n<| c |>\nI tested on Julia 1.5.1\
    \ on Ubuntu 14.04 and it worked for me. Maybe you used the wrong version of Julia?\
    \ I tested on Julia 1.5.1 on OS X and it worked for me.\n<|/ c |>\n<| c |>\nI\
    \ tested on Julia 1.5.1 on OS X and it worked for me. Maybe you used the wrong\
    \ version of Julia? I tested on Julia 1.5.1 on Ubuntu 14.04 and it worked for\
    \ me.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nHere's a solution that is\
    \ more efficient than sorting the entire array and only sorting the even indices:\n\
    <code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x ->\
    \ x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(l\
    \ .== even)\n    odd = odd.(l .== odd)\n    return even .+ odd\nend\n</cell>\n\
    <code language=julia-1.5>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work\
    \ if there are duplicate elements in the list\n<|/ c |>\n<| c |>\nI added a version\
    \ that works with duplicates.\n<|/ c |>\n<| c |>\nI added a version that works\
    \ with duplicates.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>", "    even =\
    \ l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n \
    \   even.sort()\n    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the list. For example,\
    \ `[1,1,2,3]` will give `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and\
    \ fixed it now. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if there are duplicates in the list. For example, `[1,1,2,3]` will give `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI fixed it now. Thanks for pointing it out.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's a solution using sort!\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis is not the most efficient solution, but it is very readable.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI agree, this is very readable, but I believe it\
    \ can be made more efficient by avoiding allocations. I added an answer that does\
    \ this and also avoids allocations.\n<|/ c |>\n<| a |>\nI believe this can be\
    \ made more efficient by avoiding allocations. Here is a function that does this\
    \ and also avoids allocations:\n<code>", "    even = l[findall(x -> x % 2 == 0,\
    \ l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n    odd\
    \ = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work if there are duplicate values in the list\n<|/ c |>\n<| c |>\n\
    It does work if there are duplicate values in the list. `sort` sorts duplicates\
    \ by their first occurrence.\n<|/ c |>\n<| c |>\nI tested it and it doesn't work.\
    \ Try `[1,1,2,3,3]`\n<|/ c |>\n<| c |>\nIt does work. Try `[1,1,2,3,3]`. `sort`\
    \ sorts duplicates by their first occurrence. `sort!` sorts duplicates by their\
    \ last occurrence.\n<|/ c |>\n<| c |>\nIt does work. Try `[1,1,2,3,3]`. `sort`\
    \ sorts duplicates by their first occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence. `sort!` sorts duplicates by their last occurrence. `sort!`\
    \ sorts duplicates by their last occurrence. `sort!` sorts duplicates by their\
    \ last occurrence", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(l)\n\
    \    odd = odd.(l)\n    return even ++ odd\nend", "    even = l[findall(l .% 2\
    \ == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort(even)\n    odd =\
    \ sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for your answer. I am not familiar with Julia yet, so I might not understand\
    \ it completely. Could you please explain what `l[findall(l .% 2 == 0)]` does?\
    \ I understand that `findall` finds indices of elements that satisfy a condition,\
    \ but I don't understand what `.%` does.\n<|/ c |>\n<| c |>\n`l[findall(l .% 2\
    \ == 0)]` finds the indices of elements that satisfy `l .% 2 == 0`. `.%` is the\
    \ modulus operator. It returns the remainder of division of two numbers. For example,\
    \ `5 % 2` is `1`, but `5 .% 2` is `5`.\n<|/ c |>\n<| c |>\nOh, I see. So `l .%\
    \ 2 == 0` returns a vector of booleans, where each boolean is true if the corresponding\
    \ element of `l` is even, and false otherwise. `findall` then finds indices of\
    \ elements that satisfy the condition. Thanks!\n<|/ c |>\n<| c |>\nYes, that's\
    \ right. `findall(l .% 2 == 0)` returns a vector of booleans. `l .% 2 == 0` returns\
    \ a vector of booleans, where each boolean is true if the corresponding element\
    \ of `l` is even, and false otherwise.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ I am not familiar with Julia yet, so I might not understand it completely. Could\
    \ you please explain what `l[findall(l .% 2 == 0)]` does? I understand that `findall`\
    \ finds indices of elements that satisfy a condition, but I don't understand what\
    \ `.%` does.\n<|/ c |>\n<| a |>\nHere is a solution using Julia's built-in sort!\
    \ and find! functions:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd\
    \ = sort_odd(odd)\n    return even ++ odd\nend", "    even = l[findall(x -> x\
    \ % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n \
    \   odd.sort()\n    return even + odd\nend\n</cell>\n<code language=julia-1.0>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even = union(even,\
    \ odd)\n    return even\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n  \
    \  odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n   \
    \ even.extend(odd)\n    return even\nend", "    even = l[findall(l .%2 == 0)]\n\
    \    odd = l[findall(l .%2 == 1)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not work. `sort_even([1,2,3,4,5,6,7,8,9,10])`\
    \ returns `[1,2,3,4,5,6,7,8,9,10]`\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I tested it on Julia 1.5.1. What version are you using?\n<|/ c |>\n<| c |>\n\
    I am using Julia 1.5.1. I tested it on Julia 1.5.1. What version are you using?\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 1.5.1. What version are you using?\n<|/\
    \ c |>\n<| c |>\nI tested it on Julia 1.5.1. What version are you using?\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n \
    \   even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThanks for the answer. I am not familiar with Julia yet, so I did\
    \ not know about `findall`. However, I do not understand how this works. Could\
    \ you please explain how this works?\n<|/ c |>\n<| c |>\n`findall` returns a list\
    \ of indices where a predicate is true. `x -> x % 2 == 0` returns true for all\
    \ even numbers and false for all odd numbers. `findall(x -> x % 2 != 0, l)` returns\
    \ all odd numbers. `x -> x % 2 == 0` returns true for all even numbers and false\
    \ for all odd numbers. `x -> x % 2 != 0` returns true for all odd numbers and\
    \ false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` returns true for all odd numbers\
    \ and false for all even numbers. `x -> x % 2 != 0` ", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_odd(even)\n\
    \    odd = sort_odd(odd)\n    even = even.(odd)\n    return even\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks for your answer! I didn't know that `sort`\
    \ can sort by multiple criteria. Unfortunately, I cannot use Julia 1.5 because\
    \ my code relies on some packages that only exist in Julia 1.5. Do you know if\
    \ there is a way to do this in Julia 1.5?\n<|/ c |>\n<| c |>\nI added a solution\
    \ for Julia 1.5\n<|/ c |>\n<| c |>\nThanks for your answer! I didn't know that\
    \ `sort` can sort by multiple criteria. Unfortunately, I cannot use Julia 1.5\
    \ because my code relies on some packages that only exist in Julia 1.5. Do you\
    \ know if there is a way to do this in Julia 1.5?\n<|/ c |>\n<| c |>\nI added\
    \ a solution for Julia 1.5\n<|/ c |>\n<| a dscore=0 |>\nThe answer by is great,\
    \ but I thought I'd add some explanation as to why it works.\nThe sort function\
    \ takes a function as its first argument. The function must take two arguments\
    \ and return a single value. The function will be called on each element of the\
    \ array in order, and its return value will be used to determine which element\
    \ should come first.\nThe function you pass to sort must take two arguments and\
    \ return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to sort must take two arguments\
    \ and return a single value. The function you pass to ", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even.(l)\n    odd = odd.(l)\n    return even\
    \ ++ odd\nend", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .%\
    \ 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\n\
    This doesn't work. `sort_even([1,3,5,7,9])` returns `[1,3,5,7,9]`.\n<|/ c |>\n\
    <| c |>\nI fixed the bug, thanks for pointing it out. Now it works.\n<|/ c |>\n\
    <| a |>\nThe answer by is good, but I wanted to add an alternative that uses sortperm:\n\
    <code>\njulia> sortperm([1,3,5,7,9])\n10-element Array{Int64,1}:\n 3\n 5\n 7\n\
    \ 9\n 1\n 2\n 4\n 6\n 8\n10\n</code>\n<|/ a tags=julia,sorting dscore=4 |>\n<|\
    \ c |>\nThis should be the accepted answer. `sortperm` does exactly what OP wants,\
    \ while `sort` does not.\n<|/ c |>\n<| a dscore=3 |>\nThe answer by is good, but\
    \ I wanted to add an alternative that uses sortperm:\n<code>\njulia> sortperm([1,3,5,7,9])\n\
    10-element Array{Int64,1}:\n 3\n 5\n 7\n 9\n 1\n 2\n 4\n 6\n 8\n10\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a dscore=3 |>\nThe answer by is good, but I wanted\
    \ to add an alternative that uses sortperm:\n<code>\njulia> sortperm([1,3,5,7,9])\n\
    10-element Array{Int64,1}:\n 3\n 5\n 7\n 9\n 1\n 2\n 4\n 6\n 8\n10\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\n<code>\njulia> sortperm([1,3,5,7,9])\n\
    10-element Array{Int64,1}:\n 3\n 5\n 7\n 9\n 1\n 2\n 4\n 6\n 8\n10\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\n<code>\njulia> sortperm([1,3,5,7,9", "  \
    \  even = l[findall(l .% 2 == 0)]\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nI like the idea of using an anonymous function for the sorting\
    \ function, but this doesn't seem to work. `sort_even([1,2,3,4,5,6,7,8,9,10])`\
    \ returns `[1,2,3,4,5,6,7,8,9,10]`\n<|/ c |>\n<| c |>\nOops, I forgot to add the\
    \ `return` statement to the anonymous function. Fixed now.\n<|/ c |>\n<| c |>\n\
    Thanks, this works great! I didn't realize that you could use an anonymous function\
    \ like that. I'm still new to Julia, so I appreciate the help.\n<|/ c |>\n<| c\
    \ |>\nI added a version that doesn't require an anonymous function.\n<|/ c |>\n\
    <| a dscore=1 |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3,4,5,6,7,8,9,10])\n\
    10-element Array{Int64,1}:\n 8\n 9\n10\n 1\n 6\n 7\n 2\n 3\n 4\n 5\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis works great! I didn't realize that\
    \ you could use an anonymous function like that. I'm still new to Julia, so I\
    \ appreciate the help.\n<|/ c |>\n<| a dscore=1 |>\nHere's a version that doesn't\
    \ require an anonymous function:\n<code>", "    even = l[findall(l .%2 == 0)]\n\
    \    odd = l[findall(l .%2 == 1)]\n    even.sort()\n    odd.sort()\n    even.zip(odd)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like the idea of using `.%2` instead\
    \ of `%2==0`, but this doesn't seem to work. `sort_even([1,2,3,4,5,6,7,8,9,10])`\
    \ returns `[1,2,3,4,5,6,7,8,9,10]`.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with vectors of any length.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with vectors of any length.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution\
    \ using sortperm:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n\
    \    even = even[findall(even .% 2 == 1)]\n    return even\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid\
    \ the intermediate `even` array. Maybe `sort!` could be used instead?\n<|/ c |>\n\
    <| c |>\nI thought about it, but I wasn't sure how to implement it. I think `sort!`\
    \ would require a mutable array, so it wouldn't be as efficient.\n<|/ c |>\n<|\
    \ c |>\nI added a solution that avoids the intermediate `even` array\n<|/ c |>\n\
    <| c |>\nI added a solution that avoids the intermediate `even` array\n<|/ c |>\n\
    <| a dscore=1 |>\nA simple solution that avoids the intermediate even array would\
    \ be to sort each of the even indicies separately and then concatenate them together:\n\
    <code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n\
    \    even = sort_odd(even)\n    odd = sort_odd(odd)\n    even = even.(odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nI\
    \ like your solution, but I believe it can be simplified even further. `sort_even`\
    \ can be simplified to `sort_odd(l)` since `sort_odd(l)` will sort `l` by its\
    \ even indices. Then `sort_odd(l)` can be simplified to `sort_odd(l)[findall(l\
    \ .% 2 == 1)]` since `sort_odd(l)` will sort `l` by its odd indices. Then `sort_odd(l)[findall(l\
    \ .% 2 .== 1)]` can be simplified to `sort_odd(l)[findall(l .% 2 == 1)]` since\
    \ `sort_odd(l)` will sort `l` by its odd indices. Then `sort_odd(l)[findall(l\
    \ .% 2 .== 1)]` can be simplified to `sort_odd(l)[findall(l .% 2 == 1)]` since\
    \ `sort_odd(l)` will sort `l` by its odd indices. Then `sort_odd(l)[findall(l\
    \ .% 2 == 1)]` can be simplified to `sort_odd(l)[findall(l .% 2 == 1)]` since\
    \ `sort_odd(l)` will sort `l` by its odd indices.\n<|/ c |>\n<| c |>\nI like your\
    \ solution, but I believe it can be simplified even further. `sort_even` can be\
    \ simplified to `sort_odd(l)` since `sort_odd(l)` will sort `l` by its even indices.\
    \ Then `sort_odd(l)` can be simplified to `sort_odd(l)[findall(l .% 2 == 1)]`\
    \ since `sort_odd(l)` will sort `l` by its odd indices. Then `sort_odd(l)[findall(l\
    \ .% 2 .== 1)]` can be simplified to `sort_odd(l)[findall(l .% 2 == 1)]` since\
    \ `sort_odd(l)` will sort `l` by its odd indices. Then `sort_odd(l)[findall(l\
    \ .% 2 == 1)]` can be simplified to `sort_odd(l)[findall(l .% 2 == 1)]` since\
    \ `sort_odd(l)` will sort `l` by its odd indices.\n<|/ c |>", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    This doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nI guess it\
    \ depends on what you mean by \"work\".  It does work for the example in the question.\
    \  If you have a different example that doesn't work, please post a new question.\n\
    <|/ c |>\n<| c |>\nI meant that it doesn't work if `l` is an `Array{Int64,1}`.\
    \  I guess I should have made that clearer.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean.  I updated my answer to account for that case.\n<|/ c |>\n<| c |>\nI guess\
    \ I should have made that clearer in the first place.  I meant that your answer\
    \ doesn't work if `l` is an `Array{Int64,1}`.  I guess I should have made that\
    \ clearer in the first place.  I meant that your answer doesn't work if `l` is\
    \ an `Array{Int64,1}`.  I guess I should have made that clearer in the first place.\
    \  I meant that your answer doesn't work if `l` is an `Array{Int64,1}`.  I guess\
    \ I should have made that clearer in the first place.  I meant that your answer\
    \ doesn't work if `l` is an `Array{Int64,1}`.  I guess I should have made that\
    \ clearer in the first place.  I meant that your answer doesn't work if `l` is\
    \ an `Array{Int64,1}`.  I guess I should have made that clearer in the first place.\
    \  I meant that your answer doesn't work if `l` is an `Array{Int64,1}`.  I guess\
    \ I should have made that clearer in the first place.  I meant that your answer\
    \ doesn't work if `l` is an `Array{Int64,1}`.  I guess I should have made that\
    \ clearer in the first place.  I meant that your answer doesn't work if `l` is\
    \ an `Array{Int64,1}`.  I guess I should have made that clearer in the first place.\
    \  I meant that your answer doesn't work if `l` is an `Array{Int64,1}`.  I guess\
    \ I should have made that clearer in the first place.  I meant that your answer\
    \ doesn't ", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n  \
    \  even = union(even, odd)\n    return even\nend", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    even = sort(even)\n    even = even.(l)\n    return even\n\
    end\n</cell>\n<code language=julia-1.5>", "    even = l[findall(x -> x % 2 ==\
    \ 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n  \
    \  odd = sort(odd)\n    even = even.(1:length(even))\n    odd = odd.(1:length(odd))\n\
    \    even = even.(2:length(even))\n    odd = odd.(2:length(odd))\n    even = even.(3:length(even))\n\
    \    odd = odd.(3:length(odd))\n    even = even.(4:length(even))\n    odd = odd.(4:length(odd))\n\
    \    even = even.(5:length(even))\n    odd = odd.(5:length(odd))\n    even = even.(6:length(even))\n\
    \    odd = odd.(6:length(odd))\n    even = even.(7:length(even))\n    odd = odd.(7:length(odd))\n\
    \    even = even.(8:length(even))\n    odd = odd.(8:length(odd))\n    even = even.(9:length(even))\n\
    \    odd = odd.(9:length(odd))\n    even = even.(10:length(even))\n    odd = odd.(10:length(odd))\n\
    \    even = even.(11:length(even))\n    odd = odd.(11:length(odd))\n    even =\
    \ even.(12:length(even))\n    odd = odd.(12:length(odd))\n    even = even.(13:length(even))\n\
    \    odd = odd.(13:length(odd))\n    even = even.(14:length(even))\n    odd =\
    \ odd.(14:length(odd))\n    even = even.(15:length(even))\n    odd = odd.(15:length(odd))\n\
    \    even = even.(16:length(even))\n    odd = odd.(16:length(odd))\n    even =\
    \ even.(17:length(even))\n    odd = odd.(17:length(odd))\n    even = even.(18:length(even))\n\
    \    odd = odd.(18:length(odd))\n    even = even.(19:length(even))\n    odd =\
    \ odd.(19:length(odd))\n    even = even.(20:length(even))\n    odd = odd.(20:length(odd))\n\
    \    even = even.(21:length(even))\n    odd = odd.(21:length(odd))\n    even =\
    \ even.", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x ->\
    \ x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia\
    \ |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n   \
    \ even = even.(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n\
    <| c |>\nThis doesn't work. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nIt does work. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`\n\
    <|/ c |>\n<| c |>\nI see what you mean. My mistake. Thanks for pointing that out.\n\
    <|/ c |>\n<| c |>\nI added a version that works with vectors.\n<|/ c |>\n<| c\
    \ |>\nI added a version that works with vectors.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nHere's a version that works with vectors:\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    even = even.(1:length(even))\n    odd = odd.(1:length(odd))\n    return even\
    \ .+ odd\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nI like using zip for these sorts of things. Here's a solution\
    \ using zip:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n  \
    \  return even ++ odd\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    even = sort(even)\n    odd = sort(odd)\n    return even + odd\nend", "  \
    \  even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    even = l[findall(l .== 0)]\n    even = sort(even)\n\
    \    even = even.(l)\n    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't seem to work. `sort_even([1,2,3,4,5,6,7,8,9,0])` returns `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I guess it depends\
    \ on the version of Julia you are using.\n<|/ c |>\n<| c |>\nI tested it on Julia\
    \ 0.6.2 and it works. I guess it depends on the version of Julia you are using.\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I guess it depends\
    \ on the version of Julia you are using.\n<|/ c |>\n<| c |>\nI tested it on Julia\
    \ 0.6.2 and it works. I guess it depends on the version of Julia you are using.\n\
    <|/ c |>\n<| a tags=julia |>\n<code>", "    even = l[findall(x -> x % 2 == 0,\
    \ l)]\n    even = sort(even)\n    even = even.(l)\n    return even\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort`\
    \ doesn't work on `Int64` arrays.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a version that works with `Int64` arrays.\n<|/ c |>\n<| a dscore=1 |>\nHere's\
    \ a solution using Julia's built-in sort function and some list comprehensions:\n\
    <code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    even = sort(even)\n \
    \   even = even.(l)\n    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks for the answer! I understand that my code is not efficient, but I wanted\
    \ to see how it could be done in Julia without using any loops. I guess I should\
    \ learn how to use loops more thoroughly before I start using Julia.\n<|/ c |>\n\
    <| c |>\nI added a version without loops. I hope it helps.\n<|/ c |>\n<| c |>\n\
    Thanks for the answer! I understand that my code is not efficient, but I wanted\
    \ to see how it could be done in Julia without using any loops. I guess I should\
    \ learn how to use loops more thoroughly before I start using Julia.\n<|/ c |>\n\
    <| c |>\nI added a version without loops. I hope it helps.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI believe that your code is inefficient because you are creating a new vector\
    \ and sorting it every time you call sort_odd. You can avoid this by creating\
    \ a vector of indices and then sorting that vector:\n<code>", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=0 |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n \
    \   even.zip(odd).collect{Tuple{Int64, Int64}}\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI like your solution, but I wonder how it compares performance\
    \ wise to my solution. My solution uses `sort` and your solution uses `sort!`.\
    \ My solution also uses `collect`, which I believe is slower than `sort`. Do you\
    \ know if there is a way to speed up `collect`?\n<|/ c |>\n<| c |>\nI haven't\
    \ tested it, but I believe `collect` is slower than `sort` because `sort` has\
    \ to copy the array before it can sort it.  `collect` just collects the elements\
    \ of the array into a vector.  So `sort` has to copy the array before it can sort\
    \ it.  `sort!` doesn't have to copy the array before it can sort it.  So `sort!`\
    \ should be faster.\n<|/ c |>\n<| c |>\nI tested it and it seems that `sort!`\
    \ is indeed faster than `sort`. However, I still wonder if there is a way to speed\
    \ up `collect`. `collect` seems to be the bottleneck in my code.\n<|/ c |>\n<|\
    \ c |>\nI added a solution that uses `collect` instead of `sort`.\n<|/ c |>\n\
    <| c |>\nI added a solution that uses `collect` instead of `sort`.\n<|/ c |>\n\
    <| a tags=julia,sorting,arrays |>\nI believe this should work:\n<code>", "   \
    \ even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThanks for your answer! I didn't know that you can do `l .% 2` like that.\
    \ Could you explain what that does? I thought it just divided `l` by 2, but then\
    \ I realized that `l .% 2` would give me the remainder of division by 2, which\
    \ is not what I want.\n<|/ c |>\n<| c |>\n`l .% 2` gives you the remainder of\
    \ division by 2. So `l .% 2 == 0` gives you the odd indicies of `l`. `l .% 2 !=\
    \ 0` gives you the even indicies of `l`. `l .% 2` gives you the even indicies\
    \ of `l` divided by 2. So `l .% 2 == 0` gives you the odd indicies of `l` divided\
    \ by 2. `l .% 2 != 0` gives you the even indicies of `l` divided by 2. So `l .%\
    \ 2 == 0` gives you the odd indicies of `l` divided by 2. `l .% 2 != 0` gives\
    \ you the even indicies of `l` divided by 2. So `l .% 2 == 0` gives you the odd\
    \ indicies of `l` divided by 2. `l .% 2 != 0` gives you the even indicies of `l`\
    \ divided by 2. So `l .% 2 == 0` gives you the odd indicies of `l` divided by\
    \ 2. `l .% 2 != 0` gives you the even indicies of `l` divided by 2. So `l .% 2\
    \ == 0` gives you the odd indicies of `l` divided by 2. `l .% 2 != 0` gives you\
    \ the even indicies of `l` divided by 2. So `l .% 2 == 0` gives you the odd indicies\
    \ of `l` divided by 2. `l .% 2 != 0` gives you the even indicies of `l` divided\
    \ by 2. So `l .% 2 == 0` gives you the odd indicies of `l` divided by 2. `l .%\
    \ 2 != 0` gives you the even indicies of `l` divided by 2. So `l .% 2 == 0` gives\
    \ you the ", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n \
    \   return even .+ odd\nend", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.zip(odd)\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work if the list contains\
    \ duplicates. For example, `[1,1,2,3]` will sort into `[1,2,3]` instead of `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the list contains duplicates. For example,\
    \ `[1,1,2,3]` will sort into `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    I edited my answer to include a solution that works with duplicates.\n<|/ c |>\n\
    <| a dscore=3 |>\nA more general solution that works with any number of duplicates:\n\
    <code>\njulia> function sort_duplicates(x::Vector{Int})\n           n = length(x)\n\
    \           m = sort(unique(x))\n           if n == 1\n               return m\n\
    \           else\n               return sort(m)\n           end\n       end\n\
    sort_duplicates (generic function with 1 method)", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even.(1:length(even))\n    odd = odd.(1:length(odd))\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\n\
    This doesn't work if `l` is an `Int64` array. `sort` will sort it lexicographically,\
    \ which is not what we want.\n<|/ c |>\n<| c |>\nI agree with you. I've added\
    \ a version that works with `Int64` arrays. I hope this helps.\n<|/ c |>\n<| a\
    \ |>\nA simple and efficient solution would be to first sort the even indices\
    \ and then concatenate them with the odd indices. \n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    even = sort(even)\n    even = even[findall(even .% 2 == 1)]\n\
    \    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=0\
    \ |>\nThe answer by is very good, but I thought I'd add an alternative solution\
    \ that uses only built-in functions. \n<code>", "    even = l[findall(x -> x %\
    \ 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n   \
    \ odd.sort()\n    even.zip(odd).map(x -> x[1])\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns\
    \ `[1,2,3,4,5,6,7,8,9,10]`\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/\
    \ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on\
    \ Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\njulia> function sort_even(l::Vector{Int64})\n           even = l[findall(x\
    \ -> x % 2 == 0, l)]\n           odd = l[findall(x -> x % 2 != 0, l)]\n      \
    \     even.sort()\n           odd.sort()\n           even.zip(odd).map(x -> x[1])\n\
    \       end\nsort_even (generic function with 1 method)", "    even = l[findall(l\
    \ .%2 == 0)]\n    odd = l[findall(l .%2 == 1)]\n    even.sort()\n    odd.sort()\n\
    \    even.zip(odd)\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\n\
    julia> l = [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,133,135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,165,167,169,171,173,175,177,179,181,183,185,187,189,191,193,195,197,199,201,203,205,207,209,211,213,215,217,219,221,223,225,227,229,231,233,235,237,239,241,243,245,247,249,251,253,255,257,259,261,263,265,267,269,271,273,275,277,279,281,283,285,287,289,291,293,295,297,299,301,303,305,307,309,311,313,315,317,319,321,323,325,327,329,331,333,335,337,339,341,343,345,347,349,351,353,355,357,359,361,363,365,367,369,371,373,375,377,379,381,383,385,387,389,391,393,395,397,399,401,403,405,407,409,411,413,415,417,419,421,423,425,427,429,431,433,435,437,",
  "    even = l[findall(l .%2 == 0)]\n    odd = l[findall(l .%2 == 1)]\n    even =\
    \ sort_even(even)\n    odd = sort_odd(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if there are duplicate\
    \ elements in the list. For example, `[1,1,2,3]` returns `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nYes, I noticed that after I posted my comment. I've updated my answer\
    \ to include a solution that works with duplicate elements.\n<|/ c |>\n<| c |>\n\
    I added a solution that works with duplicate elements. I hope you don't mind that\
    \ I added a second answer that uses `sortperm` instead of `sort`.\n<|/ c |>\n\
    <| a tags=julia,sorting |>\nI like to use sortperm:\n<code>\njulia> sortperm([1,1,2,3])\n\
    3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis\
    \ doesn't work if there are duplicate elements in the list. For example, `[1,1,2,3]`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I noticed that after I posted my\
    \ comment. I've updated my answer to include a solution that works with duplicate\
    \ elements.\n<|/ c |>\n<| a dscore=2 |>\nI like to use sortperm:\n<code>\njulia>\
    \ sortperm([1,1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=2 |>\nI like to use sortperm:\n<code>\njulia> sortperm([1,1,2,3])\n\
    3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a tags=julia,sorting |>\n\
    <| a tags=julia,sorting |>\nI like to use sortperm:\n<code>\njulia> sortperm([1,1,2,3])\n\
    3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,sorting\
    \ |>\nI like to use sortperm:\n<code>\njulia> sortperm([1,1,2,3])\n3-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n</code>\n<|/", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>", "    even =\
    \ l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even.(l)\n    return\
    \ even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\n\
    The answer by is correct, but I thought I'd add my own answer which doesn't require\
    \ the use of a temporary variable or an intermediate array. \n<code>", "    even\
    \ = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    sort_even([1,2,3,4,5,6,7,8,9,10])\n</cell>\n<text>\nExercise: Write a function\
    \ that takes a list l and returns a list l' such that\n    l' is identical to\
    \ l in the even indicies, while its values at the odd indicies are equal\n   \
    \ to the values of the odd indicies of l, but sorted.\n            \"\"\"", " \
    \   even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work for\
    \ me. `sort_even([1,3,5,7,9,11,13,15,17,19])` returns `[3, 5, 7, 9, 11, 13, 15,\
    \ 17, 19]`.\n<|/ c |>\n<| c |>\nI tested it and it works for me. Are you sure\
    \ you copied it correctly? I tested it with `sort_even([1,3,5,7,9,11,13,15,17,19])`\
    \ which returns `[3, 5, 7, 9, 11, 13, 15, 17, 19]`.\n<|/ c |>\n<| c |>\nYes, I\
    \ copied it correctly. I just tried it again and it works. I must have had a typo\
    \ somewhere in my code when I tried it the first time.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis should work:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n</cell>\n\
    <code language=julia-1.5>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    even.zip(odd)\n\
    end\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nI like the idea of\
    \ using an anonymous function for the predicate. Thanks!\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\njulia> function sort_odd(x::Vector{Int64})\n           return sort(x,\
    \ by=x->x%2)\n       end\nsort_odd (generic function with 1 method)", "    even\
    \ = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n\
    \    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThanks for your answer. Your solution is very elegant, but unfortunately\
    \ it takes too much time for my big dataset. My dataset has about 300 000 rows\
    \ and it takes about 30 minutes to sort it. I think it would be better to sort\
    \ it by column (like in Excel) but I don't know how I can do it in Julia.\n<|/\
    \ c |>\n<| c |>\nI added a solution that sorts by column, but it is still not\
    \ as fast as your solution. Maybe you can think of something else?\n<|/ c |>\n\
    <| c |>\nI added a solution that sorts by column, but it is still not as fast\
    \ as your solution. Maybe you can think of something else?\n<|/ c |>\n<| c |>\n\
    I added a solution that sorts by column, but it is still not as fast as your solution.\
    \ Maybe you can think of something else?\n<|/ c |>\n<| c |>\nI added a solution\
    \ that sorts by column, but it is still not as fast as your solution. Maybe you\
    \ can think of something else?\n<|/ c |>\n<| a dscore=1 |>\nI finally found a\
    \ solution that sorts by column, but it is still not as fast as your solution.\
    \ Maybe you can think of something else?\n<code>", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    even = sort_even(even)\n    even = sort_even(even)\n  \
    \  even = sort_even(even)\n    return even\nend", "    even = l[findall(l .% 2\
    \ == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort(even)\n    odd =\
    \ sort(odd)\n    even = even.+(0:length(even)-1)\n    odd = odd.+(0:length(odd)-1)\n\
    \    return even, odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work.\
    \ `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `([1,3,5,7,9,10], [2,4,6,8,10])`\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I edited my answer to include a working\
    \ example.\n<|/ c |>\n<| c |>\nI tested it and it works. I edited my answer to\
    \ include a working example.\n<|/ c |>\n<| c |>\nI tested it and it works. I edited\
    \ my answer to include a working example.\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works. I edited my answer to include a working example.\n<|/ c |>\n<| a |>\n\
    I like to use zip to combine two lists together, and then use map to apply a function\
    \ to each element in the zipped list. \n<code>", "    even = l[findall(x -> x\
    \ % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n \
    \   odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a |>\n<| c |>\nI like your\
    \ solution. One thing though, `sort` does not return a sorted vector, it returns\
    \ a sorted array. `sort!` will sort the array in-place.\n<|/ c |>\n<| c |>\nThanks,\
    \ I didn't know that. I've edited my answer to reflect this.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere's a solution using sort!:\n<code>", "    even = l[findall(l .% 2 ==\
    \ 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd\
    \ = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the list. For example, `sort_even([1,1,2,2])` returns `[1,1,2,2]`.\n<|/ c\
    \ |>\n<| c |>\nYes, it does. I didn't think about that case. I'll fix it.\n<|/\
    \ c |>\n<| a tags=julia,sorting |>\nHere is a solution using sortperm:\n<code>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>", "    even =\
    \ l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n \
    \   even = sort(even)\n    odd = sort(odd)\n    even = even.(l)\n    odd = odd.(l)\n\
    \    return even ++ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<|\
    \ a dscore=2 |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_odd_even(l::Vector{Int64})\n\
    \           even = l[findall(x -> x % 2 == 0, l)]\n           odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n           return sortperm(even .+ odd)\n       end\nsort_odd_even\
    \ (generic function with 1 method)", "    even = l[findall(l .% 2 == 0)]\n   \
    \ odd = l[findall(l .% 2 .== 1)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n\
    \    even = even.(odd)\n    return even\nend", "    even = l[findall(l .% 2 ==\
    \ 0)]\n    even = sort_even(even)\n    odd = l[findall(l .% 2 .== 1)]\n    odd\
    \ = sort_odd(odd)\n    even = sort(even)\n    odd = sort(odd)\n    return even\
    \ .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if you have\
    \ a list like `[1,1,2,3,3]`\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ lists of any length.\n<|/ c |>\n<| c |>\nI added a version that works with lists\
    \ of any length.\n<|/ c |>\n<| a |>\nHere's a solution using sortperm:\n<code>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even = union(even,\
    \ odd)\n    return even\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n  \
    \  odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd =\
    \ sort_odd(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nThe answer by is very\
    \ elegant and efficient, but I thought I'd add an alternative that doesn't require\
    \ any preprocessing of the input. \nThe idea is to find the indices of the even\
    \ elements in the input vector, and then use those to index into the input vector\
    \ to find the corresponding odd elements. \n<code>", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I like this solution, but I wonder if there is a way to do this without creating\
    \ a new vector. Perhaps some sort of in-place sorting?\n<|/ c |>\n<| c |>\nI added\
    \ a solution that does not create a new vector\n<|/ c |>\n<| c |>\nThanks, I like\
    \ it! I wonder if there is a way to do this without creating a new vector. Perhaps\
    \ some sort of in-place sorting?\n<|/ c |>\n<| c |>\nI added a solution that does\
    \ not create a new vector\n<|/ c |>\n<| c |>\nThanks, I like it! I wonder if there\
    \ is a way to do this without creating a new vector. Perhaps some sort of in-place\
    \ sorting?\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using sort!\n<code>",
  "    even = l[findall(l .% 2 == 0)]\n    even = sort_odd(even)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a tags=sorting,julia |>\n<| a |>\nI like 's\
    \ answer, but here's another one that uses only built-in functions:\n<code>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    even = sort(even)\n    even = even.(l)\n\
    \    return even\nend", "    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n\
    \    even = sort(even)\n    even = even.(l)\n    return even\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI like the idea of using `.%` instead of `div`\n<|/ c |>\n<|\
    \ c |>\nYes, I like that too. Thanks for sharing!\n<|/ c |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to avoid the allocation of a new array\
    \ and to directly modify the original one. Something like `even = sort(l[findall(l\
    \ .% 2 == 0)])`\n<|/ c |>\n<| c |>\nI added a version that does not allocate a\
    \ new array\n<|/ c |>\n<| a tags=julia,sorting |>\nHere is a solution without\
    \ allocation:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd =\
    \ l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\n\
    The answer by is great, but I thought I'd add an alternative that uses only built-in\
    \ functions. \n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n    even =\
    \ even.(odd)\n    even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis\
    \ doesn't seem to work. `sort_even([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend", " \
    \   even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\n\
    This doesn't seem to work. `sort_even([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])`\
    \ returns `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n<|/ c |>\n<|\
    \ c |>\nAh, I see what you're saying. You're right. I was thinking about this\
    \ problem in terms of sorting a vector of numbers. I didn't realize that `sort`\
    \ was a function that sorts vectors. I edited my answer to fix the problem.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(x -> x % 2 == 0, l)]\n           odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n           even = sort_even(even)\n           odd = sort_odd(odd)\n\
    \           even = union(even, odd)\n           return even\n       end\nsort_even\
    \ (generic function with 1 method)", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd\
    \ = sort_odd(odd)\n    return even ++ odd\nend\n</code>\n<|/ a |>\n<| c |>\nI\
    \ like your solution, but I feel like it could be made more efficient. For example,\
    \ `sort!` will sort in-place, so it would be better to sort `l` in-place and then\
    \ return `l` rather than creating a new vector and sorting that.\n<|/ c |>\n<|\
    \ c |>\nI agree, `sort!` would be more efficient. I'll update my answer.\n<|/\
    \ c |>\n<| a dscore=1 |>\nI like your solution, but I feel like it could be made\
    \ more efficient. For example, sort! will sort in-place, so it would be better\
    \ to sort l in-place and then return l rather than creating a new vector and sorting\
    \ that.\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(l)\n\
    \    odd = odd.(l)\n    return even ++ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .%2 == 0)]\n    odd = l[findall(l .%2 == 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).map(x -> x[1])\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThanks for your answer! I didn't know about `sortperm`. I tried\
    \ your solution and it works perfectly. Thanks again!\n<|/ c |>\n<| c |>\n`sortperm`\
    \ is very useful, especially when you want to sort a vector in place. `sortperm`\
    \ returns a permutation vector, which is then used to sort the original vector.\
    \ `sortperm` also has a `reverse` argument, which reverses the order of the permutation\
    \ vector. `sortperm` also has a `by` argument, which allows you to specify how\
    \ you want to sort your vector. For example, `sortperm(vec)` sorts the vector\
    \ `vec` in ascending order. `sortperm(vec, by = x -> x)` sorts the vector `vec`\
    \ in ascending order by the value of each element in `vec`.\n<|/ c |>\n<| a |>\n\
    Here is a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .%2 == 0)]\n           odd = l[findall(l .%2 ==\
    \ 1)]\n           even.sort()\n           odd.sort()\n           even.zip(odd).map(x\
    \ -> x[1])\n       end\nsort_even (generic function with 1 method)", "    even\
    \ = l[findall(l .% 2 == 0)]\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    return even\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd =\
    \ l[findall(x -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n\
    \    even = sort(even)\n    odd = sort(odd)\n    return even ++ odd\nend\n</cell>\n\
    <code language=julia-1.5>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    return\
    \ even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThe easiest way\
    \ is to use sortperm:\n<code>\njulia> l = rand(1:10, 10)\n10-element Vector{Int64}:\n\
    \ 3\n 2\n 6\n 7\n 8\n 9\n 8\n 7\n 6\n 2\n 3", "    even = l[findall(x -> x % 2\
    \ == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n\
    \    even.zip(odd).map(x -> x[1])\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work if the list contains duplicates. For example, `[1,1,2,3]` returns `[1,1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nGood catch! I fixed the code by adding\
    \ `unique` to the `sort` calls.\n<|/ c |>\n<| a dscore=2 |>\nI like using zip\
    \ for this:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(1:length(even))\n\
    \    odd = odd.(1:length(odd))\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate values in `l`\n<|/ c |>\n\
    <| c |>\nIt does work if there are duplicate values in `l`\n<|/ c |>\n<| c |>\n\
    Yes, it does. I tested it before posting my comment. Try it yourself.\n<|/ c |>\n\
    <| c |>\nOh, I see what you mean. Yes, it does work. Sorry about that. I'll edit\
    \ my answer.\n<|/ c |>\n<| c |>\nI edited my answer to fix the problem you mentioned.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution using sortperm:\n<code>", "    even\
    \ = l[findall(x -> x % 2 == 0, l)]\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    return even\nend", "    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n\
    \    even = even.(l)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have duplicates in the list. For example,\
    \ `[1,1,2,3]` will produce `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I see that now.\
    \ Thanks for pointing that out. I will edit my answer.\n<|/ c |>\n<| c |>\nI added\
    \ a version that doesn't have that problem.\n<|/ c |>\n<| c |>\nI added a version\
    \ that doesn't have that problem.\n<|/ c |>\n<| a tags=julia,sorting |>\nI like\
    \ using sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if you have\
    \ duplicates in the list. For example, `[1,1,2,3]` will produce `[1,1,2,3]`.\n\
    <|/ c |>\n<| c |>\nYes, I see that now. Thanks for pointing that out. I will edit\
    \ my answer.\n<|/ c |>\n<| a dscore=3 |>\n<code>\njulia> function sort_odd(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .% 2 == 0)]\n           even = sort(even)\n   \
    \        even = even.(l)\n           return even\n       end\nsort_odd (generic\
    \ function with 1 method)", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    even = union(even, odd)\n    return even\nend", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    even = sort(even)\n    even = even[findall(x -> x % 2 ==\
    \ 0, even)]\n    even = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n\
    \    even = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n    even\
    \ = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n    even = sort(even)\n\
    \    even = even[findall(x -> x % 2 == 0, even)]\n    even = sort(even)\n    even\
    \ = even[findall(x -> x % 2 == 0, even)]\n    even = sort(even)\n    even = even[findall(x\
    \ -> x % 2 == 0, even)]\n    even = sort(even)\n    even = even[findall(x -> x\
    \ % 2 == 0, even)]\n    even = sort(even)\n    even = even[findall(x -> x % 2\
    \ == 0, even)]\n    even = sort(even)\n    even = even[findall(x -> x % 2 == 0,\
    \ even)]\n    even = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n\
    \    even = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n    even\
    \ = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n    even = sort(even)\n\
    \    even = even[findall(x -> x % 2 == 0, even)]\n    even = sort(even)\n    even\
    \ = even[findall(x -> x % 2 == 0, even)]\n    even = sort(even)\n    even = even[findall(x\
    \ -> x % 2 == 0, even)]\n    even = sort(even)\n    even = even[findall(x -> x\
    \ % 2 == 0, even)]\n    even = sort(even)\n    even = even[findall(x -> x % 2\
    \ == 0, even)]\n    even = sort(even)\n    even = even[findall(x -> x % 2 == 0,\
    \ even)]\n    even = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n\
    \    even = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n    even\
    \ = sort(even)\n    even = even[findall(x -> x % 2 == 0, even)]\n    even = sort(even)\n\
    \    even = even[findall(", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    return\
    \ even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays\
    \ |>\nHere's a solution using sortperm:\n<code>", "    even = l[findall(x -> x\
    \ % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend", "    even = l[findall(l .%\
    \ 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n \
    \   odd = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI appreciate your answer, but this does not answer\
    \ my question. I want to know how I can sort a list without using any built-in\
    \ functions. I already know how to sort a list using built-in functions. I want\
    \ to know how I can sort a list without using any built-in functions.\n<|/ c |>\n\
    <| c |>\nI appreciate your answer, but this does not answer my question. I want\
    \ to know how I can sort a list without using any built-in functions. I already\
    \ know how to sort a list using built-in functions. I want to know how I can sort\
    \ a list without using any built-in functions.\n<|/ c |>\n<| c |>\nI appreciate\
    \ your answer, but this does not answer my question. I want to know how I can\
    \ sort a list without using any built-in functions. I already know how to sort\
    \ a list using built-in functions. I want to know how I can sort a list without\
    \ using any built-in functions.\n<|/ c |>\n<| c |>\nI appreciate your answer,\
    \ but this does not answer my question. I want to know how I can sort a list without\
    \ using any built-in functions. I already know how to sort a list using built-in\
    \ functions. I want to know how I can sort a list without using any built-in functions.\n\
    <|/ c |>\n<| c |>\nI appreciate your answer, but this does not answer my question.\
    \ I want to know how I can sort a list without using any built-in functions. I\
    \ already know how to sort a list using built-in functions. I want to know how\
    \ I can sort a list without using any built-in functions.\n<|/ c |>\n<| a tags=sorting,julia\
    \ |>\nThe function sort_odd is wrong. It should be \n<code>", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the list.\
    \ For example, `[1,1,2,3]` returns `[1,2,3]` instead of `[1,1,2,3]`.\n<|/ c |>\n\
    <| c |>\nI believe that `sort!` will sort in-place and thus not require a return\
    \ value.\n<|/ c |>\n<| c |>\n`sort!` will sort in-place and thus not require a\
    \ return value. But `sort!` will sort in-place and thus not require a return value.\
    \ But `sort!` will sort in-place and thus not require a return value. But `sort!`\
    \ will sort in-place and thus not require a return value. But `sort!` will sort\
    \ in-place and thus not require a return value. But `sort!` will sort in-place\
    \ and thus not require a return value. But `sort!` will sort in-place and thus\
    \ not require a return value. But `sort!` will sort in-place and thus not require\
    \ a return value. But `sort!` will sort in-place and thus not require a return\
    \ value. But `sort!` will sort in-place and thus not require a return value. But\
    \ `sort!` will sort in-place and thus not require a return value. But `sort!`\
    \ will sort in-place and thus not require a return value. But `sort!` will sort\
    \ in-place and thus not require a return value. But `sort!` will sort in-place\
    \ and thus not require a return value. But `sort!` will sort in-place and thus\
    \ not require a return value. But `sort!` will sort in-place and thus not require\
    \ a return value. But `sort!` will sort in-place and thus not require a return\
    \ value. But `sort!` will sort in-place and thus not require a return value. But\
    \ `sort!` will sort in-place and thus not require a return value. But `sort!`\
    \ will sort in-place and thus not require a return value. But `sort!` will sort\
    \ in-place and thus not require a return value. But `sort!` will sort in-place\
    \ and thus not require a return value. But `sort!` will sort in-place and thus\
    \ not require a return value. But `sort!` will sort in-place and thus ", "   \
    \ even = l[findall(l .%2 == 0)]\n    odd = l[findall(l .%2 == 1)]\n    even =\
    \ sort_even(even)\n    odd = sort_odd(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a dscore=0 |>\n<code>", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    return even ++\
    \ odd\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(x -> x\
    \ % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n \
    \   odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nThe accepted answer doesn't work for me. Here's a version that does:\n<code>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    even = sort(even)\n    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    return even\nend", "    even = l[findall(x -> x % 2\
    \ == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the input array.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are duplicates in the input array.\
    \ `sort_even([2,3,5,2,4,5,6,7,8])` returns `[2,3,4,5,6,7,8,2,5]`\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if there are duplicates in the input array. `sort_even([2,3,5,2,4,5,6,7,8])`\
    \ returns `[2,3,4,5,6,7,8,2,5]`\n<|/ c |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in the input array. `sort_even([2,3,5,2,4,5,6,7,8])` returns\
    \ `[2,3,4,5,6,7,8,2,5]`\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nI wrote\
    \ a package called ArrayTools.jl which has several sorting algorithms implemented.\n\
    <code>\nusing ArrayTools\nsort_even([2,3,5,2,4,5,6,7,8])\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=4 |>\nI wrote a package called ArrayTools.jl which has several\
    \ sorting algorithms implemented.\n<code>\nusing ArrayTools\nsort_even([2,3,5,2,4,5,6,7,8])\n\
    </code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\n<code>", "    even\
    \ = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even.(1:length(even))\n    odd = odd.(1:length(odd))\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<|\
    \ c |>\nThis is not the fastest solution, but it is very readable. Thanks!\n<|/\
    \ c |>\n<| c |>\nI added a faster solution\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even = sort(even)\n           odd = sort(odd)\n        \
    \   even = even.(1:length(even))\n           odd = odd.(1:length(odd))\n     \
    \      return even .+ odd\n       end", "    even = l[findall(l .% 2 == 0)]\n\
    \    even = sort(even)\n    even = even[findall(even .% 2 == 1)]\n    return even\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you very much for your answer!\
    \ I tried to run your code, but I got an error message saying \"UndefRefError:\
    \ no global function \"sort\" for `l = [2, 5, 1, 4, 3]`\". Do you know why this\
    \ happened? Thanks!\n<|/ c |>\n<| c |>\nI added a link to my answer, which explains\
    \ why `sort` doesn't work. `sort` only works on numeric arrays. If you want a\
    \ more general solution, please see my answer.\n<|/ c |>\n<| c |>\nThank you very\
    \ much for your answer! I tried to run your code, but I got an error message saying\
    \ \"UndefRefError: no global function \"sort\" for `l = [2, 5, 1, 4, 3]`\". Do\
    \ you know why this happened? Thanks!\n<|/ c |>\n<| c |>\nI added a link to my\
    \ answer, which explains why `sort` doesn't work. `sort` only works on numeric\
    \ arrays. If you want a more general solution, please see my answer.\n<|/ c |>\n\
    <| a |>\nYou can use the following code:\n<code>", "    even = l[findall(l .%\
    \ 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n \
    \   odd = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| c |>\nI like your solution, however it\
    \ seems that it only works on vectors of Int64. Is there a way to make it work\
    \ on other types?\n<|/ c |>\n<| c |>\nYes, it works on other types. Just replace\
    \ `Int64` with `Int`, `Float64` with `Float`, `String` with `Any`, etc.\n<|/ c\
    \ |>\n<| c |>\nI edited my answer to include a solution that works for other types\
    \ as well.\n<|/ c |>\n<| a dscore=1 |>\nA simple solution is to sort each subarray\
    \ separately and then concatenate them:\n<code>\njulia> a = [1 2 3 4 5 6 7 8 9\
    \ 10]\n10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10", " \
    \   even = l[findall(l .%2 == 0)]\n    odd = l[findall(l .%2 == 1)]\n    even\
    \ = sort_odd(even)\n    odd = sort_odd(odd)\n    even = sort(even)\n    odd =\
    \ sort(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis doesn't work. `sort` doesn't sort `Int64` vectors.\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I've edited the answer to fix\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution using sort!\n<code>", " \
    \   even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even.sort()\n    odd.sort()\n    even.zip(odd).collect{|x| x[1] }\n\
    end\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nI like this solution, but\
    \ I wonder if there is a way to avoid the allocation of a new array and still\
    \ use sort!\n<|/ c |>\n<| c |>\nI added a version that avoids allocation\n<|/\
    \ c |>\n<| c |>\nI added a version that avoids allocation\n<|/ c |>\n<| c |>\n\
    I added a version that avoids allocation\n<|/ c |>\n<| c |>\nI added a version\
    \ that avoids allocation\n<|/ c |>\n<| a dscore=2 |>\nThe accepted answer by is\
    \ great, but I thought I'd add an alternative that doesn't require allocation:\n\
    <code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n         \
    \  even = l[findall(x -> x % 2 == 0, l)]\n           odd = l[findall(x -> x %\
    \ 2 != 0, l)]\n           even.sort()\n           odd.sort()\n           even.zip(odd).collect{|x|\
    \ x[1] }\n       end\nsort_even (generic function with 1 method)", "    even =\
    \ l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n \
    \   even = sort_odd(even)\n    odd = sort_odd(odd)\n    return even ++ odd\nend",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n\
    </cell>\n<code language=julia-1.5>", "    even = l[findall(l .% 2 == 0)]\n   \
    \ odd = l[findall(l .% 2 .== 1)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n\
    \    even = union(even, odd)\n    return even\nend", "    even = l[findall(l .%\
    \ 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n\
    \    even.zip(odd) \nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis\
    \ does not work if the list contains duplicates.\n<|/ c |>\n<| c |>\nI added a\
    \ version that works with duplicates.\n<|/ c |>\n<| a tags=julia,sorting |>\n\
    The answer by is correct, but I thought I'd add an alternative that doesn't require\
    \ the use of sort. \n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even.zip(odd)\n       end\nsort_even (generic function with\
    \ 1 method)", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n   \
    \ return even ++ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\n\
    This doesn't seem to work. `sort_even([2,4,6,8,10,12,14,16,18,20])` returns `[2,4,6,8,10,12,14,16,18,20]`.\n\
    <|/ c |>\n<| c |>\nOh, I see what you mean. I'll fix it.\n<|/ c |>\n<| c |>\n\
    I fixed it now. Sorry about that.\n<|/ c |>\n<| c |>\nI fixed it now. Sorry about\
    \ that.\n<|/ c |>\n<| c |>\nI fixed it now. Sorry about that.\n<|/ c |>\n<| a\
    \ tags=julia,sorting,arrays |>\nI believe that this is what you are looking for:\n\
    <code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n         \
    \  even = l[findall(x -> x % 2 == 0, l)]\n           odd = l[findall(x -> x %\
    \ 2 != 0, l)]\n           even = sort_odd(even)\n           odd = sort_odd(odd)\n\
    \           return even ++ odd\n       end", "    even = l[findall(x -> x % 2\
    \ == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work if there are duplicates in the list. For example, `[1,1,2,3]`\
    \ will produce `[1,2,3]` instead of `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting. Try it yourself.\n<|/ c |>\n<| c |>\nI tested it\
    \ on Julia 0.6.2 and it works. I guess you used a different version?\n<|/ c |>\n\
    <| c |>\nYes, I used 0.6.2. But I guess you used a different version? I tested\
    \ it on 0.6.2 and it works. I guess you used a different version?\n<|/ c |>\n\
    <| c |>\nI tested it on 0.6.2 and it works. I guess you used a different version?\
    \ I tested it on 0.6.2 and it works. I guess you used a different version?\n<|/\
    \ c |>\n<| a dscore=1 |>\nThis solution uses only a single pass over the input\
    \ array:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n   \
    \ even = union(even, odd)\n    return even\nend", "    even = l[findall(l .% 2\
    \ == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_odd(even)\n    odd\
    \ = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend", "    even\
    \ = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't seem to work. `sort_even([2,4,6,8,10,12,14,16,18,20])` returns `[2,4,6,8,10,12,14,16,18,20]`\
    \ instead of `[2,4,6,8,10,14,18,16,12,20]`.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. I've edited my answer to fix the bug. Thanks!\n<|/ c |>\n<| c |>\nI see\
    \ what you mean. I've edited my answer to fix the bug. Thanks!\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's a solution using sortperm:\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    even = sort_even(even)\n    even = even[findall(even .== 0)]\n\
    \    even = sort_even(even)\n    even = even[findall(even .== 0)]\n    even =\
    \ sort_even(even)\n    even = even[findall(even .== 0)]\n    even = sort_even(even)\n\
    \    even = even[findall(even .== 0)]\n    even = sort_even(even)\n    even =\
    \ even[findall(even .== 0)]\n    even = sort_even(even)\n    even = even[findall(even\
    \ .== 0)]\n    even = sort_even(even)\n    even = even[findall(even .== 0)]\n\
    \    even = sort_even(even)\n    even = even[findall(even .== 0)]\n    even =\
    \ sort_even(even)\n    even = even[findall(even .== 0)]\n    even = sort_even(even)\n\
    \    even = even[findall(even .== 0)]\n    even = sort_even(even)\n    even =\
    \ even[findall(even .== 0)]\n    even = sort_even(even)\n    even = even[findall(even\
    \ .== 0)]\n    even = sort_even(even)\n    even = even[findall(even .== 0)]\n\
    \    even = sort_even(even)\n    even = even[findall(even .== 0)]\n    even =\
    \ sort_even(even)\n    even = even[findall(even .== 0)]\n    even = sort_even(even)\n\
    \    even = even[findall(even .== 0)]\n    even = sort_even(even)\n    even =\
    \ even[findall(even .== 0)]\n    even = sort_even(even)\n    even = even[findall(even\
    \ .== 0)]\n    even = sort_even(even)\n    even = even[findall(even .== 0)]\n\
    \    even = sort_even(even)\n    even = even[findall(even .== 0)]\n    even =\
    \ sort_even(even)\n    even = even[findall(even .== 0)]\n    even = sort_even(even)\n\
    \    even = even[findall(even .== 0)]\n    even = sort_even(even)\n    even =\
    \ even[findall(even .== 0)]\n    even = sort_even(even)\n    even = even[findall(even\
    \ .== 0)]\n    even = sort_even(even)\n    even = even[findall(even .== 0)]\n",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis does not work if there are duplicate elements in the list.\
    \ For example, if `l = [1,2,2,3]`, then `sort_even` returns `[1,2,3]`.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with duplicates.\n<|/ c |>\n<| c |>\n\
    I added a version that works with duplicates.\n<|/ c |>\n<| a dscore=2 |>\nI came\
    \ up with a solution that is more efficient than sorting the entire list and then\
    \ removing duplicates. \n<code>", "    even = l[findall(l .% 2 == 0)]\n    even\
    \ = sort(even)\n    even = even.(l)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ using an anonymous function?\n<|/ c |>\n<| c |>\nI added a solution without\
    \ anonymous function\n<|/ c |>\n<| c |>\nThanks, I appreciate it!\n<|/ c |>\n\
    <| a |>\nHere is a solution without anonymous functions:\n<code>", "    even =\
    \ l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n \
    \   even.sort()\n    odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nI like this solution, but I wonder if there is a way to avoid the explicit\
    \ `findall()` calls. I wonder if there is a way to do this without having to explicitly\
    \ call `findall()`.\n<|/ c |>\n<| c |>\nI added a version that doesn't use `findall()`\n\
    <|/ c |>\n<| c |>\nI added a version that doesn't use `findall()`\n<|/ c |>\n\
    <| c |>\nI added a version that doesn't use `findall()`\n<|/ c |>\n<| c |>\nI\
    \ added a version that doesn't use `findall()`\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nThe other answers here are great, but I thought I'd add one more that uses\
    \ sortperm:\n<code>\njulia> l = rand(1:10, 10)\n10-element Vector{Int64}:\n 3\n\
    \ 2\n 7\n 8\n 9\n 6\n 8\n 2\n 9\n 5\n 7\n 3", "    even = l[findall(x -> x % 2\
    \ == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the original list. For example,\
    \ `[1,1,2,3]` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that doesn't require duplicates :)\n<|/ c |>\n<| a dscore=1 |>\n\
    Here's a solution using Julia's built-in sort!:\n<code>\njulia> function sort_odd(l)\n\
    \           sort!(l, by=x->(x%2==1)?x:(x%2==0)?-(x+1):0)\n       end\nsort_odd\
    \ (generic function with 1 method)", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd\
    \ = sort_odd(odd)\n    even = even.(1:length(even))\n    odd = odd.(1:length(odd))\n\
    \    even = even.(2:length(even))\n    odd = odd.(2:length(odd))\n    even = even.(3:length(even))\n\
    \    odd = odd.(3:length(odd))\n    even = even.(4:length(even))\n    odd = odd.(4:length(odd))\n\
    \    even = even.(5:length(even))\n    odd = odd.(5:length(odd))\n    even = even.(6:length(even))\n\
    \    odd = odd.(6:length(odd))\n    even = even.(7:length(even))\n    odd = odd.(7:length(odd))\n\
    \    even = even.(8:length(even))\n    odd = odd.(8:length(odd))\n    even = even.(9:length(even))\n\
    \    odd = odd.(9:length(odd))\n    even = even.(10:length(even))\n    odd = odd.(10:length(odd))\n\
    \    even = even.(11:length(even))\n    odd = odd.(11:length(odd))\n    even =\
    \ even.(12:length(even))\n    odd = odd.(12:length(odd))\n    even = even.(13:length(even))\n\
    \    odd = odd.(13:length(odd))\n    even = even.(14:length(even))\n    odd =\
    \ odd.(14:length(odd))\n    even = even.(15:length(even))\n    odd = odd.(15:length(odd))\n\
    \    even = even.(16:length(even))\n    odd = odd.(16:length(odd))\n    even =\
    \ even.(17:length(even))\n    odd = odd.(17:length(odd))\n    even = even.(18:length(even))\n\
    \    odd = odd.(18:length(odd))\n    even = even.(19:length(even))\n    odd =\
    \ odd.(19:length(odd))\n    even = even.(20:length(even))\n    odd = odd.(20:length(odd))\n\
    \    even = even.(21:length(even))\n    odd = odd.(21:length(odd))\n    ", " \
    \   even = l[findall(x -> x % 2 == 0, l)]\n    even = sort(even)\n    even = even.(l)\n\
    \    return even\nend\n</cell>\n<code language=julia-1.0>", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    return even .+ odd\nend", "    even = l[findall(l\
    \ .%2 == 0)]\n    odd = l[findall(l .%2 == 1)]\n    even = sort_even(even)\n \
    \   odd = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nThe answer by is correct, but I thought I'd\
    \ add some explanation as to why it works.\nThe function sort_even is called recursively,\
    \ but only on the even indices of the input vector. \nThe function sort_odd is\
    \ called recursively, but only on the odd indices of the input vector. \nThe function\
    \ sort_even is called recursively, but only on the even indices of the input vector.\
    \ \nThe function sort_odd is called recursively, but only on the odd indices of\
    \ the input vector. \nThe function sort_even is called recursively, but only on\
    \ the even indices of the input vector. \nThe function sort_odd is called recursively,\
    \ but only on the odd indices of the input vector. \nThe function sort_even is\
    \ called recursively, but only on the even indices of the input vector. \nThe\
    \ function sort_odd is called recursively, but only on the odd indices of the\
    \ input vector. \nThe function sort_even is called recursively, but only on the\
    \ even indices of the input vector. \nThe function sort_odd is called recursively,\
    \ but only on the odd indices of the input vector. \nThe function sort_even is\
    \ called recursively, but only on the even indices of the input vector. \nThe\
    \ function sort_odd is called recursively, but only on the odd indices of the\
    \ input vector. \nThe function sort_even is called recursively, but only on the\
    \ even indices of the input vector. \nThe function sort_odd is called recursively,\
    \ but only on the odd indices of the input vector. \nThe function sort_even is\
    \ called recursively, but only on the even indices of the input vector. \nThe\
    \ function sort_odd is called recursively, but only on the odd indices of the\
    \ input vector. \nThe function sort_even is called recursively, but only on the\
    \ even indices of the input vector. \nThe function sort_odd is called recursively,\
    \ but only on the odd indices of the input vector. \nThe function sort_even is\
    \ called recursively, but only on the even indices of the input vector. \nThe\
    \ function sort_odd is called recursively, but only on the odd indices of the\
    \ input vector. \nThe function sort_even is called recursively, but only on the\
    \ even indices of the input vector. \nThe function sort_odd is called recursively,\
    \ but only on the odd indices of the input vector. \n", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    return even .+ odd\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n  \
    \  odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n   \
    \ even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for your answer! I really appreciate it! I ran your code, but I got this\
    \ error: `ERROR: LoadError: ArgumentError: invalid argument to find_index: Int64\
    \ does not have a method find_index`\n<|/ c |>\n<| c |>\nI added the function\
    \ `find_index` I used into the answer. Maybe you used a different function or\
    \ used the wrong argument type?\n<|/ c |>\n<| c |>\nI used the function you added\
    \ into the answer. Maybe I used the wrong argument type?\n<|/ c |>\n<| c |>\n\
    I added the function `find_index` I used into the answer. Maybe you used a different\
    \ function or used the wrong argument type?\n<|/ c |>\n<| c |>\nI added the function\
    \ `find_index` I used into the answer. Maybe you used a different function or\
    \ used the wrong argument type?\n<|/ c |>\n<| a tags=julia |>\nI used the function\
    \ you added into the answer. Maybe I used the wrong argument type?", "    even\
    \ = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n\
    \    even = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even,\
    \ odd)\n    return even\nend", "    even = l[findall(l .% 2 == 0)]\n    odd =\
    \ l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ work for me. `sort_even([1,3,5,7,9])` returns `[3, 5, 7, 1, 9]` instead of `[7,\
    \ 5, 3, 1, 9]`.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out.\
    \ Sorry about that.\n<|/ c |>\n<| c |>\nThanks for your answer! I tested it and\
    \ it works perfectly. Could you please explain why you used `@inbounds` here?\
    \ I didn't know that `@inbounds` existed in Julia.\n<|/ c |>\n<| c |>\n`@inbounds`\
    \ tells Julia to only evaluate the function on the bounds of the array (in this\
    \ case `l[findall(l .% 2 == 0)]`). Since `l` is an array, `@inbounds` tells Julia\
    \ to only evaluate the function on the bounds of the array `l`. The `findall`\
    \ function returns a vector of indices where `l` has an even number, so `@inbounds`\
    \ tells Julia to only evaluate the function on the bounds of the vector returned\
    \ by `findall`.\n<|/ c |>\n<| c |>\nOh I see. Thanks a lot!\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nI wrote a function that sorts even and odd numbers in an array:\n<code>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_odd(even)\n    odd = sort_odd(odd)\n    even = union(even, odd)\n   \
    \ return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't seem to work. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nOops, I missed the fact that `sort_even` was supposed to return\
    \ a sorted array. I've edited my answer to fix this.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nOops, I missed the fact that `sort_even` was supposed to return\
    \ a sorted array. I've edited my answer to fix this.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| a tags=julia,sorting,arrays |>\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    even = sort_odd(even)\n    even = sort(even)\n    return even\n\
    end", "    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    odd\
    \ = l[findall(l .% 2 .== 1)]\n    odd = sort_odd(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to\
    \ work. `sort_even([1,3,5,7,9])` returns `[3, 5, 7, 1, 9]` instead of `[7, 5,\
    \ 3, 1, 9]`.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out.\
    \ Now it works.\n<|/ c |>\n<| a tags=sorting,julia |>\nI believe that you can\
    \ do this with sortperm:\n<code>\njulia> sortperm([1,3,5,7,9])\n10-element Array{Int64,1}:\n\
    \ 3\n 5\n 7\n 1\n 9\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to\
    \ work. `sortperm([1,3,5,7,9])` returns `[3, 5, 7, 1, 9]` instead of `[7, 5, 3,\
    \ 1, 9]`.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now\
    \ it works.\n<|/ c |>\n<| a tags=sorting,julia |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\
    \ \n           even = l[findall(l .% 2 == 0)]\n           even = sort_even(even)\n\
    \           odd = l[findall(l .% 2 .== 1)]\n           odd = sort_odd(odd)\n \
    \          even = union(even, odd)\n           return even\n       end", "   \
    \ even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    even = even.(1:length(even))\n    odd\
    \ = odd.(1:length(odd))\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work. `sort` sorts both even and odd indicies in parallel.\
    \ `sort!` sorts them in sequence. `sort!` also sorts both even and odd indicies\
    \ in parallel. `sort!` also sorts them in sequence. `sort!` also sorts both even\
    \ and odd indicies in parallel. `sort!` also sorts them in sequence. `sort!` also\
    \ sorts both even and odd indicies in parallel. `sort!` also sorts them in sequence.\
    \ `sort!` also sorts both even and odd indicies in parallel. `sort!` also sorts\
    \ them in sequence. `sort!` also sorts both even and odd indicies in parallel.\
    \ `sort!` also sorts them in sequence. `sort!` also sorts both even and odd indicies\
    \ in parallel. `sort!` also sorts them in sequence. `sort!` also sorts both even\
    \ and odd indicies in parallel. `sort!` also sorts them in sequence. `sort!` also\
    \ sorts both even and odd indicies in parallel. `sort!` also sorts them in sequence.\
    \ `sort!` also sorts both even and odd indicies in parallel. `sort!` also sorts\
    \ them in sequence. `sort!` also sorts both even and odd indicies in parallel.\
    \ `sort!` also sorts them in sequence. `sort!` also sorts both even and odd indicies\
    \ in parallel. `sort!` also sorts them in sequence. `sort!` also sorts both even\
    \ and odd indicies in parallel. `sort!` also sorts them in sequence. `sort!` also\
    \ sorts both even and odd indicies in parallel. `sort!` also sorts them in sequence.\
    \ `sort!` also sorts both even and odd indicies in parallel. `sort!` also sorts\
    \ them in sequence. `sort!` also ", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd\
    \ = sort_odd(odd)\n    even = sort(even)\n    odd = sort(odd)\n    return even\
    \ ++ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\n\
    Here's a solution that doesn't require any packages:\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend", "    even\
    \ = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n\
    \    even = sort_even(even)\n    odd = sort_odd(odd)\n    even = union(even, odd)\n\
    \    return even\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution,\
    \ thank you! I didn't know about `union`, so I learned something new today. Also,\
    \ thanks for the tip about `sort!`. I didn't know about that either.\n<|/ c |>\n\
    <| c |>\nI added a solution that uses `sort!`\n<|/ c |>\n<| c |>\nI added a solution\
    \ that uses `sort!`\n<|/ c |>\n<| a tags=julia |>\nI like your solution, thank\
    \ you! I didn't know about union, so\n  I learned something new today. Also, thanks\
    \ for the tip about\n  sort!. I didn't know about that either.", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like your solution, but I wonder why you chose to write `l .%\
    \ 2 == 0` instead of `l .% 2 == 1`?\n<|/ c |>\n<| c |>\nI didn't know that `%`\
    \ could be used like that. Thanks!\n<|/ c |>\n<| c |>\nI guess it's because `%`\
    \ is an operator that works on vectors and matrices. `l` is an `Int64` so `l .%\
    \ 2 == 0` gives a vector of booleans indicating which elements are odd or even.\n\
    <|/ c |>\n<| c |>\nI see. Thanks for the explanation!\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even = sort_even(even)\n           odd = sort_odd(odd)\n\
    \           return even ++ odd\n       end", "    even = l[findall(x -> x % 2\
    \ == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution, but I believe it can\
    \ be simplified a bit. `even = l[findall(x -> x % 2 == 0, l)]` can be written\
    \ as `even = l[findall(x -> x % 2 == 0, l)]` since `findall` returns a `Vector{Int}`.\n\
    <|/ c |>\n<| c |>\nYes, I agree. I was trying to keep it close to the original\
    \ code as much as possible.\n<|/ c |>\n<| c |>\nI like your solution, but I believe\
    \ it can be simplified a bit. `even = l[findall(x -> x % 2 == 0, l)]` can be written\
    \ as `even = l[findall(x -> x % 2 == 0, l)]` since `findall` returns a `Vector{Int}`.\n\
    <|/ c |>\n<| c |>\nYes, I agree. I was trying to keep it close to the original\
    \ code as much as possible.\n<|/ c |>\n<| c |>\nI like your solution, but I believe\
    \ it can be simplified a bit. `even = l[findall(x -> x % 2 == 0, l)]` can be written\
    \ as `even = l[findall(x -> x % 2 == 0, l)]` since `findall` returns a `Vector{Int}`.\n\
    <|/ c |>\n<| a dscore=1 |>\nThe other answers here are great, but I thought I'd\
    \ add my own solution, which is slightly different in that it doesn't use any\
    \ extra memory and doesn't require any extra packages.\n<code>", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even.(l)\n    odd = odd.(l)\n    return even\
    \ ++ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this solution, but\
    \ I wonder if there is a way to do it without using an anonymous function?\n<|/\
    \ c |>\n<| c |>\nI added a version without anonymous function\n<|/ c |>\n<| a\
    \ tags=julia |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(x -> x % 2 == 0, l)]\n           odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n           even = sort(even)\n           odd = sort(odd)\n\
    \           even = even.(l)\n           odd = odd.(l)\n           return even\
    \ ++ odd\n       end\nsort_even (generic function with 1 method)", "    even =\
    \ l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n \
    \   even = sort_even(even)\n    odd = sort_odd(odd)\n    even = union(even, odd)\n\
    \    return even\nend", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n    even =\
    \ sort(even)\n    odd = sort(odd)\n    even = union(even, odd)\n    return even\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to avoid the copying.\n<|/ c |>\n<| c |>\nI added a version that\
    \ avoids copying, but it's still a little bit slower than the other solutions.\n\
    <|/ c |>\n<| c |>\nI added a version that avoids copying, but it's still a little\
    \ bit slower than the other solutions.\n<|/ c |>\n<| a tags=julia,sorting |>\n\
    Here's a version that avoids copying by using a mutable array and sorting it in-place:\n\
    <code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x ->\
    \ x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    even.zip(odd).collect{Tuple{Int64,\
    \ Int64}}\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3,4,5,6,7,8,9,10])`\
    \ returns `[1,2,3,4,5,6,7,8,9,10]` instead of `[1,2,3,4,5,6,7,8,9,10,11]`\n<|/\
    \ c |>\n<| c |>\nI tested it and it works. Are you sure you copied the code correctly?\n\
    <|/ c |>\n<| c |>\nYes, I copied it exactly. I'm running Julia 0.6.2\n<|/ c |>\n\
    <| c |>\nI tested it on 0.6.2 and it works. Are you sure you copied the code correctly?\n\
    <|/ c |>\n<| c |>\nI tested it on 0.6.2 and it works. Are you sure you copied\
    \ the code correctly?\n<|/ c |>\n<| a tags=julia,sorting |>\nI came up with this\
    \ solution:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n  \
    \  even = sort(even)\n    odd = sort(odd)\n    return even ++ odd\nend", "   \
    \ even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even = union(even,\
    \ odd)\n    return even\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n  \
    \  odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd =\
    \ sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work for me. `sort_even([1,3,5,7,9,11,13,15,17,19])`\
    \ returns `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]`\n<|/ c |>\n<| c\
    \ |>\nI tested it and it works. I guess you forgot to copy the function definition.\
    \ Try copying the function definition from the answer above.\n<|/ c |>\n<| c |>\n\
    Oh I see. Yeah I forgot to copy the function definition. Thanks!\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n\
    \    even = sort(even)\n    odd = sort(odd)\n    even = union(even, odd)\n   \
    \ return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if the list contains duplicates.\n<|/ c |>\n<| c |>\nIt does work if you\
    \ use `sort!` instead of `sort`.\n<|/ c |>\n<| a dscore=2 |>\nThe accepted answer\
    \ doesn't work for duplicates. Here's a version that does:\n<code>", "    even\
    \ = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n\
    \    even = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even,\
    \ odd)\n    return even\nend", "    even = l[findall(l .% 2 == 0)]\n    odd =\
    \ l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis does not work if there are duplicate elements in the input\
    \ array. For example, `sort_even([1,2,2,3,4])` returns `[1,1,2,3,4]`.\n<|/ c |>\n\
    <| c |>\nI see what you mean. I've edited my answer to fix that problem.\n<|/\
    \ c |>\n<| a |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    even = union(even, odd)\n    return even\nend", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    even = sort(even)\n    even = even.(l)\n    return even\n\
    end\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work for\
    \ me. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]` instead\
    \ of `[1,2,3,4,5,6,7,8,9,10,1]`.\n<|/ c |>\n<| c |>\nI tested it and it worked\
    \ for me. Did you copy the code exactly? I used `sort_even([1,2,3,4,5,6,7,8,9,10])`\
    \ as my input.\n<|/ c |>\n<| c |>\nYes, I copied it exactly. I'm using Julia 0.6.2\n\
    <|/ c |>\n<| c |>\nI tested it on 0.6.2 and it works. I guess something went wrong\
    \ with the installation. I'll try to reinstall and see if it works.\n<|/ c |>\n\
    <| c |>\nI reinstalled Julia 0.6.2 and it worked. Thanks for your help.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nThe accepted answer does not work for me on Julia 0.6.2.\
    \ I tried the following:\n<code>\njulia> sort_even([1,2,3,4,5,6,7,8,9,10])\n10-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n</code>\nThe correct\
    \ answer should be:\n<code>\njulia> sort_even([1,2,3,4,5,6,7,8,9,10])\n10-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n 1\n</code>\nThe reason\
    \ is that Julia 0.6.2 does not sort arrays by default when they are passed as\
    \ parameters. To fix this you can use the following code:\n<code>\njulia> sort_even([1,2,3,4,5,6,7,8,9,10])\n\
    10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays |>\nThe accepted\
    \ answer does not work for me on Julia 0.6.2. I tried the following:\n<code>\n\
    julia> ", "    even = l[findall(l .% 2 == 0)]\n    even = sort_odd(even)\n   \
    \ even = sort(even)\n    return even\nend", "    even = l[findall(x -> x % 2 ==\
    \ 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n  \
    \  odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI like the idea of using an anonymous function and `findall`. However,\
    \ this doesn't seem to work if you have a vector with negative numbers. `sort_even([-5,-4,-3,-2,-1,0,1,2,3,4,5])`\
    \ returns `[-5,-4,-3,-2,-1,0,1,2,3,4,5]` instead of `[-5,-4,-3,-2,-1,0,1,2,3,4,5,6]`\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've edited my answer to account for negative\
    \ numbers. I didn't realize that `sort` would sort negative numbers differently\
    \ than positive numbers.\n<|/ c |>\n<| c |>\nI see what you mean. I've edited\
    \ my answer to account for negative numbers. I didn't realize that `sort` would\
    \ sort negative numbers differently than positive numbers.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere's a solution using sort!\n<code>", "    even = l[findall(x -> x % 2\
    \ == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\nYes, it does. I tested it on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nYes, it\
    \ does. I tested it on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nYes, it does. I tested\
    \ it on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nI tested it on `Array{Int64,1}` and\
    \ it works. I guess you didn't test it on `Array{Int64,2}`\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    return even\
    \ .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThanks for\
    \ the answer! I actually tried this before posting the question, but I got an\
    \ error saying \"MethodError: no method matching sort(::Int64)\" which I couldn't\
    \ figure out how to fix. Maybe I did something wrong.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include a solution that should work\n<|/ c |>\n<| c |>\nThanks!\
    \ This works perfectly! I didn't know that you could use an anonymous function\
    \ like that. I'm still new to Julia, so I appreciate your help.\n<|/ c |>\n<|\
    \ c |>\nGlad it helped! I added a more efficient solution that should work even\
    \ for very large lists.\n<|/ c |>\n<| c |>\nThanks again! I appreciate it!\n<|/\
    \ c |>\n<| a tags=julia,sorting,arrays |>\nYou can use the built-in function sort!\
    \ to sort an array:\n<code>\njulia> a = [1, 3, 2]\n2-element Array{Int64,1}:\n\
    \ 1\n 3\n 2", "    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n   \
    \ even = even.(l)\n    return even\nend", "    even = l[findall(l .% 2 == 0)]\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nHere's a solution\
    \ using sortperm:\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    even\
    \ = sort_odd(even)\n    even = even.(l)\n    return even\nend", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like the idea of using an iterator to sort\
    \ and avoid the copying, but this doesn't seem to work. `sort_even([2,3,5,1,4,6,7])`\
    \ returns `[2,3,4,5,6,7,1]` instead of `[2,3,4,5,6,7]`.\n<|/ c |>\n<| c |>\nI\
    \ see what you mean. I didn't realize that `sort` would sort the even indices.\
    \ I edited my answer to fix it.\n<|/ c |>\n<| c |>\nI added a version that doesn't\
    \ require an extra copy of the list.\n<|/ c |>\n<| a dscore=2 |>\nThe other answers\
    \ here are great, but I thought I'd add my own solution, which is more efficient\
    \ than sorting the entire list and then copying it.\n<code>", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    even = sort(even)\n    odd = sort(odd)\n    even\
    \ = union(even, odd)\n    return even\nend", "    even = l[findall(x -> x % 2\
    \ == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `sort_even([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| c |>\nIt does work. `sort_even([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| c |>\nIt does work. `sort_even([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| c |>\nIt does work. `sort_even([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| c |>\nIt does work. `sort_even([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| a tags=sorting,julia |>\nI believe this can be done using sortperm:\n\
    <code>\njulia> sortperm([1,3,5,7,9,11])\n10-element Array{Int64,1}:\n 2\n 3\n\
    \ 1\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. `sortperm([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n<|/ c |>\n\
    <| c |>\nIt does work. `sortperm([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| c |>\nIt does work. `sortperm([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| c |>\nIt does work. `sortperm([1,3,5,7,9,11])` returns `[1,2,3,4,5,6,7,8,9,11]`\n\
    <|/ c |>\n<| c |>\nIt does work. `", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd\
    \ = sort_odd(odd)\n    even = even.(odd)\n    return even\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd =\
    \ l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer! I didn't\
    \ know about `sort!`. However, this doesn't seem to work if I try to use it on\
    \ `l = [1, 3, 2]`. I get `[1 3 2]` instead of `[1 2 3]`.\n<|/ c |>\n<| c |>\n\
    I tested it on `l = [1, 3, 2]` and it works. What is the code you are using?\n\
    <|/ c |>\n<| c |>\nI used `sort!` instead of `sort` and it worked. Thanks!\n<|/\
    \ c |>\n<| c |>\nAh yes, I forgot about that. Thanks for pointing it out!\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd\
    \ = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend", "    even\
    \ = l[findall(x -> x % 2 == 0, l)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    return even\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\nI like your solution, but I wonder why you use `sort`\
    \ instead of `sort!`? I guess it makes a difference because `sort!` will mutate\
    \ the original vector, but `sort` will not.\n<|/ c |>\n<| c |>\n`sort!` will mutate\
    \ the original vector, but `sort` will not. `sort!` will mutate the original vector,\
    \ but `sort` will not. `sort!` will mutate the original vector, but `sort` will\
    \ not.\n<|/ c |>\n<| c |>\n`sort!` will mutate the original vector, but `sort`\
    \ will not. `sort!` will mutate the original vector, but `sort` will not. `sort!`\
    \ will mutate the original vector, but `sort` will not. `sort!` will mutate the\
    \ original vector, but `sort` will not. `sort!` will mutate the original vector,\
    \ but `sort` will not. `sort!` will mutate the original vector, but `sort` will\
    \ not. `sort!` will mutate the original vector, but `sort` will not. `sort!` will\
    \ mutate the original vector, but `sort` will not. `sort!` will mutate the original\
    \ vector, but `sort` will not. `sort!` will mutate the original vector, but `sort`\
    \ will not. `sort!` will mutate the original vector, but `sort` will not. `sort!`\
    \ will mutate the original vector, but `sort` will not. `sort!` will mutate the\
    \ original vector, but `sort` will not. `sort!` will mutate the original vector,\
    \ but `sort` will not. `sort!` will mutate the original vector, but `sort` will\
    \ not. `sort!` will mutate the original vector, but `sort` will not. `sort!` will\
    \ mutate the original vector, but `sort` will not. `sort!` will mutate the original\
    \ vector, but `sort` will not. `sort!` will mutate the original vector, but `sort`\
    \ will not. `sort!` will mutate the original vector, but `sort` will not. `sort!`\
    \ will mutate the original vector, but `sort` will not. `", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    I like your solution, however it fails for `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort(even)\n   \
    \ odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThis doesn't work. `sort` sorts in-place, so `even` will still be sorted\
    \ after `sort` is called.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted\
    \ my answer. Thanks for pointing that out.\n<|/ c |>\n<| a dscore=1 |>\nThe easiest\
    \ way is to use mapslices:\n<code>\njulia> using BenchmarkTools", "    even =\
    \ l[findall(x -> x % 2 == 0, l)]\n    even = sort(even)\n    even = even.(l)\n\
    \    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem\
    \ to work. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine for me. Can you post the code\
    \ you used?\n<|/ c |>\n<| c |>\nI used `sort_even([1,2,3,4,5,6,7,8,9,10])`\n<|/\
    \ c |>\n<| c |>\nI edited my answer to include a working solution. Hope it helps!\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine for me. Can you post the code\
    \ you used?\n<|/ c |>\n<| a tags=julia |>\nHere is a solution using sortperm:\n\
    <code>\njulia> function sort_even(l::Vector{Int64})\n           even = l[findall(x\
    \ -> x % 2 == 0, l)]\n           even = sortperm(even)\n           even = even.(l)\n\
    \           return even\n       end\nsort_even (generic function with 1 method)",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(l)\n    odd\
    \ = odd.(l)\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thank you for taking the time to write this up. I'm going to try this out and\
    \ see how it works.\n<|/ c |>\n<| c |>\nI ran your function and got this error:\
    \ `ERROR: LoadError: ArgumentError: invalid argument index for type Int64\n  in\
    \ anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/GitHub/julia-lang/julia-lang/base/types.jl:425\n\
    \  in anonymous at /Users/james/Documents/", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<|\
    \ c |>\nThis doesn't work if there are duplicate values in the array. For example,\
    \ `[1,1,2,3]` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nI added\
    \ a version that doesn't have this problem.\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\njulia> using Statistics", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    return even .+ odd\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n  \
    \  odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n   \
    \ even.zip(odd)\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThanks for\
    \ your answer! I tested your solution and it works fine. However I wanted to avoid\
    \ the use of loops and use vectorized functions. I edited my question to reflect\
    \ this.\n<|/ c |>\n<| c |>\nI edited my answer to include a vectorized solution.\
    \ Hope it helps!\n<|/ c |>\n<| c |>\nThanks for your answer! I tested your solution\
    \ and it works fine. However I wanted to avoid the use of loops and use vectorized\
    \ functions. I edited my question to reflect this.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include a vectorized solution. Hope it helps!\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nHere's a vectorized solution that uses broadcasting to avoid loops:\n<code>\n\
    julia> function sort_odd(l::Vector{Int64})::Vector{Int64}\n           odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n           even = l[findall(x -> x % 2 == 0, l)]\n     \
    \      even.sort()\n           odd.sort()\n           even.zip(odd)\n       end",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n    l[findall(l .% 2\
    \ == 0)] = odd\n    return l\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c\
    \ |>\nI like the idea of using `.%` instead of `==` here, but I wonder if that\
    \ would actually be faster than the other solutions posted here?\n<|/ c |>\n<|\
    \ c |>\nI haven't tested it, but I suspect that `==` will be faster, since it\
    \ avoids allocating a new array and copying all the elements.\n<|/ c |>\n<| c\
    \ |>\nI tested it and it seems that `==` is indeed faster, but only by a small\
    \ margin.\n<|/ c |>\n<| c |>\nI added a benchmark test to my answer. `==` seems\
    \ to be the fastest solution, at least for small arrays. I suspect that `sort`\
    \ will be faster for larger arrays, but I haven't tested it.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64} \n  \
    \         even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 .==\
    \ 1)]\n           even = sort(even)\n           odd = sort(odd)\n           l\
    \ = copy(even)\n           l[findall(l .% 2 == 0)] = odd\n           return l\n\
    \       end\nsort_even (generic function with 1 method)", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI like your solution, however it seems to me that `sort` will do\
    \ more work than necessary since it needs to sort both even and odd indices. So\
    \ it would be better to just do `even.zip(odd)` instead of `even.sort(); odd.sort();\
    \ even.zip(odd)`.\n<|/ c |>\n<| c |>\nI agree with you, however I wanted to show\
    \ that `sort` can be used for this purpose. Also, `sort` will do more work than\
    \ necessary since it needs to sort both even and odd indices. So it would be better\
    \ to just do `even.zip(odd)` instead of `even.sort(); odd.sort(); even.zip(odd)`.\n\
    <|/ c |>\n<| c |>\nI agree with you, however I wanted to show that `sort` can\
    \ be used for this purpose. Also, `sort` will do more work than necessary since\
    \ it needs to sort both even and odd indices. So it would be better to just do\
    \ `even.zip(odd)` instead of `even.sort(); odd.sort(); even.zip(odd)`.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nI believe that this is what you are looking for:\n<code>\n\
    julia> l = rand(1:10, 10)\n10-element Array{Int64,1}:\n 3\n 2\n 6\n 7\n 8\n 9\n\
    \ 2\n 3\n 9\n 5", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n    even.zip(odd)\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wanted to add another solution\
    \ that is more efficient than using sort. \n<code>", "    even = l[findall(x ->\
    \ x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort_even(even)\n\
    \    odd = sort_odd(odd)\n    even = union(even, odd)\n    return even\nend",
  "    even = l[findall(l .%2 == 0)]\n    odd = l[findall(l .%2 == 1)]\n    even.sort()\
    \ \n    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3,4,5,6,7,8,9,10])`\
    \ returns `[1,2,3,4,5,6,7,8,9,10,1]`.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I edited my answer to include a test case.\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works. I edited my answer to include a test case.\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works. I edited my answer to include a test case.\n<|/ c |>\n<| c\
    \ |>\nI tested it and it works. I edited my answer to include a test case.\n<|/\
    \ c |>\n<| a tags=julia,sorting |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=sorting,julia,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the input array.\
    \ For example, `[1,1,2,3]` will give `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nYes, I see that now. Thanks for pointing that out. I will update my answer.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even = sort_even(even)\n           odd = sort_odd(odd)\n\
    \           even = union(even, odd)\n           return even\n       end\nsort_even\
    \ (generic function with 1 method)", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work. `sort_even([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I even tested it on Julia 0.6.2\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I even tested it on\
    \ Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I even\
    \ tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and\
    \ it works. I even tested it on Julia 0.6.2\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nThe answer by is correct, but I thought I'd add some explanation as to why\
    \ it works.\nThe reason why this works is because Julia's sort function works\
    \ by first sorting by the first element of each element in the input vector, and\
    \ then sorting by the second element of each element in the input vector, and\
    \ so on. So, for example, if we have the following vector:\n<code>\njulia> x =\
    \ [10, 20, 30, 40, 50, 60, 70, 80, 90]\n10-element Array{Int64,1}:\n 10\n 20\n\
    \ 30\n 40\n 50\n 60\n 70\n 80\n 90\n</code>\nWe can see that Julia's sort function\
    \ sorts by the first element first, then by the second element, and so on:\n<code>\n\
    julia> sort(x)\n10-element Array{Int64,1}:\n 10\n 20\n 30\n 40\n 50\n 60\n 70\n\
    \ 80\n 90\n</code>\nWe can see that if we sort by the first element first, then\
    \ by the second element, then by the third element, and so on, we get the following\
    \ vector:\n<code>\njulia> sort(x, by=x[1])\n10-element Array{Int64,1}:\n 10\n\
    \ 20\n 30\n 40\n 50\n 60\n 70\n 80\n 90\n</code>\nWe can see that if we sort by\
    \ the first ", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ .== 1)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n    even = union(even,\
    \ odd)\n    return even\nend", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .!= 0)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work for me. `sort_even([2,1,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])`\
    \ returns `[2,1,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]` instead of\
    \ `[2,1,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,2,1]`.\n<|/ c |>\n<|\
    \ c |>\nI tested it on Julia 1.5.1 and it works. I suspect that you are using\
    \ an older version of Julia. Can you try the code I posted above?\n<|/ c |>\n\
    <| c |>\nI tested it on Julia 1.5.1 and it works. I suspect that you are using\
    \ an older version of Julia. Can you try the code I posted above?\n<|/ c |>\n\
    <| c |>\nI tested it on Julia 1.5.1 and it works. I suspect that you are using\
    \ an older version of Julia. Can you try the code I posted above?\n<|/ c |>\n\
    <| c |>\nI tested it on Julia 1.5.1 and it works. I suspect that you are using\
    \ an older version of Julia. Can you try the code I posted above?\n<|/ c |>\n\
    <| a dscore=1 |>\nHere is a solution using Julia's built-in sort!:\n<code>", " \
    \   even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n   \
    \ even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n\
    </cell>\n<code language=julia-1.5>", "    even = l[findall(x -> x % 2 == 0, l)]\n\
    \    odd = l[findall(x -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<|\
    \ c |>\nThis doesn't work if there are repeated elements in the input vector.\
    \ For example, `[1,2,2,3]` will give `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I noticed\
    \ that and fixed it\n<|/ c |>\n<| a dscore=2 |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(x -> x % 2 == 0, l)]\n           odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n           even = sort(even)\n           odd = sort(odd)\n\
    \           return even .+ odd\n       end\nsort_even (generic function with 1\
    \ method)", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .==\
    \ 1)]\n    even = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nI like your answer but I don't think it\
    \ answers the question. Your function `sort_even` doesn't sort the even indicies\
    \ of `l` but rather sorts the even indicies of `l` itself. This is not what the\
    \ OP asked for. He wants to sort the even indicies of `l` while keeping the odd\
    \ indicies untouched.\n<|/ c |>\n<| c |>\nI agree with you. I was just trying\
    \ to give a general solution that would work for any `Vector{Int64}`. But I guess\
    \ I misunderstood the question. I'll edit my answer.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to reflect your comment. Thanks for pointing that out.\n<|/ c |>\n\
    <| c |>\nI edited my answer to reflect your comment. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a dscore=2 |>\nI believe that you can do this with sortperm:\n\
    <code>\njulia> sortperm([1,2,3,4,5,6,7,8,9,10])\n10-element Array{Int64,1}:\n\
    \ 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    This doesn't work if you want the even indices to be sorted as well as the odd\
    \ indices.\n<|/ c |>\n<| c |>\nI believe that `sortperm` sorts both even and odd\
    \ indices. I tested this on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested this on Julia\
    \ 0.6.2. It sorts both even and odd indices. I tested this on Julia 0.6.2. It\
    \ sorts both even and odd indices. I tested this on Julia 0.6.2. It sorts both\
    \ even and odd indices. I tested this on Julia 0.6.2. It sorts both even and odd\
    \ indices. I tested this on Julia 0.6.2. It sorts both even and odd indices. I\
    \ tested this on Julia 0.6.2. It sorts both even and odd indices. I tested this\
    \ on Julia 0.6.2. It sorts both ", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 .== 1)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n\
    \    even = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=sorting,julia |>\nI like using sortperm:\n<code>\n\
    julia> sortperm([1,2,3,4,5,6,7,8,9,10])\n10-element Array{Int64,1}:\n 9\n 8\n\
    \ 7\n 6\n 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia\
    \ |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3,4,5,6,7,8,9,10])\n\
    10-element Array{Int64,1}:\n 9\n 8\n 7\n 6\n 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia>\
    \ sortperm([1,2,3,4,5,6,7,8,9,10])\n10-element Array{Int64,1}:\n 9\n 8\n 7\n 6\n\
    \ 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,julia |>\n\
    <code>\njulia> sortperm([1,2,3,4,5,6,7,8,9,10])\n10-element Array{Int64,1}:\n\
    \ 9\n 8\n 7\n 6\n 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,julia\
    \ |>\n<code>\njulia> sortperm([1,2,3,4,5,6,7,8,9,10])\n10-element Array{Int64,1}:\n\
    \ 9\n 8\n 7\n 6\n 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease\
    \ don't post only code as an answer, but also provide an explanation of what your\
    \ code does and how it solves the problem of the question. Answers with an explanation\
    \ are usually more helpful and of better quality, and are more likely to attract\
    \ upvotes\n<|/ c ", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    even = union(even, odd)\n    return even\n\
    end", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x %\
    \ 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    return\
    \ even ++ odd\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    return even\
    \ .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for the answer! I\
    \ actually ended up doing something similar, but I wanted to know if there was\
    \ a more elegant solution. I'll accept your answer since it does work, but I'm\
    \ still interested in seeing if there's a more elegant solution.\n<|/ c |>\n<|\
    \ c |>\nI added a more elegant solution. Hope it helps.\n<|/ c |>\n<| c |>\nThanks\
    \ for the update! I actually ended up doing something similar, but I wanted to\
    \ know if there was a more elegant solution. I'll accept your answer since it\
    \ does work, but I'm still interested in seeing if there's a more elegant solution.\n\
    <|/ c |>\n<| c |>\nI added a more elegant solution. Hope it helps.\n<|/ c |>\n\
    <| a dscore=2 |>\nI believe that this is more elegant and faster than the accepted\
    \ answer:\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!=\
    \ 0)]\n    even = sort_even(even)\n    odd = sort_odd(odd)\n    return even .+\
    \ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis does not work\
    \ if the list contains negative numbers. `sort_even([1,-2,3,-4,5])` returns `[1,2,-4,-3,5]`\
    \ instead of `[-1,-2,-3,-4,5]`.\n<|/ c |>\n<| c |>\nI see what you mean. I'll\
    \ edit the answer to account for negative numbers. Thanks!\n<|/ c |>\n<| a |>\n\
    The answer by is correct, but I wanted to add an explanation as to why it works.\n\
    The reason why it works is because Julia's sort function sorts elements by their\
    \ position in the array. Since Julia arrays are 0-indexed, it means that the first\
    \ element in the array is at index 0, the second is at index 1, and so on. Thus,\
    \ if you sort by their position in the array, they will come out in the correct\
    \ order.\nHowever, if you sort by their value, they will come out in the order\
    \ that they were originally in. For example, if you had the array [2,1,3,5,4],\
    \ the elements at index 0 and 1 would be swapped, because they were originally\
    \ at index 1 and 2, respectively. Thus, if you sort by their value, they will\
    \ come out in the order that they were originally in.\n<|/ a dscore=4 tags=julia,sorting\
    \ |>\n<| a dscore=3 |>\nThe answer by is correct, but I wanted to add an explanation\
    \ as to why it works.\nThe reason why it works is because Julia's sort function\
    \ sorts elements by their position in the array. Since Julia arrays are 0-indexed,\
    \ it means that the first element in the array is at index 0, the second is at\
    \ index 1, and so on. Thus, if you sort by their position in the array, they will\
    \ come out in the correct order.\nHowever, if you sort by their value, they will\
    \ come out in the order that they were originally in. For example, if you had\
    \ the array [2,1,3,5,4], the elements at index 0 and 1 would be swapped, because\
    \ they were originally at index 1 and 2, respectively. Thus, if you sort by their\
    \ value, they will come out in the order that they were originally in.\n<|/ a\
    \ tags=julia,sorting |>\n<| a tags=julia,sorting |>\nThe answer by is correct,\
    \ but I wanted to add an explanation as to why it works.", "    even = l[findall(x\
    \ -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks for the answer! I actually tried this approach before posting my\
    \ question, but I didn't think of using an anonymous function for the sort. I'll\
    \ give this a try and see if it works.\n<|/ c |>\n<| c |>\nI tested this and it\
    \ works. Thanks so much!\n<|/ c |>\n<| a dscore=0 |>\nI believe that your approach\
    \ is fine, but you can also use an anonymous function for the sorting:\n<code>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x %\
    \ 2 != 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    even = even.(l)\n\
    \    odd = odd.(l)\n    return even ++ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 != 0,\
    \ l)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n    return even ++\
    \ odd\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x\
    \ -> x % 2 != 0, l)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n \
    \   even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\n<code>", "    even = l[findall(x -> x % 2 == 0, l)]\n    odd\
    \ = l[findall(x -> x % 2 != 0, l)]\n    even = sort_odd(even)\n    odd = sort_odd(odd)\n\
    \    return even ++ odd\nend", "    even = l[findall(x -> x % 2 == 0, l)]\n  \
    \  odd = l[findall(x -> x % 2 != 0, l)]\n    even.sort()\n    odd.sort()\n   \
    \ return even + odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\n\
    This does not work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nI guess it\
    \ depends on the type of `l`. `Array{Int64,1}` does not have a `sort` method.\
    \ `Array{Int64,2}` does. `Array{Int64,3}` does not. `Array{Int64,4}` does not.\
    \ `Array{Int64,5}` does not. `Array{Int64,6}` does not. `Array{Int64,7}` does\
    \ not. `Array{Int64,8}` does not. `Array{Int64,9}` does not. `Array{Int64,10}`\
    \ does not. `Array{Int64,11}` does not. `Array{Int64,12}` does not. `Array{Int64,13}`\
    \ does not. `Array{Int64,14}` does not. `Array{Int64,15}` does not. `Array{Int64,16}`\
    \ does not. `Array{Int64,17}` does not. `Array{Int64,18}` does not. `Array{Int64,19}`\
    \ does not. `Array{Int64,20}` does not. `Array{Int64,21}` does not. `Array{Int64,22}`\
    \ does not. `Array{Int64,23}` does not. `Array{Int64,24}` does not. `Array{Int64,25}`\
    \ does not. `Array{Int64,26}` does not. `Array{Int64,27}` does not. `Array{Int64,28}`\
    \ does not. `Array{Int64,29}` does not. `Array{Int64,30}` does not. `Array{Int64,31}`\
    \ does not. `Array{Int64,32}` does not. `Array{Int64,33}` does not. `Array{Int64,34}`\
    \ does not. `Array{Int64,35}` does not. `Array{Int64,36}` does not. `Array{Int64,37}`\
    \ does not. `Array{Int64,38}` does not. `Array{Int64,39}` does not. `Array{Int64,40}`\
    \ does not. `Array{Int64,4", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.zip(odd) |> collect\n\
    end", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)\n\
    \    even = sort_odd(even)\n    even = sort_odd(even)\n    even = sort_odd(even)",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_odd(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to avoid the copying overhead of copying `even` twice and `odd` twice.\
    \ Maybe `even = sort_even(l[findall(l .% 2 == 0)])` would work?\n<|/ c |>\n<|\
    \ c |>\nYes, that would work. Thanks!\n<|/ c |>\n<| c |>\nThis solution does not\
    \ work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nI added a version that\
    \ works for `Array{Int64,1}`\n<|/ c |>\n<| a dscore=3 |>\nHere is a solution using\
    \ sortperm:\n<code>\njulia> function sort_odd(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even = sort_odd(even)\n           odd = sort_odd(odd)\n\
    \           return sortperm(even .+ odd)\n       end\nsort_odd (generic function\
    \ with 1 method)"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
