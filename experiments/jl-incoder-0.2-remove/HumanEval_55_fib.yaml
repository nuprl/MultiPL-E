name: HumanEval_55_fib
language: jl
prompt: "\"\"\"Return n-th Fibonacci number.\n                \"\"\"\nfunction fib(n::Int64)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = fib;\n\t@test(candidate(10) ==\
  \ 55)\n\t@test(candidate(1) == 1)\n\t@test(candidate(8) == 21)\n\t@test(candidate(11)\
  \ == 89)\n\t@test(candidate(12) == 144)\nend\n"
completions: ["    if n < 2 \n        then return n\n        else return fib(n-1)\
    \ + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ fib(10)\n</cell>\n<text>\nThe @code_warntype macro will warn you if you try\
    \ to call a function that doesn't exist.", "    if n < 2 \n        then return\
    \ n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will tell us how long it took\
    \ to run our function.  We will see later that we can use this information to\
    \ optimize our code.", "    if n < 2 \n        then return n\n        else return\
    \ fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.3>\n@time\
    \ fib(10)\n</cell>\n<text>\nThe @time macro will tell us the time it took to execute\
    \ the code. Let's see how long it took to compute fib(10).", "    if n == 0 ||\
    \ n == 1 \n        then return n\n    else \n        return fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(100)\n</cell>\n<text>\nExercise\nWrite a recursive\
    \ function named fib_r(n::Int64) that returns the nth Fibonacci number.", "  \
    \  if n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise\nWrite a function that calculates $n!$, where $n$ is a positive\
    \ integer.", "    if n <= 1 \n        then n\n    else fib(n - 1) + fib(n - 2)\n\
    end\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\nThe @time\
    \ macro will tell us the time it took to run our code. Let's see what happens\
    \ if we run it a million times:", "    if n == 0 || n == 1 \n        then return\
    \ n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to run the function\
    \ and time how long it takes to run. Julia will print the time it took to run\
    \ the function to the console.", "    if n == 0 || n == 1 \n        return n\n\
    \    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nJulia is lazy, so nothing is computed until you\
    \ ask for it. The function fib is only called once, even though it calls itself\
    \ twice (once to compute fib(n-1) and once to compute fib(n-2)). Julia is smart\
    \ enough to not compute fib(n-2) until it needs to.", "    if n == 0 || n == 1\
    \ \n        then return n\n    else \n        return fib(n - 1) + fib(n - 2)\n\
    end\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\nThe Julia\
    \ compiler has optimized the recursive function into a loop, so the code runs\
    \ much faster. Let's see what happens when we compile the function using @code_warntype.",
  "    if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n\
    </cell>\n<text>\nThe @time macro will give you the time it took to run a piece\
    \ of code. Let's see what happens when we run it on a larger number:", "    if\
    \ n == 0 || n == 1 \n        then return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n\"\"\"\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n\
    </cell>\n<text>\nThe @time macro will run a code block multiple times and report\
    \ the execution time for each execution.", "    if n < 0 \n        error(\"Fibonacci\
    \ number must be positive\")\n    else if n == 0 \n        0\n    else if n ==\
    \ 1 \n        1\n    else \n        fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise: Write a recursive function fib_rec that computes the n-th Fibonacci\
    \ number. Test it on small numbers and on large numbers.", "    if n == 0 || n\
    \ == 1 \n        return n\n    else \n        return fib(n - 1) + fib(n - 2)\n\
    end", "    if n == 0 || n == 1 \n        then return n\n    else \n        return\
    \ fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n\
    </cell>\n<text>\nThe @time macro will time the execution of your Julia code. \n\
    The output will look something like this:", "    if n <= 1 \n        then n \n\
    \        else fib(n-1) + fib(n-2) \nend \n</cell>\n<code language=julia-1.4>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will measure the execution time\
    \ of a block of code. \nThe first argument is the name of the block of code to\
    \ be measured. \nThe second argument is the time unit in which the code will be\
    \ executed. \nThe third argument is the number of times the code will be executed.\
    \ \nThe fourth argument is the time unit in which the code will be executed. \n\
    The fifth argument is the number of times the code will be executed. \nThe sixth\
    \ argument is the time unit in which the code will be executed. \nThe seventh\
    \ argument is the number of times the code will be executed. \nThe eighth argument\
    \ is the time unit in which the code will be executed. \nThe ninth argument is\
    \ the number of times the code will be executed. \nThe tenth argument is the time\
    \ unit in which the code will be executed. \nThe eleventh argument is the number\
    \ of times the code will be executed. \nThe twelfth argument is the time unit\
    \ in which the code will be executed. \nThe thirteenth argument is the number\
    \ of times the code will be executed. \nThe fourteenth argument is the time unit\
    \ in which the code will be executed. \nThe fifteenth argument is the number of\
    \ times the code will be executed. \nThe sixteenth argument is the time unit in\
    \ which the code will be executed. \nThe seventeenth argument is the number of\
    \ times the code will be executed. \nThe eighteenth argument is the time unit\
    \ in which the code will be executed. \nThe nineteenth argument is the number\
    \ of times the code will be executed. \nThe twenty-first argument is the time\
    \ unit in which the code will be executed. \nThe twenty-second argument is the\
    \ number of times the code will be executed. \nThe twenty-third argument is the\
    \ time unit in which the code will be executed. \nThe twenty-fourth argument is\
    \ the number of times the code will be executed. \nThe twenty-fifth argument is\
    \ the time unit in which the code will be executed. \nThe twenty-sixth argument\
    \ is the number of times the code will be executed. \nThe twenty-seventh argument\
    \ is the time unit in which the code will be executed. \nThe twenty-eighth argument\
    \ is the number of times the code will be executed. \nThe twenty-ninth argument\
    \ is the time unit in which the code will be executed. \nThe thirty-first argument\
    \ is the time unit in which the code will be executed. \nThe thirty-second argument\
    \ is the number of times the code will be executed. \nThe thirty-third ", "  \
    \  if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise\nWrite a recursive function fib_rec(n::Int64)::Int64 that returns\
    \ the n-th Fibonacci number.", "    if n == 0 || n == 1 \n        then return\
    \ n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to run a code block\
    \ and time how long it takes to run. Julia will then print the time it took to\
    \ run the code block.", "    if n == 0 || n == 1 \n        then return n\n   \
    \ else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec that\
    \ computes the nth Fibonacci number recursively.", "    if n == 0 || n == 1 \n\
    \        return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(10)\n</cell>\n<text>\nExercise\nWrite a recursive function fib_rec\
    \ that computes the nth Fibonacci number.", "    if n == 0 || n == 1 \n      \
    \  return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nJulia is lazy, so it will\
    \ not compute Fibonacci numbers for numbers below a certain threshold, like 10\
    \ or 20. Instead, it will store the results in a cache and return the cached result\
    \ whenever it needs to. Let's see how it works:", "    if n < 0 \n        error(\"\
    Fibonacci number must be positive\")\n    else if n == 0 \n        0\n    else\
    \ if n == 1 \n        1\n    else \n        fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise: Write a function\
    \ that returns the n-th Fibonacci number modulo 1000000007 (i.e. the remainder\
    \ after dividing by 1000000007).", "    if n == 0 || n == 1 \n        then return\
    \ n\n        else return fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\nExercise: Write a recursive\
    \ function fib_rec(n::Int64)::Int64 that returns the n-th Fibonacci number.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro tells Julia to run a block of code a number of times and\
    \ then report the time it took to run that block of code. Julia will automatically\
    \ compile the code into a native machine instruction set (CPU) instruction set\
    \ (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (ISA) instruction\
    \ set (ISA) instruction set (ISA) instruction set (ISA) instruction set (ISA)\
    \ instruction set (ISA) instruction set (ISA) instruction set (IS", "    if n\
    \ < 2\n        1\n    else\n        fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time macro will\
    \ time the execution of the code in the cell and output the elapsed time. In the\
    \ example above the elapsed time is approximately 0.04 seconds. If you run this\
    \ cell multiple times you will get different results.", "    if n < 2 \n     \
    \   then return n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n\"\"\
    \"\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(2)\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype fib(1)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(0)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(-1)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(-2)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(-3)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(-4)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(-5)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(-6)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(-7)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(-8)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(10)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(100)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(1000)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(10000)\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ fib(100000)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(1000000)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(10000000)\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype fib(100000000)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(1000000000)\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ fib(10000000000)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(100000000000)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(1000000000000)\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype fib(10000000000000)\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype fib(100000000000000)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(1000000000000000)\n", "    if n < 2 \n        then return n\
    \ \n        else return fib(n-2) + fib(n-1) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise\nWrite a function that calculates the\
    \ n-th Fibonacci number using recursion.", "    if n < 0 \n        error(\"Fibonacci\
    \ number must be positive\")\n    else if n == 0 \n        0\n    else if n ==\
    \ 1 \n        1\n    else \n        fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\nExercise: Write a recursive\
    \ function fib_rec(n::Int64) that returns the nth Fibonacci number.", "    if\
    \ n == 0 || n == 1 \n        then return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a recursive function named fib_r(n::Int64) that returns\
    \ the nth Fibonacci number.", "    if n == 0 || n == 1 \n        then return n\n\
    \    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will measure the time it takes\
    \ to run the function and report the elapsed time as a floating point number.\
    \ Here we see that fib(10) takes about 0.1 seconds to run.", "    if n == 0 ||\
    \ n == 1 \n        return n\n    else \n        return fib(n - 1) + fib(n - 2)\n\
    end\n</cell>\n<code language=julia-1.4>\n@time fib(10)\n</cell>\n<text>\nExercise:\
    \ Write a recursive function fib_r(n::Int64)::Int64 which returns the nth Fibonacci\
    \ number using recursion.", "    if n == 0 || n == 1 \n        return n\n    else\n\
    \        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe function fib is recursive, which means it\
    \ calls itself over and over again, until it hits the maximum recursion depth\
    \ (the maximum amount of nested function calls). Julia has a special syntax for\
    \ recursive functions, which looks like this:", "    if n < 2 \n        then return\
    \ n \n        else return fib(n-1) + fib(n-2) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that computes the n-th Fibonacci number recursively.",
  "    if n <= 1 \n        then n \n        else fib(n-1) + fib(n-2) \nend \n</cell>\n\
    <code language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\nExercise\nWrite a function\
    \ that calculates the n-th Fibonacci number using memoization.", "    if n ==\
    \ 0 || n == 1 \n        return n \n    else \n        return fib(n-1) + fib(n-2)\
    \ \nend \n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\n\
    Exercise: Write a recursive function fib_rec that computes the nth Fibonacci number\
    \ recursively.\nHint: Use a base case to stop recursion.", "    if n == 0 \n \
    \       then return 0\n    else if n == 1 \n        then return 1\n    else \n\
    \        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will tell us how long it took\
    \ to run our code. Let's see what happens if we run it a million times:", "  \
    \  if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n\
    </cell>\n<text>\nThe @time macro will execute the function and return the elapsed\
    \ time. Let's compare the elapsed time with the naive implementation:", "    if\
    \ n < 2\n        1\n    else\n        fib(n-1) + fib(n-2)\nend\n\"\"\"", "   \
    \ if n < 0 \n        error(\"Fibonacci number must be positive\")\n    else if\
    \ n == 0 \n        0\n    else if n == 1 \n        1\n    else \n        fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n\
    </cell>\n<text>\nExercise 1\nWrite a Julia function that computes the n-th Fibonacci\
    \ number using recursion.", "    if n == 0 || n == 1 \n        return n\n    else\
    \ \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec(n::Int64)\
    \ which returns the nth Fibonacci number using recursion.", "    if n == 0 ||\
    \ n == 1 \n        return n\n    else \n        return fib(n - 1) + fib(n - 2)\n\
    end\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the n-th Fibonacci number using recursion.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro tells Julia to execute the function and to print out the\
    \ time it took to execute.", "    if n < 2 \n        then return n\n        else\
    \ return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @time fib(10)\n</cell>\n<text>\nExercise: Write a recursive function named fib_r(n::Int64)\
    \ which returns the n-th Fibonacci number.", "    if n == 0 || n == 1 \n     \
    \   return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.4>\n@time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia\
    \ to run a block of code a certain number of times and then print the average\
    \ time it took to run. Here we ran the code 10 times and printed the average time\
    \ it took to run:", "    if n == 0 || n == 1 \n        return n\n    else \n \
    \       return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that computes the n-th Fibonacci number using memoization.",
  "    if n < 0 \n        error(\"Fibonacci number must be positive\")\n    else if\
    \ n == 0 \n        1\n    else if n == 1 \n        1\n    else \n        fib(n-1)\
    \ + fib(n-2)\nend", "    if n == 0 || n == 1 \n        then return n\n    else\
    \ \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will tell us the time it took\
    \ to run the function fib(10)", "    if n == 0 || n == 1 \n        return n\n\
    \    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe Fibonacci sequence is defined by the recurrence\
    \ relation:", "    if n == 0 || n == 1 \n        return n\n    else \n       \
    \ return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n\
    </cell>\n<text>\nThe @time macro tells Julia to execute the function and to print\
    \ the execution time (in seconds) at the end of the cell. Julia will print the\
    \ execution time even if the function does not return anything.", "    if n ==\
    \ 0 || n == 1 \n        return n\n    else \n        return fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@code_native fib(0)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(1)\n</cell>\n<code language=julia-1.5>\n@code_native fib(10)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(20)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(30)\n</cell>\n<code language=julia-1.5>\n@code_native fib(40)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(50)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(60)\n</cell>\n<code language=julia-1.5>\n@code_native fib(70)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(80)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(90)\n</cell>\n<code language=julia-1.5>\n@code_native fib(100)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(200)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(300)\n</cell>\n<code language=julia-1.5>\n@code_native fib(400)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(500)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(600)\n</cell>\n<code language=julia-1.5>\n@code_native fib(700)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(800)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(900)\n</cell>\n<code language=julia-1.5>\n@code_native fib(1000)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(2000)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(3000)\n</cell>\n<code language=julia-1.5>\n@code_native fib(4000)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(5000)\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(6000)\n</cell>\n<code language=julia-1.5>\n@code_native fib(7000)\n\
    </cell>\n<code language=julia-1.5>\n@code_native fib(8000)\n</cell", "    if n\
    \ == 0 || n == 1 \n        then return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro will tell us how long it took to run the function and\
    \ how long it took to compile the function.", "    if n < 0 \n        error(\"\
    Fibonacci number must be non-negative\")\n    else if n == 0 \n        0\n   \
    \ else if n == 1 \n        1\n    else \n        fib(n - 1) + fib(n - 2)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise:\
    \ Write a recursive function fib_rec that computes the nth Fibonacci number.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10000);\n</cell>\n\
    <text>\nExercise 2\nWrite a function that calculates the n-th Fibonacci number\
    \ using recursion.", "    if n == 0 \n        then return 0\n    else if n ==\
    \ 1 \n        then return 1\n    else \n        return fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time\
    \ macro will time the execution of your code. \nThe @time macro will time the\
    \ execution of your code. \nThe @time macro will time the execution of your code.\
    \ \nThe @time macro will time the execution of your code. \nThe @time macro will\
    \ time the execution of your code. \nThe @time macro will time the execution of\
    \ your code. \nThe @time macro will time the execution of your code. \nThe @time\
    \ macro will time the execution of your code. \nThe @time macro will time the\
    \ execution of your code. \nThe @time macro will time the execution of your code.\
    \ \nThe @time macro will time the execution of your code. \nThe @time macro will\
    \ time the execution of your code. \nThe @time macro will time the execution of\
    \ your code. \nThe @time macro will time the execution of your code. \nThe @time\
    \ macro will time the execution of your code. \nThe @time macro will time the\
    \ execution of your code. \nThe @time macro will time the execution of your code.\
    \ \nThe @time macro will time the execution of your code. \nThe @time macro will\
    \ time the execution of your code. \nThe @time macro will time the execution of\
    \ your code. \nThe @time macro will time the execution of your code. \nThe @time\
    \ macro will time the execution of your code. \nThe @time macro will time the\
    \ execution of your code. \nThe @time macro will time the execution of your code.\
    \ \nThe @time macro will time the execution of your code. \nThe @time macro will\
    \ time the execution of your code. \nThe @time macro will time the execution of\
    \ your code. \nThe @time macro will time the execution of your code. \nThe @time\
    \ macro will time the execution of your code. \nThe @time macro will time the\
    \ execution of your code. \nThe @time macro will time the execution of your code.\
    \ \nThe @time macro will time the execution of your code. \nThe @time macro will\
    \ time the execution of your code. \nThe @time macro will time the execution of\
    \ your code. \nThe @time macro will time the execution of your code. \n", "  \
    \  if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n\
    </cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\nThe @time\
    \ macro tells Julia to execute the function and time how long it takes to run.\
    \ Here we see that fib(100) takes about 10 seconds to run. Julia is smart enough\
    \ to know that fib(100) does not depend on any external variables and will compile\
    \ it into machine code directly. On the other hand, fib(10) takes about 0.1 seconds\
    \ to run. Julia is smart enough to know that fib(10) does not depend on any external\
    \ variables and will compile it into machine code directly.", "    if n == 0 ||\
    \ n == 1 \n        then return n\n    else \n        return fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(10)\n</cell>\n\
    <text>\nThe @code_warntype macro will warn you about unused variables and functions.\
    \ It is often a good idea to remove unused variables and functions before submitting\
    \ your code. Julia will warn you about unused variables and functions if you use\
    \ the @code_warntype macro.", "    if n == 0 || n == 1 \n        then return n\n\
    \    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will tell us how long it took\
    \ to run our code. Let's see how long it took to run our fib function with n=10:",
  "    if n <= 1 \n        then n \n        else fib(n-1) + fib(n-2) \nend\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe function above\
    \ is recursive. Julia has a special syntax for recursive functions:", "    if\
    \ n == 0 || n == 1 \n        then return n\n    else \n        return fib(n -\
    \ 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro tells Julia to compile the function and to run it 10 times.\
    \ Each time Julia will compile the function and run it 10 times. So the @time\
    \ macro tells Julia to compile the function and to run it 10 times. Each time\
    \ Julia will compile the function and run it 10 times. So the @time macro tells\
    \ Julia to compile the function and to run it 10 times. Each time Julia will compile\
    \ the function and run it 10 times. So the @time macro tells Julia to compile\
    \ the function and to run it 10 times. Each time Julia will compile the function\
    \ and run it 10 times. So the @time macro tells Julia to compile the function\
    \ and to run it 10 times. Each time Julia will compile the function and run it\
    \ 10 times. So the @time macro tells Julia to compile the function and to run\
    \ it 10 times. Each time Julia will compile the function and run it 10 times.\
    \ So the @time macro tells Julia to compile the function and to run it 10 times.\
    \ Each time Julia will compile the function and run it 10 times. So the @time\
    \ macro tells Julia to compile the function and to run it 10 times. Each time\
    \ Julia will compile the function and run it 10 times. So the @time macro tells\
    \ Julia to compile the function and to run it 10 times. Each time Julia will compile\
    \ the function and run it 10 times. So the @time macro tells Julia to compile\
    \ the function and to run it 10 times. Each time Julia will compile the function\
    \ and run it 10 times. So the @time macro tells Julia to compile the function\
    \ and to run it 10 times. Each time Julia will compile the function and run it\
    \ 10 times. So the @time macro tells Julia to compile the function and to run\
    \ it 10 times. Each time Julia will compile the function and run it 10 times.\
    \ So the @time macro tells Julia to compile the function and to run it 10 times.\
    \ Each time Julia will compile the function and run it 10 times. So the @time\
    \ macro tells Julia to compile the function and to run it 10 times. Each time\
    \ Juli", "    if n == 0 || n == 1 \n        then return n\n    else \n       \
    \ return fib(n - 1) + fib(n - 2)\nend\n\"\"\"\n</cell>\n<code language=julia-1.3>\n\
    @code_warntype fib(10)\n</cell>\n<code language=julia-1.3>\n@code_warntype fib(100)\n\
    </cell>\n<text>\nThe @code_warntype macro will warn you about any type mismatch\
    \ that occurs. This is useful if you know that your function will return a type\
    \ that Julia does not understand.", "    if n == 0 || n == 1 \n        return\
    \ n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.0>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.0>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise: Write a recursive function named fibonacci that returns the nth Fibonacci\
    \ number.", "    if n == 0 || n == 1 \n        then return n\n    else \n    \
    \    return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nExercise\nWrite a recursive function named fib_r(n::Int64)\
    \ that returns the n-th Fibonacci number.", "    if n < 2 \n        then return\
    \ n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will measure the execution time\
    \ of a function or expression. Here we measure the execution time of the Fibonacci\
    \ function fib.", "    if n == 0 || n == 1 \n        return n\n    else \n   \
    \     return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n@time\
    \ fib(10)\n</cell>\n<text>\nExercise\nWrite a function that returns the nth Fibonacci\
    \ number using recursion.", "    if n == 0 || n == 1 \n        return n\n    else\
    \ \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(1000)\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that calculates the n-th Fibonacci number using recursion.", "    if n == 0\
    \ || n == 1 \n        then return n\n    else \n        return fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\n\
    Exercise\nWrite a function that computes the n-th Fibonacci number using recursion.",
  "    if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.4>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro will tell us how long it took to run the code. Let's see\
    \ how long it took to run our function fib.", "    if n < 0 \n        error(\"\
    Fibonacci number must be positive\")\n    else if n == 0 \n        1\n    else\
    \ if n == 1 \n        1\n    else \n        fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\nExercise\nWrite a function\
    \ that calculates the n-th Fibonacci number using recursion.", "    if n == 0\
    \ || n == 1 \n        return n\n    else \n        return fib(n - 1) + fib(n -\
    \ 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\n\
    Exercise\nWrite a recursive function fib_rec that computes the nth Fibonacci number.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe function fib is recursive, i.e. it calls itself to compute the next\
    \ Fibonacci number. Julia has special syntax for recursive functions, which are\
    \ denoted by a keyword (@).", "    if n == 0 || n == 1 \n        return n\n  \
    \  else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will run a block of code a number\
    \ of times and then report the time it took to run that block of code. Here we\
    \ ran the code 10 times and then printed the average time it took to run that\
    \ block of code.", "    if n == 0 || n == 1 \n        return n\n    else\n   \
    \     return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise: Write a recursive function named fibonacci that returns the nth Fibonacci\
    \ number.", "    if n == 0 || n == 1 \n        return n\n    else \n        return\
    \ fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n\
    </cell>\n<text>\nExercise\nWrite a function that calculates the n-th Fibonacci\
    \ number using recursion.", "    if n == 0 || n == 1 \n        then return n\n\
    \    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to execute the code\
    \ in the cell and time how long it takes to execute. Julia will print the elapsed\
    \ time at the end. Here we see that fib(10) takes about 2.5 seconds to execute.",
  "    if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=julia-1.0>\n\
    @code_native fib\n</cell>\n<code language=julia-1.0>\n@code_native fib\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<code language=juli", " \
    \   if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the first n Fibonacci\
    \ numbers. \nHint: Use a recursive function.", "    if n == 0 \n        then return\
    \ 0\n    else if n == 1 \n        then return 1\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(10)\n\
    </cell>\n<text>\nThe function fib(n::Int64) returns a Int64 type number. \nThe\
    \ function fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64)\
    \ returns a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type\
    \ number. \nThe function fib(n::Int64) returns a Int64 type number. \nThe function\
    \ fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64) returns\
    \ a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type number.\
    \ \nThe function fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64)\
    \ returns a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type\
    \ number. \nThe function fib(n::Int64) returns a Int64 type number. \nThe function\
    \ fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64) returns\
    \ a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type number.\
    \ \nThe function fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64)\
    \ returns a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type\
    \ number. \nThe function fib(n::Int64) returns a Int64 type number. \nThe function\
    \ fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64) returns\
    \ a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type number.\
    \ \nThe function fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64)\
    \ returns a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type\
    \ number. \nThe function fib(n::Int64) returns a Int64 type number. \nThe function\
    \ fib(n::Int64) returns a Int64 type number. \nThe function fib(n::Int64) returns\
    \ a Int64 type number. \nThe function fib(n::Int64) returns a Int64 type number.\
    \ \nThe function fib(n::Int64) returns a Int64 type number. \nThe function fib",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a recursive function named fib_r(n::Int64) that returns\
    \ the n-th Fibonacci number.", "    if n == 0 then return 0\n    if n == 1 then\
    \ return 1\n    return fib(n - 1) + fib(n - 2)\nend\n\"\"\"\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(10)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(100)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(10000)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(100000)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(10000000)\n</cell>\n<code\
    \ language=julia-1.4>\n@code_warntype fib(100000000)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(1000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(10000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000)\n</cell>\n\
    <code language=julia-1.4>\n@code_warntype fib(10000000000000)\n</cell>\n<code\
    \ language=julia-1.4>\n@code_warntype fib(100000000000000)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(1000000000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(10000000000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(10000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(10000000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000000000000000)\n\
    </cell>\n<code language=julia-", "    if n == 0 || n == 1 \n        then return\
    \ n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.3>\n@time fib(100)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(1000)\n</cell>\n<code language=julia-1.3>\n@time\
    \ fib(10000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(1000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(1000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(1000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(1000000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(10000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(10000000000000000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(100000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(10000000000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(100000000000000000000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(1000000000000000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(10000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time\
    \ fib(1000000000000000000000000000)\n", "    if n < 2 \n        then return n\n\
    \        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec(n::Int64)::Int64\
    \ that returns the n-th Fibonacci number.", "    if n < 2\n        then return\
    \ n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise 2\nWrite a recursive function named fibonacci_rec(n) that returns the\
    \ nth Fibonacci number.", "    if n == 0 || n == 1 \n        return n\n    else\
    \ \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec that\
    \ returns the nth Fibonacci number using recursion.", "    if n == 0 || n == 1\
    \ \n        then return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time\
    \ macro tells Julia to run the function and time how long it takes to run. Julia\
    \ will print the time it took to run the function and will also print a summary\
    \ of the function run. Julia will also print the time it took to run the function\
    \ and will also print a summary of the function run. Julia will print the time\
    \ it took to run the function and will also print a summary of the function run.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise: Write a recursive function named fib_r(n::Int64) that returns\
    \ the n-th Fibonacci number.", "    if n < 2 \n        then return n\n       \
    \ else return fib(n-1) + fib(n-2)\n    end\nend", "    if n == 0 \n        then\
    \ return 0\n    else if n == 1 \n        then return 1\n    else \n        return\
    \ fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(10)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(100)\n</cell>\n\
    <code language=julia-1.4>\n@code_warntype fib(1000)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(10000)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(100000)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(10000000)\n</cell>\n<code\
    \ language=julia-1.4>\n@code_warntype fib(100000000)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(1000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(10000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000)\n</cell>\n\
    <code language=julia-1.4>\n@code_warntype fib(10000000000000)\n</cell>\n<code\
    \ language=julia-1.4>\n@code_warntype fib(100000000000000)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(1000000000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ fib(10000000000000000)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(10000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(10000000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(100000000000000000000000)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(1000000000000000000000000)\n",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro tells Julia to run a block of code several times and to\
    \ print out the total time it took to run. Here we see that Julia spends most\
    \ of its time in the fib function, which makes sense since it does a lot of work\
    \ to compute Fibonacci numbers.", "    if n < 2 \n        then return n\n    \
    \    else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nExercise 2\nWrite a recursive function named fib_r(n::Int64)\
    \ that returns the nth Fibonacci number.", "    if n == 0 || n == 1 \n       \
    \ return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(10)\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(100)\n</cell>\n<text>\nExercise: Write a recursive function fib_r(n::Int64)\
    \ which returns the nth Fibonacci number.", "    if n == 0 || n == 1 \n      \
    \  return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(10)\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(100)\n</cell>\n<code language=julia-1.5>\n@time fib(1000)\n</cell>\n<text>\n\
    Exercise: Write a recursive function fib_rec that computes the n-th Fibonacci\
    \ number.", "    if n == 0 \n        then return 0\n    else if n == 1 \n    \
    \    then return 1\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype fib(10)\n</cell>\n<text>\nThe function\
    \ fib is recursive, which means that it calls itself over and over again. Julia\
    \ will try to optimize this by memoizing the results. To do this, we use the @code_warntype\
    \ macro, which will warn us if we are doing something wrong.", "    if n == 0\
    \ || n == 1 \n        return n\n    else\n        return fib(n - 1) + fib(n -\
    \ 2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100)\n</cell>\n<code language=julia-1.3>\n@time fib(1000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(10000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(10000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(100000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(10000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(100000000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(1000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(1000000000000000000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10000000000000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(100000000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time\
    \ fib(10000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000000000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(1000000000000000000000000000)\n\
    </cell>", "    if n == 0 || n == 1 \n        return n \n    else \n        return\
    \ fib(n-1) + fib(n-2) \nend \n</cell>\n<code language=julia-1.5>\n@time fib(10)\n\
    </cell>\n<text>\nExercise: Write a recursive function fib_r(n::Int64) that returns\
    \ the nth Fibonacci number.", "    if n == 0 \n        then return 0\n    else\
    \ if n == 1 \n        then return 1\n    else \n        fib(n-1) + fib(n-2)\n\
    end\n\"\"\"\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(0)\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype fib(1)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(2)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(3)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(4)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(5)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(6)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(7)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(8)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(9)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(10)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(11)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(12)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(13)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(14)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(15)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(16)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(17)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(18)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(19)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(20)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(21)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(22)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib(23)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(24)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib(25)\n</cell>\n<code language=julia-1.5",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend", "    if n < 2 \n        then return n\n        else return\
    \ fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to run a piece of code\
    \ a number of times and then report the total time taken.", "    if n == 0 ||\
    \ n == 1 \n        then return n\n    else \n        return fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\n\
    The @time macro will run a block of code a number of times and report the average\
    \ execution time.", "    if n == 0 \n        then return 0\n    else if n == 1\
    \ \n        then return 1\n    else \n        return fib(n - 1) + fib(n - 2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time\
    \ macro will execute the function and time how long it takes to run. Let's time\
    \ the function again:", "    if n == 0 \n        then return 0\n    else if n\
    \ == 1 \n        then return 1\n    else \n        return fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(100)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec\
    \ that returns the nth Fibonacci number.", "    if n == 0 || n == 1 \n       \
    \ then return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\nExercise 2\nWrite a\
    \ recursive function named fib_r(n::Int64) that returns the n-th Fibonacci number.",
  "    if n < 2 \n        then return n\n        else return fib(n-1) + fib(n-2)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\n\
    The @time macro will execute the code in the cell and return the elapsed time.\
    \ In the cell below we see how it works.", "    if n == 0 || n == 1 \n       \
    \ return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise 2\nWrite a recursive\
    \ function named fib_r(n::Int64) that returns the n-th Fibonacci number.", " \
    \   if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro tells Julia to compile the function and to run it 10 times.\
    \ Each time the function is called, Julia will compile the function and run it\
    \ 10 times. To see how long it takes to run a function, we can use the @time macro.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro tells Julia to run the function and time how long it takes\
    \ to run. Julia will then print the time it took to run the function to the screen.\
    \ Julia will then run the function and time how long it takes to run. Julia will\
    \ then print the time it took to run the function to the screen. Julia will then\
    \ run the function and time how long it takes to run. Julia will then print the\
    \ time it took to run the function to the screen. Julia will then run the function\
    \ and time how long it takes to run. Julia will then print the time it took to\
    \ run the function to the screen. Julia will then run the function and time how\
    \ long it takes to run. Julia will then print the time it took to run the function\
    \ to the screen. Julia will then run the function and time how long it takes to\
    \ run. Julia will then print the time it took to run the function to the screen.\
    \ Julia will then run the function and time how long it takes to run. Julia will\
    \ then print the time it took to run the function to the screen. Julia will then\
    \ run the function and time how long it takes to run. Julia will then print the\
    \ time it took to run the function to the screen. Julia will then run the function\
    \ and time how long it takes to run. Julia will then print the time it took to\
    \ run the function to the screen. Julia will then run the function and time how\
    \ long it takes to run. Julia will then print the time it took to run the function\
    \ to the screen. Julia will then run the function and time how long it takes to\
    \ run. Julia will then print the time it took to run the function to the screen.\
    \ Julia will then run the function and time how long it takes to run. Julia will\
    \ then print the time it took to run the function to the screen. Julia will then\
    \ run the function and time how long it takes to run. Julia will then print the\
    \ time it took to run the function to the screen. Julia will then run the function\
    \ and time how long it takes to run. Julia will then print the time it took to\
    \ run the function to the screen. Julia will then run the function and time how\
    \ long it takes to run. Julia will then print the time it took to run the function\
    \ to the screen. Julia will then run the function and time how long it ", "  \
    \  if n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend", "    if n == 0 || n == 1 \n        then return n\n     \
    \   else return fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will measure the execution time\
    \ of a block of code. Here we measure the execution time of the fib function.\
    \ We can see that it is about 4 times faster than the naive implementation. Let's\
    \ see how it performs on a larger input:", "    if n == 0 || n == 1 \n       \
    \ then return n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.0>\n@code_native fib\n</cell>\n<text>\nThe @code_native\
    \ macro will generate native code for the function fib. Let's see what it looks\
    \ like:", "    if n == 0 || n == 1 \n        then return n\n        else return\
    \ fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will execute the function and\
    \ time the execution time (in seconds).", "    if n == 0 || n == 1 \n        then\
    \ return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise: Write a recursive\
    \ function fib_rec(n::Int64) that returns the n-th Fibonacci number.", "    if\
    \ n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1) +\
    \ fib(n - 2)\nend", "    if n == 0 \n        then return 0\n    else if n == 1\
    \ \n        then return 1\n    else \n        return fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.4>\n@time fib(10)\n</cell>\n<text>\nExercise:\
    \ Write a recursive function named fib_r(n::Int64) that returns the nth Fibonacci\
    \ number.", "    if n == 0 || n == 1 \n        then return n\n    else \n    \
    \    return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@code_native\
    \ fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <code language=julia-1.5>\n@code_native fib\n</cell>\n<code language=juli", " \
    \   if n < 2 \n        then return n\n        else return fib(n-1) + fib(n-2)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\n\
    Exercise: Write a function that returns the n-th Fibonacci number in Julia", " \
    \   if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n\"\"\"\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ fib(10)\n</cell>\n<text>\nExercise: Write a function that returns the n-th Fibonacci\
    \ number using recursion.", "    if n == 0 || n == 1 \n        return n\n    else\
    \ \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.3>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise\nWrite a recursive function fib_rec that computes the nth Fibonacci number.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro will tell us how long it took to run our code. Let's see\
    \ how long it took to run our fib function with n = 10", "    if n < 2\n     \
    \   1\n    else\n        fib(n-1) + fib(n-2)\nend\n\"\"\"\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(2)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(3)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(4)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(5)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(6)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(7)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(8)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(9)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(10)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(11)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(12)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(13)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(14)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(15)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(16)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(17)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(18)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(19)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(20)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(21)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(22)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(23)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(24)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(25)\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(26)\n</cell>\n<code language=julia-1.0>\n@code_warntype fib(27)\n\
    </cell>\n<code language=julia-1.0>\n@code_warntype fib(28)\n", "    if n == 0\
    \ || n == 1 \n        return n\n    else \n        return fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time\
    \ macro will run a block of code a number of times and report the average execution\
    \ time. Here we run it 10 times and report the average execution time.", "   \
    \ if n < 0 \n        error(\"Fibonacci number must be positive\")\n    else if\
    \ n == 0 \n        1\n    else if n == 1 \n        1\n    else \n        fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a recursive function fib_rec(n::Int64) which returns\
    \ the nth Fibonacci number.", "    if n <= 1 \n        then n \n        else fib(n-1)\
    \ + fib(n-2) \nend \n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise: Write a function that computes the n-th Fibonacci number using\
    \ recursion.", "    if n == 0 || n == 1 \n        then return n\n        else\
    \ return fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will execute the code in the cell\
    \ and time how long it takes to run. In the above example, the code takes about\
    \ 0.3 seconds to run. Let's see how long it takes to run a larger number:", " \
    \   if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.4>\n@time fib(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates the n-th Fibonacci\
    \ number using recursion.", "    if n == 0 \n        then return 0\n    else if\
    \ n == 1 \n        then return 1\n    else \n        return fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100)\n</cell>\n<code language=julia-1.3>\n@time fib(1000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(10000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(10000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(100000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(10000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(100000000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(1000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(1000000000000000000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10000000000000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(100000000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time\
    \ fib(10000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000000000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n", "    if n < 2 \n        then return n\n\
    \        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @time fib(10)\n</cell>\n<text>\nExercise 2\nWrite a recursive function named fib_r(n::Int64)\
    \ which returns the nth Fibonacci number.", "    if n == 0 || n == 1 \n      \
    \  return n \n    else \n        return fib(n - 1) + fib(n - 2) \nend\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\nThe @time macro will\
    \ time the execution of a function and will print the elapsed time. Here we see\
    \ that the function takes about 1.5 seconds to compute $10$ Fibonacci numbers.",
  "    if n <= 1 \n        then n \n        else fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\nExercise\nWrite a function\
    \ that calculates the n-th Fibonacci number using recursion.", "    if n == 0\
    \ || n == 1 \n        return n \n    else \n        return fib(n-1) + fib(n-2)\
    \ \nend \n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a recursive function named fib_r(n::Int64) that returns the\
    \ nth Fibonacci number.", "    if n == 0 \n        then return 0 \n    else if\
    \ n == 1 \n        then return 1 \n    else \n        fib(n-1) + fib(n-2) \nend\
    \ \n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(100)\n</cell>\n<code language=julia-1.0>\n@time fib(1000)\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10000)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(100000)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000)\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10000000)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(100000000)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(10000000000)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(100000000000)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(1000000000001)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(1000000000002)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000000003)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(1000000000004)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(1000000000005)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000000006)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(1000000000007)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(1000000000008)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000000009)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(1000000000010)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(1000000000011)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000000012)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(1000000000013)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(1000000000014)\n</cell>\n<code language=julia-1.0>\n", "    if n ==\
    \ 0 \n        then return 0\n    else if n == 1 \n        then return 1\n    else\
    \ \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.0>\n\
    @time fib(10)\n</cell>\n<text>\nExercise\nWrite a function that calculates the\
    \ n-th Fibonacci number.", "    if n == 0 then return 0\n    if n == 1 then return\
    \ 1\n    return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise 2\nWrite a recursive function named fib_r(n::Int64)::Int64\
    \ which returns the n-th Fibonacci number.", "    if n == 0 || n == 1 \n     \
    \   then return n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10)\n</cell>\n<text>\nThe @time macro will\
    \ measure the time it takes to run a piece of code. Here we measure the time it\
    \ takes to run fib(10).", "    if n == 0 || n == 1 \n        return n\n    else\
    \ \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nExercise 3\nWrite a function that calculates the\
    \ n-th Fibonacci number using recursion.", "    if n == 0 || n == 1 \n       \
    \ return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns the n-th Fibonacci number using recursion.", "    if n == 0 ||\
    \ n == 1 \n        then return n\n    else \n        return fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\n\
    The @time macro will run a block of code a number of times and then print the\
    \ elapsed time. Here we ran the code 10 times and printed the elapsed time.",
  "    if n < 2 \n        then return n\n        else return fib(n-1) + fib(n-2)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\n\
    The @time macro will execute the code in the cell and return the elapsed time\
    \ (in seconds) for the cell to execute.", "    if n == 0 || n == 1 \n        then\
    \ return n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time macro tells\
    \ Julia to run the function and time how long it takes to run. Here we see that\
    \ Julia is able to run this function in about 2 milliseconds.", "    if n < 2\
    \ \n        then return n\n        else return fib(n-1) + fib(n-2)\n    end\n\
    end\n</cell>\n<code language=julia-1.4>\n@time fib(10)\n</cell>\n<text>\nExercise\n\
    Write a function that calculates the n-th Fibonacci number using recursion.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend", "    if n == 0 || n == 1 \n        return n\n    else \n\
    \        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe Julia compiler can optimize this recursive\
    \ function by memoizing the result. Let's see how it works:", "    if n == 0 ||\
    \ n == 1 \n        return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time\
    \ macro will run your function and time how long it takes to run. Let's time the\
    \ fib function above with n = 10. We'll use the @time macro to time the execution\
    \ of fib function and to see how long it takes to run. We'll use the @elapsed\
    \ macro to measure the time taken to run the fib function and to see how long\
    \ it took to run.", "    if n < 2 \n        then return n \n        else return\
    \ fib(n - 1) + fib(n - 2) \n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype fib(10)\n</cell>\n<text>\nExercise: Write a function that returns\
    \ the n-th Fibonacci number using recursion.", "    if n == 0 || n == 1 \n   \
    \     return n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\nThe @time macro will\
    \ tell us how long it took to run the code. On my laptop it took about 0.2 seconds\
    \ to run this code.", "    if n == 0 || n == 1 \n        return n\n    else \n\
    \        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.4>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will execute the code in the cell\
    \ and return the time taken in seconds. If the cell is executed multiple times\
    \ then multiple times the time taken will be returned.", "    if n == 0 || n ==\
    \ 1 \n        then return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise:\
    \ Write a recursive function fib_rec that computes the nth Fibonacci number using\
    \ recursion.", "    if n == 0 || n == 1 \n        then return n\n    else \n \
    \       return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will execute the function and\
    \ print the elapsed time. Julia will print the elapsed time in the following format:",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise: Write a recursive function fib_rec(n::Int64) that returns the\
    \ n-th Fibonacci number.", "    if n < 0 \n        error(\"Fibonacci number must\
    \ be positive\")\n    else if n == 0 \n        0\n    else if n == 1 \n      \
    \  1\n    else \n        fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_native fib(10)\n</cell>\n<text>\nThe @code_native macro will automatically\
    \ generate native code for the function fib. Let's try it out on a few examples:",
  "    if n == 0 \n        then return 0\n    else if n == 1 \n        then return\
    \ 1\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.0>\n\
    @time fib(10)\n</cell>\n<text>\nExercise\nWrite a recursive function fib_rec(n::Int64)::Int64\
    \ that returns the n-th Fibonacci number.", "    if n <= 1 \n        then 1\n\
    \        else fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(10)\n</cell>\n<text>\nExercise\nWrite a function that computes the n-th\
    \ Fibonacci number using recursion.", "    if n == 0 || n == 1 \n        return\
    \ n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nExercise\nWrite a recursive function named fib_r(n::Int64)\
    \ that returns the n-th Fibonacci number.", "    if n == 0 || n == 1 \n      \
    \  then return n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time macro will\
    \ tell us how long it took to run our code. Let's see what happens if we run it\
    \ a million times:", "    if n == 0 then return 0\n    if n == 1 then return 1\n\
    \    return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will execute the function and\
    \ print out the time it took to run. Let's see how long it took to run this function:",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that computes the n-th Fibonacci number using memoization.", "  \
    \  if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n\
    \ - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n@code_native fib(10)\n\
    </cell>\n<text>\nJulia is smart enough to optimize this recursive function and\
    \ turn it into a loop:", "    if n == 0 || n == 1 \n        then return n\n  \
    \  else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise: Write a recursive function fib_rec(n::Int64)::Int64 that returns the\
    \ n-th Fibonacci number.", "    if n == 0 || n == 1 \n        then return n\n\
    \        else return fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to run a piece of\
    \ code for a certain number of iterations and then report the elapsed time. Julia\
    \ will then compile the code into a native machine instruction set and run it\
    \ on the CPU.", "    if n == 0 || n == 1 \n        then return n\n    else \n\
    \        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will give you the execution time\
    \ of your code snippet.", "    if n == 0 || n == 1 \n        then return n\n \
    \       else return fib(n - 1) + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to run a piece of\
    \ code a certain number of times and then report the total time taken.", "   \
    \ if n == 0 || n == 1 \n        then return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@code_native fib\n</cell>\n\
    <text>\nJulia is smart enough to realize that fib(n-1) + fib(n-2) is the same\
    \ function as fib(n), so it doesn't need to compute it twice. Julia also knows\
    \ that fib(n) can be computed using fib(n-1) + fib(n-2), so it doesn't need to\
    \ compute it at all.", "    if n <= 1\n        1\n    else\n        fib(n-1) +\
    \ fib(n-2)\nend\n\"\"\"", "    if n <= 1 \n        then n \n        else fib(n-1)\
    \ + fib(n-2) \nend\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro will execute the function and return the elapsed time\
    \ (in seconds) for the function call.", "    if n == 0 || n == 1 \n        return\
    \ n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(100);\n</cell>\n<text>\nExercise 2\nWrite a recursive function named\
    \ fib_r(n::Int64) that returns the n-th Fibonacci number.", "    if n < 2 \n \
    \       then return n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time\
    \ macro tells Julia to run a code block a number of times and then print the time\
    \ it took to run that code block. Here we see that Julia is able to compute the\
    \ Fibonacci number in less than a second (about 2.5 seconds).", "    if n == 0\
    \ \n        then return 0\n    else if n == 1 \n        then return 1\n    else\
    \ \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(2)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(1)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(3)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(4)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(5)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(6)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(7)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(8)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(9)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(10)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(11)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(12)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(13)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(14)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(15)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(16)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(17)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(18)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(19)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(20)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(21)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(22)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(23)\n\
    </cell>\n<code language=julia-1.4>\n@code_warntype fib(24)\n</cell>\n<code language=julia-1.4>\n\
    @code_warntype fib(25)\n</cell>\n<code language=julia-1.4>\n@code_warntype fib(26)\n\
    </cell>\n<code language=julia-1.", "    if n < 2 \n        then return n\n   \
    \     else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nExercise\nWrite a function that returns the n-th\
    \ Fibonacci number in Julia.", "    if n < 2 \n        then return n\n       \
    \ else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will tell us how long it took\
    \ to run the code. Let's see what happens if we run it a million times:", "  \
    \  if n == 0 || n == 1 \n        return n\n    else \n        return fib(n - 1)\
    \ + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro tells Julia to compile the function and to run it a number\
    \ of times and to report the execution time for each execution.", "    if n <\
    \ 0 \n        error(\"Fibonacci number must be positive\")\n    else if n == 0\
    \ \n        return 0 \n    else if n == 1 \n        return 1 \n    else \n   \
    \     return fib(n-1) + fib(n-2) \nend \n</cell>\n<code language=julia-1.0>\n\
    @time fib(10)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec that\
    \ computes Fibonacci numbers using recursion.", "    if n == 0 \n        then\
    \ return 0\n    else if n == 1 \n        then return 1\n    else \n        return\
    \ fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(100)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000)\n</cell>\n<code language=julia-1.3>\n@time fib(10000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(100000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000)\n</cell>\n<code language=julia-1.3>\n@time fib(10000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(100000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(10000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(100000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(10000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(100000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(1000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(100000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(1000000000000000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(10000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(100000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time fib(1000000000000000000000)\n\
    </cell>\n<code language=julia-1.3>\n@time fib(10000000000000000000000)\n</cell>\n\
    <code language=julia-1.3>\n@time fib(100000000000000000000000)\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(1000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n@time\
    \ fib(100000000000000000000000000)\n</cell>\n<code language=julia-1.3>\n", " \
    \   if n == 0 \n        then return 0\n    else if n == 1 \n        then return\
    \ 1\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.3>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise 2\nWrite a recursive function fib_rec(n::Int64)::Int64 that returns the\
    \ nth Fibonacci number.", "    if n < 0 \n        error(\"Fibonacci number must\
    \ be positive\")\n    else if n == 0 \n        1\n    else \n        fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise: Write a recursive function fib_r(n::Int64)::Int64 that returns\
    \ the n-th Fibonacci number.", "    if n < 0 \n        error(\"Fibonacci number\
    \ must be positive\")\n    else if n == 0 \n        1\n    else if n == 1 \n \
    \       1\n    else \n        fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will execute the function and\
    \ time how long it takes to run. Let's time the function again:", "    if n ==\
    \ 0 || n == 1 \n        then return n\n    else \n        fib(n - 1) + fib(n -\
    \ 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10000)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec\
    \ that computes the nth Fibonacci number.", "    if n < 0 \n        error(\"n\
    \ must be positive\")\n    else if n == 0 \n        return 0 \n    else if n ==\
    \ 1 \n        return 1 \n    else \n        return fib(n-1) + fib(n-2) \nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(100)\n</cell>\n<text>\nExercise: Write a recursive function fib_rec(n::Int64)\
    \ that returns the nth Fibonacci number.", "    if n < 2 \n        then return\
    \ n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro will tell us how long it took\
    \ to run the code. Let's see what happens if we run it a million times:", "  \
    \  if n == 0 || n == 1 \n        then return n\n        else return fib(n - 1)\
    \ + fib(n - 2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n\
    </cell>\n<text>\nExercise: Write a function that calculates the n-th Fibonacci\
    \ number using recursion.", "    if n == 0 || n == 1 \n        return n\n    else\
    \ \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(100);\n</cell>\n<text>\nExercise 2\nWrite a function that computes the\
    \ n-th Fibonacci number using memoization.", "    if n == 0 || n == 1 \n     \
    \   return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise: Write a recursive\
    \ function named fib_r(n::Int64) that returns the nth Fibonacci number.", "  \
    \  if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that calculates the n-th Fibonacci number\
    \ using a recursive function and memoization.", "    if n < 2 \n        then return\
    \ n\n        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<text>\n\
    Exercise: Write a recursive function fib_rec(n::Int64) which returns the n-th\
    \ Fibonacci number.", "    if n == 0 || n == 1 \n        return n\n    else \n\
    \        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib(1000)\n</cell>\n<text>\nThe @time macro tells Julia to execute the code\
    \ in the cell and time how long it takes to execute. Julia will print the elapsed\
    \ time at the end. Here we see that Julia executes the code in the cell and prints\
    \ the elapsed time at the end.", "    if n == 0 \n        then return 0\n    else\
    \ if n == 1 \n        then return 1\n    else \n        return fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise\n\
    Write a function that returns the nth Fibonacci number using recursion.", "  \
    \  if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n\
    <text>\nExercise: Write a recursive function fib_rec(n::Int64) that returns the\
    \ nth Fibonacci number recursively.", "    if n < 2\n        1\n    else\n   \
    \     fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.0>\n@time fib(10)\n\
    </cell>\n<text>\nThe @time macro tells Julia to run a block of code several times\
    \ and then report the time it took to run that block of code. Julia will run that\
    \ block of code several times and then report the time it took to run that block\
    \ of code. Julia will run that block of code several times and then report the\
    \ time it took to run that block of code.", "    if n == 0 || n == 1 \n      \
    \  return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.4>\n@time fib(10)\n</cell>\n<text>\nExercise\nWrite a function\
    \ that calculates the n-th Fibonacci number using memoization.", "    if n ==\
    \ 0 || n == 1 \n        then return n\n    else \n        return fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(1000)\n</cell>\n<text>\nThe @time macro will time the execution of the\
    \ code block you provide.", "    if n == 0 || n == 1 \n        return n\n    else\
    \ \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nJulia is lazy, so this recursive function will\
    \ never actually be called. Instead, Julia will store a reference to the function\
    \ and call it when it is needed. In the above example, the function fib is only\
    \ called once, when it is first referenced.", "    if n == 0 || n == 1 \n    \
    \    then return n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(1000)\n</cell>\n<text>\nExercise 2\nWrite a function that computes the\
    \ n-th Fibonacci number using recursion.", "    if n == 0 || n == 1 \n       \
    \ then return n\n    else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nThe @time macro tells\
    \ Julia to run the function and time how long it takes to run. Julia will automatically\
    \ print the time it took to run the function and also the memory it took to run\
    \ the function. Note that Julia will automatically print the time it took to run\
    \ the function and also the memory it took to run the function.", "    if n ==\
    \ 0 || n == 1 \n        return n\n    else \n        return fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.5>\n@code_native fib(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a Julia function which returns the n-th Fibonacci number\
    \ using recursion.", "    if n < 2 \n        then return n\n        else return\
    \ fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ fib(10)\n</cell>\n<text>\nThe @code_warntype macro will warn you if you try\
    \ to call a function that doesn't exist.", "    if n == 0 || n == 1 \n       \
    \ return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n</cell>\n<code\
    \ language=julia-1.3>\n@time fib(10)\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that calculates the n-th Fibonacci number using recursion.", "    if n == 0\
    \ || n == 1 \n        return n\n    else \n        return fib(n-1) + fib(n-2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@code_warntype fib(10)\n</cell>\n<text>\n\
    The function fib is recursive, meaning that it will call itself over and over\
    \ again until it reaches the base case (when n is 0 or 1).", "    if n == 0 ||\
    \ n == 1 \n        return n\n    else \n        return fib(n-1) + fib(n-2)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<text>\nExercise:\
    \ Write a recursive function fib_rec that computes the n-th Fibonacci number recursively.",
  "    if n == 0 || n == 1 \n        return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n\
    <text>\nThe @time macro will execute the code in the cell and return the time\
    \ it took to execute.", "    if n == 0 || n == 1 \n        then return n\n   \
    \ else \n        return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to execute the function\
    \ and time how long it takes to run. Let's time the function again:", "    if\
    \ n == 0 || n == 1 \n        then return n\n    else \n        return fib(n-1)\
    \ + fib(n-2)\nend\n</cell>\n<code language=julia-1.3>\n@time fib(10)\n</cell>\n\
    <text>\nJulia is lazy, so this doesn't actually compute fib(10).", "    if n ==\
    \ 0 then return 0\n    if n == 1 then return 1\n    return fib(n - 1) + fib(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.5>\n@time fib(10)\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(100)\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(1000)\n</cell>\n<code language=julia-1.5>\n@time fib(10000)\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(100000)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(1000000)\n</cell>\n<code language=julia-1.5>\n@time fib(10000000)\n\
    </cell>\n<code language=julia-1.5>\n@time fib(100000000)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(1000000000)\n</cell>\n<code language=julia-1.5>\n@time fib(10000000000)\n\
    </cell>\n<code language=julia-1.5>\n@time fib(100000000000)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(1000000000000)\n</cell>\n<code language=julia-1.5>\n@time fib(10000000000000)\n\
    </cell>\n<code language=julia-1.5>\n@time fib(100000000000000)\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(1000000000000000)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10000000000000000)\n</cell>\n<code language=julia-1.5>\n@time fib(100000000000000000)\n\
    </cell>\n<code language=julia-1.5>\n@time fib(1000000000000000000)\n</cell>\n\
    <code language=julia-1.5>\n@time fib(10000000000000000000)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(100000000000000000000)\n</cell>\n<code language=julia-1.5>\n@time fib(1000000000000000000000)\n\
    </cell>\n<code language=julia-1.5>\n@time fib(10000000000000000000000)\n</cell>\n\
    <code language=julia-1.5>\n@time fib(100000000000000000000000)\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(1000000000000000000000000)\n</cell>\n<code language=julia-1.5>\n\
    @time fib(10000000000000000000000000)\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(100000000000000000000000000)\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(1000000000000000000000000000)\n", "    if n < 2 \n        then return n\n\
    \        else return fib(n-1) + fib(n-2)\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @time fib(10)\n</cell>\n<text>\nThe @time macro tells Julia to run the function\
    \ and time how long it takes to run. Here we see that Julia spends most of its\
    \ time in the recursive function fib, which makes sense since it calls itself\
    \ twice for each value of n."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
