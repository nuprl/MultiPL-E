name: HumanEval_121_solution
language: jl
prompt: "\"\"\"Given a non-empty list of integers, return the sum of all of the odd\
  \ elements that are in even positions.\n    \n\n    Examples\n    >>> solution([5,\
  \ 8, 7, 1]) \n    12\n    >>> solution([3, 3, 3, 3, 3]) \n    9\n        \"\"\"\n\
  function solution(lst::Vector{Int64})::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = solution;\n\t@test(candidate([5,\
  \ 8, 7, 1]) == 12)\n\t@test(candidate([3, 3, 3, 3, 3]) == 9)\n\t@test(candidate([30,\
  \ 13, 24, 321]) == 0)\n\t@test(candidate([5, 9]) == 5)\n\t@test(candidate([2, 4,\
  \ 8]) == 0)\n\t@test(candidate([30, 13, 23, 32]) == 23)\n\t@test(candidate([3, 13,\
  \ 2, 9]) == 3)\nend\n"
completions: ["    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n        \
    \    sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum Pairs\nGiven a list of numbers, return a list of\
    \ all pairs (a, b) where a < b and pairs have the same sum.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n\
    </cell>\n<code language=julia-1.0>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum even numbers\
    \ in an array (Optional)\nWrite a function that takes in a list of integers and\
    \ returns the sum of all of the even elements that are in odd positions.", " \
    \   evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(filter(x -> x % 2 == 1, odds)) + sum(evens)\nend\n</cell>\n<code\
    \ language=julia-1.3>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers Disappeared in\
    \ an Array\nGiven an array of integers, find the sum of all of the numbers that\
    \ do not appear in the array. \nFor example, given [5, 8, 7, 1, 3] return 17.",
  "    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend", "    evens = filter(x -> x % 2 == 0,\
    \ lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    return sum(odds)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum Pairs", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    \n\
    \    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x -> x % 2 != 1, evens))\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function can be defined recursively, which means it calls itself.\
    \ A recursive function can have one or more base cases. A base case is a case\
    \ where the function does not call itself. A recursive function can have one or\
    \ more recursive cases. A recursive case is a case where the function calls itself.\
    \ A recursive function can have one or more base cases and one or more recursive\
    \ cases.", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    \n    return sum(odd.+even)\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([3, 3, 3, 3, 3])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the number of times a given element appears in a given vector.", " \
    \   even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x %\
    \ 2 != 0, lst)]\n    \n    sum(odd)\nend\n</cell>\n<text>\nPart B: Odd-Even Summation\n\
    Write a function that takes a list of integers and returns the sum of all of the\
    \ odd elements that are in even positions.", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Even\
    \ Elements", "    sum = 0\n    for i in lst\n        if i%2 == 1\n           \
    \ sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum all the even numbers in a list", "    evens = filter(x\
    \ -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    return\
    \ sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum square difference\nGiven a non-empty list of integers,\
    \ return the sum of the squares of the odd integers. \nThe sum of the squares\
    \ of the even integers is 0. \nThe sum of an empty list is 0.", "    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend", "    \n    sum = 0\n    for i in lst\n        if\
    \ i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nNow let's\
    \ use recursion to solve the problem of finding the sum of all even numbers in\
    \ a list. We'll start by writing a function that takes in a list and returns the\
    \ sum of the even numbers in that list. We'll then use this function to solve\
    \ the problem of finding the sum of all even numbers in a list.", "    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@test solution([5,\
    \ 8, 7, 1]) == 12\n@test solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ 2: Recursion\nNow let's use recursion to solve the problem of finding the sum\
    \ of all even numbers in a list. We'll start by defining a function called sumEven.\
    \ This function will take in a list as an argument, and will return the sum of\
    \ all even numbers in the list. We'll then use recursion to solve the problem\
    \ by calling sumEven on every element in the list.", "    even = filter(x -> x\
    \ % 2 == 0, lst)\n    odd = filter(x -> x % 2 != 0, lst)\n    return sum(filter(x\
    \ -> x % 2 == 1, odd))\nend\n</cell>\n<text>\nProblem 3\nWrite a function that\
    \ returns a list of all numbers from 1 to n that are divisible by 3.", "    sum\
    \ = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nA recursive function is a function that calls itself. A recursive\
    \ function can call itself as many times as it wants. For example, consider the\
    \ Fibonacci sequence defined as:", "    evens = filter(x -> x % 2 == 0, lst)\n\
    \    odds = filter(x -> x % 2 != 0, lst)\n    return sum(odds)\nend\n</cell>\n\
    <text>\nProblem 3\nWrite a function that returns the product of all of the odd\
    \ elements in a given list.", "    \n    sum = 0\n    for x in lst\n        if\
    \ x % 2 == 1\n            sum += x\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nA recursive\
    \ function is a function that calls itself. A recursive function can have one\
    \ or more base cases. A base case is where a recursive function can stop calling\
    \ itself and return a value.", "    \n    sum = 0\n    for i in lst\n        if\
    \ i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Game of Life\nIn\
    \ this section, you will write your own version of the Game of Life algorithm.\
    \ Your algorithm should take in a square board and return a bitboard that indicates\
    \ when a cell has \"won\" or \"lost\" the game.", "    even = lst[findall(x ->\
    \ x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    sum(odd.+even)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function can be defined using an if statement that calls itself. This\
    \ can be done in Julia by defining a function with the function keyword.", " \
    \   \n    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum +=\
    \ x\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([3, 3, 3, 3, 3])\n</cell>\n<text>\nPart 3: Recursion\nRecursion is\
    \ a powerful tool for solving problems that involve repeating a problem until\
    \ a base case is reached.", "    sum = 0\n    for i in lst\n        if i%2 ==\
    \ 1\n            sum += i\n        end\n    end\n    return sum\nend", "    \n\
    \    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n  \
    \      end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2\
    \ != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, even) + filter(x -> x %\
    \ 2 != 1, odd))\nend\n</cell>\n<code language=julia-1.0>\n@time solution([5, 8,\
    \ 7, 1])\n</cell>\n<code language=julia-1.0>\n@time solution([3, 3, 3, 3, 3])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a vector of integers\
    \ and returns the number of elements that are less than or equal to each other. ",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend", "    evens = filter(x -> x % 2 ==\
    \ 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    evens_sum = sum(evens)\n\
    \    odds_sum = sum(odds)\n    \n    return evens_sum + odds_sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nNow that we've seen\
    \ how recursion works, let's see how we can implement it ourselves. We'll start\
    \ by writing a function that takes in a list of integers and returns the sum of\
    \ the odd elements that are in even positions.", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III: More on Vectors\n\
    Julia has many different types of vectors. In this notebook, we'll look at three\
    \ of them:", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x ->\
    \ x % 2 != 0, lst)\n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <text>\nProblem 7\nWrite a function that returns the product of the even numbers\
    \ in a given list.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    sum(filter(x -> x % 2 == 1, odds))\n\
    end\n</cell>\n<text>\nPart III: Sum All Even Elements\nWrite a function that takes\
    \ a list of integers and returns the sum of all of the even elements that are\
    \ in odd positions.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x\
    \ -> x % 2 != 0, lst)\n    \n    evensum = sum(evens)\n    oddsum = sum(odds)\n\
    \    \n    return evensum + oddsum\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function is a function that calls\
    \ itself. This can make code easier to read and understand.", "    \n    sum =\
    \ 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Sum All Numbers Disappeared in an Array", "    evens = filter(x -> x %\
    \ 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    sum(evens) + sum(odds)\n\
    end\n</cell>\n<text>\nPart 4\nWrite a function that takes in a string and returns\
    \ the number of words in the string. ", "    sum = 0\n    for i in lst\n     \
    \   if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\n\
    Now that we've seen the basics of recursion, let's see how we can use it to solve\
    \ a problem that doesn't require a loop!", "    \n    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n     \
    \       sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Game of Life\nIn this section, we will implement the\
    \ Game of Life using Julia's built-in data structures.", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<text>\nExercise 3\nWrite a function that returns the\
    \ product of all of the odd elements that are in even positions.", "    evens\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    \n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x ->\
    \ x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Recursion\nA recursive function is a function that calls itself. A recursive\
    \ function can be defined recursively, or iteratively. A recursive function calls\
    \ itself repeatedly until it reaches a base case. Recursive functions are often\
    \ easier to understand than iterative functions, but are often less efficient.",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    \n    return sum(filter(x -> x % 2 == 1, odds))\nend", "    sum = 0\n   \
    \ for i in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nA recursive function is a function that calls itself. This can\
    \ be done in Julia by using the function keyword.", "    sum = 0\n    for i in\
    \ lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum\
    \ All Numbers Disappeared in an Array", "    sum = 0\n    for i in lst\n     \
    \   if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@test solution([5, 8, 7, 1]) == 12\n\
    @test solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem 7", "    sum =\
    \ 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = sum(filter(x -> x % 2 != 0, lst))\n    return odd + sum(evens)\nend\n\
    </cell>\n<code language=julia-1.3>\n@time solution([5, 8, 7, 1])\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the product of the even elements in a\
    \ list. ", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x\
    \ % 2 != 0, lst)\n    \n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes in a list of integers and returns the\
    \ number of even and odd numbers in the list.", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2\
    \ != 0, lst)\n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@time solution(vec(primes))\n</cell>\n<text>\nPart 2\n\
    The second problem involves finding the sum of all the even numbers that are less\
    \ than a specified value.", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nA recursive function\
    \ is a function that calls itself. This can be done in Julia by using the function\
    \ keyword.", "    even = lst[findall(x -> x%2==0, lst)]\n    odd = lst[findall(x\
    \ -> x%2==1, lst)]\n    return sum(odd)+sum(even)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@time solution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<text>\nPart 2\nWrite a function that takes a list of\
    \ numbers and returns the product of all of the numbers in the list. Do not use\
    \ loops (for, while, or iterate).", "    sum = 0\n    for i in lst\n        if\
    \ i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nRecursion\
    \ is when a function calls itself. This can be done in Julia by using the function\
    \ call operator (::).", "    \n    sum = 0\n    for i in lst\n        if i%2 ==\
    \ 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers Below a Given\
    \ Number", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x\
    \ % 2 != 0, lst)\n    return sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Palindrome Partitioning\nGiven a string, find all possible\
    \ palindrome partitions of that string.", "    even = lst[findall(x -> x % 2 ==\
    \ 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(even)\
    \ + sum(odd)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nNow let's see how we can use recursion to solve this problem.\
    \ We'll start by writing a function that calculates the factorial of a number.\
    \ We'll then use recursion to solve the problem by calling the function with different\
    \ numbers. We'll then compare our results to those from previous parts to make\
    \ sure we got it right.", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend", "  \
    \  even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2\
    \ != 0, lst)]\n    \n    return sum(filter(x -> x % 2 == 1, even) + filter(x ->\
    \ x % 2 != 1, odd))\nend\n</cell>\n<text>\nProblem 7\nWrite a function that returns\
    \ the product of the even elements in a list. ", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. A recursive function can\
    \ have two types of inputs:", "    sum = 0\n    for i in lst\n        if i%2 ==\
    \ 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nA recursive function\
    \ is a function that calls itself. This can be useful in many situations, especially\
    \ in problems where you need to perform an operation on all elements of a collection,\
    \ but also need to keep track of some state between calls.", "    sum = 0\n  \
    \  for i in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.5>", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(evens) + sum(odds)\nend", "    evens = filter(x -> x % 2 == 0, lst)\n  \
    \  odds = filter(x -> x % 2 != 0, lst)\n    return sum(odds[2:end-1]) + sum(evens[2:end-1])\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum square\
    \ difference\nGiven a non-empty list of integers, return a list of all pairs (x,\
    \ y) where x is equal to the sum of the squares of all the numbers in the list\
    \ and y is equal to the sum of the squares of the numbers in the list except for\
    \ x and y where they are equal.", "    evens = filter(x -> x % 2 == 0, lst)\n\
    \    odds = filter(x -> x % 2 != 0, lst)\n    return sum(evens) + sum(odds)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Palindrome\
    \ Partitioning\nGiven a string, return a list of all possible palindrome partitioning\
    \ of that string.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1,\
    \ odds)) + sum(filter(x -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum square difference\nGiven a non-empty list of integers,\
    \ return a list of pairs of integers whose sum is equal to the given number. \n\
    \    \n    Each pair should consist of a pair of integers describing the range\
    \ of the sum.\n    \n    For example, given [4, 6, -2, -5, 7, 3], you should return\
    \ [(-2, 2), (-5, 3)].\n    \n    You can assume that each input would have exactly\
    \ one solution, and you may not use the same element twice.\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    ", "    even = filter(x -> x % 2 == 0, lst)\n    odd = filter(x\
    \ -> x % 2 != 0, lst)\n    return sum(even) + sum(odd)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum Pairs\nGiven a list of numbers, return a list of\
    \ all pairs of numbers whose sum is equal to a given target.", "    evens = filter(x\
    \ -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    return sum(filter(x\
    \ -> x % 2 == 1, odds))\nend\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ takes in a string and returns the number of words in the string.", "    evens\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(evens[2:end])\n    return\
    \ odd\nend", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x ->\
    \ x % 2 != 0, lst)\n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum Pairs\nGiven a list of numbers,\
    \ return a list of all pairs whose sum is equal to a given target.", "    even\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    return sum(filter(x -> x % 2 == 1, even) + filter(x -> x % 2 != 1,\
    \ odd))\nend\n</cell>\n<text>\nProblem 3\nWrite a function that returns a list\
    \ of all numbers from 1 to n that are divisible by 3. ", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@test solution([5,\
    \ 8, 7, 1]) == 12\n@test solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem\
    \ 8\nWrite a function that returns the product of the even elements in a list.",
  "    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Vectorized Solutions\nThe previous sections showed\
    \ how we can loop over each element of a list and perform some operation on it.\
    \ We can also vectorize this operation by applying the same operation to multiple\
    \ elements at once.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n  \
    \          sum += i\n        end\n    end\n    return sum\nend", "    evens =\
    \ filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n\
    \    return sum(odds[2:end-1]) + sum(evens[2:end-1])\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function is a function that calls\
    \ itself. This can be done in Julia by defining a function with one argument (a\
    \ list) and then calling it with the next element of the list as the argument.\
    \ For example, consider the following function that returns the factorial of a\
    \ number:", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    sum(evens) + sum(odds)\nend\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a list of integers and returns the product of\
    \ all of the numbers in the list. Do not use the reduce function.", "    even\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    return sum(odd.+even)\nend", "    sum = 0\n    for i in lst\n   \
    \     if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem 3\nA palindromic\
    \ number reads the same both ways. The largest palindrome made from the product\
    \ of two 2-digit numbers is 9009 = 91 \xD7 99.", "    \n    sum = 0\n    for i\
    \ in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n  \
    \  return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nA recursive function is a function that calls itself. A recursive\
    \ function is one that calls itself repeatedly until it reaches a base case. Base\
    \ cases are the simplest cases, where a recursive function stops calling itself\
    \ and returning a value.", "    \n    sum = 0\n    for x in lst\n        if x\
    \ % 2 == 1\n            sum += x\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the product of the even elements\
    \ in a list.", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    sum(filter(x -> x in even, odd))\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum square difference\nGiven a\
    \ vector of integers, find the sum of square differences between every pair of\
    \ consecutive elements.", "    \n    sum = 0\n    for x in lst\n        if x %\
    \ 2 == 1\n            sum += x\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@test solution([5, 8, 7, 1]) == 12\n@test solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem 7", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>", "    \n    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend", "    even = filter(x -> x % 2 == 0, lst)\n    odd = filter(x -> x\
    \ % 2 != 0, lst)\n    return sum(odd.take(even))\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution([5, 8, 7, 1]) \n</cell>\n<code language=julia-1.5>\n@time solution([3,\
    \ 3, 3, 3, 3]) \n</cell>\n<text>\nProblem 7\nWrite a function that returns the\
    \ product of all numbers in a given vector.", "    evens = filter(x -> x % 2 ==\
    \ 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    return sum(odds[end-1:end])\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Disappeared in an Array", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.3>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Even Elements", "    \n\
    \    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n  \
    \      end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum Pairs", "    sum = 0\n    for i in lst\n      \
    \  if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.0>\n@test solution([5, 8, 7, 1]) == 12\n@test\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart 3: Recursion\nRecursion\
    \ is a powerful tool for solving problems that involve repeating a process over\
    \ and over again. For example, if we wanted to find the factorial of a number,\
    \ we could write a function that would call itself until it reached the number\
    \ 1, and then return the number itself. Here is an example of a recursive function\
    \ that computes the factorial of a number:", "    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. This can be done in Julia\
    \ by defining a function with the keyword recursive and calling it with the function\
    \ name as a parameter. For example:", "    \n    sum = 0\n    for i in lst\n \
    \       if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem 7\nWrite a function\
    \ that returns the product of the even elements of an input list of integers.",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(evens) + sum(odds)\nend\n</cell>\n<text>\nProblem 8\nWrite a function\
    \ that returns the number of elements in a list that satisfy a given condition.\
    \ For example, the number of elements in the list [2, 3, 5, 7, 11, 13] that are\
    \ greater than 10 are 5. If a condition isn't provided, it should return 0 instead.",
  "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2\
    \ != 0, lst)]\n    sum(filter(x -> x % 2 == 1, odd))\nend\n</cell>\n<text>\nProblem\
    \ 7\nWrite a function that returns the sum of the numbers in the list provided\
    \ as an argument.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x\
    \ -> x % 2 != 0, lst)\n    \n    return sum(evens) + sum(odds)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III: Palindrome Partitioning\nIn this\
    \ problem, you will write a function that takes in a string and returns a list\
    \ of palindrome partitions. Each partition is represented as a list of characters,\
    \ where each character is either an 'a' or an 'e'.", "    evens = filter(x ->\
    \ x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    return\
    \ sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum all the odd digits in a number", "    evens = filter(x\
    \ -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    return\
    \ sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nA recursive function can be defined recursively, which means\
    \ it calls itself. A recursive function has two parts:", "    sum = 0\n    for\
    \ x in lst\n        if x % 2 == 1\n            sum += x\n        end\n    end\n\
    \    return sum\nend", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x\
    \ -> x % 2 != 0, lst)\n    return sum(evens) + sum(odds)\nend\n</cell>\n<text>\n\
    Problem 8\nWrite a function that returns the number of times a given number appears\
    \ in a given list.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x\
    \ -> x % 2 != 0, lst)\n    \n    return sum(filter(x -> x % 2 == 1, odds))\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum square difference\n\
    Given a non-empty list of integers, return the sum of the squares of the odd integers.\
    \ \nThe sum is computed according to the formula:", "    even = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(filter(x -> x % 2 == 1, even) + filter(x -> x % 2 != 1, odd))\nend\n</cell>\n\
    <text>\nProblem 3\nWrite a function that returns the product of the even numbers\
    \ in a list. ", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(filter(x\
    \ -> x % 2 != 0, lst))\n    return odd + evens\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum all the even numbers in a list\nGiven a non-empty\
    \ list of integers, return a new list containing all of the even numbers from\
    \ the original list. \n    \n    ", "    evens = lst[findall(x -> x % 2 == 0,\
    \ lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(filter(x\
    \ -> x % 2 == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum square difference\nGiven a\
    \ vector of numbers, calculate the sum of the squares of the numbers in the vector.",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function is a function that calls\
    \ itself. This can be useful in many situations. For example, consider the Fibonacci\
    \ sequence defined as:", "    sum = 0\n    for x in lst\n        if x % 2 == 1\n\
    \            sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nRecursion is a powerful\
    \ tool for solving problems that involve repeating a problem with smaller inputs.\
    \ For example, if we want to find the sum of all elements in a list, we can write\
    \ a function that calls itself to solve the problem for smaller inputs. Here is\
    \ an example of a recursive function that sums the elements of an input list:",
  "    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 != 0\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum all the\
    \ even numbers in a list\nGiven a non-empty list of integers, return a list of\
    \ all even numbers in the list. \n    ", "    sum = 0\n    for i in lst\n    \
    \    if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Disappeared in an Array", "    evens = filter(x -> x % 2 == 0, lst)\n    odds\
    \ = filter(x -> x % 2 != 0, lst)\n    return sum(evens) + sum(odds)\nend\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the product of all even numbers\
    \ in a given list.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1,\
    \ odds)) + sum(filter(x -> x % 2 != 1, evens))\nend\n</cell>\n<text>\nPart III:\
    \ Sum all the even numbers in a list\nWrite a function that takes a list of integers\
    \ and returns the sum of all the even numbers in the list.", "    sum = 0\n  \
    \  for i in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.0>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nA recursive function is a function that calls itself. This can\
    \ be done in Julia by using the function keyword.", "    evens = filter(x -> x\
    \ % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    return sum(evens)\
    \ + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Sum All Numbers Except Self\nGiven a non-empty vector of numbers, return\
    \ a vector of the sum of all of the numbers in the vector except the number itself.",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(odds[2:end-1]) + sum(evens[2:end-1])\nend", "    even = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    \n \
    \   return sum(odd.+even)\nend\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns the product of all the numbers in a list. Except the number 1, which\
    \ is 1\xD71=1. \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    \n    return sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function is a function that calls\
    \ itself. A recursive function can have two types of inputs: base cases and recursive\
    \ cases.", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n       \
    \     sum += i\n        end\n    end\n    return sum\nend", "    sum = 0\n   \
    \ for x in lst\n        if x % 2 == 1\n            sum += x\n        end\n   \
    \ end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nA recursive function is a function that calls itself. This can\
    \ be useful in many situations, such as solving problems such as fibonacci numbers.\
    \ In this section, we will see how to use recursion to solve problems such as\
    \ fibonacci numbers.", "    \n    sum = 0\n    for i in lst\n        if i%2 ==\
    \ 1\n            sum += i\n        end\n    end\n    return sum\nend", "    even\
    \ = filter(x -> x % 2 == 0, lst)\n    odd = filter(x -> x % 2 != 0, lst)\n   \
    \ \n    return sum(filter(x -> x % 2 == 1, odd))\nend", "    evens = filter(x\
    \ -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    return sum(filter(x\
    \ -> x % 2 == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n\
    <text>\nProblem 9\nWrite a function that returns the number of times a given substring\
    \ appears in a given string.", "    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nNow that we have an\
    \ understanding of what a recursive function is, let's see how we can implement\
    \ it ourselves. We'll start by writing a function that can add up all the numbers\
    \ in a list:", "    sum = 0\n    for i in lst\n        if i%2 == 1\n         \
    \   sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nNow that we've seen the basics of recursion,\
    \ let's see how we can use it to solve problems more complicated than \"find the\
    \ sum of all even numbers in a list\".  For this problem, we'll need to use recursion\
    \ to solve the problem of \"find the sum of all even numbers in a list\".  Let's\
    \ start with a simple case:", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(evens) + sum(odds)\n\
    end\n</cell>\n<text>\nProblem 7\nWrite a function that returns a list of all numbers\
    \ from 1 to n that are divisible by 3 or 5.", "    even = filter(x -> x % 2 ==\
    \ 0, lst)\n    odd = filter(x -> x % 2 != 0, lst)\n    \n    return sum(filter(x\
    \ -> x % 2 == 1, odd))\nend\n</cell>\n<text>\nProblem 3\nWrite a function that\
    \ returns a list of all numbers from 1 to n that are divisible by 3.", "    \n\
    \    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n  \
    \      end\n    end\n    return sum\nend", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Except Self\nWrite a function that returns the sum of all the numbers in a vector,\
    \ except the number itself, which you would get if you added all the numbers in\
    \ the vector together.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n   \
    \ odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2\
    \ == 1, odds)) + sum(filter(x -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nRecursion is a powerful tool for solving\
    \ problems that involve repeating a problem until a base case is reached.", " \
    \   evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    \n    return sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum even numbers from 1 to 100 (without loop)", " \
    \   evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(evens) + sum(odds)\nend\n</cell>\n<text>\nProblem 7\nWrite a function\
    \ that returns the product of all of the numbers in a list.", "    evens = filter(x\
    \ -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    return\
    \ sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<code language=julia-1.3>\n\
    @time solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.3>\n@time solution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<text>\nPart 4: Recursion", "    even = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(odd + even)\nend\n</cell>\n<text>\nPart 4\nWrite a function that takes a\
    \ string and returns the number of words in the string.", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n\
    \            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    sum = 0\n    for x in lst\n        if x % 2 == 1\n\
    \            sum += x\n        end\n    end\n    return sum\nend", "    sum =\
    \ 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem\
    \ 3\nA perfect number is a number for which the sum of its proper divisors is\
    \ exactly equal to the number. For example, the sum of the proper divisors of\
    \ 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum all the even-valued elements in a list\nWrite a\
    \ function that returns the sum of all the even-valued elements in a list.", " \
    \   even = filter(x -> x % 2 == 0, lst)\n    odd = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(even) + sum(odd)\nend\n</cell>\n<text>\nExercise 4\nWrite a function\
    \ that takes a vector of strings and returns a vector of strings where each string\
    \ is the concatenation of all the strings in the original vector, except the string\
    \ \"and\" which concatenates all the strings in the original vector except the\
    \ string \"and\".", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd =\
    \ lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(filter(x -> x % 2 ==\
    \ 1, even) + filter(x -> x % 2 != 1, odd))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function can be defined recursively,\
    \ which means it calls itself. This can be done by defining a function with a\
    \ name that starts with an uppercase letter. For example, the following function\
    \ calls itself to compute the factorial:", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum all numbers\
    \ in a list that are less than 100", "    evens = filter(x -> x % 2 == 0, lst)\n\
    \    odds = filter(x -> x % 2 != 0, lst)\n    \n    return sum(odds[2:end-1])\
    \ + sum(evens[2:end-1])\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Palindrome Partitioning\nThe palindrome partitioning problem is one where\
    \ you have a string and you want to split it into two halves while still preserving\
    \ the original string structure. For example, given \"aab\", return [\"aa\", \"\
    ab\"].", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x %\
    \ 2 != 0, lst)\n    return sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function is a function that calls\
    \ itself. A recursive function is one that calls itself over and over again until\
    \ it reaches a base case. For example, a recursive function that calculates the\
    \ factorial of a number might look something like this:", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@time solution([5,\
    \ 8, 7, 1]) \n</cell>\n<code language=julia-1.5>\n@time solution([3, 3, 3, 3,\
    \ 3]) \n</cell>\n<text>\nPart 2\nThe second problem involves finding the sum of\
    \ the numbers in the Fibonacci sequence that are less than a million. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonacci sequence and we want to find the sum\
    \ of all the numbers in the Fibonacci sequence that are less than $n$. More formally,\
    \ we are given $n$ numbers in the Fibonac", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end", "    \n    sum = 0\n    for x in lst\n        if x % 2 == 1\n          \
    \  sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum all even numbers in a vector", "    \n    sum =\
    \ 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nA recursive function is a function that calls itself. This can\
    \ be done in Julia by using the function keyword.", "    even = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    \n \
    \   return sum(filter(x -> x % 2 == 1, even) + filter(x -> x % 2 != 1, odd))\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum Pairs\n\
    Given a list of numbers, return a list of all pairs (a, b) where a < b and a +\
    \ b is in the list.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd\
    \ = sum(lst[findall(x -> x % 2 != 0, lst)])\n    return odd + sum(evens)\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Palindrome Partitioning",
  "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2\
    \ != 0, lst)]\n    sum(even) + sum(odd)\nend\n</cell>\n<text>\nProblem 7\nWrite\
    \ a function that returns the number of elements in a list that satisfy a predicate.",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(evens) + sum(odds)\nend", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: More on loops",
  "    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function is a function that calls\
    \ itself. A recursive function can have two types of inputs: base cases and recursive\
    \ cases.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x\
    \ % 2 != 0, lst)\n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers Disappeared in\
    \ an Array\nGiven a sorted array of integers, find the sum of all the numbers\
    \ appearing more than half the time.", "    even = lst[findall(x -> x % 2 == 0,\
    \ lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(odd.+even)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Finding the\
    \ first missing positive integer\nGiven a sorted array of integers, find the first\
    \ missing positive integer.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = sum(evens[2:end])\n    return odd\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nThe previous problem was solved using an\
    \ iterative approach. Now let's see how we could solve this problem using recursion.",
  "    \n    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum +=\
    \ x\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nNow let's see how we can use recursion to\
    \ solve this problem. We'll start by writing a function that can compute the factorial\
    \ of a number. We'll then use that function to write a function that computes\
    \ the sum of all odd integers in a given list.", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end", "    sum = 0\n    for i in lst\n        if i%2==0\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart II: Recursion\nA recursive function is a function that calls\
    \ itself. This can be done in Julia by defining a function with the keyword recursive\
    \ and calling it with the function name followed by the arguments that should\
    \ be passed to the function as its arguments.", "    \n    sum = 0\n    for i\
    \ in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n  \
    \  return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Recursion\nA recursive function is a function that calls itself. A recursive\
    \ function can have one or more base cases. A base case is a case where the function\
    \ does not call itself. A recursive function can have one or more recursive calls.\
    \ A recursive call can have one or more base cases. A recursive call can have\
    \ one or more recursive calls. A recursive call can have one or more base cases.\
    \ A recursive call can have one or more recursive calls. A recursive call can\
    \ have one or more base cases. A recursive call can have one or more recursive\
    \ calls. A recursive call can have one or more base cases. A recursive call can\
    \ have one or more recursive calls. A recursive call can have one or more base\
    \ cases. A recursive call can have one or more recursive calls. A recursive call\
    \ can have one or more base cases. A recursive call can have one or more recursive\
    \ calls. A recursive call can have one or more base cases. A recursive call can\
    \ have one or more recursive calls. A recursive call can have one or more base\
    \ cases. A recursive call can have one or more recursive calls. A recursive call\
    \ can have one or more base cases. A recursive call can have one or more recursive\
    \ calls. A recursive call can have one or more base cases. A recursive call can\
    \ have one or more recursive calls. A recursive call can have one or more base\
    \ cases. A recursive call can have one or more recursive calls. A recursive call\
    \ can have one or more base cases. A recursive call can have one or more recursive\
    \ calls. A recursive call can have one or more base cases. A recursive call can\
    \ have one or more recursive calls. A recursive call can have one or more base\
    \ cases. A recursive call can have one or more recursive calls. A recursive call\
    \ can have one or more base cases. A recursive call can have one or more recursive\
    \ calls. A recursive call can have one or more base cases. A recursive call can\
    \ have one or more recursive calls. A recursive call can have one or more base\
    \ cases. A recursive call can have one or more recursive calls. A recursive call\
    \ can have one or more base cases. A recursive call can have one or more recursive\
    \ calls. A recursive call can have one or more base cases. A recursive call can\
    \ have one or more recursive calls. A recursive call can have one or more base\
    \ cases. A recursive call can have one or more recursive calls. A recursive call\
    \ can have one or more base cases. A recursive call can have one or more recursive\
    \ calls. A recursive call can have one or more base cases. A recursive call can\
    \ have one or more recursive calls. A recursive call can have one or more ", " \
    \   evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x\
    \ % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x\
    \ -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Sum All Numbers Disappeared in an Array", "    evens = filter(x -> x %\
    \ 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    return sum(odds[2:end-1])\
    \ + sum(evens[2:end-1])\nend\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns the number of elements in a list that satisfy a predicate.", "    evens\
    \ = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n  \
    \  return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\n\
    end\n</cell>\n<code language=julia-1.4>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. This can be done in Julia\
    \ by defining a function with the function keyword.", "    sum = 0\n    for x\
    \ in lst\n        if x % 2 == 1\n            sum += x\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ II: Recursion\nRecursion is when a function calls itself. In Julia, this is\
    \ done by defining a function with the keyword function followed by the name of\
    \ the function, and a colon to indicate the end of the function definition.",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum all the even numbers in a vector", "    even =\
    \ lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n\
    \    return sum(even) + sum(odd)\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n\
    <text>\nPart III. Sum all the even numbers in a list", "    \n    sum = 0\n  \
    \  for i in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem\
    \ 7\nWrite a function that returns the number of times the value 1 appears in\
    \ a given list.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x\
    \ -> x % 2 != 0, lst)\n    \n    sum(evens) + sum(odds)\nend\n</cell>\n<text>\n\
    Problem 8\nWrite a function that returns the product of all of the odd elements\
    \ in a given list.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1,\
    \ odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<text>\nProblem\
    \ 7\nWrite a function that returns the number of times a given substring appears\
    \ in a given string.", "    \n    sum = 0\n    for i in lst\n        if i%2 ==\
    \ 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III: Recursion\nRecursion is one of\
    \ the most important and most important concepts in programming. It is a way of\
    \ breaking down problems into smaller pieces and solving them one at a time. Recursion\
    \ is often the most efficient way to solve a problem, but there are other ways\
    \ to solve the same problem.", "    evens = filter(x -> x % 2 == 0, lst)\n   \
    \ odds = filter(x -> x % 2 != 0, lst)\n    \n    return sum(evens) + sum(odds)\n\
    end", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum\
    \ += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum all odd digits in a number", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend", "    even = lst[findall(x -> x%2 == 0, lst)]\n \
    \   odd = lst[findall(x -> x%2 != 0, lst)]\n    \n    return sum(odd)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers Disappeared in\
    \ an Array\nGiven a sorted array of integers, find the sum of all numbers appearing\
    \ more than half the time.", "    even = lst[findall(x -> x%2 == 0, lst)]\n  \
    \  odd = lst[findall(x -> x%2 != 0, lst)]\n    \n    return sum(even) + sum(odd)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Disappeared in an Array", "    even = filter(x -> x % 2 == 0, lst)\n    odd\
    \ = filter(x -> x % 2 != 0, lst)\n    return sum(even) + sum(odd)\nend\n</cell>\n\
    <text>\nProblem 8\nWrite a function that takes a string and returns the number\
    \ of words in the string.", "    even = lst[findall(x -> x % 2 == 0, lst)]\n \
    \   odd = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(odd.+even)\nend\n\
    </cell>\n<text>\nProblem 3\nWrite a function that takes a vector of integers and\
    \ returns the sum of the squares of the odd numbers in that vector. ", "    even\
    \ = filter(x -> x % 2 == 0, lst)\n    odd = filter(x -> x % 2 != 0, lst)\n   \
    \ \n    sum(even) + sum(odd)\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n\
    <text>\nPart II: Recursion\nA recursive function is a function that calls itself.\
    \ A recursive function can have two types of inputs: base cases and recursive\
    \ cases. Base cases occur when the function has finished its task and is ready\
    \ to accept new inputs. Recursive cases occur when the function has finished its\
    \ task and is ready to accept new inputs, but it needs to make use of one or more\
    \ of the functions it called before it can do so. For example, consider the Fibonacci\
    \ sequence defined recursively as follows:", "    evens = lst[findall(x -> x %\
    \ 2 == 0, lst)]\n    odd = sum(x -> x % 2 == 1, lst)\n    return odd + sum(x ->\
    \ x in evens, lst)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Sum square difference\nGiven a vector of numbers, compute the sum of the\
    \ squares of the numbers in the vector.", "    sum = 0\n    for i in lst\n   \
    \     if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: More on functions\n\
    Now that we've seen how to use loops to solve problems, let's see how we can use\
    \ Julia's functional programming tools to solve the same problems.", "    evens\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    return sum(evens) + sum(odds)\nend", "    \n    sum = 0\n    for\
    \ i in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Sum all numbers in a range\nGiven a positive integer $N$, return $N$ if\
    \ it is evenly divisible by 3, otherwise return the sum of all numbers from 1\
    \ to $N$ that are divisible by 3.", "    evens = filter(x -> x % 2 == 0, lst)\n\
    \    odds = filter(x -> x % 2 != 0, lst)\n    return sum(filter(x -> x % 2 ==\
    \ 1, odds))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart\
    \ III. Sum even numbers in a vector", "    sum = 0\n    for i in lst\n       \
    \ if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n\
    <text>\nPart III: Recursion\nA recursive function is a function that calls itself.\
    \ This can be very useful in many situations. For example, consider the Fibonacci\
    \ sequence defined as:", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nNow that we've seen\
    \ how recursion works, let's see how we can use it to solve a problem that doesn't\
    \ require a loop. Let's say we want to find the sum of all even numbers in a list.\
    \ One way to do this is with a loop:", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>", "    sum = 0\n    for i in lst\n   \
    \     if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Except Self\nWrite a function that returns the sum of all integers except the\
    \ number itself, if it is even.", "    evens = filter(x -> x % 2 == 0, lst)\n\
    \    odds = filter(x -> x % 2 != 0, lst)\n    return sum(odds) + sum(evens)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum square\
    \ difference\nGiven a non-empty list of integers, return a list of pairs of integers\
    \ whose sum is equal to the given number. \n    \n    Each pair should consist\
    \ of a pair of integers describing the range of the sum.\n    \n    For example,\
    \ given [4, 8, 15, 16, 23, 42], you should return [[0, 3], [4, 9]].\n    \n  \
    \  You can assume that the given numbers will all be unique.\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    ", "    even = filter(x -> x % 2 == 0, lst)\n\
    \    odd = filter(x -> x % 2 != 0, lst)\n    return sum(even) + sum(odd)\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nThe previous\
    \ problem was solved using loops. Now, let's see how we can solve this problem\
    \ using recursion.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(filter(x -> x % 2\
    \ != 0, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that returns the product of all elements in a list.", " \
    \   evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(odds[2:end-1]) + sum(evens[2:end-1])\nend\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a vector of integers and returns a new vector\
    \ where each element is the sum of the elements in the original vector except\
    \ the element at that index.", "    evens = filter(x -> x % 2 == 0, lst)\n   \
    \ odds = filter(x -> x % 2 != 0, lst)\n    sum(evens) + sum(odds)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum Pairs\nGiven a vector of integers,\
    \ return a new vector where each element is the sum of the two numbers directly\
    \ before it in the original vector.", "    even = filter(x -> x % 2 == 0, lst)\n\
    \    odd = filter(x -> x % 2 != 0, lst)\n    return sum(even) + sum(odd)\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart II: Recursion\nThe previous\
    \ problem was a little bit more challenging than the previous ones. Here we go\
    \ a little bit more challenging, and we will be using recursion to solve it.",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend", "    sum = 0\n    for x in lst\n    \
    \    if x % 2 == 1\n            sum += x\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum all the\
    \ even numbers in a list\nWrite a function that returns the sum of all the even\
    \ numbers in a given list.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds\
    \ = filter(x -> x % 2 != 0, lst)\n    \n    return sum(filter(x -> x % 2 == 1,\
    \ odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum Pairs\nGiven a collection of numbers, return a\
    \ new collection of numbers where each pair of numbers is the sum of the two original\
    \ numbers.", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n     \
    \       sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    \n    sum = 0\n    for i in lst\n        if i%2 != 0\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n\
    <text>\nProblem 7\nWrite a function that returns the product of the even elements\
    \ of a list of numbers.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n\
    \            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n</cell>\n<text>\nPart III. Sum all even numbers in a vector",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Recursion\nA recursive function is a function that\
    \ calls itself. A recursive function can have one or more base cases. A base case\
    \ is a case where the function does not call itself recursively.", "    evens\
    \ = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n  \
    \  \n    sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n\
    <text>\nPart III. Sum Pairs\nGiven a list of numbers, return a new list containing\
    \ all the pairs of numbers (i, j)\nsuch that i < j and abs(i - j) <= k. \nFor\
    \ example, given [5, 7, 7, 8, 10] and k = 2, return [5, 7].", "    evens = filter(x\
    \ -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    \n    return\
    \ sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<text>\nProblem 7\nWrite a\
    \ function that returns the product of the even numbers in a given list.", " \
    \   \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart III. Sum All Odd Elements", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@test solution([5, 8, 7, 1]) == 12\n\
    @test solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\nProblem 4\nWrite a function\
    \ that returns the product of all of the numbers in a given list."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
