{
  "language": "d",
  "name": "HumanEval_57_monotonic",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpeb_z6kus.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpeb_z6kus.__unittest_L20_C1() [0x427f47]\n??:? void tmpeb_z6kus.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = 0;\n\tlong min = 0;\n\tbool isMonotonic = true;\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] != max && l[i] != min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpoyzhkgka.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpoyzhkgka.__unittest_L29_C1() [0x427f9d]\n??:? void tmpoyzhkgka.__modtest() [0x428120]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool increasing = true;\n\tbool decreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tincreasing = false;\n\t\t\tdecreasing = false;\n\t\t}\n\t}\n\treturn increasing || decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1dzhf872.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283bd]\n??:? void tmp1dzhf872.__unittest_L31_C1() [0x428011]\n??:? void tmp1dzhf872.__modtest() [0x42813c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c43f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430465]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430914]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2a9]\n??:? runModuleUnitTests [0x42c215]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428880]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong minv = l[0];\n\tlong maxv = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < minv)\n\t\t{\n\t\t\tminv = l[i];\n\t\t}\n\t\telse if(l[i] > maxv)\n\t\t{\n\t\t\tmaxv = l[i];\n\t\t}\n\t}\n\treturn minv < maxv;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpckcdf4fk.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpckcdf4fk.__unittest_L24_C1() [0x427f4b]\n??:? void tmpckcdf4fk.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tlong x = l[i];\n\t\tif(x == r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(x == l)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = isDecreasing = true;\n\t\t}\n\t\tr = x;\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd904fmn3.d(9): Error: variable `l` is shadowing variable `tmpd904fmn3.monotonic.l`\n/tmp/tmpd904fmn3.d(10): Error: only one index allowed to index `long`\n/tmp/tmpd904fmn3.d(13): Error: no property `length` for type `long`\n/tmp/tmpd904fmn3.d(15): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd904fmn3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgpspos_f.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283fd]\n??:? void tmpgpspos_f.__unittest_L33_C1() [0x427faf]\n??:? void tmpgpspos_f.__modtest() [0x428180]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c47f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b312]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430954]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]\n??:? runModuleUnitTests [0x42c255]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > r)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] < r)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1f9yp92j.d(9): Error: variable `l` is shadowing variable `tmp1f9yp92j.monotonic.l`\n/tmp/tmp1f9yp92j.d(10): Error: only one index allowed to index `long`\n/tmp/tmp1f9yp92j.d(12): Error: no property `length` for type `long`\n/tmp/tmp1f9yp92j.d(14): Error: only one index allowed to index `long`\n/tmp/tmp1f9yp92j.d(19): Error: only one index allowed to index `long`\n/tmp/tmp1f9yp92j.d(26): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1f9yp92j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool result = false;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > prev)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfxaa4nry.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428355]\n??:? void tmpfxaa4nry.__unittest_L29_C1() [0x427e6c]\n??:? void tmpfxaa4nry.__modtest() [0x4280d8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b26a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430389]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]\n??:? runModuleUnitTests [0x42c1ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428818]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] > r)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisDecreasing = true;\n\t\t\tisIncreasing = true;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8uczgmfx.d(9): Error: variable `l` is shadowing variable `tmp8uczgmfx.monotonic.l`\n/tmp/tmp8uczgmfx.d(10): Error: only one index allowed to index `long`\n/tmp/tmp8uczgmfx.d(13): Error: no property `length` for type `long`\n/tmp/tmp8uczgmfx.d(15): Error: only one index allowed to index `long`\n/tmp/tmp8uczgmfx.d(19): Error: only one index allowed to index `long`\n/tmp/tmp8uczgmfx.d(28): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8uczgmfx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool increasing = true;\n\tbool decreasing = true;\n\tfor(int i=1; i<l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tincreasing = false;\n\t\t\tdecreasing = false;\n\t\t}\n\t}\n\treturn increasing || decreasing;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmhog1525.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4283bd]\n??:? void tmpmhog1525.__unittest_L35_C1() [0x428011]\n??:? void tmpmhog1525.__modtest() [0x42813c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c43f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430465]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430914]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2a9]\n??:? runModuleUnitTests [0x42c215]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428880]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpf1jylfsq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpf1jylfsq.__unittest_L25_C1() [0x427f33]\n??:? void tmpf1jylfsq.__modtest() [0x428104]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3lc5a59_.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4283e5]\n??:? void tmp3lc5a59_.__unittest_L37_C1() [0x427f97]\n??:? void tmp3lc5a59_.__modtest() [0x428168]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c467]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43048d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43093c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430419]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2d1]\n??:? runModuleUnitTests [0x42c23d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288a8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqixm02hx.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqixm02hx.__unittest_L20_C1() [0x427f47]\n??:? void tmpqixm02hx.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tbool l3 = false;\n\tbool l4 = false;\n\tbool l5 = false;\n\tbool l6 = false;\n\tbool l7 = false;\n\tbool l8 = false;\n\tbool l9 = false;\n\tbool l10 = false;\n\tbool l11 = false;\n\tbool l12 = false;\n\tbool l13 = false;\n\tbool l14 = false;\n\tbool l15 = false;\n\tbool l16 = false;\n\tbool l17 = false;\n\tbool l18 = false;\n\tbool l19 = false;\n\tbool l20 = false;\n\tbool l21 = false;\n\tbool l22 = false;\n\tbool l23 = false;\n\tbool l24 = false;\n\tbool l25 = false;\n\tbool l26 = false;\n\tbool l27 = false;\n\tbool l28 = false;\n\tbool l29 = false;\n\tbool l30 = false;\n\tbool l31 = false;\n\tbool l32 = false;\n\tbool l33 = false;\n\tbool l34 = false;\n\tbool l35 = false;\n\tbool l36 = false;\n\tbool l37 = false;\n\tbool l38 = false;\n\tbool l39 = false;\n\tbool l40 = false;\n\tbool l41 = false;\n\tbool l42 = false;\n\tbool l43 = false;\n\tbool l44 = false;\n\tbool l45 = false;\n\tbool l46 = false;\n\tbool l47 = false;\n\tbool l48 = false;\n\tbool l49 = false;\n\tbool l50 = false;\n\tbool l51 = false;\n\tbool l52 = false;\n\tbool l53 = false;\n\tbool l54 = false;\n\tbool l55 = false;\n\tbool l56 = false;\n\tbool l57 = false;\n\tbool l58 = false;\n\tbool l59 = false;\n\tbool l60 = false;\n\tbool l61 = false;\n\tbool l62 = false;\n\tbool l63 = false;\n\tbool l64 = false;\n\tbool l65 = false;\n\tbool l66 = false;\n\tbool l67 = false;\n\tbool l68 = false;\n\tbool l69 = false;\n\tbool l70 = false;\n\tbool l71 = false;\n\tbool l72 = false;\n\tbool l73 = false;\n\tbool l74 = false;\n\tbool l75 = false;\n\tbool l76 = false;\n\tbool l77 = false;\n\tbool l78 = false;\n\tbool l79 = false;\n\tbool l80 = false;\n\tbool l81 = false;\n\tbool l82 = \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppovco0o4.d(91): Error: expression expected, not `unittest`\n/tmp/tmppovco0o4.d(92): Error: semicolon expected, not `{`\n/tmp/tmppovco0o4.d(104): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppovco0o4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp41mnk_7z.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp41mnk_7z.__unittest_L24_C1() [0x427eac]\n??:? void tmp41mnk_7z.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if (l[i] < min)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgpt88t8d.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpgpt88t8d.__unittest_L28_C1() [0x427f57]\n??:? void tmpgpt88t8d.__modtest() [0x428128]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tlong l = l[0];\n\twhile (i < l.length && j < l.length) {\n\t\tif (l[i] < l[j]) {\n\t\t\tk = i;\n\t\t\ti = j;\n\t\t\tj = k;\n\t\t}\n\t\telse {\n\t\t\tk = i;\n\t\t\ti = j;\n\t\t\tj = k;\n\t\t}\n\t}\n\tif (i < l.length) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv7vdslse.d(12): Error: variable `l` is shadowing variable `tmpv7vdslse.monotonic.l`\n/tmp/tmpv7vdslse.d(13): Error: no property `length` for type `long`\n/tmp/tmpv7vdslse.d(13): Error: no property `length` for type `long`\n/tmp/tmpv7vdslse.d(14): Error: only one index allowed to index `long`\n/tmp/tmpv7vdslse.d(14): Error: only one index allowed to index `long`\n/tmp/tmpv7vdslse.d(25): Error: no property `length` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv7vdslse.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tbool isMonotonic = true;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) \n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > l[j]) \n\t\t{\n\t\t\tj++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp14v3trsh.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428355]\n??:? void tmp14v3trsh.__unittest_L31_C1() [0x427e68]\n??:? void tmp14v3trsh.__modtest() [0x4280d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b26a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430389]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]\n??:? runModuleUnitTests [0x42c1ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428818]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong minVal = l[0];\n\tlong maxVal = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < minVal)\n\t\t{\n\t\t\tminVal = l[i];\n\t\t}\n\t\tif (l[i] > maxVal)\n\t\t{\n\t\t\tmaxVal = l[i];\n\t\t}\n\t}\n\tif (minVal < maxVal)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptv29yx2b.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmptv29yx2b.__unittest_L33_C1() [0x427ea8]\n??:? void tmptv29yx2b.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppvmm_6d7.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmppvmm_6d7.__unittest_L24_C1() [0x427f4b]\n??:? void tmppvmm_6d7.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tbool result = false;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > l[j]) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpic25pqbz.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x42834d]\n??:? void tmpic25pqbz.__unittest_L27_C1() [0x427eff]\n??:? void tmpic25pqbz.__modtest() [0x4280d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b262]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430381]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b239]\n??:? runModuleUnitTests [0x42c1a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428810]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t\treturn false;\n\t\tif(l[i] < min)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2jhbo9os.d(24): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp2jhbo9os.__unittest_L20_C1() [0x427e58]\n??:? void tmp2jhbo9os.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpc4l1hwbi.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpc4l1hwbi.__unittest_L24_C1() [0x427f37]\n??:? void tmpc4l1hwbi.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min > max)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp4rfae0a.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpp4rfae0a.__unittest_L29_C1() [0x427f53]\n??:? void tmpp4rfae0a.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tlong next = 1;\n\tbool result = false;\n\t\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tcurr = next;\n\t\tnext = l[i];\n\t\tif (curr < prev)\n\t\t{\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptez0usrz.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmptez0usrz.__unittest_L28_C1() [0x427e20]\n??:? void tmptez0usrz.__modtest() [0x42808c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min=0;\n\tlong max=l[0];\n\tfor(int i=1;i<l.length;i++)\n\t{\n\t\tif(l[i]<min)\n\t\t\tmin=l[i];\n\t\tif(l[i]>max)\n\t\t\tmax=l[i];\n\t}\n\treturn (min>max);\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcb_3nqvg.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428375]\n??:? void tmpcb_3nqvg.__unittest_L24_C1() [0x427e88]\n??:? void tmpcb_3nqvg.__modtest() [0x4280f4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b28a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43041d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308cc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b261]\n??:? runModuleUnitTests [0x42c1cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428838]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(l[i] < min)\n\t\t\t{\n\t\t\t\tisDecreasing = false;\n\t\t\t}\n\t\t\telse if(l[i] > max)\n\t\t\t{\n\t\t\t\tisIncreasing = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5wyhy0os.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428425]\n??:? void tmp5wyhy0os.__unittest_L37_C1() [0x427fd3]\n??:? void tmp5wyhy0os.__modtest() [0x4281a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c4a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b33a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43097c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430459]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b311]\n??:? runModuleUnitTests [0x42c27d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long i = 0;\n    long j = 1;\n    bool result = false;\n    while(i < l.length && j < l.length) \n    {\n        if(l[i] < l[j]) {\n            result = true;\n            break;\n        }\n        else if(l[i] > l[j]) {\n            result = false;\n            break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n}\n/*\nReturn True if list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkcp_3sg5.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42834d]\n??:? void tmpkcp_3sg5.__unittest_L31_C1() [0x427eff]\n??:? void tmpkcp_3sg5.__modtest() [0x4280d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b262]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430381]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b239]\n??:? runModuleUnitTests [0x42c1a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428810]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpeb_z6kus.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpeb_z6kus.__unittest_L20_C1() [0x427f47]\n??:? void tmpeb_z6kus.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long x0 = l[0];\n    long x1 = l[1];\n    long x2 = l[2];\n    long x3 = l[3];\n    long x4 = l[4];\n    long x5 = l[5];\n    long x6 = l[6];\n    long x7 = l[7];\n    long x8 = l[8];\n    long x9 = l[9];\n    long x10 = l[10];\n    long x11 = x[11];\n    long x12 = x[12];\n    long x13 = x[13];\n    long x14 = x[14];\n    long x15 = x[15];\n    long x16 = x[16];\n    long x17 = x[17];\n    long x18 = x[18];\n    long x19 = x[19];\n    long x20 = x[20];\n    long x21 = x[21];\n    long x22 = x[22];\n    long x23 = x[23];\n    long x24 = x[24];\n    long x25 = x[25];\n    long x26 = x[26];\n    long x27 = x[27];\n    long x28 = x[28];\n    long x29 = x[29];\n    long x30 = x[28];\n    long x31 = x[29];\n    long x32 = x[28];\n    long x33 = x[29];\n    long x34 = x[28];\n    long x35 = x[29];\n    long x36 = x[28];\n    long x37 = x[29];\n    long x38 = x[28];\n    long x39 = x[29];\n    long x40 = x[28];\n    long x41 = x[29];\n    long x42 = x[28];\n    long x43 = x[29];\n    long x44 = x[28];\n    long x45 = x[29];\n    long x46 = x[28];\n    long x47 = x[29];\n    long x48 = x[28];\n    long x49 = x[29];\n    long x50 = x[28];\n    long x51 = x[29];\n    long x52 = x[28];\n    long x53 = x[29];\n    long x54 = x[28];\n    long x55 = x[29];\n    long x56 = x[28];\n    long x57 = x[29];\n    long x58 = x[28];\n    long x59\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgiq12w_q.d(69): Error: semicolon expected, not `unittest`\n/tmp/tmpgiq12w_q.d(69): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgiq12w_q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tlong l = l[0];\n\tlong m = l[1];\n\twhile (i < l.length) \n\t{\n\t\tk = l;\n\t\tl = m;\n\t\tm = k;\n\t\ti++;\n\t}\n\tif (l < m) return true;\n\telse return false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzibn1caw.d(12): Error: variable `l` is shadowing variable `tmpzibn1caw.monotonic.l`\n/tmp/tmpzibn1caw.d(13): Error: only one index allowed to index `long`\n/tmp/tmpzibn1caw.d(14): Error: no property `length` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzibn1caw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long a = l[0];\n    long b = l[1];\n    long c = l[2];\n    long d = l[3];\n    long e = l[4];\n    long f = l[5];\n    long g = l[6];\n    long h = l[7];\n    long i = l[8];\n    long j = l[9];\n    long k = l[10];\n    long l = l[11];\n    long m = l[12];\n    long n = l[13];\n    long o = l[14];\n    long p = l[15];\n    long q = l[16];\n    long r = l[17];\n    long s = l[18];\n    long t = l[19];\n    long u = l[20];\n    long v = l[21];\n    long w = l[22];\n    long x = l[23];\n    long y = l[24];\n    long z = l[25];\n    long a = l[26];\n    long b = l[27];\n    long c = l[28];\n    long d = l[29];\n    long e = l[30];\n    long f = l[31];\n    long g = l[32];\n    long h = l[33];\n    long i = l[34];\n    long j = l[35];\n    long k = l[36];\n    long l = l[37];\n    long m = l[38];\n    long n = l[39];\n    long o = l[40];\n    long p = l[41];\n    long q = l[42];\n    long r = l[43];\n    long s = l[44];\n    long t = l[45];\n    long u = l[46];\n    long v = l[47];\n    long w = l[48];\n    long x = l[49];\n    long y = l[50];\n    long z = l[51];\n    long a = l[52];\n    long b = l[53];\n    long c = l[54];\n    long d = l[55];\n    long e = l[56];\n    long f = l[57];\n    long g = l[58];\n    long h = l[59];\n    long i = l[60];\n    long j = l[61];\n    long k = l[62];\n    long l = l[63];\n    long m = l[64];\n    long n = l[65];\n    long o = \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe6bju5pu.d(76): Error: expression expected, not `unittest`\n/tmp/tmpe6bju5pu.d(77): Error: semicolon expected, not `{`\n/tmp/tmpe6bju5pu.d(89): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe6bju5pu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": -1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\twhile (i < l.length && j < l.length) {\n\t\tif (l[i] < l[j]) {\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] > l[j]) {\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Timeout",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164453
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\twhile(i < l.length && j < l.length) \n\t{\n\t\tif(l[i] < l[j]) \n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if(l[i] > l[j]) \n\t\t{\n\t\t\tisDecreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\tif(isIncreasing && isDecreasing) \n\t{\n\t\treturn true;\n\t}\n\telse \n\t{\n\t\treturn false;\n\t}\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdqbt42vu.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428365]\n??:? void tmpdqbt42vu.__unittest_L41_C1() [0x427e7c]\n??:? void tmpdqbt42vu.__modtest() [0x4280e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b27a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43040d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430399]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b251]\n??:? runModuleUnitTests [0x42c1bd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428828]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > r)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\telse if (l[i] < r)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph6t_rx6s.d(9): Error: variable `l` is shadowing variable `tmph6t_rx6s.monotonic.l`\n/tmp/tmph6t_rx6s.d(10): Error: only one index allowed to index `long`\n/tmp/tmph6t_rx6s.d(12): Error: no property `length` for type `long`\n/tmp/tmph6t_rx6s.d(14): Error: only one index allowed to index `long`\n/tmp/tmph6t_rx6s.d(18): Error: only one index allowed to index `long`\n/tmp/tmph6t_rx6s.d(24): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph6t_rx6s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tlong next = 1;\n\tbool result = false;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tcurr = next;\n\t\tnext = l[i];\n\t\tif (curr < prev)\n\t\t{\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\telse if (curr > prev)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3wb_yrma.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmp3wb_yrma.__unittest_L31_C1() [0x427e2c]\n??:? void tmp3wb_yrma.__modtest() [0x428098]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c397]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b22a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43086c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430349]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b201]\n??:? runModuleUnitTests [0x42c16d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tlong mid = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tisDecreasing = false;\n\t\t}\n\t\tmid = l[i];\n\t}\n\tif(isIncreasing && isDecreasing)\n\t{\n\t\treturn true;\n\t}\n\telse if(isIncreasing && !isDecreasing)\n\t{\n\t\treturn false;\n\t}\n\telse if(!isIncreasing && isDecreasing)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\treturn true;\n\t}\n}\n/*\nReturn True if list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpi_5u1s_u.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428415]\n??:? void tmpi_5u1s_u.__unittest_L52_C1() [0x427fc7]\n??:? void tmpi_5u1s_u.__modtest() [0x428198]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c497]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b32a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43096c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430449]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b301]\n??:? runModuleUnitTests [0x42c26d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > prev)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbt6x7mea.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428355]\n??:? void tmpbt6x7mea.__unittest_L29_C1() [0x427e6c]\n??:? void tmpbt6x7mea.__modtest() [0x4280d8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b26a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430389]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]\n??:? runModuleUnitTests [0x42c1ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428818]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpf1jylfsq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpf1jylfsq.__unittest_L25_C1() [0x427f33]\n??:? void tmpf1jylfsq.__modtest() [0x428104]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = std.array.length(l);\n\tlong l2 = l / 2;\n\tlong l3 = l - l2;\n\tlong l4 = l3 - l2;\n\tlong l5 = l4 - l2;\n\tlong l6 = l5 - l2;\n\tlong l7 = l6 - l2;\n\tlong l8 = l7 - l2;\n\tlong l9 = l8 - l2;\n\tlong l10 = l9 - l2;\n\tlong l11 = l10 - l2;\n\tlong l12 = l11 - l2;\n\tlong l13 = l12 - l2;\n\tlong l14 = l13 - l2;\n\tlong l15 = l14 - l2;\n\tlong l16 = l15 - l2;\n\tlong l17 = l16 - l2;\n\tlong l18 = l17 - l2;\n\tlong l19 = l18 - l2;\n\tlong l20 = l19 - l2;\n\tlong l21 = l20 - l2;\n\tlong l22 = l21 - l2;\n\tlong l23 = l22 - l2;\n\tlong l24 = l23 - l2;\n\tlong l25 = l24 - l2;\n\tlong l26 = l25 - l2;\n\tlong l27 = l26 - l2;\n\tlong l28 = l27 - l2;\n\tlong l29 = l28 - l2;\n\tlong l30 = l29 - l2;\n\tlong l31 = l30 - l2;\n\tlong l32 = l31 - l2;\n\tlong l33 = l32 - l2;\n\tlong l34 = l33 - l2;\n\tlong l35 = l34 - l2;\n\tlong l36 = l35 - l2;\n\tlong l37 = l36 - l2;\n\tlong l38 = l37 - l2;\n\tlong l39 = l38 - l2;\n\tlong l40 = l39 - l2;\n\tlong l41 = l40 - l2;\n\tlong l42 = l41 - l2;\n\tlong l43 = l42 - l2;\n\tlong l44 = l43 - l2;\n\tlong l45 = l44 - l2;\n\tlong l46 = l45 - l2;\n\tlong l47 = l46 - l2;\n\tlong l48 = l47 - l2;\n\t\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1s1bqa1m.d(58): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1s1bqa1m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5_hxj07f.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp5_hxj07f.__unittest_L29_C1() [0x427ff1]\n??:? void tmp5_hxj07f.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tbool isMonotonic = true;\n\twhile (i < l.length && j > 0) {\n\t\tif (l[i] < l[j]) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpjb8lo8o7.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x4282ed]\n??:? void tmpjb8lo8o7.__unittest_L25_C1() [0x427e04]\n??:? void tmpjb8lo8o7.__modtest() [0x428070]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c36f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b202]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430395]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430844]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430321]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d9]\n??:? runModuleUnitTests [0x42c145]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tlong i = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > r)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] < r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp57jsux05.d(9): Error: variable `l` is shadowing variable `tmp57jsux05.monotonic.l`\n/tmp/tmp57jsux05.d(10): Error: only one index allowed to index `long`\n/tmp/tmp57jsux05.d(15): Error: variable `i` is shadowing variable `tmp57jsux05.monotonic.i`\n/tmp/tmp57jsux05.d(15): Error: no property `length` for type `long`\n/tmp/tmp57jsux05.d(17): Error: only one index allowed to index `long`\n/tmp/tmp57jsux05.d(21): Error: only one index allowed to index `long`\n/tmp/tmp57jsux05.d(29): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57jsux05.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3xd5sdrq.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmp3xd5sdrq.__unittest_L20_C1() [0x427f37]\n??:? void tmp3xd5sdrq.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i=1; i<l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4ey36dl3.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp4ey36dl3.__unittest_L20_C1() [0x427f47]\n??:? void tmp4ey36dl3.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long prev=l[0];\n    bool isMonotonic=true;\n    for(int i=1;i<l.length;i++)\n    {\n        if(l[i]<prev)\n        {\n            isMonotonic=false;\n            break;\n        }\n        prev=l[i];\n    }\n    return isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp6mrufaxe.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmp6mrufaxe.__unittest_L22_C1() [0x427f09]\n??:? void tmp6mrufaxe.__modtest() [0x42808c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tlong l = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) \n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > l[j]) \n\t\t{\n\t\t\tisDecreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp15o8kw54.d(12): Error: variable `l` is shadowing variable `tmp15o8kw54.monotonic.l`\n/tmp/tmp15o8kw54.d(15): Error: no property `length` for type `long`\n/tmp/tmp15o8kw54.d(15): Error: no property `length` for type `long`\n/tmp/tmp15o8kw54.d(17): Error: only one index allowed to index `long`\n/tmp/tmp15o8kw54.d(17): Error: only one index allowed to index `long`\n/tmp/tmp15o8kw54.d(22): Error: only one index allowed to index `long`\n/tmp/tmp15o8kw54.d(22): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp15o8kw54.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long m = l[0];\n    long n = l[1];\n    long k = l[2];\n    long l = l[3];\n    long m = std.math.rem(m, k);\n    long n = std.math.rem(n, k);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n    long m = std.math.rem(m, l);\n    long n = std.math.rem(n, l);\n    long k = std.math.rem(k, l);\n    long l = std.math.rem(l, l);\n\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpluu0a48y.d(58): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpluu0a48y.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tbool result = false;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > l[j]) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpic25pqbz.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x42834d]\n??:? void tmpic25pqbz.__unittest_L27_C1() [0x427eff]\n??:? void tmpic25pqbz.__modtest() [0x4280d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b262]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430381]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b239]\n??:? runModuleUnitTests [0x42c1a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428810]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min < max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprp0gt7dl.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmprp0gt7dl.__unittest_L24_C1() [0x427f47]\n??:? void tmprp0gt7dl.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnwngbrof.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpnwngbrof.__unittest_L29_C1() [0x427fe1]\n??:? void tmpnwngbrof.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long l1 = l[0];\n    long l2 = l[1];\n    long l3 = l[2];\n    long l4 = l[3];\n    long l5 = l[4];\n    long l6 = l[5];\n    long l7 = l[6];\n    long l8 = l[7];\n    long l9 = l[8];\n    long l10 = l[9];\n    long l11 = l[10];\n    long l12 = l[11];\n    long l13 = l[12];\n    long l14 = l[13];\n    long l15 = l[14];\n    long l16 = l[15];\n    long l17 = l[16];\n    long l18 = l[17];\n    long l19 = l[18];\n    long l20 = l[19];\n    long l21 = l[20];\n    long l22 = l[21];\n    long l23 = l[22];\n    long l24 = l[23];\n    long l25 = l[24];\n    long l26 = l[25];\n    long l27 = l[26];\n    long l28 = l[27];\n    long l29 = l[28];\n    long l30 = l[29];\n    long l31 = l[30];\n    long l32 = l[31];\n    long l33 = l[32];\n    long l34 = l[33];\n    long l35 = l[34];\n    long l36 = l[35];\n    long l37 = l[36];\n    long l38 = l[37];\n    long l39 = l[38];\n    long l40 = l[39];\n    long l41 = l[40];\n    long l42 = l[41];\n    long l43 = l[42];\n    long l44 = l[43];\n    long l45 = l[44];\n    long l46 = l[45];\n    long l47 = l[46];\n    long l48 = l[47];\n    long l49 = l[48];\n    long l50 = l[49];\n    long l51 = l[50];\n    long l52 = l[51];\n    long l53 = l[52];\n    long l54 = l[53];\n    long l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdki1o4u_.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmpdki1o4u_.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdki1o4u_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    for(int i=1; i<l.length; i++)\n    {\n        if(l[i] > l)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd4ef8a4p.d(9): Error: variable `l` is shadowing variable `tmpd4ef8a4p.monotonic.l`\n/tmp/tmpd4ef8a4p.d(10): Error: no property `length` for type `long`\n/tmp/tmpd4ef8a4p.d(12): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd4ef8a4p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (max < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcyaa6eh6.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpcyaa6eh6.__unittest_L29_C1() [0x427f43]\n??:? void tmpcyaa6eh6.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tlong x = l[i];\n\t\tif((r - x) > 0) return false;\n\t\tr = x;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9ry5_wid.d(9): Error: variable `l` is shadowing variable `tmp9ry5_wid.monotonic.l`\n/tmp/tmp9ry5_wid.d(10): Error: only one index allowed to index `long`\n/tmp/tmp9ry5_wid.d(11): Error: no property `length` for type `long`\n/tmp/tmp9ry5_wid.d(13): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ry5_wid.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnmr_j2zv.d(112): Error: semicolon expected, not `unittest`\n/tmp/tmpnmr_j2zv.d(112): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnmr_j2zv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < l)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd3obcchi.d(9): Error: variable `l` is shadowing variable `tmpd3obcchi.monotonic.l`\n/tmp/tmpd3obcchi.d(11): Error: no property `length` for type `long`\n/tmp/tmpd3obcchi.d(13): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd3obcchi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (min > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpx6par9rx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpx6par9rx.__unittest_L29_C1() [0x427f53]\n??:? void tmpx6par9rx.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t\tisIncreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9zzhgvz5.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmp9zzhgvz5.__unittest_L26_C1() [0x427ea0]\n??:? void tmp9zzhgvz5.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < l)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\n/*\nReturn True if all elements are equal.\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfltv57_u.d(9): Error: variable `l` is shadowing variable `tmpfltv57_u.monotonic.l`\n/tmp/tmpfltv57_u.d(12): Error: no property `length` for type `long`\n/tmp/tmpfltv57_u.d(14): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfltv57_u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tlong next = l[i];\n\t\tif (curr < next)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (curr > next)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (curr == next)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if (curr < prev)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (curr > prev)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tlong mid = 0;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tmid = (min + max) / 2;\n\t\tif (mid > l[i])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4k3jhl6o.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4283dd]\n??:? void tmp4k3jhl6o.__unittest_L34_C1() [0x427fd9]\n??:? void tmp4k3jhl6o.__modtest() [0x42815c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c45f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430485]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430934]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430411]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2c9]\n??:? runModuleUnitTests [0x42c235]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288a0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tlong c = l[i];\n\t\tif(c < r)\n\t\t\treturn false;\n\t\tr = c;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpriyrzwvu.d(9): Error: variable `l` is shadowing variable `tmpriyrzwvu.monotonic.l`\n/tmp/tmpriyrzwvu.d(10): Error: only one index allowed to index `long`\n/tmp/tmpriyrzwvu.d(11): Error: no property `length` for type `long`\n/tmp/tmpriyrzwvu.d(13): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpriyrzwvu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev=l[0];\n\tbool isMonotonic=true;\n\tfor(int i=1;i<l.length;++i)\n\t{\n\t\tlong cur=l[i];\n\t\tif(cur<prev)\n\t\t{\n\t\t\tisMonotonic=false;\n\t\t\tbreak;\n\t\t}\n\t\tprev=cur;\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmps2pqwkqv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmps2pqwkqv.__unittest_L23_C1() [0x427ef1]\n??:? void tmps2pqwkqv.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c377]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b20a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43039d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43084c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430329]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e1]\n??:? runModuleUnitTests [0x42c14d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool increasing = true;\n\tbool decreasing = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif(l[i] < max)\n\t\t{\n\t\t\tincreasing = false;\n\t\t}\n\t\tif(l[i] > min)\n\t\t{\n\t\t\tdecreasing = false;\n\t\t}\n\t}\n\treturn increasing || decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = 0;\n\tlong min = l[0];\n\tbool flag = false;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t\tflag = true;\n\t\t}\n\t\telse if (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t\tflag = false;\n\t\t}\n\t}\n\treturn flag;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnxeggapc.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428375]\n??:? void tmpnxeggapc.__unittest_L27_C1() [0x427f27]\n??:? void tmpnxeggapc.__modtest() [0x4280f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b28a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43041d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308cc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b261]\n??:? runModuleUnitTests [0x42c1cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428838]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0080zel0.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283e5]\n??:? void tmp0080zel0.__unittest_L33_C1() [0x427f97]\n??:? void tmp0080zel0.__modtest() [0x428168]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c467]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43048d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43093c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430419]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2d1]\n??:? runModuleUnitTests [0x42c23d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288a8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++) \n\t{\n\t\tif (l[i] < min) \n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) \n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min > max) \n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwux1tq0j.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpwux1tq0j.__unittest_L33_C1() [0x427f43]\n??:? void tmpwux1tq0j.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) {\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] > l[j]) {\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_isr4ryy.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428365]\n??:? void tmp_isr4ryy.__unittest_L28_C1() [0x427f17]\n??:? void tmp_isr4ryy.__modtest() [0x4280e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b27a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43040d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430399]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b251]\n??:? runModuleUnitTests [0x42c1bd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428828]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    long r = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i] < r)\n        {\n            return false;\n        }\n        if(l[i] > r)\n        {\n            r = l[i];\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2_3hj56e.d(9): Error: variable `l` is shadowing variable `tmp2_3hj56e.monotonic.l`\n/tmp/tmp2_3hj56e.d(10): Error: only one index allowed to index `long`\n/tmp/tmp2_3hj56e.d(11): Error: no property `length` for type `long`\n/tmp/tmp2_3hj56e.d(13): Error: only one index allowed to index `long`\n/tmp/tmp2_3hj56e.d(17): Error: only one index allowed to index `long`\n/tmp/tmp2_3hj56e.d(19): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2_3hj56e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong a = l[0];\n\tlong b = l[1];\n\tlong c = l[2];\n\tlong d = l[3];\n\tlong e = l[4];\n\tlong f = l[5];\n\tlong g = l[6];\n\tlong h = l[7];\n\tlong i = l[8];\n\tlong j = l[9];\n\tlong k = l[10];\n\tlong l = l[11];\n\tlong m = l[12];\n\tlong n = l[13];\n\tlong o = l[14];\n\tlong p = l[15];\n\tlong q = l[16];\n\tlong r = l[17];\n\tlong s = l[18];\n\tlong t = l[19];\n\tlong u = l[20];\n\tlong v = l[21];\n\tlong w = l[22];\n\tlong x = l[23];\n\tlong y = l[24];\n\tlong z = l[25];\n\tlong a = l[26];\n\tlong b = l[27];\n\tlong c = l[28];\n\tlong d = l[29];\n\tlong e = l[30];\n\tlong f = l[31];\n\tlong g = l[32];\n\tlong h = l[33];\n\tlong i = l[34];\n\tlong j = l[35];\n\tlong k = l[36];\n\tlong l = l[37];\n\tlong m = l[38];\n\tlong n = l[39];\n\tlong o = l[40];\n\tlong p = l[41];\n\tlong q = l[42];\n\tlong r = l[43];\n\tlong s = l[44];\n\tlong t = l[45];\n\tlong u = l[46];\n\tlong v = l[47];\n\tlong w = l[48];\n\tlong x = l[49];\n\tlong y = l[50];\n\tlong z = l[51];\n\tlong a = l[52];\n\tlong b = l[53];\n\tlong c = l[54];\n\tlong d = l[55];\n\tlong e = l[56];\n\tlong f = l[57];\n\tlong g = l[58];\n\tlong h = l[59];\n\tlong i = l[60];\n\tlong j = l[61];\n\tlong k = l[62];\n\tlong l = l[63];\n\tlong m = l[64];\n\tlong n = l[65];\n\tlong o = \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphhms9bdz.d(76): Error: expression expected, not `unittest`\n/tmp/tmphhms9bdz.d(77): Error: semicolon expected, not `{`\n/tmp/tmphhms9bdz.d(89): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphhms9bdz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tlong cur = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < cur)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\tcur = l[i];\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgvx6qcrk.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428415]\n??:? void tmpgvx6qcrk.__unittest_L31_C1() [0x428015]\n??:? void tmpgvx6qcrk.__modtest() [0x428198]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c497]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b32a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43096c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430449]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b301]\n??:? runModuleUnitTests [0x42c26d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max=0;\n\tlong min=l[0];\n\tbool isMonotonic=true;\n\tfor(int i=1;i<l.length;i++)\n\t{\n\t\tif(l[i]<min)\n\t\t{\n\t\t\tmin=l[i];\n\t\t}\n\t\telse if(l[i]>max)\n\t\t{\n\t\t\tmax=l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic=false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkd8m6cya.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x428375]\n??:? void tmpkd8m6cya.__unittest_L29_C1() [0x4280de]\n??:? void tmpkd8m6cya.__modtest() [0x4280f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b28a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43041d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308cc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b261]\n??:? runModuleUnitTests [0x42c1cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428838]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprfpj6k7s.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4283ed]\n??:? void tmprfpj6k7s.__unittest_L29_C1() [0x427f9f]\n??:? void tmprfpj6k7s.__modtest() [0x428170]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c46f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b302]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430495]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430944]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430421]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2d9]\n??:? runModuleUnitTests [0x42c245]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isMonotonic = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < r)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\telse if(l[i] > r)\n\t\t{\n\t\t\tisMonotonic = true;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprq_gqnos.d(9): Error: variable `l` is shadowing variable `tmprq_gqnos.monotonic.l`\n/tmp/tmprq_gqnos.d(10): Error: only one index allowed to index `long`\n/tmp/tmprq_gqnos.d(12): Error: no property `length` for type `long`\n/tmp/tmprq_gqnos.d(14): Error: only one index allowed to index `long`\n/tmp/tmprq_gqnos.d(18): Error: only one index allowed to index `long`\n/tmp/tmprq_gqnos.d(22): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprq_gqnos.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tlong cur = l[0];\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cur < min)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(cur > max)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tcur = l[i];\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2141gji5.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4283f5]\n??:? void tmp2141gji5.__unittest_L37_C1() [0x427fa3]\n??:? void tmp2141gji5.__modtest() [0x428174]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c477]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b30a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43049d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43094c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430429]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e1]\n??:? runModuleUnitTests [0x42c24d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288b8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmv49_cd0.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpmv49_cd0.__unittest_L29_C1() [0x427ff1]\n??:? void tmpmv49_cd0.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long l1 = l[0];\n    long l2 = l[1];\n    long l3 = l[2];\n    long l4 = l[3];\n    long l5 = l[4];\n    long l6 = l[5];\n    long l7 = l[6];\n    long l8 = l[7];\n    long l9 = l[8];\n    long l10 = l[9];\n    long l11 = l[10];\n    long l12 = l[11];\n    long l13 = l[12];\n    long l14 = l[13];\n    long l15 = l[14];\n    long l16 = l[15];\n    long l17 = l[16];\n    long l18 = l[17];\n    long l19 = l[18];\n    long l20 = l[19];\n    long l21 = l[20];\n    long l22 = l[21];\n    long l23 = l[22];\n    long l24 = l[23];\n    long l25 = l[24];\n    long l26 = l[25];\n    long l27 = l[26];\n    long l28 = l[27];\n    long l29 = l[28];\n    long l30 = l[29];\n    long l31 = l[30];\n    long l32 = l[31];\n    long l33 = l[32];\n    long l34 = l[33];\n    long l35 = l[34];\n    long l36 = l[35];\n    long l37 = l[36];\n    long l38 = l[37];\n    long l39 = l[38];\n    long l40 = l[39];\n    long l41 = l[40];\n    long l42 = l[41];\n    long l43 = l[42];\n    long l44 = l[43];\n    long l45 = l[44];\n    long l46 = l[45];\n    long l47 = l[46];\n    long l48 = l[47];\n    long l49 = l[48];\n    long l50 = l[49];\n    long l51 = l[50];\n    long l52 = l[51];\n    long l53 = l[52];\n    long l54 = l[53];\n    long l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdki1o4u_.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmpdki1o4u_.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdki1o4u_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tbool result = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tbool isIncreasing = l[i] > l;\n\t\tbool isDecreasing = l[i] < l;\n\t\tbool isMonotonic = isIncreasing || isDecreasing;\n\t\tresult = result && isMonotonic;\n\t\tl = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzzeowzbr.d(9): Error: variable `l` is shadowing variable `tmpzzeowzbr.monotonic.l`\n/tmp/tmpzzeowzbr.d(11): Error: no property `length` for type `long`\n/tmp/tmpzzeowzbr.d(13): Error: only one index allowed to index `long`\n/tmp/tmpzzeowzbr.d(14): Error: only one index allowed to index `long`\n/tmp/tmpzzeowzbr.d(17): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzzeowzbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = std.length(l);\n\tlong i;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\t\n\tfor(i = 1; i < l; ++i)\n\t{\n\t\tif(l[i-1] > l[i])\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(l[i-1] < l[i])\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t}\n\t\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphz0nt12q.d(9): Error: undefined identifier `length` in package `std`\n/tmp/tmphz0nt12q.d(9): Error: variable `l` is shadowing variable `tmphz0nt12q.monotonic.l`\n/tmp/tmphz0nt12q.d(16): Error: only one index allowed to index `long`\n/tmp/tmphz0nt12q.d(16): Error: only one index allowed to index `long`\n/tmp/tmphz0nt12q.d(20): Error: only one index allowed to index `long`\n/tmp/tmphz0nt12q.d(20): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphz0nt12q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptw0p0ijb.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmptw0p0ijb.__unittest_L20_C1() [0x427f47]\n??:? void tmptw0p0ijb.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfy5t_51g.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpfy5t_51g.__unittest_L29_C1() [0x427ff1]\n??:? void tmpfy5t_51g.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > r)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] < r)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppjwoo3_n.d(9): Error: variable `l` is shadowing variable `tmppjwoo3_n.monotonic.l`\n/tmp/tmppjwoo3_n.d(10): Error: only one index allowed to index `long`\n/tmp/tmppjwoo3_n.d(12): Error: no property `length` for type `long`\n/tmp/tmppjwoo3_n.d(14): Error: only one index allowed to index `long`\n/tmp/tmppjwoo3_n.d(18): Error: only one index allowed to index `long`\n/tmp/tmppjwoo3_n.d(22): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppjwoo3_n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnwngbrof.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpnwngbrof.__unittest_L29_C1() [0x427fe1]\n??:? void tmpnwngbrof.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgjgs7vad.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283ed]\n??:? void tmpgjgs7vad.__unittest_L33_C1() [0x427f9f]\n??:? void tmpgjgs7vad.__modtest() [0x428170]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c46f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b302]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430495]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430944]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430421]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2d9]\n??:? runModuleUnitTests [0x42c245]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong a = l[0];\n\tlong b = l[1];\n\tlong c = l[2];\n\tlong d = l[3];\n\tlong e = l[4];\n\tlong f = l[5];\n\tlong g = l[6];\n\tlong h = l[7];\n\tlong i = l[8];\n\tlong j = l[9];\n\tlong k = l[10];\n\tlong l = l[11];\n\tlong m = l[12];\n\tlong n = l[13];\n\tlong o = l[14];\n\tlong p = l[15];\n\tlong q = l[16];\n\tlong r = l[17];\n\tlong s = l[18];\n\tlong t = l[19];\n\tlong u = l[20];\n\tlong v = l[21];\n\tlong w = l[22];\n\tlong x = l[23];\n\tlong y = l[24];\n\tlong z = l[25];\n\tlong a = l[26];\n\tlong b = l[27];\n\tlong c = l[28];\n\tlong d = l[29];\n\tlong e = l[30];\n\tlong f = l[31];\n\tlong g = l[32];\n\tlong h = l[33];\n\tlong i = l[34];\n\tlong j = l[35];\n\tlong k = l[36];\n\tlong l = l[37];\n\tlong m = l[38];\n\tlong n = l[39];\n\tlong o = l[40];\n\tlong p = l[41];\n\tlong q = l[42];\n\tlong r = l[43];\n\tlong s = l[44];\n\tlong t = l[45];\n\tlong u = l[46];\n\tlong v = l[47];\n\tlong w = l[48];\n\tlong x = l[49];\n\tlong y = l[50];\n\tlong z = l[51];\n\tlong a = l[52];\n\tlong b = l[53];\n\tlong c = l[54];\n\tlong d = l[55];\n\tlong e = l[56];\n\tlong f = l[57];\n\tlong g = l[58];\n\tlong h = l[59];\n\tlong i = l[60];\n\tlong j = l[61];\n\tlong k = l[62];\n\tlong l = l[63];\n\tlong m = l[64];\n\tlong n = l[65];\n\tlong o = \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphhms9bdz.d(76): Error: expression expected, not `unittest`\n/tmp/tmphhms9bdz.d(77): Error: semicolon expected, not `{`\n/tmp/tmphhms9bdz.d(89): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphhms9bdz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong x = 0;\n\tlong y = 0;\n\tbool increasing = true;\n\tbool decreasing = true;\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tx = l[i];\n\t\ty = l[i+1];\n\t\tif (x < y)\n\t\t{\n\t\t\tincreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdecreasing = false;\n\t\t}\n\t}\n\treturn increasing || decreasing;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpkmluh1z8.d(16): Range violation\n----------------\n??:? _d_arrayboundsp [0x4283a6]\n??:? bool tmpkmluh1z8.monotonic(long[]) [0x427d70]\n??:? void tmpkmluh1z8.__unittest_L32_C1() [0x427df5]\n??:? void tmpkmluh1z8.__modtest() [0x428078]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c377]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b20a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43039d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43084c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430329]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e1]\n??:? runModuleUnitTests [0x42c14d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgpspos_f.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283fd]\n??:? void tmpgpspos_f.__unittest_L33_C1() [0x427faf]\n??:? void tmpgpspos_f.__modtest() [0x428180]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c47f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b312]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430954]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]\n??:? runModuleUnitTests [0x42c255]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > prev)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = l[i];\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp148sy92o.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428355]\n??:? void tmp148sy92o.__unittest_L29_C1() [0x427e6c]\n??:? void tmp148sy92o.__modtest() [0x4280d8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b26a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430389]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]\n??:? runModuleUnitTests [0x42c1ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428818]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long x0 = l[0];\n    long x1 = l[1];\n    long x2 = l[2];\n    long x3 = l[3];\n    long x4 = l[4];\n    long x5 = l[5];\n    long x6 = l[6];\n    long x7 = l[7];\n    long x8 = l[8];\n    long x9 = l[9];\n    long x10 = l[10];\n    long x11 = x[11];\n    long x12 = x[12];\n    long x13 = x[13];\n    long x14 = x[14];\n    long x15 = x[15];\n    long x16 = x[16];\n    long x17 = x[17];\n    long x18 = x[18];\n    long x19 = x[19];\n    long x20 = x[20];\n    long x21 = x[21];\n    long x22 = x[22];\n    long x23 = x[23];\n    long x24 = x[24];\n    long x25 = x[25];\n    long x26 = x[26];\n    long x27 = x[27];\n    long x28 = x[28];\n    long x29 = x[29];\n    long x30 = l[30];\n    long x31 = l[31];\n    long x32 = l[32];\n    long x33 = l[33];\n    long x34 = l[34];\n    long x35 = l[35];\n    long x36 = l[36];\n    long x37 = l[37];\n    long x38 = l[38];\n    long x39 = l[39];\n    long x40 = l[40];\n    long x41 = l[41];\n    long x42 = l[42];\n    long x43 = l[43];\n    long x44 = l[44];\n    long x45 = l[45];\n    long x46 = l[46];\n    long x47 = l[47];\n    long x48 = l[48];\n    long x49 = l[49];\n    long x50 = l[50];\n    long x51 = l[51];\n    long x52 = l[52];\n    long x53 = l[53];\n    long x54 = l[54];\n    long x55 = l[55];\n    long x56 = l[56\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnt2rfic0.d(66): Error: found `unittest` when expecting `,`\n/tmp/tmpnt2rfic0.d(79): Error: found `void` when expecting `,`\n/tmp/tmpnt2rfic0.d(79): Error: found `{` when expecting `,`\n/tmp/tmpnt2rfic0.d(79): Error: expression expected, not `}`\n/tmp/tmpnt2rfic0.d(79): Error: found `End of File` when expecting `,`\n/tmp/tmpnt2rfic0.d(79): Error: found `End of File` when expecting `]`\n/tmp/tmpnt2rfic0.d(79): Error: semicolon expected, not `End of File`\n/tmp/tmpnt2rfic0.d(79): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnt2rfic0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\t\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6q6yhh5a.d(115): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6q6yhh5a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] < r)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] == r)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if (l[i] < r)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t}\n\t\telse if (l[i] > r)\n\t\t{\n\t\t\tisDecreasing = true;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyrfd5i28.d(9): Error: variable `l` is shadowing variable `tmpyrfd5i28.monotonic.l`\n/tmp/tmpyrfd5i28.d(10): Error: only one index allowed to index `long`\n/tmp/tmpyrfd5i28.d(13): Error: no property `length` for type `long`\n/tmp/tmpyrfd5i28.d(15): Error: only one index allowed to index `long`\n/tmp/tmpyrfd5i28.d(19): Error: only one index allowed to index `long`\n/tmp/tmpyrfd5i28.d(23): Error: only one index allowed to index `long`\n/tmp/tmpyrfd5i28.d(28): Error: only one index allowed to index `long`\n/tmp/tmpyrfd5i28.d(32): Error: only one index allowed to index `long`\n/tmp/tmpyrfd5i28.d(36): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyrfd5i28.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] > curr)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = isDecreasing = true;\n\t\t}\n\t\tif (isIncreasing && isDecreasing)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if (isIncreasing)\n\t\t{\n\t\t\tprev = curr;\n\t\t\tcurr = l[i];\n\t\t}\n\t\telse if (isDecreasing)\n\t\t{\n\t\t\tprev = curr;\n\t\t\tcurr = l[i];\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbtfsdhkf.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x4283ad]\n??:? void tmpbtfsdhkf.__unittest_L44_C1() [0x427f5b]\n??:? void tmpbtfsdhkf.__modtest() [0x42812c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c42f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430455]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430904]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b299]\n??:? runModuleUnitTests [0x42c205]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428870]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong x0 = l[0];\n\tlong x1 = l[1];\n\tlong x2 = l[2];\n\tlong x3 = l[3];\n\tlong x4 = l[4];\n\tlong x5 = l[5];\n\tlong x6 = l[6];\n\tlong x7 = l[7];\n\tlong x8 = l[8];\n\tlong x9 = l[9];\n\tlong x10 = l[10];\n\tlong x11 = l[11];\n\tlong x12 = l[12];\n\tlong x13 = l[13];\n\tlong x14 = l[14];\n\tlong x15 = l[15];\n\tlong x16 = l[16];\n\tlong x17 = l[17];\n\tlong x18 = l[18];\n\tlong x19 = l[19];\n\tlong x20 = l[20];\n\tlong x21 = l[21];\n\tlong x22 = l[22];\n\tlong x23 = l[23];\n\tlong x24 = l[24];\n\tlong x25 = l[25];\n\tlong x26 = l[26];\n\tlong x27 = l[27];\n\tlong x28 = l[28];\n\tlong x29 = l[29];\n\tlong x30 = l[30];\n\tlong x31 = l[31];\n\tlong x32 = l[32];\n\tlong x33 = l[33];\n\tlong x34 = l[34];\n\tlong x35 = l[35];\n\tlong x36 = l[36];\n\tlong x37 = l[37];\n\tlong x38 = l[38];\n\tlong x39 = l[39];\n\tlong x40 = l[40];\n\tlong x41 = l[41];\n\tlong x42 = l[42];\n\tlong x43 = l[43];\n\tlong x44 = l[44];\n\tlong x45 = l[45];\n\tlong x46 = l[46];\n\tlong x47 = l[47];\n\tlong x48 = l[48];\n\tlong x49 = l[49];\n\tlong x50 = l[50];\n\tlong x51 = l[51];\n\tlong x52 = l[52];\n\tlong x53 = l[53];\n\tlong x54 = l[54];\n\t\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp414iztm8.d(65): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp414iztm8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpi5al092j.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpi5al092j.__unittest_L29_C1() [0x427fe1]\n??:? void tmpi5al092j.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool result = true;\n\tfor(int i = 1; i < l.length; i++) \n\t{\n\t\tif(l[i] < l[i-1]) \n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if(l[i] > r) \n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tr = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0uei0kns.d(9): Error: variable `l` is shadowing variable `tmp0uei0kns.monotonic.l`\n/tmp/tmp0uei0kns.d(10): Error: only one index allowed to index `long`\n/tmp/tmp0uei0kns.d(12): Error: no property `length` for type `long`\n/tmp/tmp0uei0kns.d(14): Error: only one index allowed to index `long`\n/tmp/tmp0uei0kns.d(14): Error: only one index allowed to index `long`\n/tmp/tmp0uei0kns.d(19): Error: only one index allowed to index `long`\n/tmp/tmp0uei0kns.d(26): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0uei0kns.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < l)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(l[i] > r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(l[i] < r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(l[i] > l)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6x0u6s5o.d(9): Error: variable `l` is shadowing variable `tmp6x0u6s5o.monotonic.l`\n/tmp/tmp6x0u6s5o.d(10): Error: only one index allowed to index `long`\n/tmp/tmp6x0u6s5o.d(13): Error: no property `length` for type `long`\n/tmp/tmp6x0u6s5o.d(15): Error: only one index allowed to index `long`\n/tmp/tmp6x0u6s5o.d(19): Error: only one index allowed to index `long`\n/tmp/tmp6x0u6s5o.d(23): Error: only one index allowed to index `long`\n/tmp/tmp6x0u6s5o.d(27): Error: only one index allowed to index `long`\n/tmp/tmp6x0u6s5o.d(35): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6x0u6s5o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong minVal = l[0];\n\tlong maxVal = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < minVal)\n\t\t{\n\t\t\tminVal = l[i];\n\t\t}\n\t\tif (l[i] > maxVal)\n\t\t{\n\t\t\tmaxVal = l[i];\n\t\t}\n\t}\n\tif (minVal < maxVal)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuneaetqr.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpuneaetqr.__unittest_L29_C1() [0x427eb8]\n??:? void tmpuneaetqr.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tbool l3 = false;\n\tbool l4 = false;\n\tbool l5 = false;\n\tbool l6 = false;\n\tbool l7 = false;\n\tbool l8 = false;\n\tbool l9 = false;\n\tbool l10 = false;\n\tbool l11 = false;\n\tbool l12 = false;\n\tbool l13 = false;\n\tbool l14 = false;\n\tbool l15 = false;\n\tbool l16 = false;\n\tbool l17 = false;\n\tbool l18 = false;\n\tbool l19 = false;\n\tbool l20 = false;\n\tbool l21 = false;\n\tbool l22 = false;\n\tbool l23 = false;\n\tbool l24 = false;\n\tbool l25 = false;\n\tbool l26 = false;\n\tbool l27 = false;\n\tbool l28 = false;\n\tbool l29 = false;\n\tbool l30 = false;\n\tbool l31 = false;\n\tbool l32 = false;\n\tbool l33 = false;\n\tbool l34 = false;\n\tbool l35 = false;\n\tbool l36 = false;\n\tbool l37 = false;\n\tbool l38 = false;\n\tbool l39 = false;\n\tbool l40 = false;\n\tbool l41 = false;\n\tbool l42 = false;\n\tbool l43 = false;\n\tbool l44 = false;\n\tbool l45 = false;\n\tbool l46 = false;\n\tbool l47 = false;\n\tbool l48 = false;\n\tbool l49 = false;\n\tbool l50 = false;\n\tbool l51 = false;\n\tbool l52 = false;\n\tbool l53 = false;\n\tbool l54 = false;\n\tbool l55 = false;\n\tbool l56 = false;\n\tbool l57 = false;\n\tbool l58 = false;\n\tbool l59 = false;\n\tbool l60 = false;\n\tbool l61 = false;\n\tbool l62 = false;\n\tbool l63 = false;\n\tbool l64 = false;\n\tbool l65 = false;\n\tbool l66 = false;\n\tbool l67 = false;\n\tbool l68 = false;\n\tbool l69 = false;\n\tbool l70 = false;\n\tbool l71 = false;\n\tbool l72 = false;\n\tbool l73 = false;\n\tbool l74 = false;\n\tbool l75 = false;\n\tbool l76 = false;\n\tbool l77 = false;\n\tbool l78 = false;\n\tbool l79 = false;\n\tbool l80 = false;\n\tbool l81 = false;\n\tbool l82 = \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppovco0o4.d(91): Error: expression expected, not `unittest`\n/tmp/tmppovco0o4.d(92): Error: semicolon expected, not `{`\n/tmp/tmppovco0o4.d(104): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppovco0o4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tisDecreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpym623uml.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283bd]\n??:? void tmpym623uml.__unittest_L31_C1() [0x428011]\n??:? void tmpym623uml.__modtest() [0x42813c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c43f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430465]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430914]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2a9]\n??:? runModuleUnitTests [0x42c215]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428880]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong minVal = l[0];\n\tlong maxVal = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < minVal)\n\t\t{\n\t\t\tminVal = l[i];\n\t\t}\n\t\tif (l[i] > maxVal)\n\t\t{\n\t\t\tmaxVal = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdwcl4xwp.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpdwcl4xwp.__unittest_L25_C1() [0x427f43]\n??:? void tmpdwcl4xwp.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tfor(int i=1; i<l.length; i++) \n\t{\n\t\tif(l[i] > r) \n\t\t{\n\t\t\tr = l[i];\n\t\t}\n\t\telse if(l[i] < r) \n\t\t{\n\t\t\tl = l[i];\n\t\t}\n\t}\n\treturn (r-l) < 0;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyht8_7g0.d(9): Error: variable `l` is shadowing variable `tmpyht8_7g0.monotonic.l`\n/tmp/tmpyht8_7g0.d(10): Error: only one index allowed to index `long`\n/tmp/tmpyht8_7g0.d(11): Error: no property `length` for type `long`\n/tmp/tmpyht8_7g0.d(13): Error: only one index allowed to index `long`\n/tmp/tmpyht8_7g0.d(15): Error: only one index allowed to index `long`\n/tmp/tmpyht8_7g0.d(17): Error: only one index allowed to index `long`\n/tmp/tmpyht8_7g0.d(19): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyht8_7g0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2te850dz.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp2te850dz.__unittest_L25_C1() [0x427f43]\n??:? void tmp2te850dz.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tlong l = l[0];\n\twhile (i < l.length) \n\t{\n\t\tif (l[i] < l[j]) {\n\t\t\tk = i;\n\t\t}\n\t\telse {\n\t\t\tk = j;\n\t\t}\n\t\tif (l[k] < l[i]) {\n\t\t\tj = k;\n\t\t}\n\t\telse {\n\t\t\ti = k;\n\t\t}\n\t}\n\treturn (i == l.length);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwxyq7ik.d(12): Error: variable `l` is shadowing variable `tmpkwxyq7ik.monotonic.l`\n/tmp/tmpkwxyq7ik.d(13): Error: no property `length` for type `long`\n/tmp/tmpkwxyq7ik.d(15): Error: only one index allowed to index `long`\n/tmp/tmpkwxyq7ik.d(15): Error: only one index allowed to index `long`\n/tmp/tmpkwxyq7ik.d(21): Error: only one index allowed to index `long`\n/tmp/tmpkwxyq7ik.d(21): Error: only one index allowed to index `long`\n/tmp/tmpkwxyq7ik.d(28): Error: no property `length` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwxyq7ik.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i] < curr)\n        {\n            isDecreasing = false;\n        }\n        else if(l[i] > curr)\n        {\n            isIncreasing = false;\n        }\n        else if(l[i] == prev)\n        {\n            isDecreasing = false;\n        }\n        else if(l[i] == prev)\n        {\n            isIncreasing = false;\n        }\n        else\n        {\n            isDecreasing = true;\n        }\n        prev = l[i];\n        curr = l[i];\n    }\n    return isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < r)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = l[i];\n\t\t}\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp90dcqagr.d(9): Error: variable `l` is shadowing variable `tmp90dcqagr.monotonic.l`\n/tmp/tmp90dcqagr.d(10): Error: only one index allowed to index `long`\n/tmp/tmp90dcqagr.d(12): Error: no property `length` for type `long`\n/tmp/tmp90dcqagr.d(14): Error: only one index allowed to index `long`\n/tmp/tmp90dcqagr.d(20): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp90dcqagr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    long next = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        prev = curr;\n        curr = next;\n        next = l[i];\n        if(curr < prev)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm52guzqy.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmpm52guzqy.__unittest_L24_C1() [0x427f11]\n??:? void tmpm52guzqy.__modtest() [0x428094]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c397]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b22a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43086c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430349]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b201]\n??:? runModuleUnitTests [0x42c16d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tisDecreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4meh8m3c.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmp4meh8m3c.__unittest_L31_C1() [0x427ffd]\n??:? void tmp4meh8m3c.__modtest() [0x428128]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": -1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tbool monotonic = false;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) \n\t\t{\n\t\t\tk = j;\n\t\t\tj = i;\n\t\t\ti = k;\n\t\t}\n\t\telse if (l[i] > l[j]) \n\t\t{\n\t\t\tk = j;\n\t\t\tj = i;\n\t\t\ti = k;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tmonotonic = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn monotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Timeout",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164454
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp53xgjlt6.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp53xgjlt6.__unittest_L29_C1() [0x427ff1]\n??:? void tmp53xgjlt6.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkmo2ingu.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpkmo2ingu.__unittest_L29_C1() [0x427ff1]\n??:? void tmpkmo2ingu.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    long r = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < r) \n        {\n            return false;\n        }\n        r = l[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppd4maicj.d(9): Error: variable `l` is shadowing variable `tmppd4maicj.monotonic.l`\n/tmp/tmppd4maicj.d(10): Error: only one index allowed to index `long`\n/tmp/tmppd4maicj.d(11): Error: no property `length` for type `long`\n/tmp/tmppd4maicj.d(13): Error: only one index allowed to index `long`\n/tmp/tmppd4maicj.d(17): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppd4maicj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > curr)\n\t\t{\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpl6xwdo2t.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428355]\n??:? void tmpl6xwdo2t.__unittest_L31_C1() [0x427f03]\n??:? void tmpl6xwdo2t.__modtest() [0x4280d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b26a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430389]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]\n??:? runModuleUnitTests [0x42c1ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428818]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfl8iei89.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4283fd]\n??:? void tmpfl8iei89.__unittest_L34_C1() [0x427faf]\n??:? void tmpfl8iei89.__modtest() [0x428180]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c47f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b312]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430954]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]\n??:? runModuleUnitTests [0x42c255]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = 0;\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7wywds7d.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x42832d]\n??:? void tmp7wywds7d.__unittest_L27_C1() [0x427e40]\n??:? void tmp7wywds7d.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b242]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430884]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430361]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]\n??:? runModuleUnitTests [0x42c185]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": -1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) \n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] > l[j]) \n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Timeout",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164454
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tlong i;\n\tfor(i=1; i<l.length; i++){\n\t\tif(l[i] < min){\n\t\t\tmin = l[i];\n\t\t}\n\t\tif(l[i] > max){\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp_l0jscu.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpp_l0jscu.__unittest_L22_C1() [0x427f43]\n??:? void tmpp_l0jscu.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3zc8uunx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp3zc8uunx.__unittest_L29_C1() [0x427f43]\n??:? void tmp3zc8uunx.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min < max)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpo83gx893.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpo83gx893.__unittest_L29_C1() [0x427eb8]\n??:? void tmpo83gx893.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    long r = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < r) \n        {\n            r = l[i];\n        }\n        else \n        {\n            if(l[i] > r) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmta9c7rm.d(9): Error: variable `l` is shadowing variable `tmpmta9c7rm.monotonic.l`\n/tmp/tmpmta9c7rm.d(10): Error: only one index allowed to index `long`\n/tmp/tmpmta9c7rm.d(11): Error: no property `length` for type `long`\n/tmp/tmpmta9c7rm.d(13): Error: only one index allowed to index `long`\n/tmp/tmpmta9c7rm.d(15): Error: only one index allowed to index `long`\n/tmp/tmpmta9c7rm.d(19): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmta9c7rm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (max < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyiy496_k.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpyiy496_k.__unittest_L33_C1() [0x427f53]\n??:? void tmpyiy496_k.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i] < min)\n            min = l[i];\n    }\n    return max >= min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkdql3l_b.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpkdql3l_b.__unittest_L20_C1() [0x427f47]\n??:? void tmpkdql3l_b.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8qxh83_d.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp8qxh83_d.__unittest_L24_C1() [0x427f47]\n??:? void tmp8qxh83_d.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < curr)\n        {\n            isDecreasing = false;\n        }\n        else if(l[i] > curr)\n        {\n            isIncreasing = false;\n        }\n        else\n        {\n            isDecreasing = true;\n            isIncreasing = true;\n        }\n        prev = curr;\n        curr = l[i];\n    }\n    return isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp73xk7jvy.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmp73xk7jvy.__unittest_L24_C1() [0x427f37]\n??:? void tmp73xk7jvy.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min < max)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqp_ll6og.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpqp_ll6og.__unittest_L33_C1() [0x427eb8]\n??:? void tmpqp_ll6og.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; i++) \n\t{\n\t\tif(l[i] > max) \n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i] < min) \n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max >= min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqjlx2mzm.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpqjlx2mzm.__unittest_L24_C1() [0x427f37]\n??:? void tmpqjlx2mzm.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfy5t_51g.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpfy5t_51g.__unittest_L29_C1() [0x427ff1]\n??:? void tmpfy5t_51g.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++) \n\t{\n\t\tif (l[i] < curr) \n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] > curr) \n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif (isIncreasing && isDecreasing) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (isIncreasing) \n\t\t\t{\n\t\t\t\tisIncreasing = false;\n\t\t\t}\n\t\t\telse if (isDecreasing) \n\t\t\t{\n\t\t\t\tisDecreasing = false;\n\t\t\t}\n\t\t}\n\t\tcurr = l[i];\n\t}\n\treturn true;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpu9wig3zk.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428375]\n??:? void tmpu9wig3zk.__unittest_L46_C1() [0x427f27]\n??:? void tmpu9wig3zk.__modtest() [0x4280f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b28a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43041d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308cc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b261]\n??:? runModuleUnitTests [0x42c1cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428838]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tlong l = l[0];\n\twhile (i < l.length) \n\t{\n\t\twhile (j < l.length && l[j] < l[i]) \n\t\t{\n\t\t\tj++;\n\t\t}\n\t\twhile (k < l.length && l[k] > l[i]) \n\t\t{\n\t\t\tk++;\n\t\t}\n\t\tif (j < k) \n\t\t{\n\t\t\ti = j;\n\t\t\tj = k;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ti = k;\n\t\t\tk = j;\n\t\t}\n\t}\n\treturn (j == l.length);\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqq7ezi5w.d(12): Error: variable `l` is shadowing variable `tmpqq7ezi5w.monotonic.l`\n/tmp/tmpqq7ezi5w.d(13): Error: no property `length` for type `long`\n/tmp/tmpqq7ezi5w.d(15): Error: no property `length` for type `long`\n/tmp/tmpqq7ezi5w.d(15): Error: only one index allowed to index `long`\n/tmp/tmpqq7ezi5w.d(15): Error: only one index allowed to index `long`\n/tmp/tmpqq7ezi5w.d(19): Error: no property `length` for type `long`\n/tmp/tmpqq7ezi5w.d(19): Error: only one index allowed to index `long`\n/tmp/tmpqq7ezi5w.d(19): Error: only one index allowed to index `long`\n/tmp/tmpqq7ezi5w.d(34): Error: no property `length` for type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqq7ezi5w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tfor(int i = 1; i < l.length; i++) \n\t{\n\t\tif(l[i] < l[i-1]) return false; \n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeppdah2_.d(9): Error: variable `l` is shadowing variable `tmpeppdah2_.monotonic.l`\n/tmp/tmpeppdah2_.d(10): Error: no property `length` for type `long`\n/tmp/tmpeppdah2_.d(12): Error: only one index allowed to index `long`\n/tmp/tmpeppdah2_.d(12): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeppdah2_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong w = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m = 0;\n\tlong n = 0;\n\t\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6q6yhh5a.d(115): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6q6yhh5a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164439
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tbool isMonotonic = true;\n\t\n\tfor (int i = 2; i < l.length; i++)\n\t{\n\t\tlong l3 = l[i];\n\t\t\n\t\tif (l3 > l2)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (l3 < l1)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tl1 = l2;\n\t\tl2 = l3;\n\t}\n\t\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpexm2u9jn.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428325]\n??:? void tmpexm2u9jn.__unittest_L35_C1() [0x427e3c]\n??:? void tmpexm2u9jn.__modtest() [0x4280a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b23a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43087c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430359]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b211]\n??:? runModuleUnitTests [0x42c17d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev=l[0];\n\tbool ret=true;\n\tfor(int i=1;i<l.length;i++)\n\t{\n\t\tlong cur=l[i];\n\t\tif(cur<prev)\n\t\t{\n\t\t\tret=false;\n\t\t\tbreak;\n\t\t}\n\t\tprev=cur;\n\t}\n\treturn ret;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp80m801fe.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4282ed]\n??:? void tmp80m801fe.__unittest_L23_C1() [0x427eed]\n??:? void tmp80m801fe.__modtest() [0x428070]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c36f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b202]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430395]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430844]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430321]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d9]\n??:? runModuleUnitTests [0x42c145]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tfor(int i = 1; i < l.length; i++) \n\t{\n\t\tif(l[i] > l[i-1]) \n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if(l[i] < r) \n\t\t{\n\t\t\tr = l[i];\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3v4gw8bf.d(9): Error: variable `l` is shadowing variable `tmp3v4gw8bf.monotonic.l`\n/tmp/tmp3v4gw8bf.d(10): Error: only one index allowed to index `long`\n/tmp/tmp3v4gw8bf.d(11): Error: no property `length` for type `long`\n/tmp/tmp3v4gw8bf.d(13): Error: only one index allowed to index `long`\n/tmp/tmp3v4gw8bf.d(13): Error: only one index allowed to index `long`\n/tmp/tmp3v4gw8bf.d(17): Error: only one index allowed to index `long`\n/tmp/tmp3v4gw8bf.d(19): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3v4gw8bf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < r)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa4hsgvbl.d(9): Error: variable `l` is shadowing variable `tmpa4hsgvbl.monotonic.l`\n/tmp/tmpa4hsgvbl.d(10): Error: only one index allowed to index `long`\n/tmp/tmpa4hsgvbl.d(12): Error: no property `length` for type `long`\n/tmp/tmpa4hsgvbl.d(14): Error: only one index allowed to index `long`\n/tmp/tmpa4hsgvbl.d(19): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa4hsgvbl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min == max) {\n\t\treturn false;\n\t}\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min || l[i] > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmph56dprt3.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x428415]\n??:? void tmph56dprt3.__unittest_L34_C1() [0x427fc7]\n??:? void tmph56dprt3.__modtest() [0x428198]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c497]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b32a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43096c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430449]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b301]\n??:? runModuleUnitTests [0x42c26d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long i = 0;\n    long j = 0;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    bool isMonotonic = true;\n    \n    while(i < l.length && j < l.length)\n    {\n        if(l[i] < l[j])\n        {\n            isIncreasing = false;\n        }\n        else if(l[i] > l[j])\n        {\n            isDecreasing = false;\n        }\n        else if(l[i] == l[j])\n        {\n            isMonotonic = false;\n        }\n        i++;\n        j++;\n    }\n    return isMonotonic;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not provide an answer to the question. To critique or request clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/19148062)\n<|/ c |>\n<| c |>\nI believe this does answer the question. He asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked if there is a way to check if a list is monotonic and I provided a solution. He also asked \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpj53obov5.d(34): Error: declaration expected, not `<`\n/tmp/tmpj53obov5.d(45): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(46): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(47): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(48): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(49): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(50): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(51): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(52): Error: declaration expected, not `assert`\n/tmp/tmpj53obov5.d(53): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj53obov5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t\tif(min > max)\n\t\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7y5ztd8r.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp7y5ztd8r.__unittest_L23_C1() [0x427f43]\n??:? void tmp7y5ztd8r.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpotmt1l_z.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpotmt1l_z.__unittest_L29_C1() [0x427fe1]\n??:? void tmpotmt1l_z.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tlong k = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) \n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > l[j]) \n\t\t{\n\t\t\tisDecreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdnxnszz8.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428365]\n??:? void tmpdnxnszz8.__unittest_L38_C1() [0x427f17]\n??:? void tmpdnxnszz8.__modtest() [0x4280e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b27a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43040d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430399]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b251]\n??:? runModuleUnitTests [0x42c1bd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428828]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptta3br2k.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmptta3br2k.__unittest_L29_C1() [0x427fe1]\n??:? void tmptta3br2k.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] > r)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if(l[i] < l)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1zqq9uqd.d(9): Error: variable `l` is shadowing variable `tmp1zqq9uqd.monotonic.l`\n/tmp/tmp1zqq9uqd.d(10): Error: only one index allowed to index `long`\n/tmp/tmp1zqq9uqd.d(11): Error: no property `length` for type `long`\n/tmp/tmp1zqq9uqd.d(13): Error: only one index allowed to index `long`\n/tmp/tmp1zqq9uqd.d(17): Error: only one index allowed to index `long`\n/tmp/tmp1zqq9uqd.d(21): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1zqq9uqd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long max = 0;\n    long min = 0;\n    for(int i = 0; i < l.length; i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n        if(l[i] < min){\n            min = l[i];\n        }\n    }\n    bool isMonotonic = true;\n    if(max < min){\n        for(int i = 0; i < l.length; i++){\n            if(l[i] > max){\n                isMonotonic = false;\n            }\n            if(l[i] < min){\n                isMonotonic = false;\n            }\n        }\n    }\n    return isMonotonic;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a function that checks if a list is monotonically increasing or decreasing. It also checks if it is strictly increasing or strictly decreasing.\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5dg9xy04.d(32): Error: declaration expected, not `<`\n/tmp/tmp5dg9xy04.d(41): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(42): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(43): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(44): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(45): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(46): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(47): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(48): Error: declaration expected, not `assert`\n/tmp/tmp5dg9xy04.d(49): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5dg9xy04.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev=l[0];\n\tbool isIncreasing=true;\n\tfor(int i=1;i<l.length;i++)\n\t{\n\t\tlong cur=l[i];\n\t\tif(cur<prev)\n\t\t{\n\t\t\tisIncreasing=false;\n\t\t}\n\t\telse if(cur>prev)\n\t\t{\n\t\t\tisIncreasing=true;\n\t\t}\n\t\tprev=cur;\n\t}\n\treturn isIncreasing;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmph13mrw8i.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmph13mrw8i.__unittest_L30_C1() [0x427eab]\n??:? void tmph13mrw8i.__modtest() [0x42807c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] != max && l[i] != min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i] > l)\n        {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmx0_5hyc.d(9): Error: variable `l` is shadowing variable `tmpmx0_5hyc.monotonic.l`\n/tmp/tmpmx0_5hyc.d(10): Error: no property `length` for type `long`\n/tmp/tmpmx0_5hyc.d(12): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmx0_5hyc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < l)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] > r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg1dmyt0a.d(9): Error: variable `l` is shadowing variable `tmpg1dmyt0a.monotonic.l`\n/tmp/tmpg1dmyt0a.d(10): Error: only one index allowed to index `long`\n/tmp/tmpg1dmyt0a.d(13): Error: no property `length` for type `long`\n/tmp/tmpg1dmyt0a.d(15): Error: only one index allowed to index `long`\n/tmp/tmpg1dmyt0a.d(19): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg1dmyt0a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tbool result = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i-1] > l[i])\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo404o4_v.d(9): Error: variable `l` is shadowing variable `tmpo404o4_v.monotonic.l`\n/tmp/tmpo404o4_v.d(11): Error: no property `length` for type `long`\n/tmp/tmpo404o4_v.d(13): Error: only one index allowed to index `long`\n/tmp/tmpo404o4_v.d(13): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo404o4_v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = 0;\n\tlong min = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t\tisIncreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg0bb7wdi.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpg0bb7wdi.__unittest_L28_C1() [0x427f3f]\n??:? void tmpg0bb7wdi.__modtest() [0x428110]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong x = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < x)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] > x)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\tx = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg8e9_5zy.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x42833d]\n??:? void tmpg8e9_5zy.__unittest_L26_C1() [0x427f3d]\n??:? void tmpg8e9_5zy.__modtest() [0x4280c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b252]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430894]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430371]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b229]\n??:? runModuleUnitTests [0x42c195]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428800]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3xd5sdrq.d(26): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmp3xd5sdrq.__unittest_L20_C1() [0x427f37]\n??:? void tmp3xd5sdrq.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tbool result = false;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < l)\n\t\t{\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpom9ywn5c.d(9): Error: variable `l` is shadowing variable `tmpom9ywn5c.monotonic.l`\n/tmp/tmpom9ywn5c.d(11): Error: no property `length` for type `long`\n/tmp/tmpom9ywn5c.d(13): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpom9ywn5c.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong i = 0;\n\tlong j = 1;\n\tbool result = true;\n\twhile (i < l.length && j < l.length) \n\t{\n\t\tif (l[i] < l[j]) \n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (l[i] > l[j]) \n\t\t{\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\treturn result;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp6_rcv9ww.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42834d]\n??:? void tmp6_rcv9ww.__unittest_L33_C1() [0x427e64]\n??:? void tmp6_rcv9ww.__modtest() [0x4280d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b262]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430381]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b239]\n??:? runModuleUnitTests [0x42c1a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428810]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for me. `monotonic([1,2,3])` returns `true` while `monotonic([3,2,1])` returns `false`.\n<|/ c |>\n<| c |>\nThe code works fine for me. Try it here: https://ideone.com/uK4YGQ\n<|/ c |>\n<| c |>\nYes, it does. I tested it on ideone.com. Maybe you forgot to copy the code from my answer? The code I posted is exactly the same as yours.\n<|/ c |>\n<| c |>\nI did copy the code from your answer. Maybe I forgot to copy the code from your answer? The code I posted is exactly the same as yours.\n<|/ c |>\n<| c |>\nI tested it on ideone.com. Maybe you forgot to copy the code from my answer? The code I posted is exactly the same as yours.\n<|/ c |>\n<| a tags=c++,arrays,algorithm |>\nI believe that your algorithm is correct. \nThe only thing that could be improved is to use std::min and std::max instead of min and max to save some time.\n<|/ a dscore=2 |>\n<| c |>\n`std::min` and `std::max` don't exist in C++.\n<|/ c |>\n<| c |>\n: They do in C++11 and later.\n<|/ c |>\n<| c |>\n: Yes, they do in C++11 and later. C++03 doesn't have them.\n<|/ c |>\n<| c |>\n: Yes, they do in C++11 and later. C++03 doesn't have them.\n<|/ c |>\n<| c |>\n: Yes, they do in C++11 and later. C++03 doesn't have them.\n<|/ c |>\n<| a tags=c++,arrays,algorithm |>\nI believe that your algorithm is correct. \nThe only thing that could be improved is to use std::min and std::max instead of min and max to save some time.\n<|/ a dscore=2 |>\n<| c |>\n`std::min` and `std::max` don't exist in C++.\n<|/ c \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37f7b1wk.d(20): Error: declaration expected, not `<`\n/tmp/tmp37f7b1wk.d(23): Error: unterminated character constant\n/tmp/tmp37f7b1wk.d(42): Error: unterminated character constant\n/tmp/tmp37f7b1wk.d(48): Error: unterminated character constant\n/tmp/tmp37f7b1wk.d(51): Error: unterminated character constant\n/tmp/tmp37f7b1wk.d(54): Error: unterminated character constant\n/tmp/tmp37f7b1wk.d(61): Error: unterminated character constant\n/tmp/tmp37f7b1wk.d(67): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(68): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(69): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(70): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(71): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(72): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(73): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(74): Error: declaration expected, not `assert`\n/tmp/tmp37f7b1wk.d(75): Error: unrecognized declaration\nF",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tlong mid = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < mid)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\tif (l[i] > mid)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\tmid = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpksdg_lfe.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42844d]\n??:? void tmpksdg_lfe.__unittest_L36_C1() [0x42804d]\n??:? void tmpksdg_lfe.__modtest() [0x4281d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c4cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b362]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4309a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430481]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b339]\n??:? runModuleUnitTests [0x42c2a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428910]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l1 = l[0];\n\tlong l2 = l[1];\n\tlong l3 = l[2];\n\tlong l4 = l[3];\n\tlong l5 = l[4];\n\tlong l6 = l[5];\n\tlong l7 = l[6];\n\tlong l8 = l[7];\n\tlong l9 = l[8];\n\tlong l10 = l[9];\n\tlong l11 = l[10];\n\tlong l12 = l[11];\n\tlong l13 = l[12];\n\tlong l14 = l[13];\n\tlong l15 = l[14];\n\tlong l16 = l[15];\n\tlong l17 = l[16];\n\tlong l18 = l[17];\n\tlong l19 = l[18];\n\tlong l20 = l[19];\n\tlong l21 = l[20];\n\tlong l22 = l[21];\n\tlong l23 = l[22];\n\tlong l24 = l[23];\n\tlong l25 = l[24];\n\tlong l26 = l[25];\n\tlong l27 = l[26];\n\tlong l28 = l[27];\n\tlong l29 = l[28];\n\tlong l30 = l[29];\n\tlong l31 = l[30];\n\tlong l32 = l[31];\n\tlong l33 = l[32];\n\tlong l34 = l[33];\n\tlong l35 = l[34];\n\tlong l36 = l[35];\n\tlong l37 = l[36];\n\tlong l38 = l[37];\n\tlong l39 = l[38];\n\tlong l40 = l[39];\n\tlong l41 = l[40];\n\tlong l42 = l[41];\n\tlong l43 = l[42];\n\tlong l44 = l[43];\n\tlong l45 = l[44];\n\tlong l46 = l[45];\n\tlong l47 = l[46];\n\tlong l48 = l[47];\n\tlong l49 = l[48];\n\tlong l50 = l[49];\n\tlong l51 = l[50];\n\tlong l52 = l[51];\n\tlong l53 = l[52];\n\tlong l54 = l[53];\n\tlong l\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4awynn3f.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmp4awynn3f.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4awynn3f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164437
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong minv = l[0];\n\tlong maxv = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < minv)\n\t\t{\n\t\t\tminv = l[i];\n\t\t}\n\t\telse if(l[i] > maxv)\n\t\t{\n\t\t\tmaxv = l[i];\n\t\t}\n\t}\n\treturn (minv < maxv);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7t9x7hlx.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmp7t9x7hlx.__unittest_L24_C1() [0x427f3b]\n??:? void tmp7t9x7hlx.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqa_6b4v6.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpqa_6b4v6.__unittest_L29_C1() [0x427fe1]\n??:? void tmpqa_6b4v6.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbqz7ro7f.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpbqz7ro7f.__unittest_L29_C1() [0x427ff1]\n??:? void tmpbqz7ro7f.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpftqutg9k.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpftqutg9k.__unittest_L28_C1() [0x427f37]\n??:? void tmpftqutg9k.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = 0;\n\tlong min = 1;\n\tbool increasing = true;\n\tbool decreasing = true;\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max && l[i] < min)\n\t\t{\n\t\t\tincreasing = false;\n\t\t}\n\t\tif (l[i] < max && l[i] > min)\n\t\t{\n\t\t\tdecreasing = false;\n\t\t}\n\t}\n\treturn increasing || decreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpin1q74p0.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x42842d]\n??:? void tmpin1q74p0.__unittest_L34_C1() [0x427fdb]\n??:? void tmpin1q74p0.__modtest() [0x4281ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c4af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b342]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430984]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430461]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b319]\n??:? runModuleUnitTests [0x42c285]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tlong next = l[i];\n\t\tif (curr < next)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\telse if (curr > next)\n\t\t{\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfsskfwx1.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmpfsskfwx1.__unittest_L30_C1() [0x427e1c]\n??:? void tmpfsskfwx1.__modtest() [0x428088]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tlong next = l[i];\n\t\tif(curr > next)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(curr < next)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(curr == next)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if(curr > prev)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(curr < prev)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(curr == prev)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if(curr < prev && curr > next)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(curr > prev && curr < next)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(curr == prev && curr == next)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if(curr < prev && curr > next)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(curr > prev && curr < next)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(curr == prev && curr == next)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if(curr < prev && curr > next)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(curr > prev && curr < next)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(curr == prev && curr == next)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if(curr < prev && curr > next)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(curr > prev && curr < next)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if(curr == prev && curr == next)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\telse if(curr < prev && curr > next)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if(curr > prev && curr < next)\n\t\t{\n\t\t\tisDecre\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp52yeg48u.d(101): Error: found `unittest` when expecting `;` following statement\n/tmp/tmp52yeg48u.d(114): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp52yeg48u.d(114): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp52yeg48u.d(114): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52yeg48u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 0,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] > curr)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8c74a20g.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp8c74a20g.__unittest_L27_C1() [0x427e58]\n??:? void tmp8c74a20g.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpva3nw632.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283fd]\n??:? void tmpva3nw632.__unittest_L33_C1() [0x427faf]\n??:? void tmpva3nw632.__modtest() [0x428180]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c47f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b312]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430954]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]\n??:? runModuleUnitTests [0x42c255]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpva3nw632.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4283fd]\n??:? void tmpva3nw632.__unittest_L33_C1() [0x427faf]\n??:? void tmpva3nw632.__modtest() [0x428180]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c47f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b312]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430954]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]\n??:? runModuleUnitTests [0x42c255]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpx8q2r_32.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpx8q2r_32.__unittest_L24_C1() [0x427f4b]\n??:? void tmpx8q2r_32.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164441
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isMonotonic = true;\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < r)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpog13s3c6.d(9): Error: variable `l` is shadowing variable `tmpog13s3c6.monotonic.l`\n/tmp/tmpog13s3c6.d(10): Error: only one index allowed to index `long`\n/tmp/tmpog13s3c6.d(12): Error: no property `length` for type `long`\n/tmp/tmpog13s3c6.d(14): Error: only one index allowed to index `long`\n/tmp/tmpog13s3c6.d(20): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpog13s3c6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong prev=l[0];\n\tlong cur=l[0];\n\tfor(int i=1;i<l.length;i++)\n\t{\n\t\tif(l[i]<cur)\n\t\t\treturn false;\n\t\telse if(l[i]>cur)\n\t\t{\n\t\t\tprev=cur;\n\t\t\tcur=l[i];\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8zbslptj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42835d]\n??:? void tmp8zbslptj.__unittest_L23_C1() [0x427f59]\n??:? void tmp8zbslptj.__modtest() [0x4280dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b272]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430405]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430391]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b249]\n??:? runModuleUnitTests [0x42c1b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428820]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > r)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] < r)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] == r)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\tr = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2bv_5k.d(9): Error: variable `l` is shadowing variable `tmp4y2bv_5k.monotonic.l`\n/tmp/tmp4y2bv_5k.d(10): Error: only one index allowed to index `long`\n/tmp/tmp4y2bv_5k.d(13): Error: no property `length` for type `long`\n/tmp/tmp4y2bv_5k.d(15): Error: only one index allowed to index `long`\n/tmp/tmp4y2bv_5k.d(19): Error: only one index allowed to index `long`\n/tmp/tmp4y2bv_5k.d(23): Error: only one index allowed to index `long`\n/tmp/tmp4y2bv_5k.d(33): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2bv_5k.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn isMonotonic;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3zc8uunx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp3zc8uunx.__unittest_L29_C1() [0x427f43]\n??:? void tmp3zc8uunx.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpd2nms69_.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpd2nms69_.__unittest_L29_C1() [0x427ff1]\n??:? void tmpd2nms69_.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164441
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tlong r = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tlong x = l[i];\n\t\tif((r - x) > 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tr = x;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp34hjjb5e.d(9): Error: variable `l` is shadowing variable `tmp34hjjb5e.monotonic.l`\n/tmp/tmp34hjjb5e.d(10): Error: only one index allowed to index `long`\n/tmp/tmp34hjjb5e.d(11): Error: no property `length` for type `long`\n/tmp/tmp34hjjb5e.d(13): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp34hjjb5e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164440
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\n/*\nReturn True if list elements are monotonically increasing or decreasing.\n                \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpeiglkkbs.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4283c5]\n??:? void tmpeiglkkbs.__unittest_L37_C1() [0x427f77]\n??:? void tmpeiglkkbs.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c447]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43046d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43091c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2b1]\n??:? runModuleUnitTests [0x42c21d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428888]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164441
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqf0hzvbv.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqf0hzvbv.__unittest_L24_C1() [0x427f47]\n??:? void tmpqf0hzvbv.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164438
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpo4gc33i3.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42838d]\n??:? void tmpo4gc33i3.__unittest_L24_C1() [0x427f3b]\n??:? void tmpo4gc33i3.__modtest() [0x42810c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428850]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164441
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n                \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyj3apnk7.d(24): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpyj3apnk7.__unittest_L20_C1() [0x427eac]\n??:? void tmpyj3apnk7.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164441
    }
  ]
}