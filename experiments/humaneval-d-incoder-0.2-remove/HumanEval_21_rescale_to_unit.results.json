{
  "language": "d",
  "name": "HumanEval_21_rescale_to_unit",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp472nscmb.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmp472nscmb.__unittest_L25_C1() [0x428952]\n??:? void tmp472nscmb.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpki79zba1.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpki79zba1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float range = max - min;\n    float scale = (float) 1.0 / (range + 1.0f);\n    \n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph6_6wcif.d(22): Error: C style cast illegal, use `cast(float)1.00000`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph6_6wcif.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyvtm2_ut.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpyvtm2_ut.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpyvtm2_ut.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyvtm2_ut.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz4ofj9ca.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmpz4ofj9ca.__unittest_L25_C1() [0x428952]\n??:? void tmpz4ofj9ca.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float range = max - min;\n    float scale = (float)(1.0f / range);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = (numbers[i] - min) * scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpli6epvp5.d(22): Error: C style cast illegal, use `cast(float)(1.00000F / range)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpli6epvp5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprgudvl8o.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429505]\n??:? void tmprgudvl8o.__unittest_L71_C1() [0x428dca]\n??:? void tmprgudvl8o.__modtest() [0x429288]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43175d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5a1]\n??:? runModuleUnitTests [0x42d50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = numbers[i] * scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work if you have a list of numbers that sum to zero. For example, if you have `[1, 1, 1]`, the output will be `[0, 0, 0]`.\n<|/ c |>\n<| c |>\n: I thought the OP was looking for something that would work for any set of numbers. I guess I misunderstood the question. I'll edit my answer to include a solution that works for any set of numbers.\n<|/ c |>\n<| c |>\nThis doesn't work for `[1, 1, 1]` because `sum` is `0`.\n<|/ c |>\n<| c |>\n: Yes, I realized that after I posted my comment. I've edited my answer to include a solution that works for any set of numbers.\n<|/ c |>\n<| c |>\nThis doesn't work for `[1, 1, 1]` because `sum` is `0`.\n<|/ c |>\n<| a dscore=4 |>\nThe simplest way is to use the formula for linear regression:\n<code>\ny = mx + b\n</code>\nwhere m is the slope and b is the y-intercept. \nThe slope is just the difference between the largest and smallest number in the list, and the y-intercept is the average of the largest and smallest numbers in the list.\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work if you have a list of numbers that sum to zero. For example, if you have `[1, 1, 1]`, the output will be `[0, 0, 0]`.\n<|/ c |>\n<| c |>\n: I thought the OP was looking for something that would work for any set of numbers. I guess I misunderstood the question. I'll edit my answer to include a solution that works for any set of numbers.\n<|/ c |>\n<| c |>\nThis doesn't work for `[1, 1, 1]` because `sum` is `0`.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static double[] RescaleTo\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq18s78mj.d(28): Error: declaration expected, not `<`\n/tmp/tmpq18s78mj.d(31): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(34): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(37): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(40): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(43): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(54): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(57): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(60): Error: unterminated character constant\n/tmp/tmpq18s78mj.d(69): Error: declaration expected, not `assert`\n/tmp/tmpq18s78mj.d(70): Error: declaration expected, not `assert`\n/tmp/tmpq18s78mj.d(71): Error: declaration expected, not `assert`\n/tmp/tmpq18s78mj.d(72): Error: declaration expected, not `assert`\n/tmp/tmpq18s78mj.d(73): Error: declaration expected, not `assert`\n/tmp/tmpq18s78mj.d(74): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq18s78mj.d\", \"-I/tmp\"]",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpne7yk50j.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429545]\n??:? void tmpne7yk50j.__unittest_L71_C1() [0x428e06]\n??:? void tmpne7yk50j.__modtest() [0x4292c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d777]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c60a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43179d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5e1]\n??:? runModuleUnitTests [0x42d54d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429a08]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float scale = (max - min) / (float) std.math.sqrt(numbers.length);\n    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_minmax(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float scale = (max - min) / (float) std.math.sqrt(numbers.length);\n    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_minmax_with_minmax(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float scale = (max - min) / (float) std.math.sqrt(numbers.length);\n    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_minmax_with_minmax_with_minmax(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float scale = (max - min) / (float) std.math.sqrt(numbers.length);\n    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_minmax_with_minmax_with_minmax_with_minmax(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float scale = (max - min) / (float) std.math.sqrt(numbers.length);\n    float[] result = new float[numbers.length];\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp35hta6q9.d(12): Error: C style cast illegal, use `cast(float)std.math.sqrt(numbers.length)`\n/tmp/tmp35hta6q9.d(27): Error: C style cast illegal, use `cast(float)std.math.sqrt(numbers.length)`\n/tmp/tmp35hta6q9.d(42): Error: C style cast illegal, use `cast(float)std.math.sqrt(numbers.length)`\n/tmp/tmp35hta6q9.d(57): Error: C style cast illegal, use `cast(float)std.math.sqrt(numbers.length)`\n/tmp/tmp35hta6q9.d(72): Error: C style cast illegal, use `cast(float)std.math.sqrt(numbers.length)`\n/tmp/tmp35hta6q9.d(74): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp35hta6q9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer. I'm a little confused though. How would I apply this to a list of floats? I understand how to apply it to an array, but how would I apply it to a list of floats?\n<|/ c |>\n<| c |>\nI added a sample of how to apply this to a list of floats.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm a little confused though. How would I apply this to a list of floats? I understand how to apply it to an array, but how would I apply it to a list of floats?\n<|/ c |>\n<| c |>\nI added a sample of how to apply this to a list of floats.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm a little confused though. How would I apply this to a list of floats? I understand how to apply it to an array, but how would I apply it to a list of floats?\n<|/ c |>\n<| a dscore=1 |>\n<code>\nfloat min = float.MaxValue;\nfloat max = float.MinValue;\nforeach (float n in numbers)\n{\n    if (n < min)\n        min = n;\n    if (n > max)\n        max = n;\n}\nfloat scale = (max - min) / (float)(numbers.length - 1);\nfloat[] result = new float[numbers.length];\nfor (int i = 0; i < numbers.length; i++)\n    result[i] = numbers[i] * scale;\n</code>\n<|/ a tags=c#,arrays,math,list |>\n<| a dscore=1 |>\n<code>\nfloat[] numbers = { 1, 2, 3, 4 };\nfloat[] result = new float[numbers.Length];\nfloat min = float.MaxValue;\nfloat max = float.MinValue;\nforeach (float n in numbers)\n{\n    if (n < min)\n        min = n;\n    if (n > max)\n        max = n;\n}\nfloat scale = (max - min) / (float)(numbers.Length - 1);\nfor (int i = 0; i < numbers.Length; i++)\n    result[i] = numbers[i] * scale;\n</code>\n<|/ a tags=c#,arrays,math,list |>\n<| a dscore=1 |>\n\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcyczkdda.d(12): Error: found `in` when expecting `;`\n/tmp/tmpcyczkdda.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpcyczkdda.d(25): Error: declaration expected, not `<`\n/tmp/tmpcyczkdda.d(28): Error: unterminated character constant\n/tmp/tmpcyczkdda.d(34): Error: unterminated character constant\n/tmp/tmpcyczkdda.d(40): Error: unterminated character constant\n/tmp/tmpcyczkdda.d(46): Error: declaration expected, not `foreach`\n/tmp/tmpcyczkdda.d(50): Error: declaration expected, not `if`\n/tmp/tmpcyczkdda.d(52): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyczkdda.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7j022rqj.d(21): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7j022rqj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz4ofj9ca.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmpz4ofj9ca.__unittest_L25_C1() [0x428952]\n??:? void tmpz4ofj9ca.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzaxoi87f.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x4294d5]\n??:? void tmpzaxoi87f.__unittest_L71_C1() [0x428d9a]\n??:? void tmpzaxoi87f.__modtest() [0x429258]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d707]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c59a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43172d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431bdc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c571]\n??:? runModuleUnitTests [0x42d4dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429998]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7txbqh8h.d(21): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7txbqh8h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (1.0f / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpc1girsp6.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmpc1girsp6.__unittest_L25_C1() [0x428952]\n??:? void tmpc1girsp6.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwlt4ussb.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwlt4ussb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpslc74tsf.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4290bd]\n??:? void tmpslc74tsf.__unittest_L26_C1() [0x42897e]\n??:? void tmpslc74tsf.__modtest() [0x428e3c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c182]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431315]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317c4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4312a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c159]\n??:? runModuleUnitTests [0x42d0c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429580]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI wrote a small program to convert a float array to a float array where each element is the average of the two elements before it.\n<code>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpffcdvboh.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpffcdvboh.d(24): Error: declaration expected, not `<`\n/tmp/tmpffcdvboh.d(36): Error: declaration expected, not `assert`\n/tmp/tmpffcdvboh.d(37): Error: declaration expected, not `assert`\n/tmp/tmpffcdvboh.d(38): Error: declaration expected, not `assert`\n/tmp/tmpffcdvboh.d(39): Error: declaration expected, not `assert`\n/tmp/tmpffcdvboh.d(40): Error: declaration expected, not `assert`\n/tmp/tmpffcdvboh.d(41): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpffcdvboh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=math,c++,algorithm |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| c |>\nIt works fine for me. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| c |>\nIt doesn't work for me with [1,2,3] and [2,3,4]. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| c |>\nIt works for me with [1,2,3] and [2,3,4] too. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| c |>\nIt works for me with [1,2,3] and [2,3,4] too. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nfloat rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=math,c++,algorithm |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| c |>\nIt works fine for me. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| c |>\nIt works for me with [1,2,3] and [2,3,4] too. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\n<| c |>\nIt works for me with [1,2,3] and [2,3,4] too. Try it with `[1,2,3]` and `[2,3,4]`.\n<|/ c |>\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo8lxya9e.d(24): Error: declaration expected, not `<`\n/tmp/tmpo8lxya9e.d(27): Error: unterminated character constant\n/tmp/tmpo8lxya9e.d(33): Error: unterminated character constant\n/tmp/tmpo8lxya9e.d(47): Error: declaration expected, not `for`\n/tmp/tmpo8lxya9e.d(47): Error: no identifier for declarator `i`\n/tmp/tmpo8lxya9e.d(47): Error: declaration expected, not `<`\n/tmp/tmpo8lxya9e.d(47): Error: no identifier for declarator `i`\n/tmp/tmpo8lxya9e.d(47): Error: declaration expected, not `++`\n/tmp/tmpo8lxya9e.d(51): Error: declaration expected, not `else`\n/tmp/tmpo8lxya9e.d(53): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo8lxya9e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    \n    foreach(float f in numbers)\n    {\n        if(f < min)\n            min = f;\n        if(f > max)\n            max = f;\n    }\n    \n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    foreach(float f in numbers)\n        f *= scale;\n    \n    return numbers;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,math,.net |>\nI wrote this in C# and tested it against the other answers. I believe it to be correct. \n<code>\npublic static class Math\n{\n    public static double RescaleToUnit(this double[] numbers)\n    {\n        double min = double.MaxValue;\n        double max = double.MinValue;\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp593ya_22.d(13): Error: found `in` when expecting `;`\n/tmp/tmp593ya_22.d(21): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp593ya_22.d(23): Error: found `in` when expecting `;`\n/tmp/tmp593ya_22.d(28): Error: declaration expected, not `<`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp593ya_22.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = (float)(numbers[i] - min) * scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm73fnyzt.d(22): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpm73fnyzt.d(26): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm73fnyzt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa3q36i5i.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpa3q36i5i.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpa3q36i5i.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa3q36i5i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp472nscmb.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmp472nscmb.__unittest_L25_C1() [0x428952]\n??:? void tmp472nscmb.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1xjctjcj.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmp1xjctjcj.__unittest_L24_C1() [0x42895a]\n??:? void tmp1xjctjcj.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_zero(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] += min;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_zero_and_one(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] += min;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] += 1;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_zero_and_one_and_one(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpelygxwk9.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpelygxwk9.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpelygxwk9.d(63): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpelygxwk9.d(89): Error: expression expected, not `unittest`\n/tmp/tmpelygxwk9.d(88): Error: found `{` when expecting `)`\n/tmp/tmpelygxwk9.d(91): Error: semicolon expected, not `alias`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpelygxwk9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (range == 0) ? 1 : range / max;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp93e60yf2.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42909d]\n??:? void tmp93e60yf2.__unittest_L25_C1() [0x428962]\n??:? void tmp93e60yf2.__modtest() [0x428e20]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c162]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431281]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c139]\n??:? runModuleUnitTests [0x42d0a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429560]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt_v8yl9a.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpt_v8yl9a.__unittest_L24_C1() [0x428946]\n??:? void tmpt_v8yl9a.__modtest() [0x428e04]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c14a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43178c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431269]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c121]\n??:? runModuleUnitTests [0x42d08d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxjxtliwu.d(10): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpxjxtliwu.d(11): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxjxtliwu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu4hhvibn.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu4hhvibn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz4ofj9ca.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmpz4ofj9ca.__unittest_L25_C1() [0x428952]\n??:? void tmpz4ofj9ca.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpne7yk50j.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429545]\n??:? void tmpne7yk50j.__unittest_L71_C1() [0x428e06]\n??:? void tmpne7yk50j.__modtest() [0x4292c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d777]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c60a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43179d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5e1]\n??:? runModuleUnitTests [0x42d54d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429a08]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a number and a set of numbers, find the closest number in the set that matches the given number\n    \n*/\nfloat closest_number(float number, float[] numbers) \n{\n    float minDist = FLT_MAX;\n    float minIndex = -1;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        float dist = abs(number - numbers[i]);\n        if(dist < minDist)\n        {\n            minDist = dist;\n            minIndex = i;\n        }\n    }\n    return numbers[minIndex];\n}\n/*\n Given a number and a set of numbers, find the closest number in the set that matches the given number\n    \n*/\nfloat closest_number(float number, float[] numbers, int startIndex) \n{\n    float minDist = FLT_MAX;\n    float minIndex = -1;\n    for(int i = startIndex; i < numbers.length; i++)\n    {\n        float dist = abs(number - numbers[i]);\n        if(dist < minDist)\n        {\n            minDist = dist;\n            minIndex = i;\n        }\n    }\n    return numbers[minIndex];\n}\n/*\n Given a number and a set of numbers, find the closest number in the set that matches the given number\n    \n*/\nfloat closest_number(float number, float[] numbers, int startIndex, int endIndex) \n{\n    float minDist = FLT_MAX;\n    float minIndex = -1;\n    for(int i = startIndex; i < endIndex; i++)\n    {\n        float dist = abs(number - numbers[i]);\n        if(dist < minDist)\n        {\n            minDist = dist;\n            minIndex = i;\n        }\n    }\n    return numbers[minIndex];\n}\n/*\n Given a number and a set of numbers, find the closest number in the set that matches the given number\n    \n*/\nfloat closest_number(float number, float[] numbers, int startIndex, int endIndex, int step) \n{\n    float minDist = FLT_MAX;\n    float minIndex = -1;\n    for(int i = startIndex; i < endIndex; i += step)\n    {\n        float dist = abs(number - numbers[i]);\n        if(dist < minDist)\n        {\n            minDist = dist;\n            min\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4ez7zjzf.d(96): Error: found `unittest` when expecting `;` following statement\n/tmp/tmp4ez7zjzf.d(106): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp4ez7zjzf.d(106): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp4ez7zjzf.d(106): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ez7zjzf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (range == 0.0) ? 1.0 : range / max(abs(range), abs(min));\n    float scaled = new float[numbers.length];\n    for (int i = 0; i < numbers.length; ++i)\n        scaled[i] = numbers[i] * scale;\n    return scaled;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5haidkxy.d(10): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp5haidkxy.d(11): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmp5haidkxy.d(13): Error: function expected before `()`, not `max` of type `float`\n/tmp/tmp5haidkxy.d(14): Error: cannot implicitly convert expression `new float[](numbers.length)` of type `float[]` to `float`\n/tmp/tmp5haidkxy.d(16): Error: only one index allowed to index `float`\n/tmp/tmp5haidkxy.d(17): Error: cannot implicitly convert expression `scaled` of type `float` to `float[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5haidkxy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5frw_kt0.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp5frw_kt0.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp5frw_kt0.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5frw_kt0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1vaizhfj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4290dd]\n??:? void tmp1vaizhfj.__unittest_L26_C1() [0x42899e]\n??:? void tmp1vaizhfj.__modtest() [0x428e5c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d30f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c1a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431335]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4312c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c179]\n??:? runModuleUnitTests [0x42d0e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295a0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (range/numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmps88o1j26.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x4290cd]\n??:? void tmps88o1j26.__unittest_L25_C1() [0x42898e]\n??:? void tmps88o1j26.__modtest() [0x428e4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c192]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431325]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317d4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4312b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c169]\n??:? runModuleUnitTests [0x42d0d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429590]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)(range / 2.0f);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = (float)(numbers[i] - min) / scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc51d_p2z.d(13): Error: C style cast illegal, use `cast(float)(range / 2.00000F)`\n/tmp/tmpc51d_p2z.d(17): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc51d_p2z.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq047iv_q.d(10): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpq047iv_q.d(11): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq047iv_q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a small library to solve this problem in one line:\n<code>\nimport std.array;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4ceton13.d(24): Error: declaration expected, not `<`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ceton13.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6hmhnf86.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp6hmhnf86.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp6hmhnf86.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\n/tmp/tmp6hmhnf86.d(82): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\n/tmp/tmp6hmhnf86.d(87): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6hmhnf86.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your answer but I'm having trouble understanding it.  Can you explain it a little more?\n<|/ c |>\n<| c |>\nI added some comments to explain it a little more. Hope it helps.\n<|/ c |>\n<| c |>\nI added a version that doesn't require the min and max to be the same (which I believe is what you were asking for)\n<|/ c |>\n<| c |>\nI added a version that doesn't require the min and max to be the same (which I believe is what you were asking for)\n<|/ c |>\n<| c |>\nI added a version that doesn't require the min and max to be the same (which I believe is what you were asking for)\n<|/ c |>\n<| a tags=math,c#,algorithm |>\nI believe this should work:\n<code>\npublic static void Main(string[] args)\n{\n    float[] numbers = new float[] { 0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f, 0.8f, 0.9f };\n    float[] rescaledNumbers = rescaleToUnit(numbers);\n    foreach (float number in rescaledNumbers)\n    {\n        Console.WriteLine(number);\n    }\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7cfo3uwd.d(24): Error: declaration expected, not `<`\n/tmp/tmp7cfo3uwd.d(27): Error: unterminated character constant\n/tmp/tmp7cfo3uwd.d(33): Error: unterminated character constant\n/tmp/tmp7cfo3uwd.d(36): Error: unterminated character constant\n/tmp/tmp7cfo3uwd.d(39): Error: unterminated character constant\n/tmp/tmp7cfo3uwd.d(48): Error: declaration expected, not `foreach`\n/tmp/tmp7cfo3uwd.d(51): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7cfo3uwd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] - min;\n        rescaled[i] = rescaled[i]/range;\n    }\n    return rescaled;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] - min;\n        rescaled[i] = rescaled[i]/range;\n    }\n    return rescaled;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = min(numbers);\n    double max = max(numbers);\n    double range = max - min;\n    double rescaled = new double[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] - min;\n        rescaled[i] = rescaled[i]/range;\n    }\n    return rescaled;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = min(numbers);\n    double max = max(numbers);\n    double range = max - min;\n    double rescaled = new double[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] - min;\n        rescaled[i] = rescaled[i]/range;\n    }\n    return rescaled;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphpbv5f9q.d(10): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmphpbv5f9q.d(11): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmphpbv5f9q.d(13): Error: cannot implicitly convert expression `new float[](numbers.length)` of type `float[]` to `float`\n/tmp/tmphpbv5f9q.d(16): Error: only one index allowed to index `float`\n/tmp/tmphpbv5f9q.d(17): Error: only one index allowed to index `float`\n/tmp/tmphpbv5f9q.d(19): Error: cannot implicitly convert expression `rescaled` of type `float` to `float[]`\n/tmp/tmphpbv5f9q.d(28): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmphpbv5f9q.d(29): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmphpbv5f9q.d(31): Error: cannot implicitly convert expression `new float[](numbers.length)` of type `float[]` to `float`\n/tmp/tmphpbv5f9q.d(34): Error: only one index allowed to index `float`\n/tmp/tmphpbv5f9q.d(35): Error: only one index allowed to index `float`\n/tmp/tmphpbv5f9q.d(37)",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzbdd65og.d(96): unittest failure\n----------------\n??:? _d_unittestp [0x429745]\n??:? void tmpzbdd65og.__unittest_L92_C1() [0x429006]\n??:? void tmpzbdd65og.__modtest() [0x4294c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d977]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c80a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43199d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431e4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431929]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c7e1]\n??:? runModuleUnitTests [0x42d74d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429c08]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2lsxro0i.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x4290ad]\n??:? void tmp2lsxro0i.__unittest_L24_C1() [0x42896e]\n??:? void tmp2lsxro0i.__modtest() [0x428e2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c172]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431305]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431291]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c149]\n??:? runModuleUnitTests [0x42d0b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429570]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (1.0f / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpc1girsp6.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmpc1girsp6.__unittest_L25_C1() [0x428952]\n??:? void tmpc1girsp6.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu4hhvibn.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu4hhvibn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c++,arrays,algorithm |>\n<| c |>\nThis doesn't work if you have a list of numbers that is all zero. For example, if you have an array of {0,0} then this algorithm will produce {0,0}\n<|/ c |>\n<| c |>\nI believe that if you have a list of numbers that is all zero, your algorithm will produce an array of {0,0}. That's what I'm saying.\n<|/ c |>\n<| c |>\nI believe that if you have a list of numbers that is all zero, your algorithm will produce an array of {0,0}. That's what I'm saying.\n<|/ c |>\n<| c |>\nI believe that if you have a list of numbers that is all zero, your algorithm will produce an array of {0,0}. That's what I'm saying.\n<|/ c |>\n<| c |>\nI believe that if you have a list of numbers that is all zero, your algorithm will produce an array of {0,0}. That's what I'm saying.\n<|/ c |>\n<| a tags=c++,arrays,algorithm |>\n<code>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk1d2o0bs.d(24): Error: declaration expected, not `<`\n/tmp/tmpk1d2o0bs.d(27): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(30): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(30): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(33): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(33): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(36): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(36): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(39): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(39): Error: unterminated character constant\n/tmp/tmpk1d2o0bs.d(51): Error: declaration expected, not `assert`\n/tmp/tmpk1d2o0bs.d(52): Error: declaration expected, not `assert`\n/tmp/tmpk1d2o0bs.d(53): Error: declaration expected, not `assert`\n/tmp/tmpk1d2o0bs.d(54): Error: declaration expected, not `assert`\n/tmp/tmpk1d2o0bs.d(55): Error: declaration expected, not `assert`\n/tmp/tmpk1d2o0bs.d(56): Error: unrecognized declaration\nFailed: [\"",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_minus_one(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_minus_two(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_minus_three(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprv2doyxv.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmprv2doyxv.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmprv2doyxv.d(61): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmprv2doyxv.d(82): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmprv2doyxv.d(87): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprv2doyxv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max) \n{\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float scale) \n{\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float scale, float offset) \n{\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] += offset;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float scale, float offset, float scale2) \n{\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] += offset;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale2;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwm_m2quh.d(77): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwm_m2quh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpslc74tsf.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4290bd]\n??:? void tmpslc74tsf.__unittest_L26_C1() [0x42897e]\n??:? void tmpslc74tsf.__modtest() [0x428e3c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c182]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431315]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317c4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4312a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c159]\n??:? runModuleUnitTests [0x42d0c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429580]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (range/numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c++,math,algorithm |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| c |>\nIt doesn't work because you assume that the numbers are all positive. Try it with `[-1,-2,-3,-4,-5]`.\n<|/ c |>\n<| c |>\n: Yes, I missed that case. Thanks for pointing it out. I've edited the answer to fix it.\n<|/ c |>\n<| c |>\n: I've added a version that works with negative numbers. Thanks for pointing it out.\n<|/ c |>\n<| c |>\n: I've added a version that works with negative numbers. Thanks for pointing it out.\n<|/ c |>\n<| a tags=c++,math,algorithm |>\n<code>\nfloat rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (range/numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| a tags=c++,math,algorithm |>\n<code>\nfloat rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (range/numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu1h17inj.d(25): Error: declaration expected, not `<`\n/tmp/tmpu1h17inj.d(28): Error: unterminated character constant\n/tmp/tmpu1h17inj.d(31): Error: unterminated character constant\n/tmp/tmpu1h17inj.d(34): Error: unterminated character constant\n/tmp/tmpu1h17inj.d(37): Error: unterminated character constant\n/tmp/tmpu1h17inj.d(40): Error: unterminated character constant\n/tmp/tmpu1h17inj.d(48): Error: declaration expected, not `for`\n/tmp/tmpu1h17inj.d(48): Error: no identifier for declarator `i`\n/tmp/tmpu1h17inj.d(48): Error: declaration expected, not `<`\n/tmp/tmpu1h17inj.d(48): Error: no identifier for declarator `i`\n/tmp/tmpu1h17inj.d(48): Error: declaration expected, not `++`\n/tmp/tmpu1h17inj.d(52): Error: declaration expected, not `if`\n/tmp/tmpu1h17inj.d(54): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu1h17inj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    double sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    double scale = (max - min) / (sum - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmd9vuxqz.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x429575]\n??:? void tmpmd9vuxqz.__unittest_L77_C1() [0x428e3a]\n??:? void tmpmd9vuxqz.__modtest() [0x4292f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d7a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4317cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431759]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c611]\n??:? runModuleUnitTests [0x42d57d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429a38]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not work. Try it with a list of numbers like `[1,2,3]`. The smallest number will be `0` and the largest will be `1`.\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c |>\n<| a tags=c#,math,algorithm |>\nI believe that this is what you are looking for:\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    return value * (max - min) + min;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis does not work. Try it with a list of numbers like `[1,2,3]`. The smallest number will be `0` and the largest will be `1`.\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c |>\n<| c |>\nI tested it with a list of numbers like `[1,2,3]` and it worked fine. Can you give an example where it fails?\n<|/ c \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_58cghk8.d(24): Error: declaration expected, not `<`\n/tmp/tmp_58cghk8.d(47): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_58cghk8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2lsxro0i.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x4290ad]\n??:? void tmp2lsxro0i.__unittest_L24_C1() [0x42896e]\n??:? void tmp2lsxro0i.__modtest() [0x428e2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c172]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431305]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431291]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c149]\n??:? runModuleUnitTests [0x42d0b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429570]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    \n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = numbers[i] - min;\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max)\n{\n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = numbers[i] - min;\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float factor)\n{\n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = numbers[i] - min;\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float factor, float epsilon)\n{\n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = numbers[i] - min;\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float factor, float epsilon, float epsilon2)\n{\n    float scale = (max - min) / (float)(number\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoke77y8w.d(21): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpoke77y8w.d(38): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpoke77y8w.d(55): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpoke77y8w.d(72): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpoke77y8w.d(89): Error: found `unittest` when expecting `)`\n/tmp/tmpoke77y8w.d(91): Error: C style cast illegal, use `cast(float)number`\n/tmp/tmpoke77y8w.d(91): Error: semicolon expected, not `{`\n/tmp/tmpoke77y8w.d(100): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoke77y8w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nI believe this should be the accepted answer. Especially since it uses built-in functions. I tested it and it works perfectly.\n<|/ c |>\n<| a dscore=4 |>\nI believe this can be done with LINQ:\n<code>\nvar numbers = new List<float>() { 1, 2, 3, 4 };\nvar result = numbers.Select(x => x / numbers.Min()).ToList();\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work if you have negative numbers in the list\n<|/ c |>\n<| c |>\n: It does work. Try it out. `numbers.Min()` will return the smallest number in the list. Dividing each number by the smallest number will give the desired result.\n<|/ c |>\n<| c |>\nI tested it and it doesn't work. Try it yourself. It returns `{ 1, 1/2, 1/3, 1/4 }` instead of `{ 1, 1/2, 1/3, 1/4 }`.\n<|/ c |>\n<| c |>\n: I tested it myself. It works perfectly. Try it yourself. It returns `{ 1, 1/2, 1/3, 1/4 }` instead of `{ 1, 1/2, 1/3, 1/4 }`.\n<|/ c |>\n<| c |>\n: I tested it myself. It works perfectly. Try it yourself. It returns `{ 1, 1/2, 1/3, 1/4 }` instead of `{ 1, 1/2, 1/3, 1/4 }`.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\nvar numbers = new List<float>() { 1, 2, 3, 4 };\nvar result = numbers.Select(x => x / numbers.Min()).ToList();\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\n<code>\nvar numbers = new List<float>() { 1, 2, 3, 4 };\nvar result = numbers.Select(x => x / numbers.Min()).ToList();\n</code>\n<|/ a tags=c#,math,algorithm \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp294nrtxx.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp294nrtxx.d(24): Error: declaration expected, not `<`\n/tmp/tmp294nrtxx.d(34): Error: declaration expected, not `<`\n/tmp/tmp294nrtxx.d(37): Error: unterminated character constant\n/tmp/tmp294nrtxx.d(43): Error: unterminated character constant\n/tmp/tmp294nrtxx.d(55): Error: declaration expected, not `<`\n/tmp/tmp294nrtxx.d(61): Error: declaration expected, not `<`\n/tmp/tmp294nrtxx.d(67): Error: declaration expected, not `assert`\n/tmp/tmp294nrtxx.d(68): Error: declaration expected, not `assert`\n/tmp/tmp294nrtxx.d(69): Error: declaration expected, not `assert`\n/tmp/tmp294nrtxx.d(70): Error: declaration expected, not `assert`\n/tmp/tmp294nrtxx.d(71): Error: declaration expected, not `assert`\n/tmp/tmp294nrtxx.d(72): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp294nrtxx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)(1 / range);\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_vector(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)(1 / range);\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_vector2(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)(1 / range);\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_vector3(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)(1 / range);\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_vector4(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)(1 / range);\n    float rescaled\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph_6l2xig.d(13): Error: C style cast illegal, use `cast(float)(1 / range)`\n/tmp/tmph_6l2xig.d(31): Error: C style cast illegal, use `cast(float)(1 / range)`\n/tmp/tmph_6l2xig.d(49): Error: C style cast illegal, use `cast(float)(1 / range)`\n/tmp/tmph_6l2xig.d(67): Error: C style cast illegal, use `cast(float)(1 / range)`\n/tmp/tmph_6l2xig.d(85): Error: C style cast illegal, use `cast(float)(1 / range)`\n/tmp/tmph_6l2xig.d(87): Error: semicolon expected, not `unittest`\n/tmp/tmph_6l2xig.d(87): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_6l2xig.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI used the above solutions, but I wanted to be able to use them for multiple arrays. I came up with this:\n<code>\npublic float[] rescale(float[] numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i) {\n        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i) {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a tags=math,java,arrays |>\n<| a tags=math,java,arrays |>\n<code>\npublic float[] rescale(float[] numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i) {\n        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i) {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i) {\n        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i) {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a tags=math,java,arrays |>\n<| a tags=math,java,arrays |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnyx13ijc.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpnyx13ijc.d(24): Error: declaration expected, not `<`\n/tmp/tmpnyx13ijc.d(32): Error: declaration expected, not `for`\n/tmp/tmpnyx13ijc.d(32): Error: no identifier for declarator `i`\n/tmp/tmpnyx13ijc.d(32): Error: declaration expected, not `<`\n/tmp/tmpnyx13ijc.d(32): Error: declaration expected, not `++`\n/tmp/tmpnyx13ijc.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnyx13ijc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns a list of `float[]` but `rescale_to_unit(numbers)` returns a list of `float`. So the compiler complains about `float[]` not being assignable to `float`.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the definition of rescale_to_unit to the answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the definition of rescale_to_unit to the answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the definition of rescale_to_unit to the answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the definition of rescale_to_unit to the answer.\n<|/ c |>\n<| a dscore=2 |>\nThe other answers here are all good, but I thought I'd add my own solution, which is slightly more concise and doesn't require a separate function. It also doesn't require any extra libraries.\n<code>\nimport std.math;\nimport std.typecons;\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpevzb50x4.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpevzb50x4.d(24): Error: declaration expected, not `<`\n/tmp/tmpevzb50x4.d(27): Error: unterminated character constant\n/tmp/tmpevzb50x4.d(42): Error: unterminated character constant\n/tmp/tmpevzb50x4.d(42): Error: unterminated character constant\n/tmp/tmpevzb50x4.d(42): Error: unterminated character constant\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpevzb50x4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplc7nh2dt.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmplc7nh2dt.__unittest_L24_C1() [0x42894a]\n??:? void tmplc7nh2dt.__modtest() [0x428e08]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c14a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43178c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431269]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c121]\n??:? runModuleUnitTests [0x42d08d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (range == 0) ? 1 : range / max;\n    \n    for(int i = 0; i < numbers.length; ++i)\n    {\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpioqr9cp2.d(10): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpioqr9cp2.d(11): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpioqr9cp2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1xjctjcj.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmp1xjctjcj.__unittest_L24_C1() [0x42895a]\n??:? void tmp1xjctjcj.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = (double)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy1f22i7x.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpy1f22i7x.d(42): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpy1f22i7x.d(64): Error: C style cast illegal, use `cast(double)(range / numbers.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy1f22i7x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpx1jacnaq.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x4290bd]\n??:? void tmpx1jacnaq.__unittest_L24_C1() [0x42897e]\n??:? void tmpx1jacnaq.__modtest() [0x428e3c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c182]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431315]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317c4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4312a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c159]\n??:? runModuleUnitTests [0x42d0c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429580]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(1.0f / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c++,math,algorithm |>\n<| c |>\nThis doesn't work if the numbers are negative.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it out. `rescale_to_unit([-1, -2, -3])` returns `[0, 0, 1]`.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it out. `rescale_to_unit([-1, -2, -3])` returns `[0, 0, 1]`.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it out. `rescale_to_unit([-1, -2, -3])` returns `[0, 0, 1]`.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it out. `rescale_to_unit([-1, -2, -3])` returns `[0, 0, 1]`.\n<|/ c |>\n<| a tags=c++,math,algorithm |>\n<code>\nfloat rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(1.0f / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if the numbers are negative.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it out. `rescale_to_unit([-1, -2, -3])` returns `[0, 0, 1]`.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it out. `rescale_to_unit([-1, -2, -3])` returns `[0, 0, 1]`.\n<|/ c |>\n<| c |>\n: Yes, it does. \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxavhg56f.d(20): Error: C style cast illegal, use `cast(float)(1.00000F / range)`\n/tmp/tmpxavhg56f.d(25): Error: declaration expected, not `<`\n/tmp/tmpxavhg56f.d(28): Error: unterminated character constant\n/tmp/tmpxavhg56f.d(48): Error: declaration expected, not `for`\n/tmp/tmpxavhg56f.d(48): Error: no identifier for declarator `i`\n/tmp/tmpxavhg56f.d(48): Error: declaration expected, not `<`\n/tmp/tmpxavhg56f.d(48): Error: declaration expected, not `++`\n/tmp/tmpxavhg56f.d(52): Error: declaration expected, not `if`\n/tmp/tmpxavhg56f.d(54): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxavhg56f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp_hmyn90.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429575]\n??:? void tmpp_hmyn90.__unittest_L71_C1() [0x428e3a]\n??:? void tmpp_hmyn90.__modtest() [0x4292f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d7a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4317cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431759]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c611]\n??:? runModuleUnitTests [0x42d57d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429a38]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max)\n{\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float range)\n{\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float range, float scale)\n{\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float range, float scale, float offset)\n{\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] += offset;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float range, float scale, float offset, float offset)\n{\n    for(int i = 0; i < numbers.length; ++\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6pszyvla.d(80): Error: expression expected, not `unittest`\n/tmp/tmp6pszyvla.d(81): Error: found `{` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pszyvla.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1vaizhfj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x4290dd]\n??:? void tmp1vaizhfj.__unittest_L26_C1() [0x42899e]\n??:? void tmp1vaizhfj.__modtest() [0x428e5c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d30f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c1a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431335]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4312c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c179]\n??:? runModuleUnitTests [0x42d0e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295a0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (float)(numbers[i] - min) * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = (double)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (double)(numbers[i] - min) * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzu_7x1mt.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpzu_7x1mt.d(22): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\n/tmp/tmpzu_7x1mt.d(42): Error: C style cast illegal, use `cast(double)(range / numbers.length)`\n/tmp/tmpzu_7x1mt.d(44): Error: C style cast illegal, use `cast(double)(numbers[i] - min)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzu_7x1mt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c++,math,algorithm |>\n<| c |>\nThis doesn't work if you have negative numbers. Try it with `[-10, -5, -2, 0, 2, 5, 10]`.\n<|/ c |>\n<| c |>\n: It works with negative numbers. Try it with `[-10, -5, -2, 0, 2, 5, 10]`.\n<|/ c |>\n<| c |>\n: It works with negative numbers. Try it with `[-10, -5, -2, 0, 2, 5, 10]`.\n<|/ c |>\n<| c |>\n: It works with negative numbers. Try it with `[-10, -5, -2, 0, 2, 5, 10]`.\n<|/ c |>\n<| c |>\n: It works with negative numbers. Try it with `[-10, -5, -2, 0, 2, 5, 10]`.\n<|/ c |>\n<| a dscore=3 |>\nThe algorithm is quite simple:\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfa18gkpi.d(18): Error: declaration expected, not `<`\n/tmp/tmpfa18gkpi.d(21): Error: unterminated character constant\n/tmp/tmpfa18gkpi.d(41): Error: declaration expected, not `assert`\n/tmp/tmpfa18gkpi.d(42): Error: declaration expected, not `assert`\n/tmp/tmpfa18gkpi.d(43): Error: declaration expected, not `assert`\n/tmp/tmpfa18gkpi.d(44): Error: declaration expected, not `assert`\n/tmp/tmpfa18gkpi.d(45): Error: declaration expected, not `assert`\n/tmp/tmpfa18gkpi.d(46): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfa18gkpi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max)\n{\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float epsilon)\n{\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float epsilon, float scale)\n{\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float epsilon, float scale, float epsilon2)\n{\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps6tj5n45.d(77): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps6tj5n45.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp80ze91gh.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x4290ad]\n??:? void tmp80ze91gh.__unittest_L24_C1() [0x42896e]\n??:? void tmp80ze91gh.__modtest() [0x428e2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c172]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431305]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431291]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c149]\n??:? runModuleUnitTests [0x42d0b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429570]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1xjctjcj.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmp1xjctjcj.__unittest_L24_C1() [0x42895a]\n??:? void tmp1xjctjcj.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float)(numbers.Length - 1);\n    foreach (float n in numbers)\n        n -= min;\n    foreach (float n in numbers)\n        n *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,.net,linear-algebra |>\n<| c |>\nThis doesn't work if you have negative numbers. `Math.Abs(numbers[0] - numbers[1])` will give you a negative number when `numbers[0]` is negative.\n<|/ c |>\n<| c |>\nI didn't say it wouldn't, I said it wouldn't. `Math.Abs(numbers[0] - numbers[1])` will give you a negative number when `numbers[0]` is negative.\n<|/ c |>\n<| c |>\nI didn't say it wouldn't, I said it wouldn't. `Math.Abs(numbers[0] - numbers[1])` will give you a negative number when `numbers[0]` is negative.\n<|/ c |>\n<| c |>\nI didn't say it wouldn't, I said it wouldn't. `Math.Abs(numbers[0] - numbers[1])` will give you a negative number when `numbers[0]` is negative.\n<|/ c |>\n<| c |>\nI didn't say it wouldn't, I said it wouldn't. `Math.Abs(numbers[0] - numbers[1])` will give you a negative number when `numbers[0]` is negative.\n<|/ c |>\n<| a tags=c#,math,.net,linear-algebra |>\nI wrote a C# library for linear algebra called MathNet.Numerics.LinearAlgebra that has some nice linear algebra routines including a matrix multiplication routine.\n<|/ a dscore=5 |>\n<| c |>\nI used this library and found it to be very slow. MathNet is very fast but doesn't have all the functionality I need. Thanks though!\n<|/ c |>\n<| c |>\nI agree with you. MathNet is very slow and I haven't found a better library yet.\n<|/ c |>\n<| c |>\nMathNet is very slow and I haven't found a better library yet.\n<|/ c |>\n<| c |>\nMathNet \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_7n3yecn.d(12): Error: found `in` when expecting `;`\n/tmp/tmp_7n3yecn.d(19): Error: C style cast illegal, use `cast(float)(numbers.Length - 1)`\n/tmp/tmp_7n3yecn.d(20): Error: found `in` when expecting `;`\n/tmp/tmp_7n3yecn.d(22): Error: found `in` when expecting `;`\n/tmp/tmp_7n3yecn.d(26): Error: declaration expected, not `<`\n/tmp/tmp_7n3yecn.d(29): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(32): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(32): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(32): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(35): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(35): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(35): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(38): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(38): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(38): Error: unterminated character constant\n/tmp/tmp_7n3yecn.d(41): Error: unterminated character const",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyo4g1yqn.d(78): unittest failure\n----------------\n??:? _d_unittestp [0x4294fd]\n??:? void tmpyo4g1yqn.__unittest_L74_C1() [0x428dbe]\n??:? void tmpyo4g1yqn.__modtest() [0x42927c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d72f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431755]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c04]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c599]\n??:? runModuleUnitTests [0x42d505]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnco29wvu.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmpnco29wvu.__unittest_L25_C1() [0x428952]\n??:? void tmpnco29wvu.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqk46zyf_.d(78): unittest failure\n----------------\n??:? _d_unittestp [0x4294bd]\n??:? void tmpqk46zyf_.__unittest_L74_C1() [0x428d82]\n??:? void tmpqk46zyf_.__modtest() [0x429240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431715]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431bc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c559]\n??:? runModuleUnitTests [0x42d4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpphetxqsp.d(87): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpphetxqsp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpki79zba1.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpki79zba1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpea359msb.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429545]\n??:? void tmpea359msb.__unittest_L71_C1() [0x428e06]\n??:? void tmpea359msb.__modtest() [0x4292c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d777]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c60a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43179d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5e1]\n??:? runModuleUnitTests [0x42d54d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429a08]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt_v8yl9a.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpt_v8yl9a.__unittest_L24_C1() [0x428946]\n??:? void tmpt_v8yl9a.__modtest() [0x428e04]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c14a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43178c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431269]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c121]\n??:? runModuleUnitTests [0x42d08d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float scale = (max - min) / (numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplwv4e387.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmplwv4e387.__unittest_L30_C1() [0x42895a]\n??:? void tmplwv4e387.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_min_max(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_min_max_and_scale(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_min_max_and_scale_and_offset(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - 1);\n    for(int i = 0; i < numbers.length; i++)\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7g9ya6bz.d(98): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7g9ya6bz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float)(numbers.Length - 1);\n    foreach (float n in numbers)\n        n -= min;\n    foreach (float n in numbers)\n        n *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not work if your array has negative numbers. Try it with `float[] numbers = { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 };`\n<|/ c |>\n<| c |>\nI tested it and it works fine. Can you please give me an example where it doesn't work?\n<|/ c |>\n<| c |>\nI tested it with `float[] numbers = { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 };` and it works fine.\n<|/ c |>\n<| c |>\nI tested it with `float[] numbers = { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 };` and it works fine.\n<|/ c |>\n<| c |>\nI tested it with `float[] numbers = { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 };` and it works fine.\n<|/ c |>\n<| a |>\n<code>\npublic static float[] rescale(float[] numbers)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float)(numbers.Length - 1);\n    foreach (float n in numbers)\n        n -= min;\n    foreach (float n in numbers)\n        n *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=1 tags=c#,math,arrays |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale(float[] numbers)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float)(numbers.Length - 1);\n    foreach (float n in numbers)\n        n -= min;\n    foreach (float n in numbers)\n        n *= scale;\n    return numbers;\n}\n\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqxb_2cxl.d(12): Error: found `in` when expecting `;`\n/tmp/tmpqxb_2cxl.d(19): Error: C style cast illegal, use `cast(float)(numbers.Length - 1)`\n/tmp/tmpqxb_2cxl.d(20): Error: found `in` when expecting `;`\n/tmp/tmpqxb_2cxl.d(22): Error: found `in` when expecting `;`\n/tmp/tmpqxb_2cxl.d(26): Error: declaration expected, not `<`\n/tmp/tmpqxb_2cxl.d(32): Error: unterminated character constant\n/tmp/tmpqxb_2cxl.d(49): Error: declaration expected, not `foreach`\n/tmp/tmpqxb_2cxl.d(53): Error: declaration expected, not `if`\n/tmp/tmpqxb_2cxl.d(55): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqxb_2cxl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppfj71vja.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429505]\n??:? void tmppfj71vja.__unittest_L71_C1() [0x428dca]\n??:? void tmppfj71vja.__modtest() [0x429288]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43175d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5a1]\n??:? runModuleUnitTests [0x42d50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max)\n{\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float epsilon)\n{\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float epsilon, float min_bound, float max_bound)\n{\n    float scale = (max_bound - min_bound) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float epsilon, float min_bound, float max_bound, float epsilon2)\n{\n    float scale = (max_bound - min_bound) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8pn14ecm.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp8pn14ecm.d(31): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp8pn14ecm.d(43): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp8pn14ecm.d(55): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp8pn14ecm.d(67): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp8pn14ecm.d(72): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8pn14ecm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach(float f in numbers)\n    {\n        if(f < min)\n            min = f;\n        if(f > max)\n            max = f;\n    }\n    float scale = (max - min) / (float.MaxValue - float.MinValue);\n    foreach(float f in numbers)\n    {\n        f *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,linear-algebra,algorithm |>\n<| c |>\nThis doesn't work if you have negative numbers in the list. For example, if you have [1,2,-3] then your algorithm will give [0,0,0] instead of [1,1,1]\n<|/ c |>\n<| c |>\nI agree with you that this is a good solution for positive numbers. However, I believe that negative numbers are also possible and that they should be handled accordingly. For example, if you have [-1,-2,-3] then your algorithm will give [0,0,0] instead of [1,1,1]\n<|/ c |>\n<| c |>\nI believe that negative numbers are also possible and that they should be handled accordingly. For example, if you have [-1,-2,-3] then your algorithm will give [0,0,0] instead of [1,1,1]\n<|/ c |>\n<| c |>\nI believe that negative numbers are also possible and that they should be handled accordingly. For example, if you have [-1,-2,-3] then your algorithm will give [0,0,0] instead of [1,1,1]\n<|/ c |>\n<| c |>\nI believe that negative numbers are also possible and that they should be handled accordingly. For example, if you have [-1,-2,-3] then your algorithm will give [0,0,0] instead of [1,1,1]\n<|/ c |>\n<| a tags=c#,math,linear-algebra,algorithm |>\nI believe that negative numbers are also possible and that they should be handled accordingly. For example, if you have [-1,-2,-3] then your algorithm will give [0,0,0] instead of [1,1,1]\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpokc4p2pc.d(12): Error: found `in` when expecting `;`\n/tmp/tmpokc4p2pc.d(20): Error: found `in` when expecting `;`\n/tmp/tmpokc4p2pc.d(26): Error: declaration expected, not `<`\n/tmp/tmpokc4p2pc.d(29): Error: unterminated character constant\n/tmp/tmpokc4p2pc.d(49): Error: declaration expected, not `assert`\n/tmp/tmpokc4p2pc.d(50): Error: declaration expected, not `assert`\n/tmp/tmpokc4p2pc.d(51): Error: declaration expected, not `assert`\n/tmp/tmpokc4p2pc.d(52): Error: declaration expected, not `assert`\n/tmp/tmpokc4p2pc.d(53): Error: declaration expected, not `assert`\n/tmp/tmpokc4p2pc.d(54): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpokc4p2pc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppbo64kcs.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42907d]\n??:? void tmppbo64kcs.__unittest_L25_C1() [0x42893e]\n??:? void tmppbo64kcs.__modtest() [0x428dfc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c142]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431784]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431261]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c119]\n??:? runModuleUnitTests [0x42d085]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429540]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (float)(numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (float)(numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = (max - min);\n    double scale = (double)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (double)(numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1rsree1_.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmp1rsree1_.d(22): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\n/tmp/tmp1rsree1_.d(42): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmp1rsree1_.d(44): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\n/tmp/tmp1rsree1_.d(64): Error: C style cast illegal, use `cast(double)(range / numbers.length)`\n/tmp/tmp1rsree1_.d(66): Error: C style cast illegal, use `cast(double)(numbers[i] - min)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1rsree1_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprl943kab.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42906d]\n??:? void tmprl943kab.__unittest_L24_C1() [0x428932]\n??:? void tmprl943kab.__modtest() [0x428df0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d29f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c132]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431774]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431251]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c109]\n??:? runModuleUnitTests [0x42d075]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429530]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    \n    float range = max - min;\n    float scale = 1.0f / range;\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3rf5shz0.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x42907d]\n??:? void tmp3rf5shz0.__unittest_L31_C1() [0x42893e]\n??:? void tmp3rf5shz0.__modtest() [0x428dfc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c142]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431784]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431261]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c119]\n??:? runModuleUnitTests [0x42d085]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429540]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a number and a set of numbers, find the smallest number in the set that is greater than the number\n*/\nfloat find_next_larger(float number, float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(numbers[i] > number)\n            return numbers[i];\n        else if(numbers[i] < number)\n            return min + (float)(numbers[i] - min) * scale;\n    }\n    return max;\n}\n/*\n Given a number and a set of numbers, find the largest number in the set that is less than the number\n*/\nfloat find_next_smaller(float number, float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(numbers[i] < number)\n            return numbers[i];\n        else if(numbers[i] > number)\n            return max - (float)(numbers[i] - max) * scale;\n    }\n    return min;\n}\n/*\n Given a number and a set of numbers, find the smallest number in the set that is less than or equal to the number\n*/\nfloat find_next_smaller_equal(float number, float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(numbers[i] <= number)\n            return numbers[i];\n        else if(numbers[i] >= number)\n            return min + (float)(number - min\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb1ldszan.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpb1ldszan.d(38): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpb1ldszan.d(44): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\n/tmp/tmpb1ldszan.d(62): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpb1ldszan.d(68): Error: C style cast illegal, use `cast(float)(numbers[i] - max)`\n/tmp/tmpb1ldszan.d(86): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpb1ldszan.d(92): Error: found `unittest` when expecting `)`\n/tmp/tmpb1ldszan.d(94): Error: C style cast illegal, use `cast(float)(number - min)`\n/tmp/tmpb1ldszan.d(94): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpb1ldszan.d(103): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb1ldszan.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz4ofj9ca.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42908d]\n??:? void tmpz4ofj9ca.__unittest_L25_C1() [0x428952]\n??:? void tmpz4ofj9ca.__modtest() [0x428e10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c152]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431794]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431271]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c129]\n??:? runModuleUnitTests [0x42d095]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429550]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,math,algorithm |>\nThe simplest way is to find the minimum and maximum values in the array, and divide each element by its difference between the maximum and minimum.\n<|/ a dscore=0 |>\n<| c |>\nThat doesn't work if the array contains negative numbers. Also, the OP wants to scale each element to range [0,1].\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work. I said it wouldn't work if you wanted the minimum to be 0, and the maximum to be 1.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work. I said it wouldn't work if you wanted the minimum to be 0, and the maximum to be 1.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work. I said it wouldn't work if you wanted the minimum to be 0, and the maximum to be 1.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work. I said it wouldn't work if you wanted the minimum to be 0, and the maximum to be 1.\n<|/ c |>\n<| a tags=c++,math,algorithm |>\n<code>\nfloat rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfloat rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7bip7kmb.d(24): Error: declaration expected, not `<`\n/tmp/tmp7bip7kmb.d(30): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(33): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(33): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(33): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(36): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(36): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(36): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(39): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(39): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(39): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(42): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(42): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(42): Error: unterminated character constant\n/tmp/tmp7bip7kmb.d(50): Error: declaration expected, not `for`\n/tmp/tmp7bip7kmb.d(50): Error: no identifier for declarator `i`\n/tmp/tmp7bip7kmb.",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a small library that does this for you:\nhttps://github.com/david-hoffman/Mathematica-Function-Library\nIt has some nice features like the ability to apply a function to each element of a list, or to apply a function to each element of a list of lists.\n<|/ a tags=math,algorithm,c# |>\n<| a dscore=2 |>\nI wrote a C# library that does this for you:\nhttps://github.com/david-hoffman/Mathematica-Function-Library\nIt has some nice features like the ability to apply a function to each element of a list, or to apply a function to each element of a list of lists.\n<|/ a tags=math,algorithm,c# |>\n<| a tags=math,algorithm,c# |>\nI wrote a C# library that does this for you:\nhttps://github.com/david-hoffman/Mathematica-Function-Library\nIt has some nice features like the ability to apply a function to each element of a list, or to apply a function to each element of a list of lists.\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,c# |>\nI wrote a C# library that does this for you:\nhttps://github.com/david-hoffman/Mathematica-Function-Library\nIt has some nice features like the ability to apply a function to each element of a list, or to apply a function to each element of a list of lists.\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wrote a C# library that does this for you:\nhttps://github.com/david-hoffman/Mathematica-Function-Library\nIt has some nice features like the ability to apply a function to each element of a list, or to apply a function to each element of a list of lists.\n<|/ a tags=math,algorithm,c# |>\n<| a dscore=1 |>\nI wrote a C# library that does this for you:\nhttps://github.com/david-hoffman/Mathematica-Function\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp83put5hm.d(24): Error: declaration expected, not `<`\n/tmp/tmp83put5hm.d(58): Error: declaration expected, not `assert`\n/tmp/tmp83put5hm.d(59): Error: declaration expected, not `assert`\n/tmp/tmp83put5hm.d(60): Error: declaration expected, not `assert`\n/tmp/tmp83put5hm.d(61): Error: declaration expected, not `assert`\n/tmp/tmp83put5hm.d(62): Error: declaration expected, not `assert`\n/tmp/tmp83put5hm.d(63): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83put5hm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    float[] rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        rescaled[i] = numbers[i] * scale;\n    return rescaled;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    float[] rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        rescaled[i] = numbers[i] * scale;\n    return rescaled;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = 1.0f / range;\n    double[] rescaled = new double[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        rescaled[i] = numbers[i] * scale;\n    return rescaled;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpsbv39wl4.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x429625]\n??:? void tmpsbv39wl4.__unittest_L77_C1() [0x428ee6]\n??:? void tmpsbv39wl4.__modtest() [0x4293a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da4f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c8e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431b6d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43201c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431af9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c8b9]\n??:? runModuleUnitTests [0x42d825]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429ae8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers, float scale) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers, float scale, float min) \n{\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers, float scale, float min, float max) \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppvj7lhhl.d(90): Error: semicolon expected following function declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppvj7lhhl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    float sum = 0;\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp35yk6ou9.d(10): Error: no property `MAX_VALUE` for type `float`\n/tmp/tmp35yk6ou9.d(11): Error: no property `MIN_VALUE` for type `float`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp35yk6ou9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    \n    foreach(float number in numbers)\n    {\n        if(number < min)\n            min = number;\n        \n        if(number > max)\n            max = number;\n    }\n    \n    float scale = (max - min) / (float) numbers.length;\n    \n    foreach(float number in numbers)\n    {\n        number *= scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkfvv9e0q.d(13): Error: found `in` when expecting `;`\n/tmp/tmpkfvv9e0q.d(22): Error: C style cast illegal, use `cast(float)numbers.length`\n/tmp/tmpkfvv9e0q.d(24): Error: found `in` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkfvv9e0q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a number and a range, return the number in the range closest to that number\n*/\nfloat clamp(float number, float min, float max)\n{\n    float range = max - min;\n    float diff = number - min;\n    if(diff > 0)\n        return min + diff;\n    else if(diff < 0)\n        return max - diff;\n    else\n        return min;\n}\n/*\n Given a number and a range, return the number in the range closest to that number\n*/\nfloat clamp(float number, float min, float max, float range)\n{\n    float diff = number - min;\n    if(diff > 0)\n        return min + diff;\n    else if(diff < 0)\n        return max - diff;\n    else\n        return min;\n}\n/*\n Given a number and a range, return the number in the range closest to that number\n*/\nfloat clamp(float number, float min, float max, float range, float scale)\n{\n    float diff = number - min;\n    if(diff > 0)\n        return min + diff * scale;\n    else if(diff < 0)\n        return max - diff * scale;\n    else\n        return min;\n}\n/*\n Given a number and a range, return the number in the range closest to that number\n*/\nfloat clamp(float number, float min, float max, float range, float scale, float offset)\n{\n    float diff = number - min;\n    if(diff > 0)\n        return min + diff * scale + offset;\n    else if(diff < 0)\n        return max - diff * scale - offset;\n    else\n        return min;\n}\n/*\n Given a number and a range, return the number in the range closest to that number\n*/\nfloat clamp(float number, float min, float max, float range, float scale, float offset, float clamp)\n{\n    float diff = number - min;\n    if(diff > 0)\n        return min + diff * scale + offset;\n    else if(diff < 0)\n        return max - diff * scale - offset;\n    else\n        return min;\n}\n/*\n Given a number and a range, return the number in the range closest to that number\n*/\nfloat clamp(float number, float min, float max, float range, float scale, float offset, float clamp\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tvt03vn.d(95): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tvt03vn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9tq0ykl1.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429505]\n??:? void tmp9tq0ykl1.__unittest_L71_C1() [0x428dca]\n??:? void tmp9tq0ykl1.__modtest() [0x429288]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43175d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5a1]\n??:? runModuleUnitTests [0x42d50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (float)(numbers[i] - min) * scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (float)(numbers[i] - min) * scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = (double)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (double)(numbers[i] - min) * scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats_doubles(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < number\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp222ir6kk.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmp222ir6kk.d(22): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\n/tmp/tmp222ir6kk.d(42): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmp222ir6kk.d(44): Error: C style cast illegal, use `cast(float)(numbers[i] - min)`\n/tmp/tmp222ir6kk.d(64): Error: C style cast illegal, use `cast(double)(range / numbers.length)`\n/tmp/tmp222ir6kk.d(66): Error: C style cast illegal, use `cast(double)(numbers[i] - min)`\n/tmp/tmp222ir6kk.d(86): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmp222ir6kk.d(88): Error: found `unittest` when expecting `;` following `for` condition\n/tmp/tmp222ir6kk.d(98): Error: found `void` when expecting `)`\n/tmp/tmp222ir6kk.d(98): Error: found `{` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp222ir6kk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    \n    foreach(float n in numbers)\n    {\n        min = min(min, n);\n        max = max(max, n);\n    }\n    \n    float[] result = new float[numbers.length];\n    \n    foreach(float n in numbers)\n    {\n        result[n] = (n - min) / (max - min);\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq8x4het4.d(13): Error: found `in` when expecting `;`\n/tmp/tmpq8x4het4.d(21): Error: found `in` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq8x4het4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpodxcm5rs.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpodxcm5rs.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpodxcm5rs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (1.0f / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (1.0f / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = (max - min);\n    double scale = (1.0f / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbugwbsen.d(78): unittest failure\n----------------\n??:? _d_unittestp [0x4294fd]\n??:? void tmpbugwbsen.__unittest_L74_C1() [0x428dbe]\n??:? void tmpbugwbsen.__modtest() [0x42927c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d72f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431755]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c04]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c599]\n??:? runModuleUnitTests [0x42d505]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = (double)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa5k9x8gv.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpa5k9x8gv.d(42): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpa5k9x8gv.d(64): Error: C style cast illegal, use `cast(double)(range / numbers.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa5k9x8gv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyvtm2_ut.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpyvtm2_ut.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpyvtm2_ut.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyvtm2_ut.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8mrgl844.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp8mrgl844.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp8mrgl844.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\n/tmp/tmp8mrgl844.d(82): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\n/tmp/tmp8mrgl844.d(87): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8mrgl844.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float) 1.0 / (range + 1.0f);\n    float[] rescaled = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n        rescaled[i] = numbers[i] * scale;\n    return rescaled;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1yqhkm7g.d(13): Error: C style cast illegal, use `cast(float)1.00000`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1yqhkm7g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa3q36i5i.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpa3q36i5i.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpa3q36i5i.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa3q36i5i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = 1.0f / range;\n    float rescaled = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n        rescaled[i] = numbers[i] * scale;\n    return rescaled;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3o1y27ql.d(10): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp3o1y27ql.d(11): Error: undefined identifier `max`, did you mean function `fmax`?\n/tmp/tmp3o1y27ql.d(14): Error: cannot implicitly convert expression `new float[](numbers.length)` of type `float[]` to `float`\n/tmp/tmp3o1y27ql.d(16): Error: only one index allowed to index `float`\n/tmp/tmp3o1y27ql.d(17): Error: cannot implicitly convert expression `rescaled` of type `float` to `float[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3o1y27ql.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpki79zba1.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpki79zba1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnxtryy0i.d(96): unittest failure\n----------------\n??:? _d_unittestp [0x42970d]\n??:? void tmpnxtryy0i.__unittest_L92_C1() [0x428fce]\n??:? void tmpnxtryy0i.__modtest() [0x42948c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431965]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431e14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4318f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c7a9]\n??:? runModuleUnitTests [0x42d715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429bd0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp33oh3aly.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429575]\n??:? void tmp33oh3aly.__unittest_L71_C1() [0x428e3a]\n??:? void tmp33oh3aly.__modtest() [0x4292f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d7a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4317cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431759]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c611]\n??:? runModuleUnitTests [0x42d57d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429a38]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([0.1f, 0.2f, 0.3f, 0.4f])` returns `[0.1, 0.2, 0.3, 0.4]` instead of `[0.1, 0.2, 0.3, 0.4]`.\n<|/ c |>\n<| c |>\nIt does work. Try it yourself. I tested it on `[0.1f, 0.2f, 0.3f, 0.4f]` and it returned `[0.1, 0.2, 0.3, 0.4]`.\n<|/ c |>\n<| c |>\nAh, I see what you mean. You're right. My bad. Sorry about that. :)\n<|/ c |>\n<| a tags=math,c#,algorithm |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    return ((value - min) / (max - min));\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `RescaleToUnit(0.1f, 0.2f, 0.3f)` returns `0.1f` instead of `0.1`.\n<|/ c |>\n<| c |>\nI tested it on `[0.1f, 0.2f, 0.3f]` and it returned `[0.1, 0.2, 0.3]`.\n<|/ c |>\n<| c |>\nI tested it on `[0.1f, 0.2f, 0.3f, 0.4f]` and it returned `[0.1, 0.2, 0.3, 0.4]`.\n<|/ c |>\n<| c |>\nI tested it on `[0.1f, 0.2f, 0.3f, 0.4f]` and it returned `[0.1, 0.2, 0.3, 0.4]`.\n<|/ c |>\n<| c |>\nI tested it on `[0.1f, 0.2f, 0.3f, 0.4f]` and it returned `[0.1, 0.2, 0.3, 0.4]`.\n<|/ c |>\n<| a tags=math,c#,algorithm |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    return ((value - min) / (max - min));\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work. `RescaleToUnit(0.1f, 0.\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpftz7g4sm.d(25): Error: declaration expected, not `<`\n/tmp/tmpftz7g4sm.d(28): Error: unterminated character constant\n/tmp/tmpftz7g4sm.d(34): Error: unterminated character constant\n/tmp/tmpftz7g4sm.d(41): Error: unrecognized declaration\n/tmp/tmpftz7g4sm.d(45): Error: unterminated character constant\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpftz7g4sm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    float[] rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmc4tiz2u.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x429145]\n??:? void tmpmc4tiz2u.__unittest_L28_C1() [0x428a0a]\n??:? void tmpmc4tiz2u.__modtest() [0x428ec8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43168d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c3d9]\n??:? runModuleUnitTests [0x42d345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429608]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprgudvl8o.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429505]\n??:? void tmprgudvl8o.__unittest_L71_C1() [0x428dca]\n??:? void tmprgudvl8o.__modtest() [0x429288]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43175d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5a1]\n??:? runModuleUnitTests [0x42d50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n/*\n Given a number and a set of numbers, find the smallest number in the set that is\n    closest to the number provided.\n    \n*/\nfloat find_closest_number(float number, float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(abs(number - numbers[i]) < abs(number - min + scale))\n            return numbers[i];\n    }\n    return min;\n}\n/*\n Given a number and a set of numbers, find the largest number in the set that is closest to the number provided.\n    \n*/\nfloat find_closest_number_opposite(float number, float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(abs(number - numbers[i]) < abs(number - max - scale))\n            return numbers[i];\n    }\n    return max;\n}\n/*\n Given a number and a set of numbers, find the smallest number in the set that is closest to the number provided.\n    \n*/\nfloat find_closest_number_opposite_opposite(float number, float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(abs(number - numbers[i]) < abs(number - min + scale))\n            return numbers[i];\n    }\n    return min;\n}\n/*\n Given a number and a set of number\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpas_uhg44.d(94): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpas_uhg44.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwbkq1870.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwbkq1870.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm,rescale |>\n<| c |>\nThis doesn't work if you have negative numbers. I believe this should be the accepted answer.\n<|/ c |>\n<| a dscore=4 |>\nI believe this should work:\n<code>\npublic static float[] Rescale(float[] numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.Length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm,rescale |>\n<| c |>\nThis doesn't work if you have negative numbers. I believe this should be the accepted answer.\n<|/ c |>\n<| a |>\n<code>\npublic static float[] Rescale(float[] numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.Length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=4 tags=c#,math,algorithm,rescale |>\n<| a dscore=4 |>\n<code>\npublic static float[] Rescale(float[] numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.Length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm,rescale |>\n<| a tags=c#,math,algorithm,rescale |>\n<code>\npublic static float[] Rescale(float[] numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.Length; i++)\n        numbers[i] *= scale;\n    return numbers;\n\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6z9ls6ua.d(25): Error: declaration expected, not `<`\n/tmp/tmp6z9ls6ua.d(28): Error: unterminated character constant\n/tmp/tmp6z9ls6ua.d(39): Error: declaration expected, not `for`\n/tmp/tmp6z9ls6ua.d(39): Error: no identifier for declarator `i`\n/tmp/tmp6z9ls6ua.d(39): Error: declaration expected, not `<`\n/tmp/tmp6z9ls6ua.d(39): Error: no identifier for declarator `i`\n/tmp/tmp6z9ls6ua.d(39): Error: declaration expected, not `++`\n/tmp/tmp6z9ls6ua.d(41): Error: declaration expected, not `return`\n/tmp/tmp6z9ls6ua.d(42): Error: unrecognized declaration\n/tmp/tmp6z9ls6ua.d(46): Error: unterminated character constant\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6z9ls6ua.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float rescaled = range == 0 ? 0 : numbers[0] / range;\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        rescaled += (numbers[i] - min) / range;\n    }\n    return new float[] {rescaled, rescaled};\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnjka5kzy.d(18): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpnjka5kzy.d(18): Error: found `}` when expecting `;` following statement\n/tmp/tmpnjka5kzy.d(18): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnjka5kzy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptl6th3zf.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x4294d5]\n??:? void tmptl6th3zf.__unittest_L71_C1() [0x428d9a]\n??:? void tmptl6th3zf.__modtest() [0x429258]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d707]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c59a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43172d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431bdc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c571]\n??:? runModuleUnitTests [0x42d4dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429998]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = (max - min);\n    double scale = (double)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpshbvgx8e.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpshbvgx8e.d(42): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpshbvgx8e.d(64): Error: C style cast illegal, use `cast(double)(range / numbers.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpshbvgx8e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = (numbers[i] - min) / scale;\n    }\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv0yk1yr9.d(21): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv0yk1yr9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = (max - min);\n    float scale = (range == 0) ? 0 : (1 / range);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6pxt8een.d(10): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp6pxt8een.d(11): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pxt8een.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphhtjl3sz.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42907d]\n??:? void tmphhtjl3sz.__unittest_L25_C1() [0x42893e]\n??:? void tmphhtjl3sz.__modtest() [0x428dfc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c142]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431784]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431261]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c119]\n??:? runModuleUnitTests [0x42d085]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429540]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c++,math,algorithm |>\n<| c |>\nI like this one. Very elegant and simple.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| a |>\n<code>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzevdxczu.d(24): Error: declaration expected, not `<`\n/tmp/tmpzevdxczu.d(30): Error: unterminated character constant\n/tmp/tmpzevdxczu.d(33): Error: unterminated character constant\n/tmp/tmpzevdxczu.d(36): Error: unterminated character constant\n/tmp/tmpzevdxczu.d(39): Error: unterminated character constant\n/tmp/tmpzevdxczu.d(50): Error: declaration expected, not `assert`\n/tmp/tmpzevdxczu.d(51): Error: declaration expected, not `assert`\n/tmp/tmpzevdxczu.d(52): Error: declaration expected, not `assert`\n/tmp/tmpzevdxczu.d(53): Error: declaration expected, not `assert`\n/tmp/tmpzevdxczu.d(54): Error: declaration expected, not `assert`\n/tmp/tmpzevdxczu.d(55): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzevdxczu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyvtm2_ut.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpyvtm2_ut.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpyvtm2_ut.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyvtm2_ut.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp80ze91gh.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x4290ad]\n??:? void tmp80ze91gh.__unittest_L24_C1() [0x42896e]\n??:? void tmp80ze91gh.__modtest() [0x428e2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c172]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431305]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431291]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c149]\n??:? runModuleUnitTests [0x42d0b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429570]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp80ze91gh.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x4290ad]\n??:? void tmp80ze91gh.__unittest_L24_C1() [0x42896e]\n??:? void tmp80ze91gh.__modtest() [0x428e2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c172]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431305]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431291]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c149]\n??:? runModuleUnitTests [0x42d0b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429570]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers, float scale) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers, float scale, float offset) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale + offset;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers, \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgz4xa3gp.d(91): Error: basic type expected, not `unittest`\n/tmp/tmpgz4xa3gp.d(91): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgz4xa3gp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns an array of length 1, and `numbers` has length 2.\n<|/ c |>\n<| c |>\nI tested it and it works fine. Can you post the code you used?\n<|/ c |>\n<| c |>\nI added the code I used to my original post. Thanks for your help!\n<|/ c |>\n<| c |>\nI tested it and it works fine. Can you post the code you used?\n<|/ c |>\n<| c |>\nI added the code I used to my original post. Thanks for your help!\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=arrays,c#,math |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns an array of length 1, and `numbers` has length 2.\n<|/ c |>\n<| a tags=arrays,c#,math |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfy0hjwx_.d(26): Error: declaration expected, not `<`\n/tmp/tmpfy0hjwx_.d(29): Error: unterminated character constant\n/tmp/tmpfy0hjwx_.d(50): Error: declaration expected, not `for`\n/tmp/tmpfy0hjwx_.d(50): Error: no identifier for declarator `i`\n/tmp/tmpfy0hjwx_.d(50): Error: declaration expected, not `<`\n/tmp/tmpfy0hjwx_.d(50): Error: no identifier for declarator `i`\n/tmp/tmpfy0hjwx_.d(50): Error: declaration expected, not `++`\n/tmp/tmpfy0hjwx_.d(53): Error: declaration expected, not `if`\n/tmp/tmpfy0hjwx_.d(55): Error: declaration expected, not `if`\n/tmp/tmpfy0hjwx_.d(57): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfy0hjwx_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float)(numbers.Length - 1);\n    float[] result = new float[numbers.Length];\n    for (int i = 0; i < numbers.Length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work. Try it with numbers like `[1,2,3]` - it will return `[1,2,3]`.\n<|/ c |>\n<| c |>\n: I didn't test it but I think it works. I tested it on `[1,2,3]` and it returned `[0,0,1]`\n<|/ c |>\n<| c |>\n: I tested it on `[1,2,3]` and it returned `[0,0,1]`\n<|/ c |>\n<| c |>\n: I tested it on `[1,2,3]` and it returned `[0,0,1]`\n<|/ c |>\n<| c |>\n: I tested it on `[1,2,3]` and it returned `[0,0,1]`\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static IEnumerable<float> RescaleToUnit(IEnumerable<float> numbers)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float)(numbers.Count() - 1);\n    foreach (float n in numbers)\n        yield return n * scale;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work. Try it with numbers like `[1,2,3]` - it will return `[1,2,3]`.\n<|/ c |>\n<| c |>\n: I didn't test it but I think it works. I tested it on `[1,2,3]` and it returned `[0,0,1]`\n<|/ c |>\n<| c |>\n: I tested it on `[1,2,3]` and it returned `[0,0,1]`\n<|/ c |>\n<| c |>\n: I tested it on `[1,2,3]` and it returned `[0,0,1]`\n<|/ c |>\n<| c |>\n: I tested it on `[1,2,3]` and \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq37yl6jx.d(12): Error: found `in` when expecting `;`\n/tmp/tmpq37yl6jx.d(19): Error: C style cast illegal, use `cast(float)(numbers.Length - 1)`\n/tmp/tmpq37yl6jx.d(25): Error: declaration expected, not `<`\n/tmp/tmpq37yl6jx.d(28): Error: unterminated character constant\n/tmp/tmpq37yl6jx.d(31): Error: unterminated character constant\n/tmp/tmpq37yl6jx.d(48): Error: declaration expected, not `foreach`\n/tmp/tmpq37yl6jx.d(52): Error: declaration expected, not `if`\n/tmp/tmpq37yl6jx.d(54): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq37yl6jx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float scale = (max - min) / (float)(numbers.length - 1);\n    \n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    \n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7fywnko8.d(21): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7fywnko8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to that number\n*/\nfloat rescale_range(float number, float range)\n{\n    float factor = range / number;\n    return number * factor;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to that number\n*/\ndouble rescale_range(double number, double range)\n{\n    double factor = range / number;\n    return number * factor;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to that number\n*/\nlong rescale_range(long number, long range)\n{\n    long factor = range / number;\n    return number * factor;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to that number\n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5fal85eg.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4291bd]\n??:? void tmp5fal85eg.__unittest_L52_C1() [0x428a82]\n??:? void tmp5fal85eg.__modtest() [0x428f40]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d3ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c282]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431415]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4318c4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4313a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c259]\n??:? runModuleUnitTests [0x42d1c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429680]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1,2])` returns `[1.0,2.0]` instead of `[0.5,1.0]`\n<|/ c |>\n<| c |>\nIt does work. `rescale_to_unit([1,2])` returns `[0.5,1.0]`\n<|/ c |>\n<| c |>\nOh, I see what you mean. My bad. Sorry about that. I'll fix it now.\n<|/ c |>\n<| c |>\nI fixed it now. Sorry about that.\n<|/ c |>\n<| c |>\nI fixed it now. Sorry about that.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\nI believe this should work:\n<code>\npublic static float[] Rescale(float[] numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n    float scale = max - min;\n    float scaleFactor = numbers.Length > 1 ? scale / numbers.Length : 1;\n    for(int i = 0; i < numbers.Length; i++)\n    {\n        numbers[i] *= scaleFactor;\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `Rescale([1,2])` returns `[1.0,2.0]` instead of `[0.5,1.0]`\n<|/ c |>\n<| c |>\nI fixed it now. Sorry about that.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static float[] Rescale(float[] numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n    float scale = max - min;\n    float scaleFactor = numbers.Length > 1 ? scale / numbers.Length : 1;\n    for(int i = 0; i < numbers.Length; i++)\n    {\n        numbers[i] *= scaleFactor;\n    }\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't seem to work. `Rescale([1,2])` returns `[1.0,2.0]` instead of `\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4ed3wu08.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp4ed3wu08.d(24): Error: declaration expected, not `<`\n/tmp/tmp4ed3wu08.d(27): Error: unterminated character constant\n/tmp/tmp4ed3wu08.d(33): Error: unterminated character constant\n/tmp/tmp4ed3wu08.d(50): Error: declaration expected, not `for`\n/tmp/tmp4ed3wu08.d(50): Error: no identifier for declarator `i`\n/tmp/tmp4ed3wu08.d(50): Error: declaration expected, not `<`\n/tmp/tmp4ed3wu08.d(50): Error: no identifier for declarator `i`\n/tmp/tmp4ed3wu08.d(50): Error: declaration expected, not `++`\n/tmp/tmp4ed3wu08.d(53): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ed3wu08.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprgudvl8o.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429505]\n??:? void tmprgudvl8o.__unittest_L71_C1() [0x428dca]\n??:? void tmprgudvl8o.__modtest() [0x429288]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43175d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5a1]\n??:? runModuleUnitTests [0x42d50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, int size) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < size; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < size; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, int size, float min, float max) \n{\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < size; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, int size, float min, float max, float range) \n{\n    float scale = 1.0f / range;\n    for(int i = 0; i < size; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, int size, float min, float max, float range, float scale) \n{\n    for(int i = 0; i < size; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, int size, \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm0jwzokx.d(89): Error: basic type expected, not `unittest`\n/tmp/tmpm0jwzokx.d(89): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm0jwzokx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8y6u1gtx.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y6u1gtx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, float min, float max) \n{\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, float min, float max, float scale) \n{\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, float min, float max, float scale, float offset) \n{\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] += offset;\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers, float min, float max, float scale, float offset, float scale2) \n{\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] += offset;\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale2;\n    return numbers;\n}\n/*\n Given a vector of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpczbmomla.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpczbmomla.d(31): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpczbmomla.d(56): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpczbmomla.d(70): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpczbmomla.d(83): Error: semicolon expected, not `unittest`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpczbmomla.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach(float f in numbers)\n    {\n        if(f < min)\n            min = f;\n        if(f > max)\n            max = f;\n    }\n    float scale = (max - min) / (float.MaxValue - float.MinValue);\n    foreach(float f in numbers)\n        f *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this without having to loop through every element. Maybe some kind of binary search or something?\n<|/ c |>\n<| c |>\n: I added a binary search solution that doesn't require looping through every element.  It still loops through every element, but it's done in constant time.\n<|/ c |>\n<| c |>\nI like your binary search solution, but I wonder if there is a way to do this without having to loop through every element. Maybe some kind of binary search or something?\n<|/ c |>\n<| c |>\n: I added a binary search solution that doesn't require looping through every element.  It still loops through every element, but it's done in constant time.\n<|/ c |>\n<| c |>\nI like your binary search solution, but I wonder if there is a way to do this without having to loop through every element. Maybe some kind of binary search or something?\n<|/ c |>\n<| a dscore=1 |>\nI like your binary search solution, but I wonder if there is a way to do this without having to loop through every element. Maybe some kind of binary search or something?\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzlzrie71.d(12): Error: found `in` when expecting `;`\n/tmp/tmpzlzrie71.d(20): Error: found `in` when expecting `;`\n/tmp/tmpzlzrie71.d(24): Error: declaration expected, not `<`\n/tmp/tmpzlzrie71.d(30): Error: unterminated character constant\n/tmp/tmpzlzrie71.d(30): Error: unterminated character constant\n/tmp/tmpzlzrie71.d(36): Error: unterminated character constant\n/tmp/tmpzlzrie71.d(36): Error: unterminated character constant\n/tmp/tmpzlzrie71.d(47): Error: declaration expected, not `assert`\n/tmp/tmpzlzrie71.d(48): Error: declaration expected, not `assert`\n/tmp/tmpzlzrie71.d(49): Error: declaration expected, not `assert`\n/tmp/tmpzlzrie71.d(50): Error: declaration expected, not `assert`\n/tmp/tmpzlzrie71.d(51): Error: declaration expected, not `assert`\n/tmp/tmpzlzrie71.d(52): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzlzrie71.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (range/numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp75v994ue.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42909d]\n??:? void tmp75v994ue.__unittest_L25_C1() [0x428962]\n??:? void tmp75v994ue.__modtest() [0x428e20]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c162]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431281]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c139]\n??:? runModuleUnitTests [0x42d0a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429560]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = 1.0f / (max - min);\n    foreach (float n in numbers)\n        numbers[n] *= scale;\n    return numbers;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work when numbers are negative.\n<|/ c |>\n<| c |>\nIt does work, just tested it.  It doesn't work for negative numbers, because `float.MaxValue` is `1.7976931348623157E308`.  If you want it to work for negative numbers, just change `float.MaxValue` to `-float.MaxValue`.\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers. I tested it on negative numbers and it didn't work. `float.MaxValue` is `1.7976931348623157E308`\n<|/ c |>\n<| c |>\nIt works for negative numbers.  `float.MaxValue` is `1.7976931348623157E308`.  If you want it to work for negative numbers, just change `float.MaxValue` to `-float.MaxValue`.\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers. I tested it on negative numbers and it didn't work. `float.MaxValue` is `1.7976931348623157E308`\n<|/ c |>\n<| a tags=c#,math,.net |>\nI wrote this in C#:\n<code>\npublic static class Math\n{\n    public static float RescaleToUnit(this float value)\n    {\n        float min = float.MaxValue;\n        float max = float.MinValue;\n        foreach (float n in value)\n        {\n            if (n < min)\n                min = n;\n            if (n > max)\n                max = n;\n        }\n        float scale = 1.0f / (max - min);\n        foreach (float n in value)\n            n = n * scale;\n        return value;\n    }\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work when numbers are negative.\n<|/ c |>\n<| c |>\nIt does work, just tested it.  It doesn't work for negative numbers, because `float.MaxValue` is `1.7976931348623157E308`.  If you want it to work for negative numbers, just change `float\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp79zhyok3.d(12): Error: found `in` when expecting `;`\n/tmp/tmp79zhyok3.d(20): Error: found `in` when expecting `;`\n/tmp/tmp79zhyok3.d(24): Error: declaration expected, not `<`\n/tmp/tmp79zhyok3.d(27): Error: unterminated character constant\n/tmp/tmp79zhyok3.d(30): Error: unterminated character constant\n/tmp/tmp79zhyok3.d(33): Error: unterminated character constant\n/tmp/tmp79zhyok3.d(33): Error: unterminated character constant\n/tmp/tmp79zhyok3.d(39): Error: unterminated character constant\n/tmp/tmp79zhyok3.d(39): Error: unterminated character constant\n/tmp/tmp79zhyok3.d(50): Error: declaration expected, not `foreach`\n/tmp/tmp79zhyok3.d(54): Error: declaration expected, not `if`\n/tmp/tmp79zhyok3.d(56): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp79zhyok3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float scale = 1.0f / (max - min);\n    foreach (float n in numbers)\n        numbers[n] = (n * scale) + min;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns a list of `float[]` but the original list was `List<float>`.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `List<float>` instead of `float[]` because I thought you were working with lists.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `List<float>` instead of `float[]` because I thought you were working with lists.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `List<float>` instead of `float[]` because I thought you were working with lists.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `List<float>` instead of `float[]` because I thought you were working with lists.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static List<float> RescaleToUnit(List<float> numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n    float scale = 1.0f / (max - min);\n    foreach (float n in numbers)\n        numbers[n] = (n * scale) + min;\n    return numbers;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns a list of `float[]` but the original list was `List<float>`.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `List<float>` instead of `float[]` because I thought you were working with lists.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `List<float>` instead of `float[]` because I thought you were working with lists.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `List<float>` instead of `float[]` because I thought you were \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxou6n5d9.d(12): Error: found `in` when expecting `;`\n/tmp/tmpxou6n5d9.d(20): Error: found `in` when expecting `;`\n/tmp/tmpxou6n5d9.d(24): Error: declaration expected, not `<`\n/tmp/tmpxou6n5d9.d(27): Error: unterminated character constant\n/tmp/tmpxou6n5d9.d(48): Error: declaration expected, not `foreach`\n/tmp/tmpxou6n5d9.d(50): Error: declaration expected, not `return`\n/tmp/tmpxou6n5d9.d(51): Error: unrecognized declaration\n/tmp/tmpxou6n5d9.d(55): Error: unterminated character constant\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxou6n5d9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt_v8yl9a.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpt_v8yl9a.__unittest_L24_C1() [0x428946]\n??:? void tmpt_v8yl9a.__modtest() [0x428e04]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c14a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43178c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431269]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c121]\n??:? runModuleUnitTests [0x42d08d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,.net |>\n<| a dscore=0 |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    float scale = (max - min) / (float)((int)Math.Pow(10,(int)Math.Log10(Math.Abs(value))));\n    return value * scale;\n}\n</code>\n<|/ a tags=c#,math,.net |>\n<| a tags=c#,math,.net |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    float scale = (max - min) / (float)((int)Math.Pow(10,(int)Math.Log10(Math.Abs(value))));\n    return value * scale;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    float scale = (max - min) / (float)((int)Math.Pow(10,(int)Math.Log10(Math.Abs(value))));\n    return value * scale;\n}\n</code>\n<|/ a tags=c#,math,.net |>\n<| a tags=c#,math,.net |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    float scale = (max - min) / (float)((int)Math.Pow(10,(int)Math.Log10(Math.Abs(value))));\n    return value * scale;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=c#,math,.net |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n{\n    float scale = (max - min) / (float)((int)Math.Pow(10,(int)Math.Log10(Math.Abs(value))));\n    return value * scale;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that others can learn from it\n<|/ c |>\n<| a tags=c#,math,.net |>\n<code>\npublic static float RescaleToUnit(\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjmamlj_1.d(24): Error: declaration expected, not `<`\n/tmp/tmpjmamlj_1.d(31): Error: declaration expected, not `return`\n/tmp/tmpjmamlj_1.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjmamlj_1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float range = max - min;\n    float scale = 1.0f / range;\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    float range = max - min;\n    float scale = 1.0f / range;\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    \n    double range = max - min;\n    double scale = 1.0f / range;\n    \n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i] *= scale;\n    }\n    \n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfwcbbnsa.d(96): unittest failure\n----------------\n??:? _d_unittestp [0x4294c5]\n??:? void tmpfwcbbnsa.__unittest_L92_C1() [0x428d86]\n??:? void tmpfwcbbnsa.__modtest() [0x429244]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43171d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431bcc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c561]\n??:? runModuleUnitTests [0x42d4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429988]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n/*\n Given list of \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp85zo71k7.d(87): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp85zo71k7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm,linear-algebra |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns `[-0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkl327ps0.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpkl327ps0.d(24): Error: declaration expected, not `<`\n/tmp/tmpkl327ps0.d(27): Error: unterminated character constant\n/tmp/tmpkl327ps0.d(27): Error: unterminated string constant starting at /tmp/tmpkl327ps0.d(27)\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkl327ps0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa3q36i5i.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpa3q36i5i.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpa3q36i5i.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa3q36i5i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp80ze91gh.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x4290ad]\n??:? void tmp80ze91gh.__unittest_L24_C1() [0x42896e]\n??:? void tmp80ze91gh.__modtest() [0x428e2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c172]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431305]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4317b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431291]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c149]\n??:? runModuleUnitTests [0x42d0b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429570]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1,2,3,4,5,6,7,8,9,10])` returns `[1,2,3,4,5,6,7,8,9,10]`\n<|/ c |>\n<| c |>\nI tested it and it works. I used the code from your question. Maybe you missed something or you didn't copy it correctly. Try it again. Also note that I changed the name of the function from `rescale_to_unit` to `rescale_to_unit_floats`.\n<|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I even tried copying it again and still no luck. I'm going to try and figure out what I'm doing wrong.\n<|/ c |>\n<| c |>\nI tested it again and it works. I used the code from your question. Maybe you missed something or you didn't copy it correctly. Try it again. Also note that I changed the name of the function from `rescale_to_unit` to `rescale_to_unit_floats`.\n<|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I even tried copying it again and still no luck. I'm going to try and figure out what I'm doing wrong.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nfunction rescale_to_unit(numbers)\n{\n    var min = numbers[0];\n    var max = numbers[0];\n    for(var i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    var range = (max - min);\n    var scale = (float)(range / numbers.length);\n    for(var i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) * scale + min;\n    return numbers;\n}\n</code>\n<|/ a tags=arrays,math,c#,rescale |>\n<| c |>\nWhile this code may answer the question, providing additional context regarding how and/or why it solves the problem would improve the answer\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqb5w5gem.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmpqb5w5gem.d(25): Error: declaration expected, not `<`\n/tmp/tmpqb5w5gem.d(28): Error: unterminated character constant\n/tmp/tmpqb5w5gem.d(31): Error: unterminated character constant\n/tmp/tmpqb5w5gem.d(34): Error: unterminated character constant\n/tmp/tmpqb5w5gem.d(34): Error: unterminated character constant\n/tmp/tmpqb5w5gem.d(37): Error: unterminated character constant\n/tmp/tmpqb5w5gem.d(40): Error: unterminated character constant\n/tmp/tmpqb5w5gem.d(40): Error: unterminated character constant\n/tmp/tmpqb5w5gem.d(48): Error: declaration expected, not `for`\n/tmp/tmpqb5w5gem.d(48): Error: no identifier for declarator `i`\n/tmp/tmpqb5w5gem.d(48): Error: declaration expected, not `<`\n/tmp/tmpqb5w5gem.d(48): Error: no identifier for declarator `i`\n/tmp/tmpqb5w5gem.d(48): Error: declaration expected, not `++`\n/tmp/tmpqb5w5gem.d(52): Error: declaration expected, not `if`\n/tmp/tmpqb5w5gem.d(54): Error: unrecognized declara",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_5acjwi9.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42907d]\n??:? void tmp_5acjwi9.__unittest_L25_C1() [0x42893e]\n??:? void tmp_5acjwi9.__modtest() [0x428dfc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c142]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431784]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431261]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c119]\n??:? runModuleUnitTests [0x42d085]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429540]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) / scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max) \n{\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) / scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float min, float max, float scale) \n{\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) / scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float[] bounds) \n{\n    float min = bounds[0];\n    float max = bounds[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) / scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_with_bounds(float[] numbers, float[] bounds, float scale) \n{\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) / scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnqxca75f.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpnqxca75f.d(31): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpnqxca75f.d(63): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpnqxca75f.d(79): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnqxca75f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = 1.0f / range;\n    float[] result = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,unity3d,math,algorithm |>\n<| c |>\nThanks for your answer! I understand your solution, but I need a solution that doesn't require me to import any libraries. I edited my question to reflect this.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution that doesn't require any libraries.\n<|/ c |>\n<| c |>\nThanks for your answer! I understand your solution, but I need a solution that doesn't require me to import any libraries. I edited my question to reflect this.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution that doesn't require any libraries.\n<|/ c |>\n<| c |>\nThanks for your answer! I understand your solution, but I need a solution that doesn't require me to import any libraries. I edited my question to reflect this.\n<|/ c |>\n<| a dscore=1 |>\nI believe that your problem can be solved using linear interpolation. \n<code>\nfloat minVal = float.MaxValue;\nfloat maxVal = float.MinValue;\nfloat range = maxVal - minVal;\nfloat scale = (float)(1 / range);\n</code>\nThen you can apply the scale to the numbers:\n<code>\nfloat newVal = (numbers[i] + minVal) * scale;\n</code>\n<|/ a tags=c#,unity3d,math,algorithm |>\n<| c |>\nThanks for your answer! I understand your solution, but I need a solution that doesn't require me to import any libraries. I edited my question to reflect this.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution that doesn't require any libraries.\n<|/ c |>\n<| a |>\nI believe that your problem can be solved using linear interpolation. \n<code>\nfloat minVal = float.MaxValue;\nfloat maxVal = float.MinValue;\nfloat range = maxVal - minVal;\nfloat scale = (float)(1 / range);\n</code>\nThen you can apply the scale to the numbers:\n<code>\nfloat newVal = (numbers[i] + minVal) * scale;\n</code>\n\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk4xa7962.d(19): Error: declaration expected, not `<`\n/tmp/tmpk4xa7962.d(22): Error: unterminated character constant\n/tmp/tmpk4xa7962.d(25): Error: unterminated character constant\n/tmp/tmpk4xa7962.d(28): Error: unterminated character constant\n/tmp/tmpk4xa7962.d(31): Error: unterminated character constant\n/tmp/tmpk4xa7962.d(34): Error: unterminated character constant\n/tmp/tmpk4xa7962.d(42): Error: C style cast illegal, use `cast(float)(1 / range)`\n/tmp/tmpk4xa7962.d(43): Error: declaration expected, not `<`\n/tmp/tmpk4xa7962.d(47): Error: declaration expected, not `<`\n/tmp/tmpk4xa7962.d(50): Error: unterminated character constant\n/tmp/tmpk4xa7962.d(53): Error: unterminated character constant\n/tmp/tmpk4xa7962.d(61): Error: C style cast illegal, use `cast(float)(1 / range)`\n/tmp/tmpk4xa7962.d(62): Error: declaration expected, not `<`\n/tmp/tmpk4xa7962.d(66): Error: declaration expected, not `<`\n/tmp/tmpk4xa7962.d(72): Error: declaration expected, not `assert`\n/tmp/tmpk4xa7962.d(73): Error: declaration expec",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float[] result = new float[numbers.Length];\n    for (int i = 0; i < numbers.Length; i++)\n    {\n        result[i] = numbers[i] / max - min;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work. Try it with `numbers = new float[] { 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100 };`\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated my answer to take that into account.\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated my answer to take that into account.\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated my answer to take that into account.\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated my answer to take that into account.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static float[] rescale(float[] numbers)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float[] result = new float[numbers.Length];\n    for (int i = 0; i < numbers.Length; i++)\n    {\n        result[i] = numbers[i] / max - min;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. Try it with `numbers = new float[] { 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100 };`\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated my answer to take that into account.\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale(float[] numbers)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach (float n in numbers)\n    {\n        if (n < min)\n            min = n;\n        if (n > max)\n            max = n;\n    }\n    float[] result = new float[numbers.Length];\n    for (int i = 0; i < numbers.Length; i++)\n\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_sd4458h.d(12): Error: found `in` when expecting `;`\n/tmp/tmp_sd4458h.d(26): Error: declaration expected, not `<`\n/tmp/tmp_sd4458h.d(29): Error: unterminated character constant\n/tmp/tmp_sd4458h.d(32): Error: unterminated character constant\n/tmp/tmp_sd4458h.d(35): Error: unterminated character constant\n/tmp/tmp_sd4458h.d(38): Error: unterminated character constant\n/tmp/tmp_sd4458h.d(41): Error: unterminated character constant\n/tmp/tmp_sd4458h.d(49): Error: declaration expected, not `foreach`\n/tmp/tmp_sd4458h.d(53): Error: declaration expected, not `if`\n/tmp/tmp_sd4458h.d(55): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_sd4458h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprgudvl8o.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x429505]\n??:? void tmprgudvl8o.__unittest_L71_C1() [0x428dca]\n??:? void tmprgudvl8o.__modtest() [0x429288]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43175d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c5a1]\n??:? runModuleUnitTests [0x42d50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    foreach(float n in numbers)\n    {\n        if(n < min)\n            min = n;\n        if(n > max)\n            max = n;\n    }\n    float scale = (max - min) / (float.MaxValue - float.MinValue);\n    foreach(float n in numbers)\n        n -= min;\n    foreach(float n in numbers)\n        n *= scale;\n    foreach(float n in numbers)\n        n += min;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't seem to work. Try it with the input `[1,2,3]`. The output should be `[0,0,1]`, but your function returns `[0,0,0]`.\n<|/ c |>\n<| c |>\nI tested it and it works. I used the code from your question and added the rescale_to_unit function I wrote. Maybe you missed something in the code?\n<|/ c |>\n<| c |>\nI added the rescale_to_unit function I wrote. Maybe you missed something in the code?\n<|/ c |>\n<| c |>\nI added the rescale_to_unit function I wrote. Maybe you missed something in the code?\n<|/ c |>\n<| c |>\nI added the rescale_to_unit function I wrote. Maybe you missed something in the code?\n<|/ c |>\n<| a dscore=1 |>\nI wrote a C# program that does this for you:\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwij3kvdy.d(12): Error: found `in` when expecting `;`\n/tmp/tmpwij3kvdy.d(20): Error: found `in` when expecting `;`\n/tmp/tmpwij3kvdy.d(22): Error: found `in` when expecting `;`\n/tmp/tmpwij3kvdy.d(24): Error: found `in` when expecting `;`\n/tmp/tmpwij3kvdy.d(28): Error: declaration expected, not `<`\n/tmp/tmpwij3kvdy.d(31): Error: unterminated character constant\n/tmp/tmpwij3kvdy.d(49): Error: semicolon expected, not `.`\n/tmp/tmpwij3kvdy.d(49): Error: no identifier for declarator `.Collections.Generic`\n/tmp/tmpwij3kvdy.d(50): Error: semicolon expected, not `.`\n/tmp/tmpwij3kvdy.d(50): Error: no identifier for declarator `.Linq`\n/tmp/tmpwij3kvdy.d(51): Error: semicolon expected, not `.`\n/tmp/tmpwij3kvdy.d(51): Error: no identifier for declarator `.Text`\n/tmp/tmpwij3kvdy.d(52): Error: semicolon expected, not `.`\n/tmp/tmpwij3kvdy.d(52): Error: no identifier for declarator `.Threading.Tasks`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwij3kvdy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplgut0gzx.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplgut0gzx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprl943kab.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42906d]\n??:? void tmprl943kab.__unittest_L24_C1() [0x428932]\n??:? void tmprl943kab.__modtest() [0x428df0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d29f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c132]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431774]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431251]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c109]\n??:? runModuleUnitTests [0x42d075]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429530]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpki79zba1.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpki79zba1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a 2D point (x,y), return its distance from the origin\n*/\nfloat distance_from_origin(float x, float y)\n{\n    return sqrt(x*x + y*y);\n}\n/*\n Given a 2D point (x,y), return its distance from the origin\n*/\nfloat distance_from_origin(Vector2 p)\n{\n    return sqrt(p.x*p.x + p.y*p.y);\n}\n/*\n Given a 2D point (x,y), return its distance from the origin\n*/\nfloat distance_from_origin(Vector2 p, Vector2 q)\n{\n    return sqrt(p.x*p.x + p.y*p.y + q.x*q.x + q.y*q.y);\n}\n/*\n Given a 2D point (x,y), return its distance from the origin\n*/\nfloat distance_from_origin(Vector2 p, Vector2 q, Vector2 r)\n{\n    return sqrt(p.x*p.x + p.y*p.y + q.x*q.x + q.y*q.y + r.x*r.x + r.y*r.y);\n}\n/*\n Given a 2D point (x,y), return its distance from the origin\n*/\nfloat distance_from_origin(Vector2 p, Vector2 q, Vector2 r, Vector2 s)\n{\n    return sqrt(p.x*p.x + p.y*p.y + q.x*q.x + q.y*q.y + r.x*r.x + r.y*r.y + s.x*s.x + s.y*s.y);\n}\n/*\n Given a 2D point (x,y), return its distance from the origin\n*/\nfloat distance_from_origin(Vector2 p, Vector2 q, Vector2 r, Vector2 s, Vector2 t)\n{\n    return sqrt(p.x*p.x + p.y*p.y + q.x*q.x + q.y*q.y + r.x*r.x + r.y*r.y + s.x*s.x + s.y*s.y + t.x*t.x + t.y*t.y);\n}\n/*\n Given a 2D point (x,y), return its distance from the origin\n*/\nfloat distance_from_origin(Vector2 p, Vector2 q, Vector2 r, Vector2 s, Vector2 t, Vector2 u)\n{\n    return sqrt(p.x*p.x + p.y*p.y + q.x*q.x + q.y*q.y + r.x*r.x + r.y*r.y + s.x*s.x + s.y*s.y + t.\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpatwhmrpe.d(72): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpatwhmrpe.d(73): Error: found `{` when expecting `,`\n/tmp/tmpatwhmrpe.d(74): Error: expression expected, not `alias`\n/tmp/tmpatwhmrpe.d(74): Error: found `candidate` when expecting `,`\n/tmp/tmpatwhmrpe.d(74): Error: expression expected, not `=`\n/tmp/tmpatwhmrpe.d(74): Error: found `rescale_to_unit` when expecting `,`\n/tmp/tmpatwhmrpe.d(74): Error: expression expected, not `;`\n/tmp/tmpatwhmrpe.d(76): Error: found `assert` when expecting `,`\n/tmp/tmpatwhmrpe.d(76): Error: found `;` when expecting `,`\n/tmp/tmpatwhmrpe.d(77): Error: found `;` when expecting `,`\n/tmp/tmpatwhmrpe.d(78): Error: found `;` when expecting `,`\n/tmp/tmpatwhmrpe.d(79): Error: found `;` when expecting `,`\n/tmp/tmpatwhmrpe.d(80): Error: found `;` when expecting `,`\n/tmp/tmpatwhmrpe.d(81): Error: expression expected, not `}`\n/tmp/tmpatwhmrpe.d(82): Error: found `void` when expecting `,`\n/tmp/tmpatwhmrpe.d(82): Error: found `{` when expecting `,`\n/tmp/tmpa",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphcvzqeay.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmphcvzqeay.__unittest_L24_C1() [0x42895a]\n??:? void tmphcvzqeay.__modtest() [0x428e18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d2c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c15a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4312ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43179c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431279]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c131]\n??:? runModuleUnitTests [0x42d09d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = (numbers[i] - min) * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = (double)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = (numbers[i] - min) * scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplwausu9g.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\n/tmp/tmplwausu9g.d(42): Error: C style cast illegal, use `cast(double)(range / numbers.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplwausu9g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,linear-algebra |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns a list of `float[]` but the `min` and `max` values are `float` instead of `float[]`.\n<|/ c |>\n<| c |>\nI fixed the problem you mentioned, but I didn't test it extensively. I think it should work now.\n<|/ c |>\n<| c |>\nThis doesn't seem to work either. `rescale_to_unit` returns a list of `float[]` but the `min` and `max` values are `float` instead of `float[]`.\n<|/ c |>\n<| c |>\nI fixed the problem you mentioned, but I didn't test it extensively. I think it should work now.\n<|/ c |>\n<| c |>\nThis doesn't seem to work either. `rescale_to_unit` returns a list of `float[]` but the `min` and `max` values are `float` instead of `float[]`.\n<|/ c |>\n<| a dscore=2 |>\nThis should work:\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,linear-algebra |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit` returns a list of `float[]` but the `min` and `max` values are `float` instead of `float[]`.\n<|/ c |>\n<| c |>\nI fixed the problem you mentioned, but I didn't test it extensively. I think it should work now.\n<|/ c |>\n<| c |>\nThis doesn't seem to work either. `rescale_to_unit` returns a list of `\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4dh1lro7.d(24): Error: declaration expected, not `<`\n/tmp/tmp4dh1lro7.d(27): Error: unterminated character constant\n/tmp/tmp4dh1lro7.d(30): Error: unterminated character constant\n/tmp/tmp4dh1lro7.d(33): Error: unterminated character constant\n/tmp/tmp4dh1lro7.d(36): Error: unterminated character constant\n/tmp/tmp4dh1lro7.d(39): Error: unterminated character constant\n/tmp/tmp4dh1lro7.d(48): Error: declaration expected, not `for`\n/tmp/tmp4dh1lro7.d(48): Error: no identifier for declarator `i`\n/tmp/tmp4dh1lro7.d(48): Error: declaration expected, not `<`\n/tmp/tmp4dh1lro7.d(48): Error: declaration expected, not `++`\n/tmp/tmp4dh1lro7.d(52): Error: declaration expected, not `if`\n/tmp/tmp4dh1lro7.d(54): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4dh1lro7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c++,algorithm,math |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI tested it and it works. I used the example you gave. Are you sure you used the correct code?\n<|/ c |>\n<| c |>\nI used the exact same code as yours. I used `-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5` as the input. `rescale_to_unit` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI tested it again and it works. I used the example you gave. Are you sure you used the correct code?\n<|/ c |>\n<| c |>\nI used the exact same code as yours. I used `-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5` as the input. `rescale_to_unit` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| a tags=c++,algorithm,math |>\nI believe this can be done in O(n) time complexity by simply iterating through the array and setting the min and max values as you go. \n<code>\nfloat min = numbers[0];\nfloat max = numbers[0];\nfor(int i = 1; i < numbers.length; ++i)\n{\n    if(numbers[i] < min)\n        min = numbers[i];\n    if(numbers[i] > max)\n        max = numbers[i];\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI tested it and it works. I used the example you gave. Are you sure you used the correct code?\n<|/ c |>\n<| c |>\nI used the exact same code \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3_m6gp21.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmp3_m6gp21.d(24): Error: declaration expected, not `<`\n/tmp/tmp3_m6gp21.d(27): Error: unterminated character constant\n/tmp/tmp3_m6gp21.d(46): Error: declaration expected, not `for`\n/tmp/tmp3_m6gp21.d(46): Error: no identifier for declarator `i`\n/tmp/tmp3_m6gp21.d(46): Error: declaration expected, not `<`\n/tmp/tmp3_m6gp21.d(46): Error: declaration expected, not `++`\n/tmp/tmp3_m6gp21.d(50): Error: declaration expected, not `if`\n/tmp/tmp3_m6gp21.d(52): Error: unrecognized declaration\n/tmp/tmp3_m6gp21.d(56): Error: unterminated character constant\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3_m6gp21.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpki79zba1.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpki79zba1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)range / 2.0f;\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = min(numbers);\n    float max = max(numbers);\n    float range = max - min;\n    float scale = (float)range / 2.0f;\n    float rescaled = new float[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = min(numbers);\n    double max = max(numbers);\n    double range = max - min;\n    double scale = (double)range / 2.0f;\n    double rescaled = new double[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = min(numbers);\n    double max = max(numbers);\n    double range = max - min;\n    double scale = (double)range / 2.0f;\n    double rescaled = new double[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        rescaled[i] = numbers[i] * scale;\n    }\n    return rescaled;\n}\n/*\n Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoi2v6ipw.d(13): Error: C style cast illegal, use `cast(float)range`\n/tmp/tmpoi2v6ipw.d(31): Error: C style cast illegal, use `cast(float)range`\n/tmp/tmpoi2v6ipw.d(49): Error: C style cast illegal, use `cast(double)range`\n/tmp/tmpoi2v6ipw.d(67): Error: C style cast illegal, use `cast(double)range`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoi2v6ipw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] - min;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm6nh11xi.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x429115]\n??:? void tmpm6nh11xi.__unittest_L26_C1() [0x4289da]\n??:? void tmpm6nh11xi.__modtest() [0x428e98]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d347]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c1da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43136d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43181c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4312f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c1b1]\n??:? runModuleUnitTests [0x42d11d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8y6u1gtx.d(20): Error: C style cast illegal, use `cast(float)(range / numbers.length)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8y6u1gtx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp37vvctj_.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp37vvctj_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164397
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_float(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_double_float(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double scale = (max - min) / (double)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    \nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuqswdbdt.d(19): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpuqswdbdt.d(40): Error: C style cast illegal, use `cast(float)(numbers.length - 1)`\n/tmp/tmpuqswdbdt.d(61): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\n/tmp/tmpuqswdbdt.d(82): Error: C style cast illegal, use `cast(double)(numbers.length - 1)`\n/tmp/tmpuqswdbdt.d(87): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuqswdbdt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164398
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit_floats(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\ndouble[] rescale_to_unit_doubles(double[] numbers) \n{\n    double min = numbers[0];\n    double max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    double range = max - min;\n    double scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdhx8wy_4.d(78): unittest failure\n----------------\n??:? _d_unittestp [0x4294fd]\n??:? void tmpdhx8wy_4.__unittest_L74_C1() [0x428dbe]\n??:? void tmpdhx8wy_4.__modtest() [0x42927c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d72f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c5c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431755]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431c04]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4316e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c599]\n??:? runModuleUnitTests [0x42d505]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4299c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164399
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n        \n*/\nfloat[] rescale_to_unit(float[] numbers) \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to the number\n*/\nfloat rescale_range(float number, float range)\n{\n    float factor = range / number;\n    return number * factor;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to the number\n*/\ndouble rescale_range(double number, double range)\n{\n    double factor = range / number;\n    return number * factor;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to the number\n*/\nlong rescale_range(long number, long range)\n{\n    long factor = range / number;\n    return number * factor;\n}\n/*\n Given a number and a range, return a number in the range that is the closest to the number\n*/\nunittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0, 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp53nib04c.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4291bd]\n??:? void tmp53nib04c.__unittest_L52_C1() [0x428a82]\n??:? void tmp53nib04c.__modtest() [0x428f40]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d3ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c282]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431415]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4318c4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4313a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c259]\n??:? runModuleUnitTests [0x42d1c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429680]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164399
    }
  ]
}