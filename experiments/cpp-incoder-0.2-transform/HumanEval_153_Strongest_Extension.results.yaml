language: cpp
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions){\n        cap += ext.length();\n        sm += ext.length()-1;\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions){\n   \
    \     if(ext.length() == cap){\n            strongest_extension += class_name\
    \ + \".\" + ext;\n        }\n        else if(ext.length() == sm){\n          \
    \  strongest_extension += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n\
    \        }\n        else if(ext.length() > cap && ext.length() > sm){\n      \
    \      strongest_extension += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n\
    \        }\n        else if(ext.length() < cap && ext.length() < sm){\n      \
    \      strongest_extension += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n\
    \        }\n        else if(ext.length() == cap && ext.length() < sm){\n     \
    \       strongest_extension += class_name + \".\" + ext;\n        }\n        else\
    \ if(ext.length() == sm && ext.length() > cap){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() == sm && ext.length() < cap){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() > cap && ext.length() == sm){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() < cap && ext.length() == sm){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() == cap && ext.length() > sm){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() == sm && ext.length() == cap){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() > cap && ext.length() == sm){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() < cap && ext.length() == sm){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() == sm && ext.length() > cap){\n            strongest_extension\
    \ += class_name + ext.substr(0,1) + \".\" + ext.substr(1);\n        }\n      \
    \  else if(ext.length() == sm \n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcijqupd_.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpcijqupd_.cpp:24:15: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for(auto\
    \ &ext : extensions){\n               ^\n/tmp/tmpcijqupd_.cpp:24:21: error: range-based\
    \ 'for' loops are not allowed in C++98 mode\n     for(auto &ext : extensions){\n\
    \                     ^\n/tmp/tmpcijqupd_.cpp:25:20: error: request for member\
    \ 'length' in 'ext', which is of non-class type 'int'\n         cap += ext.length();\n\
    \                    ^\n/tmp/tmpcijqupd_.cpp:26:19: error: request for member\
    \ 'length' in 'ext', which is of non-class type 'int'\n         sm += ext.length()-1;\n\
    \                   ^\n/tmp/tmpcijqupd_.cpp:29:15: error: ISO C++ forbids declaration\
    \ of 'ext' with no type [-fpermissive]\n     for(auto &ext : extensions){\n  \
    \             ^\n/tmp/tmpcijqupd_.cpp:29:21: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for(auto &ext : extensions){\n             \
    \        ^\n/tmp/tmpcijqupd_.cpp:30:16: error: request for member 'length' in\
    \ 'ext', which is of non-class type 'int'\n         if(ext.length() == cap){\n\
    \                ^\n/tmp/tmpcijqupd_.cpp:31:53: error: no match for 'operator+'\
    \ (operand types are 'std::basic_string<char>' and 'int')\n             strongest_extension\
    \ += class_name + \".\" + ext;\n                                             \
    \        ^\n/tmp/tmpcijqupd_.cpp:31:53: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmpcijqupd_.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__plus, _Tp>::result_type>\
    \ std::operator+(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(+,\
    \ __plus)\n ^\n/usr/include/c++/4.8.2/valarray:1167:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpcijqupd_.cpp:31:55: note:   mismatched\
    \ types 'cons"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &extension : extensions) {\n        cap += (extension.at(0) - 'A');\n      \
    \  sm += (extension.at(1) - 'a');\n    }\n    \n    double strength = cap - sm;\n\
    \    \n    for(auto &extension : extensions) {\n        if(strength == (extension.at(0)\
    \ - 'A') - (extension.at(1) - 'a')) {\n            strongest_extension = class_name\
    \ + \".\" + extension;\n            break;\n        }\n    }\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7b40c208.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp7b40c208.cpp:25:15: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for(auto &extension : extensions) {\n               ^\n/tmp/tmp7b40c208.cpp:25:27:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for(auto\
    \ &extension : extensions) {\n                           ^\n/tmp/tmp7b40c208.cpp:26:27:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         cap += (extension.at(0) - 'A');\n                           ^\n/tmp/tmp7b40c208.cpp:27:26:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         sm += (extension.at(1) - 'a');\n                          ^\n/tmp/tmp7b40c208.cpp:32:15:\
    \ error: ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n\
    \     for(auto &extension : extensions) {\n               ^\n/tmp/tmp7b40c208.cpp:32:27:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for(auto\
    \ &extension : extensions) {\n                           ^\n/tmp/tmp7b40c208.cpp:33:35:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         if(strength == (extension.at(0) - 'A') - (extension.at(1) - 'a')) {\n\
    \                                   ^\n/tmp/tmp7b40c208.cpp:33:61: error: request\
    \ for member 'at' in 'extension', which is of non-class type 'int'\n         if(strength\
    \ == (extension.at(0) - 'A') - (extension.at(1) - 'a')) {\n                  \
    \                                           ^\n/tmp/tmp7b40c208.cpp:34:52: error:\
    \ no match for 'operator+' (operand types are 'std::basic_string<char>' and 'int')\n\
    \             strongest_extension = class_name + \".\" + extension;\n        \
    \                                            ^\n/tmp/tmp7b40c208.cpp:34:52: note:\
    \ candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp7b40c208.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for (auto &extension :\
    \ extensions) {\n        auto cap = extension.find_first_of('A');\n        auto\
    \ sm = extension.find_first_of('l');\n        auto strength = cap - sm;\n    \
    \    if (strength > 0) {\n            strongest_extension += class_name + \".\"\
    \ + extension;\n        }\n    }\n    \n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7gfoxw6z.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp7gfoxw6z.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmp7gfoxw6z.cpp:24:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmp7gfoxw6z.cpp:25:14:\
    \ error: 'cap' does not name a type\n         auto cap = extension.find_first_of('A');\n\
    \              ^\n/tmp/tmp7gfoxw6z.cpp:26:14: error: 'sm' does not name a type\n\
    \         auto sm = extension.find_first_of('l');\n              ^\n/tmp/tmp7gfoxw6z.cpp:27:14:\
    \ error: 'strength' does not name a type\n         auto strength = cap - sm;\n\
    \              ^\n/tmp/tmp7gfoxw6z.cpp:28:13: error: 'strength' was not declared\
    \ in this scope\n         if (strength > 0) {\n             ^\n/tmp/tmp7gfoxw6z.cpp:29:53:\
    \ error: no match for 'operator+' (operand types are 'std::basic_string<char>'\
    \ and 'int')\n             strongest_extension += class_name + \".\" + extension;\n\
    \                                                     ^\n/tmp/tmp7gfoxw6z.cpp:29:53:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp7gfoxw6z.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__plus, _Tp>::result_type>\
    \ std::operator+(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(+,\
    \ __plus)\n ^\n/usr/include/c++/4.8.2/valarray:1167:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp7gfoxw6z.cpp:29:55: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'int'\n             strongest_extension\
    \ += class_name + \".\" + extension;\n                                       \
    \                ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \  "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (auto ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    \n    float strength = cap - sm;\n    \n    for (auto ext : extensions)\
    \ {\n        if (ext.length() == strength) {\n            strongest_extension\
    \ = class_name + \".\" + ext;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpervi4n5f.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpervi4n5f.cpp:26:15: error:\
    \ 'ext' does not name a type\n     for (auto ext : extensions) {\n           \
    \    ^\n/tmp/tmpervi4n5f.cpp:31:5: error: expected ';' before 'float'\n     float\
    \ strength = cap - sm;\n     ^\n/tmp/tmpervi4n5f.cpp:33:5: error: expected primary-expression\
    \ before 'for'\n     for (auto ext : extensions) {\n     ^\n/tmp/tmpervi4n5f.cpp:33:5:\
    \ error: expected ')' before 'for'\n/tmp/tmpervi4n5f.cpp:33:15: error: 'ext' does\
    \ not name a type\n     for (auto ext : extensions) {\n               ^\n/tmp/tmpervi4n5f.cpp:39:5:\
    \ error: expected ';' before 'return'\n     return strongest_extension;\n    \
    \ ^\n/tmp/tmpervi4n5f.cpp:39:5: error: expected primary-expression before 'return'\n\
    /tmp/tmpervi4n5f.cpp:39:5: error: expected ';' before 'return'\n/tmp/tmpervi4n5f.cpp:39:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpervi4n5f.cpp:39:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpervi4n5f.cpp: In function 'int\
    \ main()':\n/tmp/tmpervi4n5f.cpp:42:10: error: 'candidate' does not name a type\n\
    \     auto candidate = Strongest_Extension;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpervi4n5f.cpp:2:\n/tmp/tmpervi4n5f.cpp:43:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpervi4n5f.cpp:43:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        std::string extension = extensions[i];\n        \n        int\
    \ cap = extension.find_first_of('A');\n        int sm = extension.find_first_of('l');\n\
    \        \n        int strength = cap - sm;\n        \n        if(strength > 0)\
    \ {\n            strongest_extension += class_name + \".\" + extension;\n    \
    \    }\n    }\n    \n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj2c0hosp.cpp: In function 'int main()':\n/tmp/tmpj2c0hosp.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj2c0hosp.cpp:2:\n/tmp/tmpj2c0hosp.cpp:41:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpj2c0hosp.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpj2c0hosp.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpj2c0hosp.cpp:41:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpj2c0hosp.cpp:41:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpj2c0hosp.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap - sm;\n    if (cap > 0) {\n        strongest_extension =\
    \ class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() < strongest_extension.length()) {\n            strongest_extension\
    \ = class_name + \".\" + ext;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiwymzl5_.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpiwymzl5_.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmpiwymzl5_.cpp:24:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmpiwymzl5_.cpp:25:20: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap\
    \ += ext.length();\n                    ^\n/tmp/tmpiwymzl5_.cpp:26:19: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      sm += ext.length();\n                   ^\n/tmp/tmpiwymzl5_.cpp:32:16:\
    \ error: ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n  \
    \   for (auto &ext : extensions) {\n                ^\n/tmp/tmpiwymzl5_.cpp:32:22:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &ext : extensions) {\n                      ^\n/tmp/tmpiwymzl5_.cpp:33:17: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      if (ext.length() < strongest_extension.length()) {\n                 ^\n\
    /tmp/tmpiwymzl5_.cpp:34:52: error: no match for 'operator+' (operand types are\
    \ 'std::basic_string<char>' and 'int')\n             strongest_extension = class_name\
    \ + \".\" + ext;\n                                                    ^\n/tmp/tmpiwymzl5_.cpp:34:52:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpiwymzl5_.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__plus, _Tp>::result_type>\
    \ std::operator+(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(+,\
    \ __plus)\n ^\n/usr/include/c++/4.8.2/valarray:1167:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpiwymzl5_.cpp:34"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += (extension.at(0) - 'A');\n      \
    \  sm += (extension.at(1) - 'a');\n    }\n    float strength = cap - sm;\n   \
    \ if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    for (auto &extension : extensions) {\n        if (strength > 0) {\n\
    \            if (extension.at(0) - 'A' > strongest_extension.at(0) - 'A') {\n\
    \                strongest_extension = class_name + \".\" + extension;\n     \
    \       }\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2_xj4m7m.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp2_xj4m7m.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmp2_xj4m7m.cpp:24:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmp2_xj4m7m.cpp:25:27:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         cap += (extension.at(0) - 'A');\n                           ^\n/tmp/tmp2_xj4m7m.cpp:26:26:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         sm += (extension.at(1) - 'a');\n                          ^\n/tmp/tmp2_xj4m7m.cpp:32:16:\
    \ error: ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n\
    \     for (auto &extension : extensions) {\n                ^\n/tmp/tmp2_xj4m7m.cpp:32:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmp2_xj4m7m.cpp:34:27:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \             if (extension.at(0) - 'A' > strongest_extension.at(0) - 'A') {\n\
    \                           ^\n/tmp/tmp2_xj4m7m.cpp:35:56: error: no match for\
    \ 'operator+' (operand types are 'std::basic_string<char>' and 'int')\n      \
    \           strongest_extension = class_name + \".\" + extension;\n          \
    \                                              ^\n/tmp/tmp2_xj4m7m.cpp:35:56:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp2_xj4m7m.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__plus, _Tp>::result_type>\
    \ std::operator+(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(+,\
    \ _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgg2d51fk.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpgg2d51fk.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmpgg2d51fk.cpp:24:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmpgg2d51fk.cpp:25:20: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap\
    \ += ext.length();\n                    ^\n/tmp/tmpgg2d51fk.cpp:26:19: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      sm += ext.length();\n                   ^\n/tmp/tmpgg2d51fk.cpp: In function\
    \ 'int main()':\n/tmp/tmpgg2d51fk.cpp:40:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = Strongest_Extension;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgg2d51fk.cpp:2:\n/tmp/tmpgg2d51fk.cpp:41:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpgg2d51fk.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpgg2d51fk.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgg2d51fk.cpp:41:128: error: no matc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string extension_strength;\n    int cap_counter = 0;\n    int sm_counter\
    \ = 0;\n    \n    for (auto extension : extensions) {\n        cap_counter++;\n\
    \        auto cap = extension.substr(0, 1);\n        sm_counter++;\n        auto\
    \ sm = extension.substr(1, 1);\n        \n        if (cap == sm) {\n         \
    \   extension_strength += extension;\n        }\n    }\n    \n    if (cap_counter\
    \ > sm_counter) {\n        extension_strength += class_name;\n    }\n    \n  \
    \  return extension_strength;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp39ws9t1q.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp39ws9t1q.cpp:26:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmp39ws9t1q.cpp:37:5: error: expected ';' before 'if'\n\
    \     if (cap_counter > sm_counter) {\n     ^\n/tmp/tmp39ws9t1q.cpp:37:5: error:\
    \ expected primary-expression before 'if'\n/tmp/tmp39ws9t1q.cpp:37:5: error: expected\
    \ ';' before 'if'\n/tmp/tmp39ws9t1q.cpp:37:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmp39ws9t1q.cpp:37:5: error: expected ')' before 'if'\n/tmp/tmp39ws9t1q.cpp:\
    \ In function 'int main()':\n/tmp/tmp39ws9t1q.cpp:44:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = Strongest_Extension;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp39ws9t1q.cpp:2:\n/tmp/tmp39ws9t1q.cpp:45:60: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmp39ws9t1q.cpp:45:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmp39ws9t1q.cpp:45:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp39ws9t1q.cpp:45:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp39ws9"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - ext.length();\n    }\n    \n    float strength = cap - sm;\n    \n    for(auto\
    \ &ext : extensions) {\n        if(ext.length() == strongest_extension.length())\
    \ {\n            if(strength > ext.length() - ext.length()) {\n              \
    \  strongest_extension = ext;\n            }\n        }\n    }\n    \n    return\
    \ class_name + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpug9h2uwe.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpug9h2uwe.cpp:25:15: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for(auto\
    \ &ext : extensions) {\n               ^\n/tmp/tmpug9h2uwe.cpp:25:21: error: range-based\
    \ 'for' loops are not allowed in C++98 mode\n     for(auto &ext : extensions)\
    \ {\n                     ^\n/tmp/tmpug9h2uwe.cpp:26:20: error: request for member\
    \ 'length' in 'ext', which is of non-class type 'int'\n         cap += ext.length();\n\
    \                    ^\n/tmp/tmpug9h2uwe.cpp:27:19: error: request for member\
    \ 'length' in 'ext', which is of non-class type 'int'\n         sm += ext.length()\
    \ - ext.length();\n                   ^\n/tmp/tmpug9h2uwe.cpp:27:34: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         sm\
    \ += ext.length() - ext.length();\n                                  ^\n/tmp/tmpug9h2uwe.cpp:32:15:\
    \ error: ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n  \
    \   for(auto &ext : extensions) {\n               ^\n/tmp/tmpug9h2uwe.cpp:32:21:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for(auto\
    \ &ext : extensions) {\n                     ^\n/tmp/tmpug9h2uwe.cpp:33:16: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      if(ext.length() == strongest_extension.length()) {\n                ^\n\
    /tmp/tmpug9h2uwe.cpp:34:31: error: request for member 'length' in 'ext', which\
    \ is of non-class type 'int'\n             if(strength > ext.length() - ext.length())\
    \ {\n                               ^\n/tmp/tmpug9h2uwe.cpp:34:46: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n           \
    \  if(strength > ext.length() - ext.length()) {\n                            \
    \                  ^\n/tmp/tmpug9h2uwe.cpp: In function 'int main()':\n/tmp/tmpug9h2uwe.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/casse"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    \n    for (auto extension : extensions) {\n        cap_counter += extension.at(0)\
    \ - 'A';\n        sm_counter += extension.at(1) - 'a';\n    }\n    \n    if (cap_counter\
    \ > sm_counter) {\n        strongest_extension = class_name + extensions[0];\n\
    \    } else {\n        strongest_extension = class_name + extensions[1];\n   \
    \ }\n    \n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjxg7aces.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpjxg7aces.cpp:26:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpjxg7aces.cpp:31:5: error: expected ';' before 'if'\n\
    \     if (cap_counter > sm_counter) {\n     ^\n/tmp/tmpjxg7aces.cpp:31:5: error:\
    \ expected primary-expression before 'if'\n/tmp/tmpjxg7aces.cpp:31:5: error: expected\
    \ ';' before 'if'\n/tmp/tmpjxg7aces.cpp:31:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpjxg7aces.cpp:31:5: error: expected ')' before 'if'\n/tmp/tmpjxg7aces.cpp:\
    \ In function 'int main()':\n/tmp/tmpjxg7aces.cpp:40:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = Strongest_Extension;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpjxg7aces.cpp:2:\n/tmp/tmpjxg7aces.cpp:41:60: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpjxg7aces.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpjxg7aces.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpjxg7aces.cpp:41:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpjxg7a"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n  \
    \  }\n    double strength = cap_num - sm_num;\n    double max_strength = -1;\n\
    \    for (auto &ext : extensions) {\n        double ext_strength = ext.length()\
    \ - ext.find_first_not_of(ext.begin(), ext.end());\n        if (ext_strength >\
    \ max_strength) {\n            max_strength = ext_strength;\n        }\n    }\n\
    \    if (max_strength == -1) {\n        return class_name;\n    }\n    double\
    \ strength_diff = strength - max_strength;\n    double max_strength_diff = -1;\n\
    \    for (auto &ext : extensions) {\n        double ext_strength = ext.length()\
    \ - ext.find_first_not_of(ext.begin(), ext.end());\n        if (ext_strength >\
    \ max_strength) {\n            max_strength = ext_strength;\n        }\n     \
    \   double ext_diff = ext_strength - max_strength;\n        if (ext_diff > max_strength_diff)\
    \ {\n            max_strength_diff = ext_diff;\n        }\n    }\n    if (max_strength_diff\
    \ == -1) {\n        return class_name;\n    }\n    double strength_diff = strength\
    \ - max_strength;\n    double max_strength_diff = -1;\n    for (auto &ext : extensions)\
    \ {\n        double ext_strength = ext.length() - ext.find_first_not_of(ext.begin(),\
    \ ext.end());\n        if (ext_strength > max_strength) {\n            max_strength\
    \ = ext_strength;\n        }\n        double ext_diff = ext_strength - max_strength;\n\
    \        if (ext_diff > max_strength_diff) {\n            max_strength_diff =\
    \ ext_diff;\n        }\n    }\n    if (max_strength_diff == -1) {\n        return\
    \ class_name;\n    }\n    double strength_diff = strength - max_strength;\n  \
    \  double max_strength_diff = -1;\n    for (auto &ext : extensions) {\n      \
    \  double ext_strength = ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n\
    \        if (ext_strength > max_strength) {\n            max_strength = ext_strength;\n\
    \        }\n        double ext_diff = ext_strength - max_strength;\n        if\
    \ (ext_diff > max_strength_diff) {\n            max_strength_diff = ext_diff;\n\
    \        }\n    }\n    if (max_strength_diff == -1) {\n        return class_name;\n\
    \    }\n    double strength_diff = strength - max_strength;\n    double max_strength_diff\
    \ = -1;\n    for (auto &ext : extensions) {\n        double ext_strength = ext.length()\
    \ - ext.find_first_not_of(ext.begin(), ext.end());\n        if (ext_strength >\
    \ max_strength) {\n            max_\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7rfrpeaj.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp7rfrpeaj.cpp:21:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmp7rfrpeaj.cpp:21:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmp7rfrpeaj.cpp:22:24: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap_num\
    \ += ext.length();\n                        ^\n/tmp/tmp7rfrpeaj.cpp:23:23: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n\
    \                       ^\n/tmp/tmp7rfrpeaj.cpp:23:38: error: request for member\
    \ 'find_first_not_of' in 'ext', which is of non-class type 'int'\n         sm_num\
    \ += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n         \
    \                             ^\n/tmp/tmp7rfrpeaj.cpp:23:60: error: request for\
    \ member 'begin' in 'ext', which is of non-class type 'int'\n         sm_num +=\
    \ ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n            \
    \                                                ^\n/tmp/tmp7rfrpeaj.cpp:23:73:\
    \ error: request for member 'end' in 'ext', which is of non-class type 'int'\n\
    \         sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n\
    \                                                                         ^\n\
    /tmp/tmp7rfrpeaj.cpp:27:16: error: ISO C++ forbids declaration of 'ext' with no\
    \ type [-fpermissive]\n     for (auto &ext : extensions) {\n                ^\n\
    /tmp/tmp7rfrpeaj.cpp:27:22: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &ext : extensions) {\n                      ^\n/tmp/tmp7rfrpeaj.cpp:28:35:\
    \ error: request for member 'length' in 'ext', which is of non-class type 'int'\n\
    \         double ext_strength = ext.length() - ext.find_first_not_of(ext.begin(),\
    \ ext.end());"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_extensions = 0, sm_extensions\
    \ = 0;\n    for (auto ext : extensions) {\n        if (ext.at(0) == ext.at(1).toupper())\
    \ {\n            cap_extensions++;\n        } else {\n            sm_extensions++;\n\
    \        }\n    }\n    double strength = cap_extensions - sm_extensions;\n   \
    \ if (strength > 0) {\n        return class_name + \".\" + extensions[extensions.size()\
    \ - 1].substr(0, extensions[extensions.size() - 1].find_first_of(\"0123456789\"\
    )) + \".\" + extensions[extensions.size() - 1].substr(extensions[extensions.size()\
    \ - 1].find_first_of(\"0123456789\") + 1);\n    }\n    return class_name + \"\
    .\" + extensions[extensions.size() - 1];\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpamd7nms4.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpamd7nms4.cpp:21:15: error:\
    \ 'ext' does not name a type\n     for (auto ext : extensions) {\n           \
    \    ^\n/tmp/tmpamd7nms4.cpp:28:5: error: expected ';' before 'double'\n     double\
    \ strength = cap_extensions - sm_extensions;\n     ^\n/tmp/tmpamd7nms4.cpp:29:5:\
    \ error: expected primary-expression before 'if'\n     if (strength > 0) {\n \
    \    ^\n/tmp/tmpamd7nms4.cpp:29:5: error: expected ')' before 'if'\n/tmp/tmpamd7nms4.cpp:\
    \ In function 'int main()':\n/tmp/tmpamd7nms4.cpp:35:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = Strongest_Extension;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpamd7nms4.cpp:2:\n/tmp/tmpamd7nms4.cpp:36:60: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpamd7nms4.cpp:36:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpamd7nms4.cpp:36:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpamd7nms4.cpp:36:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpamd7nms4.cpp:36:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:6"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_letters = 0, sm_letters\
    \ = 0;\n    for (auto &ext : extensions) {\n        cap_letters += ext.length();\n\
    \        sm_letters += ext.length();\n    }\n    int strength = cap_letters -\
    \ sm_letters;\n    for (auto &ext : extensions) {\n        if (ext.length() ==\
    \ strength) {\n            return class_name + \".\" + ext;\n        }\n    }\n\
    \    return class_name;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5ng4snx7.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp5ng4snx7.cpp:21:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmp5ng4snx7.cpp:21:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmp5ng4snx7.cpp:22:28: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap_letters\
    \ += ext.length();\n                            ^\n/tmp/tmp5ng4snx7.cpp:23:27:\
    \ error: request for member 'length' in 'ext', which is of non-class type 'int'\n\
    \         sm_letters += ext.length();\n                           ^\n/tmp/tmp5ng4snx7.cpp:26:16:\
    \ error: ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n  \
    \   for (auto &ext : extensions) {\n                ^\n/tmp/tmp5ng4snx7.cpp:26:22:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &ext : extensions) {\n                      ^\n/tmp/tmp5ng4snx7.cpp:27:17: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      if (ext.length() == strength) {\n                 ^\n/tmp/tmp5ng4snx7.cpp:28:37:\
    \ error: no match for 'operator+' (operand types are 'std::basic_string<char>'\
    \ and 'int')\n             return class_name + \".\" + ext;\n                \
    \                     ^\n/tmp/tmp5ng4snx7.cpp:28:37: note: candidates are:\nIn\
    \ file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp5ng4snx7.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__plus, _Tp>::result_type>\
    \ std::operator+(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(+,\
    \ __plus)\n ^\n/usr/include/c++/4.8.2/valarray:1167:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp5ng4snx7.cpp:28:39: note:   mism"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        if (ext.size() >= cap_num && ext.size()\
    \ <= sm_num) {\n            cap_num = ext.size();\n            sm_num = ext.size();\n\
    \        }\n        else if (ext.size() > sm_num) {\n            sm_num = ext.size();\n\
    \        }\n    }\n    double cap_frac = cap_num - sm_num;\n    double sm_frac\
    \ = cap_num - sm_num;\n    if (cap_frac > sm_frac) {\n        cap_frac = sm_frac;\n\
    \    }\n    std::string strongest_ext;\n    if (cap_frac > 0.5) {\n        strongest_ext\
    \ = class_name + \".\" + extensions[0];\n    }\n    else if (cap_frac > 0.25)\
    \ {\n        strongest_ext = class_name + \".\" + extensions[1];\n    }\n    else\
    \ if (cap_frac > 0.10) {\n        strongest_ext = class_name + \".\" + extensions[2];\n\
    \    }\n    else {\n        strongest_ext = class_name + \".\" + extensions[3];\n\
    \    }\n    return strongest_ext;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppuslsqct.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmppuslsqct.cpp:21:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmppuslsqct.cpp:21:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmppuslsqct.cpp:22:17: error: request\
    \ for member 'size' in 'ext', which is of non-class type 'int'\n         if (ext.size()\
    \ >= cap_num && ext.size() <= sm_num) {\n                 ^\n/tmp/tmppuslsqct.cpp:22:42:\
    \ error: request for member 'size' in 'ext', which is of non-class type 'int'\n\
    \         if (ext.size() >= cap_num && ext.size() <= sm_num) {\n             \
    \                             ^\n/tmp/tmppuslsqct.cpp:23:27: error: request for\
    \ member 'size' in 'ext', which is of non-class type 'int'\n             cap_num\
    \ = ext.size();\n                           ^\n/tmp/tmppuslsqct.cpp:24:26: error:\
    \ request for member 'size' in 'ext', which is of non-class type 'int'\n     \
    \        sm_num = ext.size();\n                          ^\n/tmp/tmppuslsqct.cpp:26:22:\
    \ error: request for member 'size' in 'ext', which is of non-class type 'int'\n\
    \         else if (ext.size() > sm_num) {\n                      ^\n/tmp/tmppuslsqct.cpp:27:26:\
    \ error: request for member 'size' in 'ext', which is of non-class type 'int'\n\
    \             sm_num = ext.size();\n                          ^\n/tmp/tmppuslsqct.cpp:\
    \ In function 'int main()':\n/tmp/tmppuslsqct.cpp:51:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = Strongest_Extension;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmppuslsqct.cpp:2:\n/tmp/tmppuslsqct.cpp:52:60: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_extension = 0;\n    int sml_extension\
    \ = 0;\n    for (auto extension : extensions) {\n        cap_extension = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {return std::toupper(c) == c; });\n        sml_extension\
    \ = std::count_if(extension.begin(), extension.end(), [](char c) {return std::tolower(c)\
    \ == c; });\n        if (cap_extension - sml_extension > 0) {\n            strongest_extension\
    \ = class_name + \".\" + extension;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb7qp13v4.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpb7qp13v4.cpp:24:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpb7qp13v4.cpp:31:5: error: expected ';' before 'return'\n\
    \     return strongest_extension;\n     ^\n/tmp/tmpb7qp13v4.cpp:31:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpb7qp13v4.cpp:31:5: error: expected\
    \ ';' before 'return'\n/tmp/tmpb7qp13v4.cpp:31:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpb7qp13v4.cpp:31:5: error: expected ')' before 'return'\n\
    /tmp/tmpb7qp13v4.cpp: In function 'int main()':\n/tmp/tmpb7qp13v4.cpp:34:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb7qp13v4.cpp:2:\n/tmp/tmpb7qp13v4.cpp:35:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpb7qp13v4.cpp:35:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpb7qp13v4.cpp:35:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpb7qp13v4.cpp:35:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (auto &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    \n    int strength = cap - sm;\n    \n    if (strength > 0) {\n  \
    \      for (auto &ext : extensions) {\n            if (ext.length() == strength)\
    \ {\n                strongest_extension = class_name + ext;\n               \
    \ break;\n            }\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6ffxqsxu.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp6ffxqsxu.cpp:26:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmp6ffxqsxu.cpp:26:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmp6ffxqsxu.cpp:27:20: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap\
    \ += ext.length();\n                    ^\n/tmp/tmp6ffxqsxu.cpp:28:19: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      sm += ext.length();\n                   ^\n/tmp/tmp6ffxqsxu.cpp:34:20:\
    \ error: ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n  \
    \       for (auto &ext : extensions) {\n                    ^\n/tmp/tmp6ffxqsxu.cpp:34:26:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &ext : extensions) {\n                          ^\n/tmp/tmp6ffxqsxu.cpp:35:21:\
    \ error: request for member 'length' in 'ext', which is of non-class type 'int'\n\
    \             if (ext.length() == strength) {\n                     ^\n/tmp/tmp6ffxqsxu.cpp:36:50:\
    \ error: no match for 'operator+' (operand types are 'std::string {aka std::basic_string<char>}'\
    \ and 'int')\n                 strongest_extension = class_name + ext;\n     \
    \                                             ^\n/tmp/tmp6ffxqsxu.cpp:36:50: note:\
    \ candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp6ffxqsxu.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__plus, _Tp>::result_type>\
    \ std::operator+(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(+,\
    \ __plus)\n ^\n/usr/include/c++/4.8.2/valarray:1167:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for(auto extension : extensions) {\n        if(extension.at(0) == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if(extension.at(1) == class_name[1])\
    \ {\n            sm_counter++;\n        }\n    }\n    float strength = cap_counter\
    \ - sm_counter;\n    if(strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else if(strength < 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[extensions.size()-1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc5rf6v38.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpc5rf6v38.cpp:24:14: error:\
    \ 'extension' does not name a type\n     for(auto extension : extensions) {\n\
    \              ^\n/tmp/tmpc5rf6v38.cpp:32:5: error: expected ';' before 'float'\n\
    \     float strength = cap_counter - sm_counter;\n     ^\n/tmp/tmpc5rf6v38.cpp:33:5:\
    \ error: expected primary-expression before 'if'\n     if(strength > 0) {\n  \
    \   ^\n/tmp/tmpc5rf6v38.cpp:33:5: error: expected ')' before 'if'\n/tmp/tmpc5rf6v38.cpp:\
    \ In function 'int main()':\n/tmp/tmpc5rf6v38.cpp:42:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = Strongest_Extension;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpc5rf6v38.cpp:2:\n/tmp/tmpc5rf6v38.cpp:43:60: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpc5rf6v38.cpp:43:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpc5rf6v38.cpp:43:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpc5rf6v38.cpp:43:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpc5rf6v38.cpp:43:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    \n    for (auto ext : extensions) {\n        cap += ext.length();\n     \
    \   sm += ext.length();\n    }\n    \n    float strength = cap - sm;\n    \n \
    \   for (auto ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() < strongest_extension.length()) {\n        \
    \        strongest_extension = ext;\n            }\n        }\n    }\n    \n \
    \   return class_name + \".\" + strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa23mcgu_.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpa23mcgu_.cpp:26:15: error:\
    \ 'ext' does not name a type\n     for (auto ext : extensions) {\n           \
    \    ^\n/tmp/tmpa23mcgu_.cpp:31:5: error: expected ';' before 'float'\n     float\
    \ strength = cap - sm;\n     ^\n/tmp/tmpa23mcgu_.cpp:33:5: error: expected primary-expression\
    \ before 'for'\n     for (auto ext : extensions) {\n     ^\n/tmp/tmpa23mcgu_.cpp:33:5:\
    \ error: expected ')' before 'for'\n/tmp/tmpa23mcgu_.cpp:33:15: error: 'ext' does\
    \ not name a type\n     for (auto ext : extensions) {\n               ^\n/tmp/tmpa23mcgu_.cpp:41:5:\
    \ error: expected ';' before 'return'\n     return class_name + \".\" + strongest_extension;\n\
    \     ^\n/tmp/tmpa23mcgu_.cpp:41:5: error: expected primary-expression before\
    \ 'return'\n/tmp/tmpa23mcgu_.cpp:41:5: error: expected ';' before 'return'\n/tmp/tmpa23mcgu_.cpp:41:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpa23mcgu_.cpp:41:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpa23mcgu_.cpp: In function 'int\
    \ main()':\n/tmp/tmpa23mcgu_.cpp:44:10: error: 'candidate' does not name a type\n\
    \     auto candidate = Strongest_Extension;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa23mcgu_.cpp:2:\n/tmp/tmpa23mcgu_.cpp:45:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpa23mcgu_.cpp:45:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n             "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        cap = cap + toupper(extensions[i][0])\
    \ - toupper(extensions[i][0]);\n        sm = sm + tolower(extensions[i][0]) -\
    \ tolower(extensions[i][0]);\n    }\n    float strength = cap - sm;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        if (strength == cap - toupper(extensions[i][0])\
    \ - toupper(extensions[i][0])) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n            break;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0jvr3d4c.cpp: In function 'int main()':\n/tmp/tmp0jvr3d4c.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0jvr3d4c.cpp:2:\n/tmp/tmp0jvr3d4c.cpp:39:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmp0jvr3d4c.cpp:39:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmp0jvr3d4c.cpp:39:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0jvr3d4c.cpp:39:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp0jvr3d4c.cpp:39:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp0jvr3d4c.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(std::string(\" \"));\n    }\n\
    \    float strength = cap_num - sm_num;\n    std::string result = class_name +\
    \ \".\";\n    for (auto &ext : extensions) {\n        result += ext;\n       \
    \ if (ext.length() > strength) {\n            result += ext.substr(0, ext.length()\
    \ - strength);\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8w8lhrvg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    int cap_counter = 0;\n\
    \    int sm_counter = 0;\n    \n    for(auto &extension : extensions){\n     \
    \   if(extension.at(0) == class_name[0]){\n            cap_counter++;\n      \
    \  }\n        if(extension.at(1) == class_name[1]){\n            sm_counter++;\n\
    \        }\n    }\n    \n    float strength = cap_counter - sm_counter;\n    \n\
    \    if(strength > 0){\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    else if(strength == 0){\n        strongest_extension = class_name;\n\
    \    }\n    else if(strength < 0){\n        strongest_extension = class_name +\
    \ \".\" + extensions[extensions.size()-1];\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptw7i7i4x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sml_counter =\
    \ 0;\n    for(auto &extension : extensions){\n        if(std::toupper(extension[0])\
    \ == class_name[0]){\n            cap_counter++;\n        }\n        else if(std::tolower(extension[0])\
    \ == class_name[0]){\n            sml_counter++;\n        }\n    }\n    float\
    \ strength = cap_counter - sml_counter;\n    if(strength > 0){\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    else if(strength < 0){\n \
    \       strongest_extension = class_name + \".\" + extensions[extensions.size()-1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyd7s8jer.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    int cap = 0;\n    int sm = 0;\n   \
    \ \n    for (auto ext : extensions) {\n        cap += ext.length();\n        sm\
    \ += ext.length();\n    }\n    \n    if (cap - sm > 0)\n        strongest_extension\
    \ = class_name + extensions[0];\n    else\n        strongest_extension = class_name\
    \ + extensions[extensions.size()-1];\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_5twqfwr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for(auto extension\
    \ : extensions) {\n        if(extension.at(0) == class_name[0]) {\n          \
    \  cap_counter++;\n        }\n        if(extension.at(1) == class_name[0]) {\n\
    \            sm_counter++;\n        }\n    }\n    if(cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxzli06et.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &ext : extensions)\
    \ {\n        auto cap = ext.substr(0, CAP);\n        auto sm = ext.substr(CAP,\
    \ SM);\n        if (cap == class_name) {\n            cap_counter++;\n       \
    \ }\n        if (sm == class_name) {\n            sm_counter++;\n        }\n \
    \   }\n    if (cap_counter == sm_counter) {\n        extension_strength = class_name;\n\
    \    }\n    else {\n        extension_strength = class_name + \".\" + extensions[sm_counter].substr(CAP\
    \ - sm_counter, CAP - cap_counter);\n    }\n    return extension_strength;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0lzxw48d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    \n    for (auto extension : extensions) {\n\
    \        int cap = extension.find_first_of('A');\n        int sm = extension.find_first_of('z');\n\
    \        int strength = cap - sm;\n        if (strength > 0) {\n            strongest_extension\
    \ += class_name + \".\" + extension;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp36lue1ce.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int strongest_strength = -1;\n   \
    \ for (auto &ext : extensions) {\n        if (ext.length() > strongest_strength)\
    \ {\n            strongest_strength = ext.length();\n            strongest_extension\
    \ = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqy32oj2w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sm_counter = 0;\n  \
    \  for (auto ext : extensions) {\n        if (ext.at(0) == class_name.at(0)) {\n\
    \            cap_counter++;\n        }\n        if (ext.at(1) == class_name.at(0))\
    \ {\n            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6kexy21q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    double strength = cap_num - sm_num;\n\
    \    double max_strength = -1;\n    for (auto &ext : extensions) {\n        double\
    \ cur_strength = ext.length() - 1;\n        if (cur_strength > max_strength) {\n\
    \            max_strength = cur_strength;\n        }\n    }\n    if (max_strength\
    \ == -1) {\n        return class_name;\n    }\n    std::string res = class_name\
    \ + \".\";\n    for (auto &ext : extensions) {\n        double cur_strength =\
    \ ext.length() - 1;\n        if (cur_strength == max_strength) {\n           \
    \ res += ext;\n        } else {\n            res += ext.substr(0, cur_strength);\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1blw8j0_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sml_counter =\
    \ 0;\n    for(auto &extension : extensions) {\n        if(std::toupper(extension[0])\
    \ == class_name[0]) {\n            cap_counter++;\n        }\n        if(std::tolower(extension[0])\
    \ == class_name[0]) {\n            sml_counter++;\n        }\n    }\n    float\
    \ strength = cap_counter - sml_counter;\n    if(strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    else if(strength < 0) {\n\
    \        strongest_extension = class_name + \".\" + extensions[extensions.size()-1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6y5ik2cu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        if (extension.at(0) == class_name[0]) {\n\
    \            cap++;\n        }\n        if (extension.at(1) == class_name[1])\
    \ {\n            sm++;\n        }\n    }\n    float strength = cap - sm;\n   \
    \ if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    if (strength > 1) {\n        strongest_extension = class_name + \"\
    .\" + extensions[1];\n    }\n    if (strength > 2) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[2];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_y5cc_i2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        cap += e.size();\n        sm += e.size();\n    }\n\
    \    float strength = cap - sm;\n    for (auto e : extensions) {\n        if (e.size()\
    \ == strength) {\n            strongest_extension = class_name + e;\n        \
    \    break;\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpde5m4wse.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_extension = 0;\n    int sml_extension\
    \ = 0;\n    for (auto &ext : extensions) {\n        cap_extension += ext.length();\n\
    \        sml_extension += ext.length();\n    }\n    cap_extension = cap_extension\
    \ / 2;\n    sml_extension = sml_extension / 2;\n    if (cap_extension > sml_extension)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\
    \ else {\n        strongest_extension = class_name + \".\" + extensions[extensions.size()\
    \ - 1];\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcilghy3f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ \n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd7mxjvap.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ extension_strength = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n\
    \    for (auto extension : extensions) {\n        if (extension.at(0) == class_name.at(0))\
    \ {\n            cap_counter++;\n        }\n        if (extension.at(1) == class_name.at(0))\
    \ {\n            sm_counter++;\n        }\n    }\n    extension_strength = class_name\
    \ + \".\" + extensions[cap_counter - sm_counter];\n    return extension_strength;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkhgf1o2u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strength) {\n            strongest_extension\
    \ = class_name + \".\" + ext;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpns3frr48.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ result;\n    std::string extension;\n    std::string extension_str;\n    int\
    \ extension_strength;\n    int extension_cap;\n    int extension_sm = 0;\n   \
    \ int extension_strength_sum = 0;\n    int extension_cap_sum = 0;\n    int extension_sm_sum\
    \ = 0;\n    int extension_strength_max = 0;\n    int extension_cap_max = 0;\n\
    \    int extension_sm_max = 0;\n    int extension_strength_min = 0;\n    int extension_cap_min\
    \ = 0;\n    int extension_sm_min = 0;\n    int extension_strength_avg = 0;\n \
    \   int extension_cap_avg = 0;\n    int extension_sm_avg = 0;\n    int extension_strength_sum2\
    \ = 0;\n    int extension_cap_sum2 = 0;\n    int extension_sm_sum2 = 0;\n    int\
    \ extension_strength_max2 = 0;\n    int extension_cap_max2 = 0;\n    int extension_sm_max2\
    \ = 0;\n    int extension_strength_min2 = 0;\n    int extension_cap_min2 = 0;\n\
    \    int extension_sm_min2 = 0;\n    int extension_strength_avg2 = 0;\n    int\
    \ extension_cap_avg2 = 0;\n    int extension_sm_avg2 = 0;\n    int extension_strength_sum3\
    \ = 0;\n    int extension_cap_sum3 = 0;\n    int extension_sm_sum3 = 0;\n    int\
    \ extension_strength_max3 = 0;\n    int extension_cap_max3 = 0;\n    int extension_sm_max3\
    \ = 0;\n    int extension_strength_min3 = 0;\n    int extension_cap_min3 = 0;\n\
    \    int extension_sm_min3 = 0;\n    int extension_strength_avg3 = 0;\n    int\
    \ extension_cap_avg3 = 0;\n    int extension_sm_avg3 = 0;\n    int extension_strength_sum4\
    \ = 0;\n    int extension_cap_sum4 = 0;\n    int extension_sm_sum4 = 0;\n    int\
    \ extension_strength_max4 = 0;\n    int extension_cap_max4 = 0;\n    int extension_sm_max4\
    \ = 0;\n    int extension_strength_min4 = 0;\n    int extension_cap_min4 = 0;\n\
    \    int extension_sm_min4 = 0;\n    int extension_strength_avg4 = 0;\n    int\
    \ extension_cap_avg4 = 0;\n    int extension_sm_avg4 = 0;\n    int extension_strength_sum5\
    \ = 0;\n    int extension_cap_sum5 = 0;\n    int extension_sm_sum5 = 0;\n    int\
    \ extension_strength_max5 = 0;\n    int extension_cap_max5 = 0;\n    int extension_sm_max5\
    \ = 0;\n    int extension_strength_min5 = 0;\n    int extension_cap_min5 = 0;\n\
    \    int extension_sm_min5 = 0;\n    int extension_strength_avg5 = 0;\n    int\
    \ extension_cap_avg5 = 0;\n    int extension_sm_avg5 = 0;\n    int extension_strength_sum6\
    \ = 0;\n    int extension_cap_sum6 = 0;\n    int extension_sm_sum6 = 0;\n    int\
    \ extension_strength_max6 = 0;\n    int extension\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyp9gk0fi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length();\n    }\n    float strength = cap_num - sm_num;\n   \
    \ int max_strength = -1;\n    for (auto &ext : extensions) {\n        float ext_strength\
    \ = ext.length();\n        if (ext_strength > max_strength) {\n            max_strength\
    \ = ext_strength;\n        }\n    }\n    if (max_strength == -1) {\n        return\
    \ class_name;\n    }\n    std::string strongest_ext;\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == max_strength) {\n            strongest_ext =\
    \ class_name + \".\" + ext;\n            break;\n        }\n    }\n    return\
    \ strongest_ext;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgpf88l9m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ extension_strength = class_name;\n    for(auto &extension : extensions) {\n\
    \        auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        extension_strength += extension.substr(cap, cap - sm);\n    }\n    std::sort(extensions.begin(),\
    \ extensions.end(), [](const std::string &a, const std::string &b){\n        return\
    \ a.size() < b.size();\n    });\n    extension_strength += \".\";\n    for(auto\
    \ &extension : extensions) {\n        auto cap = extension.find_first_of('A');\n\
    \        auto sm = extension.find_first_of('l');\n        extension_strength +=\
    \ extension.substr(cap, cap - sm);\n    }\n    return extension_strength;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwqmw34nu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap - sm;\n    if (cap > 0) {\n        auto it = std::min_element(extensions.begin(),\
    \ extensions.end(), \n            [cap](std::string &a, std::string &b) { return\
    \ cap - a.length() < b.length(); });\n        strongest_extension = class_name\
    \ + \".\" + extensions[it->length()];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0bipzgya.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_extensions = 0, sm_extensions\
    \ = 0;\n    for (auto &ext : extensions) {\n        cap_extensions += ext.find_first_not_of('A')\
    \ - ext.find_first_of('A');\n        sm_extensions += ext.find_first_not_of('a')\
    \ - ext.find_first_of('a');\n    }\n    int strength = cap_extensions - sm_extensions;\n\
    \    if (strength == 0) return class_name;\n    int max_strength = std::max(strength,\
    \ 0);\n    for (auto &ext : extensions) {\n        if (ext.find_first_not_of('A')\
    \ - ext.find_first_of('A') == max_strength) {\n            return class_name +\
    \ \".\" + ext;\n        }\n    }\n    return class_name;\n}\nint main() {\n  \
    \  auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyh9vq153.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension :\
    \ extensions) {\n        auto cap = extension.substr(0, CAP);\n        auto sm\
    \ = extension.substr(CAP, SM);\n        if (cap == class_name) {\n           \
    \ cap_counter++;\n        }\n        if (sm == class_name) {\n            sm_counter++;\n\
    \        }\n    }\n    if (cap_counter > sm_counter) {\n        extension_strength\
    \ = class_name + \".\" + extensions[0];\n    }\n    else {\n        extension_strength\
    \ = class_name + \".\" + extensions[sm_counter];\n    }\n    return extension_strength;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpeshgr9u8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799186
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [&](std::string a, std::string\
    \ b) { return a.length() < b.length(); }));\n    if (strength > 0) {\n       \
    \ strongest_extension = class_name + \".\" + extensions[index];\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf7o7r7pa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_num = 0, sm_num = 0;\n    for (auto &ext :\
    \ extensions) {\n        cap_num += ext.length();\n        sm_num += ext.length();\n\
    \    }\n    double strength = cap_num - sm_num;\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == cap_num - sm_num) {\n            strongest_extension\
    \ = class_name + \".\" + ext;\n            break;\n        }\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiddn680m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ i : extensions) {\n        cap += i[0]-'A';\n        sm += i[1]-'a';\n    }\n\
    \    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto i : extensions)\
    \ {\n        if (i[0] == i[1]) {\n            continue;\n        }\n        if\
    \ (i[0] < i[1]) {\n            strongest_extension = class_name + \".\" + extensions[0];\n\
    \            break;\n        }\n        if (i[0] > i[1]) {\n            strongest_extension\
    \ = class_name + \".\" + extensions[1];\n            break;\n        }\n    }\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcskidj0x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    \n    for (auto &ext : extensions) {\n        cap += ext.length();\n    \
    \    sm += ext.length();\n    }\n    \n    int strength = cap - sm;\n    \n  \
    \  if (strength == 0) {\n        return class_name;\n    }\n    \n    for (auto\
    \ &ext : extensions) {\n        if (ext.length() == strength) {\n            strongest_extension\
    \ = class_name + \".\" + ext;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3pwhqt_l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &extension : extensions){\n        cap += extension.at(0) - extension.at(1);\n\
    \        sm += extension.at(1) - extension.at(0);\n    }\n    \n    float strength\
    \ = cap - sm;\n    \n    for(auto &extension : extensions){\n        if(extension.at(0)\
    \ == class_name.at(0)){\n            if(strength > extension.at(1)){\n       \
    \         strongest_extension = class_name + \".\" + extension.at(1);\n      \
    \          break;\n            }\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprv1defho.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string extension_strength = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        \n        int cap = class_name.length();\n        int sm = extensions[i].length();\n\
    \        \n        float strength = (float)cap - sm;\n        \n        if(strength\
    \ > extension_strength) {\n            extension_strength = strength;\n      \
    \  }\n    }\n    \n    return class_name + extension_strength;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplh9zq8yg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &ext : extensions) {\n        cap_counter += ext.size();\n\
    \        sm_counter += ext.size();\n    }\n    float strength = cap_counter -\
    \ sm_counter;\n    if (strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions) {\n      \
    \  if (ext.size() == strongest_extension.size()) {\n            if (ext.size()\
    \ > strongest_extension.size()) {\n                strongest_extension = class_name\
    \ + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1jhr2_jf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension :\
    \ extensions) {\n        if (extension == class_name) {\n            extension_strength\
    \ = extension;\n            break;\n        }\n        if (extension.at(0) ==\
    \ class_name.at(0)) {\n            cap_counter++;\n        }\n        if (extension.at(1)\
    \ == class_name.at(1)) {\n            sm_counter++;\n        }\n    }\n    if\
    \ (cap_counter > sm_counter) {\n        extension_strength = class_name + \".\"\
    \ + extensions[0];\n    }\n    else {\n        extension_strength = class_name\
    \ + \".\" + extensions[1];\n    }\n    return extension_strength;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmdxemit7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    \n    // Your code goes here\n \
    \   \n    std::string strongest_extension = \"\";\n    int strongest_extension_strength\
    \ = 0;\n    \n    for (auto extension : extensions) {\n        int extension_strength\
    \ = std::count_if(extension.begin(), extension.end(), [](char c) {\n         \
    \   return std::toupper(c) - std::tolower(c) >= 0;\n        });\n        if (extension_strength\
    \ > strongest_extension_strength) {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7ja5znqd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension\
    \ : extensions) {\n        cap_counter += extension.at(0) - 'A';\n        sm_counter\
    \ += extension.at(1) - 'a';\n    }\n    if (cap_counter > sm_counter) {\n    \
    \    strongest_extension = class_name + extensions[0];\n    } else {\n       \
    \ strongest_extension = class_name + extensions[1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxy6rsq2w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8dii0je4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() > cap_counter) {\n            cap_counter = ext.length();\n\
    \        }\n        if (ext.length() < sm_counter) {\n            sm_counter =\
    \ ext.length();\n        }\n    }\n    double strength = cap_counter - sm_counter;\n\
    \    for (auto &ext : extensions) {\n        if (ext.length() == cap_counter)\
    \ {\n            if (ext.compare(class_name.substr(0, cap_counter)) == 0) {\n\
    \                extension_strength = class_name + \".\" + ext;\n            }\n\
    \        }\n    }\n    return extension_strength;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxoxh7yea.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = 0;\n    int sm = 0;\n\
    \    for (auto e : extensions) {\n        cap += e.size();\n        sm += e.size();\n\
    \    }\n    int strength = cap - sm;\n    std::string res = class_name;\n    for\
    \ (auto e : extensions) {\n        if (e.size() == strength) {\n            res\
    \ += e;\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzgdqmi0z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength =\
    \ \"\";\n    std::string extension_class = \"\";\n    std::string extension_class_name\
    \ = \"\";\n    std::string extension_class_name_with_extension = \"\";\n    std::string\
    \ extension_class_name_with_extension_strength = \"\";\n    std::string extension_class_name_with_extension_strength_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class_with_extension_strength_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_extension_class_with_extension\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp64g3bbs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    std::string extension_str;\n\
    \    for (auto &extension : extensions) {\n        extension_str = extension;\n\
    \        auto cap_counter = extension_str.size();\n        auto sm_counter = extension_str.size();\n\
    \        for (int i = 0; i < cap_counter; i++) {\n            if (extension_str[i]\
    \ >= 'A' && extension_str[i] <= 'Z') {\n                cap_counter--;\n     \
    \       }\n        }\n        for (int i = 0; i < sm_counter; i++) {\n       \
    \     if (extension_str[i] >= 'a' && extension_str[i] <= 'z') {\n            \
    \    sm_counter--;\n            }\n        }\n        if (cap_counter > sm_counter)\
    \ {\n            strongest_extension = class_name + extension_str;\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_q9zs7i3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for (auto ext : extensions) {\n  \
    \      if (ext.length() == strength) {\n            strongest_extension = class_name\
    \ + \".\" + ext;\n            break;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp31s7ueio.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ extension_strength;\n    int cap_num = 0, sm_num = 0;\n    for (auto ext : extensions)\
    \ {\n        if (ext.at(0) == class_name[0]) {\n            cap_num += ext.at(1).size();\n\
    \            sm_num += ext.at(1).size();\n        }\n    }\n    extension_strength\
    \ = class_name + \".\" + extensions[extensions.size() - 1];\n    if (cap_num -\
    \ sm_num > 0) {\n        extension_strength = class_name + \".\" + extensions[extensions.size()\
    \ - 2];\n    }\n    return extension_strength;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpaoxgxcel.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n  \
    \  }\n    double strength = cap_num - sm_num;\n    double max_strength = -1;\n\
    \    for (auto &ext : extensions) {\n        if (ext.length() > max_strength)\
    \ {\n            max_strength = ext.length();\n        }\n    }\n    for (auto\
    \ &ext : extensions) {\n        if (ext.length() == max_strength) {\n        \
    \    if (ext.find_first_not_of(ext.begin(), ext.end()) == ext.end()) {\n     \
    \           return class_name + \".\" + ext;\n            }\n        }\n    }\n\
    \    return class_name + \".\" + extensions[0];\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpejfb7l5c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    std::string extension_strength = \"\";\n    int cap_extension =\
    \ 0;\n    int sml_extension = 0;\n    \n    // Your code here\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpegbmcfji.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int index = 0;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.length() == strongest_extension.length()) {\n\
    \            if (strength > 0) {\n                index = extensions.find(ext);\n\
    \                strongest_extension = class_name + \".\" + ext;\n           \
    \     break;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv2n8n2eb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length();\n    }\n    double strength = cap_num - sm_num;\n  \
    \  int strongest_ext = 0;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ > strongest_ext) {\n            strongest_ext = ext.length();\n        }\n \
    \   }\n    return class_name + \".\" + extensions[strongest_ext];\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp61ijw5zr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension\
    \ : extensions) {\n        auto cap_counter = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {return std::toupper(c) == c;});\n        auto sm_counter\
    \ = std::count_if(extension.begin(), extension.end(), [](char c) {return std::tolower(c)\
    \ == c;});\n        if (cap_counter == 0 && sm_counter == 0) {\n            strongest_extension\
    \ = class_name + \".\" + extension;\n            break;\n        }\n        if\
    \ (cap_counter > sm_counter) {\n            strongest_extension = class_name +\
    \ \".\" + extension;\n            break;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmfya_sw5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap_counter = 0;\n    int\
    \ sml_counter = 0;\n    \n    for (auto &extension : extensions) {\n        cap_counter\
    \ += std::count(extension.begin(), extension.end(), std::toupper(extension[0]));\n\
    \        sml_counter += std::count(extension.begin(), extension.end(), std::tolower(extension[0]));\n\
    \    }\n    \n    if (cap_counter > sml_counter) {\n        strongest_extension\
    \ = class_name + extensions[0];\n    } else {\n        strongest_extension = class_name\
    \ + extensions[1];\n    }\n    \n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpim7jxwq6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sml_counter =\
    \ 0;\n    for(auto extension : extensions) {\n        if(extension.at(0) == class_name.at(0))\
    \ {\n            cap_counter++;\n        }\n        if(extension.at(1) == class_name.at(0))\
    \ {\n            sml_counter++;\n        }\n    }\n    double strength = cap_counter\
    \ - sml_counter;\n    if(strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else if(strength < 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[extensions.size()-1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpe2xgov1g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for (auto &ext : extensions) {\n \
    \       if (ext.length() == strongest_extension.length()) {\n            if (ext.compare(0,\
    \ strongest_extension.length(), strongest_extension) == 0) {\n               \
    \ strongest_extension = class_name + ext;\n            }\n        }\n    }\n \
    \   return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbhkdqf60.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension :\
    \ extensions) {\n        if (extension.at(0) == class_name[0]) {\n           \
    \ cap_counter++;\n        }\n        if (extension.at(1) == class_name[1]) {\n\
    \            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvgq3bx6d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [](std::string a, std::string\
    \ b) { return a.length() < b.length(); }));\n    strongest_extension = class_name\
    \ + extensions[index];\n    if (strength > 0) {\n        return strongest_extension;\n\
    \    }\n    return \"\";\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpeh0uh_p_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    \n    for(auto extension : extensions) {\n\
    \        int cap = extension.find_first_of('A');\n        int sm = extension.find_first_of('l');\n\
    \        int strength = cap - sm;\n        \n        if(strength > 0) {\n    \
    \        strongest_extension = class_name + \".\" + extension;\n            break;\n\
    \        }\n    }\n    \n    return strongest_extension;\n}\nint main() {\n  \
    \  auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_tch97v9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_extension = class_name.size();\n    int sm_extension\
    \ = class_name.size();\n    for (auto extension : extensions) {\n        cap_extension\
    \ = std::count_if(extension.begin(), extension.end(), [](char c) {\n         \
    \   return std::toupper(c) == c;\n        });\n        sm_extension = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::tolower(c) == c;\n  \
    \      });\n    }\n    double strength = cap_extension - sm_extension;\n    if\
    \ (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplxpc9np4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_letters = 0, sm_letters\
    \ = 0;\n    for (auto &ext : extensions) {\n        cap_letters += ext.length();\n\
    \        sm_letters += ext.length() - 1;\n    }\n    int strength = cap_letters\
    \ - sm_letters;\n    for (auto &ext : extensions) {\n        auto cap_letter =\
    \ ext.length();\n        auto sm_letter = ext.length() - 1;\n        if (cap_letter\
    \ > sm_letter) {\n            strength = cap_letter - sm_letter;\n        }\n\
    \    }\n    return class_name + \".\" + extensions[std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end()))];\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr9on4466.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += (extension.at(0) - 'A');\n      \
    \  sm += (extension.at(1) - 'a');\n    }\n    float strength = cap - sm;\n   \
    \ if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    for (auto &extension : extensions) {\n        if (strength == (extension.at(0)\
    \ - 'A') - (extension.at(1) - 'a')) {\n            strongest_extension = class_name\
    \ + \".\" + extension;\n        }\n    }\n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphcdr709v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    float strength = cap_num - sm_num;\n\
    \    std::string strongest_ext;\n    for (auto &ext : extensions) {\n        if\
    \ (ext.length() == cap_num) {\n            if (strength > 0) {\n             \
    \   strongest_ext = class_name + \".\" + ext;\n                break;\n      \
    \      }\n        }\n    }\n    return strongest_ext;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiw1pcaoa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += (extension.at(0) - 'A');\n      \
    \  sm += (extension.at(1) - 'a');\n    }\n    float strength = cap - sm;\n   \
    \ if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    if (extensions.size() > 1) {\n        int i = 0;\n        for (auto\
    \ &extension : extensions) {\n            if (i == 0) {\n                strongest_extension\
    \ = class_name + \".\" + extension;\n                break;\n            }\n \
    \           if (strength > 0) {\n                strongest_extension = class_name\
    \ + \".\" + extension;\n                break;\n            }\n            i++;\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7gk0ohjs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - cap;\n    }\n    float strength = cap - sm;\n    if (strength > 0) {\n   \
    \     strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (auto &ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() < strongest_extension.length()) {\n        \
    \        strongest_extension = class_name + \".\" + ext;\n            }\n    \
    \    }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn0d1mnoh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto ext : extensions)\
    \ {\n        if (ext.at(0) == class_name[0]) {\n            cap_counter++;\n \
    \       }\n        if (ext.at(1) == class_name[0]) {\n            sm_counter++;\n\
    \        }\n    }\n    if (cap_counter > sm_counter) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    } else {\n        strongest_extension\
    \ = class_name + \".\" + extensions[1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjx6k4yf_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    std::string extension_class;\n    std::string extension_extension;\n    std::string\
    \ extension_class_name;\n    std::string extension_extension_name;\n    int extension_strength_counter\
    \ = 0;\n    int extension_class_counter = 0;\n    int extension_extension_counter\
    \ = 0;\n    int extension_strength_counter_max = 0;\n    int extension_class_counter_max\
    \ = 0;\n    int extension_extension_counter_max = 0;\n    int extension_strength_counter_min\
    \ = 0;\n    int extension_class_counter_min = 0;\n    int extension_extension_counter_min\
    \ = 0;\n    int extension_strength_counter_sum = 0;\n    int extension_class_counter_sum\
    \ = 0;\n    int extension_extension_counter_sum = 0;\n    int extension_strength_counter_average\
    \ = 0;\n    int extension_class_counter_average = 0;\n    int extension_extension_counter_average\
    \ = 0;\n    int extension_strength_counter_max2 = 0;\n    int extension_class_counter_max2\
    \ = 0;\n    int extension_extension_counter_max2 = 0;\n    int extension_strength_counter_min2\
    \ = 0;\n    int extension_class_counter_min2 = 0;\n    int extension_extension_counter_min2\
    \ = 0;\n    int extension_strength_counter_sum2 = 0;\n    int extension_class_counter_sum2\
    \ = 0;\n    int extension_extension_counter_sum2 = 0;\n    int extension_strength_counter_average2\
    \ = 0;\n    int extension_class_counter_average2 = 0;\n    int extension_extension_counter_average2\
    \ = 0;\n    int extension_strength_counter_max3 = 0;\n    int extension_class_counter_max3\
    \ = 0;\n    int extension_extension_counter_max3 = 0;\n    int extension_strength_counter_min3\
    \ = 0;\n    int extension_class_counter_min3 = 0;\n    int extension_extension_counter_min3\
    \ = 0;\n    int extension_strength_counter_sum3 = 0;\n    int extension_class_counter_sum3\
    \ = 0;\n    int extension_extension_counter_sum3 = 0;\n    int extension_strength_counter_average3\
    \ = 0;\n    int extension_class_counter_average3 = 0;\n    int extension_extension_counter_average3\
    \ = 0;\n    int extension_strength_counter_max4 = 0;\n    int extension_class_counter_max4\
    \ = 0;\n    int extension_extension_counter_max4 = 0;\n    int extension_strength_counter_min4\
    \ = 0;\n    int extension_class_counter_min4 = 0;\n    int extension_extension_counter_min4\
    \ = 0;\n    int extension_strength_counter_sum4 = 0;\n    int extension_class_counter_sum4\
    \ = 0;\n    int extension_extension_counter_sum4 = 0;\n    int extension_strength_counter_average4\
    \ = 0;\n    int extension_class_counter_average4 = 0;\n    int extension_extension_counter_average4\
    \ = 0;\n    int extension_strength_counter_max5 = 0;\n    int extension_class_counter_max5\
    \ = 0;\n    int extension_extension_counter_max5 = 0;\n    int extension_strength_counter_min5\
    \ = 0;\n    int extension\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi98i4rvj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        cap += e.size();\n        sm += e.size();\n    }\n\
    \    cap = cap - sm;\n    cap = cap / extensions.size();\n    if (cap > 0) {\n\
    \        for (auto e : extensions) {\n            if (e.size() == cap) {\n   \
    \             strongest_extension = class_name + e;\n                break;\n\
    \            }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcvq8c058.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto ext : extensions)\
    \ {\n        cap += ext.length();\n        sm += ext.length();\n    }\n    cap\
    \ = cap / extensions.size();\n    sm = sm / extensions.size();\n    if (cap -\
    \ sm > 0) strongest_extension = class_name + \".\" + extensions[0];\n    else\
    \ if (sm - cap > 0) strongest_extension = class_name + \".\" + extensions[extensions.size()\
    \ - 1];\n    else strongest_extension = class_name + \".\" + extensions[0];\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph0frivqc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length();\n    }\n    int cap = cap_num / class_name.size();\n\
    \    int sm = sm_num / class_name.size();\n    if (cap > sm) {\n        return\
    \ class_name + \".\" + extensions[0];\n    }\n    return class_name + \".\" +\
    \ extensions[extensions.size() - 1];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzt6n5t7r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (auto &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    \n    if (cap - sm > 0)\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    else\n        strongest_extension = class_name;\n\
    \    \n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsk5tjjdi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        if(ext.at(0) == class_name.at(0)) {\n        \
    \    cap = cap + ext.at(1).size();\n            sm = sm + ext.at(1).size();\n\
    \        }\n    }\n    float strength = cap - sm;\n    if(strength > 0) {\n  \
    \      strongest_extension = class_name + \".\" + extensions[0];\n    }\n    else\
    \ if(strength < 0){\n        for(auto &ext : extensions) {\n            if(ext.at(0)\
    \ == class_name.at(0)) {\n                cap = cap - ext.at(1).size();\n    \
    \            sm = sm - ext.at(1).size();\n            }\n        }\n        strength\
    \ = cap - sm;\n        if(strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[0];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp92oqcg80.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string extension_strength;\n    \n    int cap_counter = 0;\n    int\
    \ sm_counter = 0;\n    \n    for (auto extension : extensions) {\n        if (extension.at(0)\
    \ == class_name[0]) {\n            cap_counter++;\n        }\n        if (extension.at(1)\
    \ == class_name[1]) {\n            sm_counter++;\n        }\n    }\n    \n   \
    \ float strength = cap_counter - sm_counter;\n    \n    if (strength > 0) {\n\
    \        extension_strength = class_name + \".\" + extensions[0];\n    }\n   \
    \ else if (strength < 0) {\n        extension_strength = class_name + \".\" +\
    \ extensions[extensions.size() - 1];\n    }\n    else {\n        extension_strength\
    \ = class_name;\n    }\n    \n    return extension_strength;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphrmhmzke.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(' ');\n    }\n    double strength\
    \ = cap_num - sm_num;\n    double max_strength = -1;\n    for (auto &ext : extensions)\
    \ {\n        double cur_strength = ext.length() - ext.find_first_not_of(' ');\n\
    \        if (cur_strength > max_strength) {\n            max_strength = cur_strength;\n\
    \        }\n    }\n    if (max_strength == -1) {\n        return class_name;\n\
    \    }\n    double max_strength_frac = max_strength / strength;\n    double max_strength_frac_pos\
    \ = max_strength_frac > 0.5 ? 1 : 0;\n    std::string class_name_with_max_strength\
    \ = class_name + \".\";\n    for (auto &ext : extensions) {\n        double cur_strength\
    \ = ext.length() - ext.find_first_not_of(' ');\n        if (cur_strength == max_strength)\
    \ {\n            class_name_with_max_strength += ext;\n        }\n    }\n    return\
    \ class_name_with_max_strength + extensions[max_strength_frac_pos];\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd_q8f0jr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength =\
    \ \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto extension\
    \ : extensions) {\n        if (extension.at(0) == class_name[0]) {\n         \
    \   cap_counter++;\n        }\n        if (extension.at(1) == class_name[1]) {\n\
    \            sm_counter++;\n        }\n    }\n    float strength = cap_counter\
    \ - sm_counter;\n    if (strength > 0) {\n        extension_strength = class_name\
    \ + \".\" + extensions[0];\n    }\n    if (extensions.size() > 1) {\n        for\
    \ (auto extension : extensions) {\n            if (extension_strength.compare(class_name\
    \ + \".\" + extension) == 0) {\n                extension_strength = class_name\
    \ + \".\" + extension;\n            }\n        }\n    }\n    return extension_strength;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwt4q0q1h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    double strength = -1;\n    for (auto &extension :\
    \ extensions) {\n        double extension_strength = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::toupper(c) - std::tolower(c)\
    \ == 0;\n        }) / extension.size();\n        if (extension_strength > strength)\
    \ {\n            strongest_extension = class_name + \".\" + extension;\n     \
    \       strength = extension_strength;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcpmaof_w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sml_counter = 0;\n    for(auto extension\
    \ : extensions) {\n        if(extension.at(0) == class_name[0]) {\n          \
    \  cap_counter++;\n        }\n        if(extension.at(1) == class_name[0]) {\n\
    \            sml_counter++;\n        }\n    }\n    float strength = cap_counter\
    \ - sml_counter;\n    if(strength > 0) {\n        for(auto extension : extensions)\
    \ {\n            if(extension.at(0) == class_name[0]) {\n                cap_counter--;\n\
    \            }\n            if(extension.at(1) == class_name[0]) {\n         \
    \       sml_counter--;\n            }\n        }\n        strength = cap_counter\
    \ - sml_counter;\n    }\n    for(auto extension : extensions) {\n        if(extension.at(0)\
    \ == class_name[0]) {\n            cap_counter++;\n        }\n        if(extension.at(1)\
    \ == class_name[0]) {\n            sml_counter++;\n        }\n    }\n    if(cap_counter\
    \ > sml_counter) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2cuy6hrz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_extension_strength = 0;\n    int sm_extension_strength = 0;\n   \
    \ for (auto extension : extensions) {\n        auto cap_extension = extension.substr(0,\
    \ CAP);\n        auto sm_extension = extension.substr(CAP, SM);\n        auto\
    \ cap_extension_strength = std::stoi(cap_extension);\n        auto sm_extension_strength\
    \ = std::stoi(sm_extension);\n        if (cap_extension_strength > cap_extension_strength)\
    \ {\n            cap_extension_strength = cap_extension_strength;\n        }\n\
    \        if (sm_extension_strength > sm_extension_strength) {\n            sm_extension_strength\
    \ = sm_extension_strength;\n        }\n    }\n    extension_strength = class_name\
    \ + \".\" + extensions[0];\n    if (cap_extension_strength > sm_extension_strength)\
    \ {\n        extension_strength = class_name + \".\" + extensions[1];\n    }\n\
    \    return extension_strength;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7b7jvmrn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    int cap_counter = 0;\n    int sm_counter\
    \ = 0;\n    \n    for (auto &extension : extensions) {\n        if (extension\
    \ == class_name) {\n            strongest_extension = class_name;\n          \
    \  break;\n        }\n        \n        auto cap_counter = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::isupper(c);\n       \
    \ });\n        \n        auto sm_counter = std::count_if(extension.begin(), extension.end(),\
    \ [](char c) {\n            return std::islower(c);\n        });\n        \n \
    \       if (cap_counter > sm_counter) {\n            strongest_extension = class_name\
    \ + extension;\n            break;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpw2kk77vd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap = 0;\n    int sm = 0;\n    for (auto &ext : extensions) {\n     \
    \   cap += ext.length();\n        sm += ext.length();\n    }\n    cap = cap /\
    \ extensions.size();\n    sm = sm / extensions.size();\n    if (cap - sm > 0)\
    \ strongest_extension = class_name + extensions[0];\n    else strongest_extension\
    \ = class_name + extensions[extensions.size()-1];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8vc0uihy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (auto ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - ext.length();\n    }\n    \n    float strength = cap - sm;\n    \n    for\
    \ (auto ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() < strongest_extension.length()) {\n        \
    \        strongest_extension = ext;\n            }\n        } else if (ext.length()\
    \ < strongest_extension.length()) {\n            strongest_extension = ext;\n\
    \        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7h874apy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    \n    for (auto e : extensions) {\n        cap += e.size();\n        sm +=\
    \ e.size();\n    }\n    \n    int strength = cap - sm;\n    \n    if (strength\
    \ == 0) {\n        return class_name;\n    }\n    \n    for (auto e : extensions)\
    \ {\n        if (e.size() == strength) {\n            strongest_extension = class_name\
    \ + e;\n            break;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr60s3tnr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    double strongest_extension_strength = 0;\n\
    \    for (auto &extension : extensions) {\n        double extension_strength =\
    \ std::count_if(extension.begin(), extension.end(), [](char c) {\n           \
    \ return std::toupper(c) - std::tolower(c) >= 0;\n        }) / extension.size();\n\
    \        if (extension_strength > strongest_extension_strength) {\n          \
    \  strongest_extension_strength = extension_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvj602fwo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    \n    // Your code here\n    \n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprg_lo2gz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = 0;\n    int sm = 0;\n\
    \    for (auto e : extensions) {\n        cap += e.length();\n        sm += e.length()\
    \ - 1;\n    }\n    float strength = cap - sm;\n    std::string extension = \"\"\
    ;\n    for (auto e : extensions) {\n        if (e.length() == cap) {\n       \
    \     extension += e;\n        }\n        else if (e.length() == sm) {\n     \
    \       extension += e;\n        }\n        else if (e.length() > cap && e.length()\
    \ < sm) {\n            extension += e;\n        }\n        else if (e.length()\
    \ < cap && e.length() > sm) {\n            extension += e;\n        }\n    }\n\
    \    return class_name + \".\" + extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1jpoq75c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension\
    \ : extensions) {\n        cap_counter += extension.at(0) - 'A';\n        sm_counter\
    \ += extension.at(1) - 'a';\n    }\n    double strength = cap_counter - sm_counter;\n\
    \    if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    for (auto &extension : extensions) {\n        if (strength > 0) {\n\
    \            if (extension.at(0) - 'A' > strongest_extension.at(0) - 'A') {\n\
    \                strongest_extension = class_name + \".\" + extension;\n     \
    \       }\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv7io8_qv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        cap += (e.size() - 1);\n        sm += e.size();\n\
    \    }\n    float strength = cap - sm;\n    int max_strength = 0;\n    for (auto\
    \ e : extensions) {\n        if (e.size() > max_strength) {\n            max_strength\
    \ = e.size();\n        }\n    }\n    for (auto e : extensions) {\n        if (e.size()\
    \ == max_strength) {\n            if (e.compare(0, cap, class_name.c_str()) ==\
    \ 0) {\n                strongest_extension = class_name + e;\n            }\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6s2b5419.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    \n    // Your code here\n    \n\
    \    return class_name + \".\" + extensions[0];\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplzu9r0ig.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext : extensions)\
    \ {\n        cap += ext.length();\n        sm += ext.length();\n    }\n    double\
    \ strength = cap - sm;\n    int strongest_ext = 0;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        if (extensions[i].length() > strongest_ext) {\n            strongest_ext\
    \ = extensions[i].length();\n            extension = extensions[i];\n        }\n\
    \    }\n    return class_name + \".\" + extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1fjyahyj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    std::string extension_str;\n    std::string extension_class;\n    int extension_strength_counter\
    \ = 0;\n    int extension_counter_counter = 0;\n    std::string extension_class_str;\n\
    \    std::string extension_class_name_str;\n    std::string extension_class_name_counter;\n\
    \    std::string extension_class_name_counter2;\n    std::string extension_class_name_counter3;\n\
    \    std::string extension_class_name_counter4;\n    std::string extension_class_name_counter5;\n\
    \    std::string extension_class_name_counter6;\n    std::string extension_class_name_counter7;\n\
    \    std::string extension_class_name_counter8;\n    std::string extension_class_name_counter9;\n\
    \    std::string extension_class_name_counter10;\n    std::string extension_class_name_counter11;\n\
    \    std::string extension_class_name_counter12;\n    std::string extension_class_name_counter13;\n\
    \    std::string extension_class_name_counter14;\n    std::string extension_class_name_counter15;\n\
    \    std::string extension_class_name_counter16;\n    std::string extension_class_name_counter17;\n\
    \    std::string extension_class_name_counter18;\n    std::string extension_class_name_counter19;\n\
    \    std::string extension_class_name_counter20;\n    std::string extension_class_name_counter21;\n\
    \    std::string extension_class_name_counter22;\n    std::string extension_class_name_counter23;\n\
    \    std::string extension_class_name_counter24;\n    std::string extension_class_name_counter25;\n\
    \    std::string extension_class_name_counter26;\n    std::string extension_class_name_counter27;\n\
    \    std::string extension_class_name_counter28;\n    std::string extension_class_name_counter29;\n\
    \    std::string extension_class_name_counter30;\n    std::string extension_class_name_counter31;\n\
    \    std::string extension_class_name_counter32;\n    std::string extension_class_name_counter33;\n\
    \    std::string extension_class_name_counter34;\n    std::string extension_class_name_counter35;\n\
    \    std::string extension_class_name_counter36;\n    std::string extension_class_name_counter37;\n\
    \    std::string extension_class_name_counter38;\n    std::string extension_class_name_counter39;\n\
    \    std::string extension_class_name_counter40;\n    std::string extension_class_name_counter41;\n\
    \    std::string extension_class_name_counter42;\n    std::string extension_class_name_counter43;\n\
    \    std::string extension_class_name_counter44;\n    std::string extension_class_name_counter45;\n\
    \    std::string extension_class_name_counter46;\n    std::string extension_class_name_counter47;\n\
    \    std::string extension_class_name_counter48;\n    \n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwj0a676z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.length();\n        sm += ext.length() -\
    \ ext.length();\n    }\n    float strength = cap - sm;\n    if (strength > 0)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    for (int i = 1; i < extensions.size(); i++) {\n        if (strength > 0)\
    \ {\n            strongest_extension = class_name + \".\" + extensions[i];\n \
    \       }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp90bs2s3t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_extension = 0;\n    int sm_extension\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        if (extensions[i].at(0)\
    \ == class_name[0]) {\n            cap_extension = cap_extension + 1;\n      \
    \  }\n        if (extensions[i].at(1) == class_name[1]) {\n            sm_extension\
    \ = sm_extension + 1;\n        }\n    }\n    if (cap_extension - sm_extension\
    \ > 0) {\n        strongest_extension = class_name + \".\" + extensions[cap_extension\
    \ - sm_extension];\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2s2m_c6z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    int strength = cap_num - sm_num;\n \
    \   if (strength == 0)\n        return class_name;\n    int max_strength = -1;\n\
    \    for (auto &ext : extensions) {\n        int cur_strength = ext.length() -\
    \ 1;\n        if (cur_strength > max_strength) {\n            max_strength = cur_strength;\n\
    \        }\n    }\n    if (max_strength == 0)\n        return class_name;\n  \
    \  for (auto &ext : extensions) {\n        if (ext.length() == max_strength) {\n\
    \            return class_name + \".\" + ext;\n        }\n    }\n    return class_name;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpucluiqsf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    std::string extension_str;\n    std::string extension_class;\n    std::string\
    \ extension_class_name;\n    std::string extension_class_name_str;\n    std::string\
    \ extension_class_name_str2;\n    std::string extension_class_name_str3;\n   \
    \ std::string extension_class_name_str4;\n    std::string extension_class_name_str5;\n\
    \    std::string extension_class_name_str6;\n    std::string extension_class_name_str7;\n\
    \    std::string extension_class_name_str8;\n    std::string extension_class_name_str9;\n\
    \    std::string extension_class_name_str10;\n    std::string extension_class_name_str11;\n\
    \    std::string extension_class_name_str12;\n    std::string extension_class_name_str13;\n\
    \    std::string extension_class_name_str14;\n    std::string extension_class_name_str15;\n\
    \    std::string extension_class_name_str16;\n    std::string extension_class_name_str17;\n\
    \    std::string extension_class_name_str18;\n    std::string extension_class_name_str19;\n\
    \    std::string extension_class_name_str20;\n    std::string extension_class_name_str21;\n\
    \    std::string extension_class_name_str22;\n    std::string extension_class_name_str23;\n\
    \    std::string extension_class_name_str24;\n    std::string extension_class_name_str25;\n\
    \    std::string extension_class_name_str26;\n    std::string extension_class_name_str27;\n\
    \    std::string extension_class_name_str28;\n    std::string extension_class_name_str29;\n\
    \    std::string extension_class_name_str30;\n    std::string extension_class_name_str31;\n\
    \    std::string extension_class_name_str32;\n    std::string extension_class_name_str33;\n\
    \    std::string extension_class_name_str34;\n    std::string extension_class_name_str35;\n\
    \    std::string extension_class_name_str36;\n    std::string extension_class_name_str37;\n\
    \    std::string extension_class_name_str38;\n    std::string extension_class_name_str39;\n\
    \    std::string extension_class_name_str40;\n    std::string extension_class_name_str41;\n\
    \    std::string extension_class_name_str42;\n    std::string extension_class_name_str43;\n\
    \    std::string extension_class_name_str44;\n    std::string extension_class_name_str45;\n\
    \    std::string extension_class_name_str46;\n    std::string extension_class_name_str47;\n\
    \    std::string extension_class_name_str48;\n    std::string extension_class_name_str49;\n\
    \    std::string extension_class_name_str50;\n    std::string extension_class_\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqndyhl6m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension;\n    \n    for(auto &extension : extensions) {\n      \
    \  auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        auto strength = cap - sm;\n        \n        if(strength > 0) {\n   \
    \         strongest_extension = class_name + extension;\n            break;\n\
    \        }\n    }\n    \n    return strongest_extension;\n}\nint main() {\n  \
    \  auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4obw0d9t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += (extension.at(0) - 'A');\n      \
    \  sm += (extension.at(1) - 'a');\n    }\n    float strength = cap - sm;\n   \
    \ if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    for (auto &extension : extensions) {\n        if (strength > 0) {\n\
    \            strongest_extension = class_name + \".\" + extension;\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp153pkdsg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ result;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext : extensions)\
    \ {\n        cap += ext.length();\n        sm += ext.length();\n    }\n    int\
    \ strength = cap - sm;\n    if (strength == 0) {\n        return class_name;\n\
    \    }\n    int index = std::distance(extensions.begin(), std::max_element(extensions.begin(),\
    \ extensions.end(), [](std::string a, std::string b) { return a.length() < b.length();\
    \ }));\n    if (strength > 0) {\n        return class_name + \".\" + extensions[index];\n\
    \    }\n    return class_name;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpurld6_oy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &ext : extensions) {\n        if (ext.at(0) == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if (ext.at(1) == class_name[1])\
    \ {\n            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6v2774zu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for(auto &extension : extensions) {\n        cap += (extension.size()-1);\n\
    \        sm += (extension.size()-1);\n    }\n    float strength = cap - sm;\n\
    \    \n    for(auto &extension : extensions) {\n        if(extension.size()==class_name.size()\
    \ && extension.size()==strongest_extension.size()) {\n            if(cap - sm\
    \ < strength) {\n                strongest_extension = class_name + \".\" + extension;\n\
    \                strength = cap - sm;\n            }\n        }\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn_coxqix.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto ext : extensions) {\n        if (ext.length() > cap_counter)\
    \ {\n            cap_counter = ext.length();\n        }\n        if (ext.length()\
    \ > sm_counter) {\n            sm_counter = ext.length();\n        }\n    }\n\
    \    float strength = cap_counter - sm_counter;\n    if (strength > 0) {\n   \
    \     strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (int i = 1; i < extensions.size(); i++) {\n        if (strength > 0) {\n   \
    \         strongest_extension = class_name + \".\" + extensions[i];\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbb51hq0r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string result;\n    int cap_counter\
    \ = 0;\n    int sm_counter = 0;\n    for (auto &extension : extensions) {\n  \
    \      if (extension.at(0) == class_name[0]) {\n            cap_counter++;\n \
    \       }\n        if (extension.at(1) == class_name[0]) {\n            sm_counter++;\n\
    \        }\n    }\n    if (cap_counter == sm_counter) {\n        for (auto &extension\
    \ : extensions) {\n            if (extension.at(0) == class_name[0]) {\n     \
    \           cap_counter--;\n            }\n            if (extension.at(1) ==\
    \ class_name[0]) {\n                sm_counter--;\n            }\n        }\n\
    \        if (cap_counter > sm_counter) {\n            result = class_name + \"\
    .\" + extensions[0];\n        }\n        else {\n            result = class_name\
    \ + \".\" + extensions[1];\n        }\n    }\n    else {\n        result = class_name\
    \ + \".\" + extensions[0];\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpchsw0qjq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string extension_strength = \"\";\n  \
    \  std::string extension_class = \"\";\n    std::string extension_class_name =\
    \ \"\";\n    std::string extension_class_name_with_extension = \"\";\n    std::string\
    \ extension_class_name_with_extension_strength = \"\";\n    std::string extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name = \"\
    \";\n    std::string extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbmkl2dlx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto extension\
    \ : extensions) {\n        auto cap = extension.find_first_of('A');\n        auto\
    \ sm = extension.find_first_of('z');\n        if (cap != std::string::npos &&\
    \ sm != std::string::npos) {\n            cap_counter++;\n            sm_counter++;\n\
    \        }\n    }\n    if (cap_counter > sm_counter) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    else {\n        strongest_extension\
    \ = class_name + \".\" + extensions[extensions.size() - 1];\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgugt54u1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension;\n    \n    for(auto extension : extensions) {\n       \
    \ \n        auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        \n        auto strength = cap - sm;\n        \n        if(strength >\
    \ 0) {\n            strongest_extension = class_name + extension;\n          \
    \  break;\n        }\n    }\n    \n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpci6qcf3h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &extension\
    \ : extensions) {\n        cap += (extension.size()-1);\n        sm += (extension.size()-1);\n\
    \    }\n    float strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [](std::string a, std::string\
    \ b){return a.size() < b.size();}));\n    strongest_extension = class_name + \"\
    .\" + extensions[index];\n    return strongest_extension;\n}\nint main() {\n \
    \   auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpefxx3wvl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_letters = 0, sm_letters\
    \ = 0;\n    for (auto &ext : extensions) {\n        cap_letters += ext.length();\n\
    \        sm_letters += ext.length();\n    }\n    double strength = cap_letters\
    \ - sm_letters;\n    int strongest_extension = -1;\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() > strongest_extension) {\n            strongest_extension\
    \ = ext.length();\n        }\n    }\n    return class_name + \".\" + extensions[strongest_extension];\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkspxbos3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        if (ext.length() > cap_num) {\n  \
    \          cap_num = ext.length();\n        }\n        if (ext.length() < sm_num)\
    \ {\n            sm_num = ext.length();\n        }\n    }\n    int strength =\
    \ cap_num - sm_num;\n    if (strength == 0) {\n        return class_name;\n  \
    \  }\n    int index = -1;\n    for (int i = 0; i < extensions.size(); i++) {\n\
    \        if (extensions[i].length() == strength) {\n            index = i;\n \
    \           break;\n        }\n    }\n    if (index == -1) {\n        return class_name;\n\
    \    }\n    return class_name + \".\" + extensions[index];\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd411w1k3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = class_name.size();\n    int sm = class_name.size();\n\
    \    for(auto e : extensions){\n        cap = cap - e.size();\n        sm = sm\
    \ - e.size();\n    }\n    double strength = cap - sm;\n    if(strength > 0){\n\
    \        strongest_extension = class_name + \".\" + extensions[0];\n    }\n  \
    \  else if(strength < 0){\n        strongest_extension = class_name + \".\" +\
    \ extensions[extensions.size()-1];\n    }\n    else{\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg18l8fz_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &extension\
    \ : extensions) {\n        cap += extension.at(0) - 'A';\n        sm += extension.at(1)\
    \ - 'a';\n    }\n    if (cap - sm > 0)\n        strongest_extension = class_name\
    \ + extensions[0];\n    else\n        strongest_extension = class_name + extensions[1];\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxcoqknfu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    \n    for (auto &extension : extensions) {\n        if (extension.at(0)\
    \ == class_name[0]) {\n            cap_counter++;\n        }\n        if (extension.at(1)\
    \ == class_name[1]) {\n            sm_counter++;\n        }\n    }\n    \n   \
    \ if (cap_counter > sm_counter) {\n        strongest_extension = class_name +\
    \ extensions[0];\n    }\n    else if (cap_counter < sm_counter) {\n        strongest_extension\
    \ = class_name + extensions[1];\n    }\n    else {\n        strongest_extension\
    \ = class_name + extensions[2];\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8xfk88cc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.length() < strongest_extension.length()) {\n                strongest_extension\
    \ = class_name + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp92p5a7_l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_extensions = 0;\n    int sm_extensions\
    \ = 0;\n    for (auto extension : extensions) {\n        if (extension.at(0) ==\
    \ class_name.at(0)) {\n            cap_extensions += 1;\n        }\n        if\
    \ (extension.at(1) == class_name.at(1)) {\n            sm_extensions += 1;\n \
    \       }\n    }\n    if (cap_extensions > sm_extensions) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    else {\n        strongest_extension\
    \ = class_name + \".\" + extensions[1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9akh914q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_str;\n   \
    \ int cap_num = 0, sm_num = 0;\n    for (auto &ext : extensions) {\n        cap_num\
    \ += ext.length();\n        sm_num += ext.length() - 1;\n    }\n    double strength\
    \ = cap_num - sm_num;\n    int strongest_strength = -1;\n    for (auto &ext :\
    \ extensions) {\n        double ext_cap_num = 0, ext_sm_num = 0;\n        for\
    \ (auto &c : ext) {\n            ext_cap_num += c.length();\n            ext_sm_num\
    \ += c.length() - 1;\n        }\n        double ext_strength = ext_cap_num - ext_sm_num;\n\
    \        if (ext_strength > strongest_strength) {\n            strongest_strength\
    \ = ext_strength;\n            extension_str = class_name + \".\" + ext;\n   \
    \     }\n    }\n    return extension_str;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0p3ooahs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto ext : extensions)\
    \ {\n        cap_counter += ext.length();\n        sm_counter += ext.length();\n\
    \    }\n    double strength = cap_counter - sm_counter;\n    int max_strength\
    \ = -1;\n    for (auto ext : extensions) {\n        if (ext.length() > max_strength)\
    \ {\n            max_strength = ext.length();\n        }\n    }\n    if (max_strength\
    \ > 0) {\n        for (auto ext : extensions) {\n            if (ext.length()\
    \ == max_strength) {\n                strongest_extension = class_name + \".\"\
    \ + ext;\n            }\n        }\n    }\n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmk93y6r3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = class_name.size();\n \
    \   int sm = extensions.size();\n    int strength = 0;\n    for (int i = 0; i\
    \ < sm; i++) {\n        std::string ext = extensions[i];\n        int c = ext.size();\n\
    \        int s = cap - c;\n        if (s == 0) {\n            continue;\n    \
    \    }\n        strength += s;\n    }\n    if (strength == 0) {\n        return\
    \ class_name;\n    }\n    int index = strength / cap;\n    std::string res = class_name\
    \ + \".\" + extensions[index];\n    return res;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_ec0i5jg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    std::string extension_str;\n    std::string extension_class;\n    int extension_cap\
    \ = 0;\n    int extension_sm = 0;\n    std::string extension_class_name;\n   \
    \ std::string extension_class_name_str;\n    int extension_strength_int;\n   \
    \ int extension_strength_float;\n    int extension_strength_double;\n    int extension_strength_bool;\n\
    \    int extension_strength_char;\n    int extension_strength_short;\n    int\
    \ extension_strength_int8;\n    int extension_strength_int16;\n    int extension_strength_int32;\n\
    \    int extension_strength_int64;\n    int extension_strength_int;\n    int extension_strength_uint;\n\
    \    int extension_strength_float;\n    int extension_strength_double;\n    int\
    \ extension_strength_bool;\n    int extension_strength_char;\n    int extension_strength_short;\n\
    \    int extension_strength_int8;\n    int extension_strength_int16;\n    int\
    \ extension_strength_int32;\n    int extension_strength_int64;\n    int extension_strength_int;\n\
    \    int extension_strength_uint;\n    int extension_strength_float;\n    int\
    \ extension_strength_double;\n    int extension_strength_bool;\n    int extension_strength_char;\n\
    \    int extension_strength_short;\n    int extension_strength_int8;\n    int\
    \ extension_strength_int16;\n    int extension_strength_int32;\n    int extension_strength_int64;\n\
    \    int extension_strength_int;\n    int extension_strength_uint;\n    int extension_strength_float;\n\
    \    int extension_strength_double;\n    int extension_strength_bool;\n    int\
    \ extension_strength_char;\n    int extension_strength_short;\n    int extension_strength_int8;\n\
    \    int extension_strength_int16;\n    int extension_strength_int32;\n    int\
    \ extension_strength_int64;\n    int extension_strength_int;\n    int extension_strength_uint;\n\
    \    int extension_strength_float;\n    int extension_strength_double;\n    int\
    \ extension_strength_bool;\n    int extension_strength_char;\n    int extension_strength_short;\n\
    \    int extension_strength_int8;\n    int extension_strength_int16;\n    int\
    \ extension_strength_int32;\n    int extension_strength_int64;\n    int extension_strength_int;\n\
    \    int extension_strength_uint;\n    int extension_strength_float;\n    int\
    \ extension_strength_double;\n    int extension_\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc60x47ry.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - ext.length();\n    }\n    float strength = cap - sm;\n    if (strength > 0)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    for (auto &ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() < strongest_extension.length()) {\n        \
    \        strongest_extension = class_name + \".\" + ext;\n            }\n    \
    \    }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1o1ep0se.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &extension : extensions) {\n        cap += (extension.size()-1);\n        sm\
    \ += (extension.size()-1);\n    }\n    double strength = cap - sm;\n    for(auto\
    \ &extension : extensions) {\n        if(strength == (extension.size()-1)) {\n\
    \            strongest_extension = class_name + \".\" + extension;\n         \
    \   break;\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzlkdcl8m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799188
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap_num = 0, sm_num = 0;\n\
    \    for (auto &ext : extensions) {\n        cap_num += ext.length();\n      \
    \  sm_num += ext.length() - cap_num;\n    }\n    \n    if (cap_num - sm_num >\
    \ 0) {\n        auto cap_num = cap_num - sm_num;\n        auto sm_num = sm_num;\n\
    \        auto cap_pos = cap_num / 2;\n        auto sm_pos = sm_num / 2;\n    \
    \    \n        for (auto &ext : extensions) {\n            if (ext.length() ==\
    \ cap_pos) {\n                cap_num -= ext.length();\n                sm_num\
    \ -= ext.length() - cap_num;\n                cap_pos = 0;\n                sm_pos\
    \ = 0;\n            }\n            if (ext.length() == sm_pos) {\n           \
    \     cap_num -= ext.length();\n                sm_num -= ext.length() - cap_num;\n\
    \                cap_pos = 0;\n                sm_pos = 0;\n            }\n  \
    \      }\n        \n        if (cap_num > 0) {\n            strongest_extension\
    \ = class_name + \".\" + extensions[cap_num / 2];\n        }\n        if (sm_num\
    \ > 0) {\n            strongest_extension = class_name + \".\" + extensions[sm_num\
    \ / 2];\n        }\n    }\n    \n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphrg99sw6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        if (ext.size() > cap_num) {\n    \
    \        cap_num = ext.size();\n        }\n        if (ext.size() < sm_num) {\n\
    \            sm_num = ext.size();\n        }\n    }\n    int cap_strength = cap_num\
    \ - sm_num;\n    int sm_strength = sm_num - cap_num;\n    if (cap_strength > sm_strength)\
    \ {\n        return class_name + \".\" + extensions[0];\n    }\n    return class_name\
    \ + \".\" + extensions[sm_strength];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk4e4bkga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.length() < strongest_extension.length()) {\n                strongest_extension\
    \ = class_name + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp92p5a7_l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    \n    for(int i = 0; i < extensions.size();\
    \ i++){\n        std::string extension = extensions[i];\n        \n        for(int\
    \ j = 0; j < extension.size(); j++){\n            char c = extension[j];\n   \
    \         \n            if(c == toupper(extension[j])){\n                strongest_extension\
    \ += c;\n            }\n        }\n    }\n    \n    return class_name + \".\"\
    \ + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxa82d6th.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string extension_strength = \"\";\n  \
    \  int cap = 0;\n    int sm = 0;\n    for (auto &extension : extensions) {\n \
    \       cap += extension.at(0) - extension.at(1);\n        sm += extension.at(1)\
    \ - extension.at(0);\n    }\n    extension_strength = cap - sm;\n    if (extension_strength\
    \ > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    for (auto &extension : extensions) {\n        if (extension_strength\
    \ == extension.at(0) - extension.at(1))\n            strongest_extension = class_name\
    \ + \".\" + extension;\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqyi_4wpn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.length();\n        sm += ext.length() -\
    \ ext.length();\n    }\n    if (cap - sm > 0)\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    else\n        strongest_extension = class_name;\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiwi0xubn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &ext : extensions) {\n        if (ext.length() > cap_counter)\
    \ {\n            cap_counter = ext.length();\n        }\n        if (ext.length()\
    \ < sm_counter) {\n            sm_counter = ext.length();\n        }\n    }\n\
    \    float strength = cap_counter - sm_counter;\n    if (strength > 0) {\n   \
    \     strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (int i = 1; i < extensions.size(); i++) {\n        if (strength > 0) {\n   \
    \         strongest_extension = class_name + \".\" + extensions[i];\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpec9x8qf4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length();\n    }\n    double strength = cap_num - sm_num;\n  \
    \  double max_strength = -1;\n    for (auto &ext : extensions) {\n        double\
    \ ext_strength = ext.length();\n        if (ext_strength > max_strength) {\n \
    \           max_strength = ext_strength;\n        }\n    }\n    if (max_strength\
    \ == -1) {\n        return class_name;\n    }\n    int max_strength_pos = 0;\n\
    \    for (auto &ext : extensions) {\n        if (ext.length() == max_strength)\
    \ {\n            max_strength_pos = extensions.find(ext);\n        }\n    }\n\
    \    return class_name + \".\" + extensions[max_strength_pos];\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprbsqxb4c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = class_name.size();\n \
    \   int sm = extensions.size();\n    int strength = cap - sm;\n    std::string\
    \ strongest_extension;\n    for (int i = 0; i < extensions.size(); i++) {\n  \
    \      if (extensions[i].size() == cap) {\n            if (extensions[i].compare(class_name,\
    \ cap - sm, cap - sm) == 0) {\n                strongest_extension = class_name\
    \ + extensions[i];\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp88t6tmjw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string extension_strength = \"\";\n    \n    for(auto extension : extensions)\
    \ {\n        auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        \n        if(cap != std::string::npos && sm != std::string::npos) {\n\
    \            extension_strength += extension.substr(cap, cap - sm);\n        }\n\
    \    }\n    \n    extension_strength = extension_strength.substr(0, extension_strength.find_first_of('.'));\n\
    \    \n    return class_name + \".\" + extension_strength;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0syb8zfb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += (extension.at(0) - 'A');\n      \
    \  sm += (extension.at(1) - 'a');\n    }\n    if (cap - sm > 0)\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    else\n        strongest_extension\
    \ = class_name + \".\" + extensions[extensions.size() - 1];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjo8f40rx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(auto extension : extensions)\
    \ {\n        \n        std::string extension_class = \"\";\n        \n       \
    \ for(auto letter : extension) {\n            \n            if(letter == 'A' ||\
    \ letter == 'B' || letter == 'C' || letter == 'D' || letter == 'E' || letter ==\
    \ 'F' || letter == 'G' || letter == 'H' || letter == 'I' || letter == 'J' || letter\
    \ == 'K' || letter == 'L' || letter == 'M' || letter == 'N' || letter == 'O' ||\
    \ letter == 'P' || letter == 'Q' || letter == 'R' || letter == 'S' || letter ==\
    \ 'T' || letter == 'U' || letter == 'V' || letter == 'W' || letter == 'X' || letter\
    \ == 'Y' || letter == 'Z') {\n                \n                extension_class\
    \ += letter;\n                \n            }\n            \n        }\n     \
    \   \n        if(extension_class == class_name) {\n            \n            strongest_extension\
    \ = extension;\n            \n        }\n        \n    }\n    \n    return strongest_extension;\n\
    \    \n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgqq0fm4l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto e : extensions) {\n\
    \        if (std::toupper(e[0]) == class_name[0]) {\n            cap++;\n    \
    \    }\n        if (std::tolower(e[0]) == class_name[0]) {\n            sm++;\n\
    \        }\n    }\n    if (cap - sm > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    } else {\n        for (auto e : extensions) {\n\
    \            if (std::toupper(e[0]) == class_name[0]) {\n                cap++;\n\
    \            }\n            if (std::tolower(e[0]) == class_name[0]) {\n     \
    \           sm++;\n            }\n        }\n        if (cap - sm > 1) {\n   \
    \         strongest_extension = class_name + \".\" + extensions[1];\n        }\
    \ else {\n            strongest_extension = class_name + \".\" + extensions[0];\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptc1ob2dc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        cap += e.size();\n        sm += e.size();\n    }\n\
    \    float strength = cap - sm;\n    for (auto e : extensions) {\n        if (e.size()\
    \ == strength) {\n            strongest_extension = class_name + e;\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpobu5t1bb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n   \
    \ }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() == strongest_extension.size()) {\n            if (ext.size()\
    \ < strongest_extension.size()) {\n                strongest_extension = class_name\
    \ + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps2_i8_sd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for(auto extension\
    \ : extensions) {\n        auto cap = extension.substr(0, CAP);\n        auto\
    \ sm = extension.substr(CAP, SM);\n        auto cap_counter = std::count(cap.begin(),\
    \ cap.end(), CAP);\n        auto sm_counter = std::count(sm.begin(), sm.end(),\
    \ SM);\n        if(cap_counter > sm_counter) {\n            strongest_extension\
    \ = class_name + extension;\n            break;\n        }\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu3aefxvk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        cap = cap + toupper(extensions[i].at(0)\
    \ - 'A');\n        sm = sm + tolower(extensions[i].at(0) - 'a');\n    }\n    float\
    \ strength = cap - sm;\n    if (strength > 0) {\n        for (int i = 0; i < extensions.size();\
    \ i++) {\n            if (toupper(extensions[i].at(0) - 'A') == toupper(extensions[i].at(0)\
    \ - 'a')) {\n                strongest_extension = class_name + \".\" + extensions[i];\n\
    \            }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq05ixi2r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sm_counter = 0;\n  \
    \  for(int i = 0; i < extensions.size(); i++) {\n        if(extensions[i].at(0)\
    \ == class_name[0]) {\n            cap_counter++;\n        }\n        if(extensions[i].at(1)\
    \ == class_name[0]) {\n            sm_counter++;\n        }\n    }\n    float\
    \ strength = cap_counter - sm_counter;\n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        if(extensions[i].at(0) == class_name[0]) {\n            cap_counter--;\n\
    \        }\n        if(extensions[i].at(1) == class_name[0]) {\n            sm_counter--;\n\
    \        }\n    }\n    if(cap_counter > sm_counter) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    else {\n        strongest_extension\
    \ = class_name + \".\" + extensions[1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8apchl6b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        cap = extensions[i].length();\n\
    \        sm = class_name.size();\n        if (cap - sm > 0)\n            strongest_extension\
    \ += extensions[i];\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_moq3mk9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string extension_str;\n    \n    for (auto &extension : extensions)\
    \ {\n        auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        auto strength = cap - sm;\n        if (strength > 0) {\n            extension_str\
    \ += class_name + extension;\n        }\n    }\n    \n    return extension_str;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp817l0910.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ extension_strength = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n\
    \    for (auto &ext : extensions) {\n        if (ext.at(0) == class_name[0]) {\n\
    \            cap_counter++;\n        }\n        if (ext.at(1) == class_name[1])\
    \ {\n            sm_counter++;\n        }\n    }\n    extension_strength = std::to_string(cap_counter\
    \ - sm_counter);\n    return class_name + \".\" + extension_strength;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3fxchkta.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int max_strength = -1;\n    for (auto\
    \ &ext : extensions) {\n        float ext_strength = ext.length();\n        if\
    \ (ext_strength > max_strength) {\n            max_strength = ext_strength;\n\
    \            strongest_extension = ext;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphsa4yott.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto extension : extensions) {\n        if (extension == class_name)\
    \ {\n            strongest_extension = extension;\n            break;\n      \
    \  }\n        if (extension.at(0) == class_name.at(0)) {\n            cap_counter++;\n\
    \        }\n        if (extension.at(1) == class_name.at(1)){\n            sm_counter++;\n\
    \        }\n    }\n    if (cap_counter > sm_counter) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiwyokc1t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ ext : extensions) {\n        if (ext.length() > cap) {\n            cap = ext.length();\n\
    \        }\n        if (ext.length() < sm) {\n            sm = ext.length();\n\
    \        }\n    }\n    float strength = cap - sm;\n    if (strength > 0) {\n \
    \       strongest_extension = class_name + \".\" + extensions[0];\n    }\n   \
    \ for (auto ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() < strongest_extension.length()) {\n        \
    \        strongest_extension = class_name + \".\" + ext;\n            }\n    \
    \    }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4azgxpdk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    std::string extension_str;\n    int extension_strength_counter = 0;\n   \
    \ int extension_counter_counter = 0;\n    std::string extension_strength_str;\n\
    \    std::string extension_str_str;\n    int extension_counter = 0;\n    int extension_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter = 0;\n    int extension_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter = 0;\n    int\
    \ extension_counter_counter_counter_counter_counter_counter = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    int extension_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9k0diokt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8dii0je4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799187
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        cap += e.size();\n        sm += std::count(e.begin(),\
    \ e.end(), 'a');\n    }\n    float strength = cap - sm;\n    if (strength > 0)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    for (int i = 1; i < extensions.size(); i++) {\n        if (strength > 0)\
    \ {\n            strongest_extension = class_name + \".\" + extensions[i];\n \
    \       }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp873x230l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    \n    for(auto extension : extensions) {\n\
    \        auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        auto strength = cap - sm;\n        \n        if(strength > 0) {\n   \
    \         strongest_extension += class_name + \".\" + extension;\n        }\n\
    \    }\n    \n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmm4962uh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = class_name.size();\n \
    \   int sm = extensions.size();\n    int strength = cap - sm;\n    int index =\
    \ 0;\n    std::string strongest_extension;\n    while (index < sm) {\n       \
    \ if (strength > 0) {\n            strongest_extension = class_name + extensions[index];\n\
    \            strength--;\n        }\n        index++;\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp9cps83y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n\
    \    }\n    double strength = cap_num - sm_num;\n    double max_strength = std::numeric_limits<double>::max();\n\
    \    for (auto &ext : extensions) {\n        double ext_strength = ext.length();\n\
    \        if (ext_strength > max_strength) {\n            max_strength = ext_strength;\n\
    \        }\n    }\n    for (auto &ext : extensions) {\n        double ext_strength\
    \ = ext.length();\n        if (ext_strength == max_strength) {\n            if\
    \ (ext_strength < strength) {\n                strength = ext_strength;\n    \
    \        }\n        }\n    }\n    return class_name + \".\" + extensions[extensions.find_first_of(\"\
    abcdefghijklmnopqrstuvwxyz\") - strength];\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpo3qksund.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap - sm;\n    if (cap > 0) {\n        strongest_extension =\
    \ class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpara5wx9u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799189
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension;\n    \n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (auto &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - ext.length();\n    }\n    \n    float strength = cap - sm;\n    \n    for\
    \ (auto &ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() < strongest_extension.length()) {\n        \
    \        strongest_extension = class_name + ext;\n            }\n        }\n \
    \   }\n    \n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzu9nk9p6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    int strength = cap_num - sm_num;\n \
    \   if (strength > 0) {\n        auto it = std::min_element(extensions.begin(),\
    \ extensions.end(), [&strength](const std::string &a, const std::string &b) {\
    \ return strength < a.length() - b.length(); });\n        return class_name +\
    \ \".\" + extensions[it->size()];\n    }\n    return class_name;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqtntvfji.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions){\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions){\n   \
    \     if(ext.length() > strongest_extension.length()){\n            strongest_extension\
    \ = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcw7zj4gi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &ext : extensions) {\n        cap_counter += ext.length();\n\
    \        sm_counter += ext.length();\n    }\n    double strength = cap_counter\
    \ - sm_counter;\n    if (strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions) {\n      \
    \  if (ext.length() == strength) {\n            strongest_extension = class_name\
    \ + \".\" + ext;\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpksmznuc9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string extension_strength;\n    \n    for(auto &extension : extensions)\
    \ {\n        auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        extension_strength += extension.substr(cap, cap - sm);\n    }\n    \n\
    \    auto cap = extension_strength.find_first_of('A');\n    auto sm = extension_strength.find_first_of('l');\n\
    \    extension_strength += extension_strength.substr(cap, cap - sm);\n    \n \
    \   auto class_name_split = class_name.split('.');\n    \n    for(auto &class_name\
    \ : class_name_split) {\n        auto cap = class_name.find_first_of('A');\n \
    \       auto sm = class_name.find_first_of('l');\n        class_name += class_name.substr(cap,\
    \ cap - sm);\n    }\n    \n    return class_name + \".\" + extension_strength;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8sxobfpg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - cap_num;\n    }\n    double strength = cap_num - sm_num;\n\
    \    int max_strength = -1;\n    for (auto &ext : extensions) {\n        int cur_strength\
    \ = ext.length() - cap_num - sm_num;\n        if (cur_strength > max_strength)\
    \ {\n            max_strength = cur_strength;\n        }\n    }\n    if (max_strength\
    \ == -1) {\n        return class_name;\n    }\n    std::string res = class_name\
    \ + \".\";\n    for (auto &ext : extensions) {\n        std::string cur_ext =\
    \ ext;\n        cur_ext.erase(cur_ext.find_last_not_of('.'));\n        if (cur_ext.length()\
    \ == 0) {\n            continue;\n        }\n        cur_ext += \".\";\n     \
    \   if (cur_ext.length() > cap_num - sm_num) {\n            cur_ext.erase(cur_ext.find_last_not_of('.'));\n\
    \        }\n        cur_ext += extensions[extensions.find(cur_ext)];\n       \
    \ res += cur_ext;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8yuplywr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(std::toupper(ext[0]));\n    }\n\
    \    float strength = cap_num - sm_num;\n    int max_strength = -1;\n    for (auto\
    \ &ext : extensions) {\n        float cur_strength = ext.length() - ext.find_first_not_of(std::toupper(ext[0]));\n\
    \        if (cur_strength > max_strength) {\n            max_strength = cur_strength;\n\
    \        }\n    }\n    if (max_strength == -1) {\n        return class_name;\n\
    \    }\n    std::string res = class_name + \".\";\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == max_strength) {\n            res += ext;\n  \
    \      }\n    }\n    return res;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3e9aop2d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ extension_strength = \"\";\n    std::string extension_class = \"\";\n    std::string\
    \ extension_class_name = \"\";\n    std::string extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength = \"\"\
    ;\n    std::string extension_class_name_with_extension_strength_without_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension_without_class_with_extension_strength_without_extension\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfqp5sdjz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_extension = 0;\n    int sm_extension\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        if (extensions[i].at(0)\
    \ == class_name[0]) {\n            cap_extension = cap_extension + 1;\n      \
    \  }\n        if (extensions[i].at(1) == class_name[1]) {\n            sm_extension\
    \ = sm_extension + 1;\n        }\n    }\n    float strength = cap_extension -\
    \ sm_extension;\n    if (strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            if (extensions[i].at(0) ==\
    \ class_name[0]) {\n                strongest_extension = strongest_extension\
    \ + \".\" + extensions[i];\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2v2w0bd4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ extension_strength;\n    int cap_counter = 0;\n    int sm_counter = 0;\n   \
    \ for(auto extension : extensions) {\n        if(extension.at(0) == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if(extension.at(1) == class_name[1])\
    \ {\n            sm_counter++;\n        }\n    }\n    extension_strength = class_name\
    \ + \".\" + extensions[cap_counter].substr(cap_counter-sm_counter);\n    return\
    \ extension_strength;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9rc0po2o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    double strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [&](const std::string\
    \ &a, const std::string &b) { return a.length() < b.length(); }));\n    if (strength\
    \ == -1) {\n        strongest_extension = class_name;\n    } else {\n        strongest_extension\
    \ = class_name + \".\" + extensions[index];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvdjuo1h1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    \n    for (auto &extension : extensions) {\n        cap += (extension.at(0)\
    \ - 'A');\n        sm += (extension.at(1) - 'a');\n    }\n    \n    if (cap -\
    \ sm > 0) strongest_extension = class_name + \".\" + extensions[0];\n    else\
    \ strongest_extension = class_name + \".\" + extensions[1];\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgimg6i7m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto extension :\
    \ extensions) {\n        if (extension.at(0) == class_name[0]) {\n           \
    \ cap_counter++;\n        }\n        if (extension.at(1) == class_name[1]) {\n\
    \            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        extension_strength = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        extension_strength = class_name + \".\" + extensions[1];\n\
    \    }\n    return extension_strength;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpznjwrw1l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string extension_str;\n    \n    for (auto extension : extensions) {\n\
    \        auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        auto strength = cap - sm;\n        extension_str += class_name + \".\"\
    \ + extension + std::to_string(strength);\n    }\n    \n    auto max_strength\
    \ = std::max_element(extensions.begin(), extensions.end()) - extensions.begin();\n\
    \    \n    if (max_strength == extensions.end()) {\n        extension_str += class_name;\n\
    \    }\n    \n    return extension_str;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprhomlerr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    \n    // Write your code here\n\
    \    \n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpol6c5ivf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    std::string extension_str;\n    std::string extension_class;\n    std::string\
    \ extension_class_name;\n    std::string extension_class_name_str;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int extension_class_name_length;\n\
    \    int extension_class_name_length;\n    int \n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfohlc7qk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ extension_strength;\n    std::string extension_str;\n    std::string extension_class;\n\
    \    int extension_strength_counter = 0;\n    int extension_counter_counter =\
    \ 0;\n    std::string extension_class_name;\n    for (auto &extension : extensions)\
    \ {\n        if (extension_strength_counter == 0) {\n            extension_strength\
    \ = extension;\n            extension_strength_counter++;\n        }\n       \
    \ if (extension_strength_counter == 1) {\n            extension_str = extension;\n\
    \            extension_strength_counter++;\n        }\n        if (extension_strength_counter\
    \ == 2) {\n            extension_class = extension;\n            extension_strength_counter++;\n\
    \        }\n        if (extension_strength_counter == 3) {\n            extension_class_name\
    \ = extension;\n            extension_strength_counter++;\n        }\n    }\n\
    \    if (extension_strength_counter == 1) {\n        extension_str = extension_str;\n\
    \    }\n    if (extension_strength_counter == 2) {\n        extension_class =\
    \ extension_class;\n    }\n    if (extension_strength_counter == 3) {\n      \
    \  extension_class_name = extension_class_name;\n    }\n    if (extension_strength_counter\
    \ == 1) {\n        extension_strength = extension_str;\n    }\n    if (extension_strength_counter\
    \ == 2) {\n        extension_strength = extension_class;\n    }\n    if (extension_strength_counter\
    \ == 3) {\n        extension_strength = extension_class_name;\n    }\n    std::string\
    \ strongest_extension = class_name + \".\" + extension_strength;\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfprje4o1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ extension_strength;\n    int cap_extension_strength = 0;\n    int sm_extension_strength\
    \ = 0;\n    for (auto extension : extensions) {\n        cap_extension_strength\
    \ += (extension.at(0) - 'A');\n        sm_extension_strength += (extension.at(1)\
    \ - 'a');\n    }\n    extension_strength = std::to_string(cap_extension_strength\
    \ - sm_extension_strength);\n    return class_name + \".\" + extension_strength;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx2uh4zu0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        if (extension.at(0) == class_name[0]) {\n\
    \            cap = cap + 1;\n        }\n        if (extension.at(1) == class_name[1])\
    \ {\n            sm = sm + 1;\n        }\n    }\n    float strength = cap - sm;\n\
    \    if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    if (strength == 1) {\n        strongest_extension = class_name + \"\
    .\" + extensions[0];\n    }\n    if (strength > 1) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9ejpw_yc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sm_counter = 0;\n  \
    \  for (auto &extension : extensions) {\n        auto cap = extension.find_first_of('A');\n\
    \        auto sm = extension.find_first_of('z');\n        if (cap != std::string::npos\
    \ && sm != std::string::npos) {\n            cap_counter += cap - sm;\n      \
    \      sm_counter += sm;\n        }\n    }\n    double strength = cap_counter\
    \ - sm_counter;\n    if (strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else {\n        strongest_extension = class_name\
    \ + \".\" + extensions[extensions.size() - 1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpeb7chhcf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension :\
    \ extensions) {\n        if (extension.at(0) == class_name.at(0)) {\n        \
    \    cap_counter++;\n        }\n        if (extension.at(1) == class_name.at(0))\
    \ {\n            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        extension_strength = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        extension_strength = class_name + \".\" + extensions[1];\n\
    \    }\n    return extension_strength;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdid_28pk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sml_counter = 0;\n    for (auto &extension\
    \ : extensions) {\n        cap_counter += extension.at(0) - 'A';\n        sml_counter\
    \ += extension.at(1) - 'a';\n    }\n    if (cap_counter > sml_counter) {\n   \
    \     strongest_extension = class_name + \".\" + extensions[0];\n    } else {\n\
    \        strongest_extension = class_name + \".\" + extensions[1];\n    }\n  \
    \  return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjeqqer91.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &extension : extensions) {\n        cap += extension.at(0);\n        sm += extension.at(1);\n\
    \    }\n    float strength = cap - sm;\n    if(strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    else if(strength < 0){\n \
    \       strongest_extension = class_name + \".\" + extensions[extensions.size()-1];\n\
    \    }\n    else if(strength == 0){\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1ashlxz4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto extension\
    \ : extensions) {\n        if (extension.at(0) == class_name[0]) {\n         \
    \   cap_counter++;\n        }\n        if (extension.at(1) == class_name[1]) {\n\
    \            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2go3i5gv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(std::toupper(ext.at(0)));\n \
    \   }\n    double strength = cap_num - sm_num;\n    double max_strength = -1;\n\
    \    for (auto &ext : extensions) {\n        double cur_strength = ext.length()\
    \ - ext.find_first_not_of(std::toupper(ext.at(0)));\n        if (cur_strength\
    \ > max_strength) {\n            max_strength = cur_strength;\n        }\n   \
    \ }\n    if (max_strength == -1) {\n        return class_name;\n    }\n    std::string\
    \ res = class_name + \".\";\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ == max_strength) {\n            res += ext.at(0);\n            break;\n    \
    \    }\n    }\n    return res;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppf8l3wyq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.compare(strongest_extension) == 0) {\n                strongest_extension\
    \ = class_name + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprqbn1vpu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto ext : extensions) {\n        cap_counter += ext.length();\n\
    \        sm_counter += ext.length() - cap_counter;\n    }\n    double strength\
    \ = cap_counter - sm_counter;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4fh89244.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto e : extensions) {\n\
    \        cap += e.size();\n        sm += e.size();\n    }\n    cap = cap - sm;\n\
    \    for (auto e : extensions) {\n        if (cap - e.size() > 0) {\n        \
    \    strongest_extension = class_name + \".\" + e;\n            break;\n     \
    \   }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppq_sr4ob.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = class_name.size();\n \
    \   int sm = extensions.size();\n    int strength = 0;\n    for (int i = 0; i\
    \ < sm; i++) {\n        std::string extension = extensions[i];\n        int ext_cap\
    \ = extension.size();\n        int ext_sm = ext_cap - cap;\n        strength +=\
    \ ext_cap - ext_sm;\n        cap = ext_cap;\n    }\n    if (strength == 0) {\n\
    \        return class_name;\n    }\n    std::string strongest_extension = class_name\
    \ + extensions[0];\n    for (int i = 1; i < sm; i++) {\n        if (strength >\
    \ strongest_extension.size()) strongest_extension = class_name + extensions[i];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdzt669ki.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for(auto &extension\
    \ : extensions){\n        cap += extension.at(0);\n        sm += extension.at(1);\n\
    \    }\n    float strength = cap - sm;\n    \n    for(auto &extension : extensions){\n\
    \        if(extension.at(1) == extension.at(0) && extension.at(1) > strength){\n\
    \            strongest_extension = class_name + extension.at(0);\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp23m89j8z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.length();\n        sm += ext.length() -\
    \ cap;\n    }\n    float strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [&](std::string a, std::string\
    \ b) { return a.length() < b.length(); }));\n    strongest_extension = class_name\
    \ + extensions[index];\n    return strongest_extension;\n}\nint main() {\n   \
    \ auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpntvfhrfm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ extension_strength = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        if (e == class_name[0]) {\n            cap++;\n \
    \       }\n        if (e == class_name[class_name.size() - 1]) {\n           \
    \ sm++;\n        }\n    }\n    float strength = cap - sm;\n    if (strength >\
    \ 0) {\n        extension_strength = class_name + \".\" + extensions[0];\n   \
    \ }\n    for (int i = 1; i < extensions.size(); i++) {\n        if (extension_strength\
    \ == \"\") {\n            extension_strength = class_name + \".\" + extensions[i];\n\
    \        }\n        else if (extension_strength != \"\" && extension_strength\
    \ != class_name + \".\" + extensions[i]) {\n            extension_strength = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return extension_strength;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmyoykcqo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap_counter = 0;\n    int\
    \ sm_counter = 0;\n    \n    for (auto extension : extensions) {\n        if (extension.at(0)\
    \ == class_name.at(0)) {\n            cap_counter++;\n        }\n        if (extension.at(1)\
    \ == class_name.at(1)) {\n            sm_counter++;\n        }\n    }\n    \n\
    \    if (cap_counter > sm_counter) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else {\n        strongest_extension = class_name\
    \ + \".\" + extensions[1];\n    }\n    \n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp49ernp7i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_extensions = 0, sm_extensions\
    \ = 0;\n    for (auto ext : extensions) {\n        cap_extensions += ext.length();\n\
    \        sm_extensions += ext.length() - 1;\n    }\n    double strength = cap_extensions\
    \ - sm_extensions;\n    int strongest_extension = 0;\n    for (auto ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension) {\n            continue;\n\
    \        }\n        if (ext.length() > strongest_extension) {\n            strongest_extension\
    \ = ext.length();\n        }\n        if (ext.length() == strongest_extension)\
    \ {\n            strongest_extension = ext.length() - 1;\n        }\n    }\n \
    \   return class_name + \".\" + extensions[strongest_extension];\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplur13nbo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    \n    for (int i = 0; i < extensions.size(); i++) {\n        cap += (extensions[i].size()\
    \ - extensions[i].find_first_of('A'));\n        sm += (extensions[i].size() -\
    \ extensions[i].find_first_of('a'));\n    }\n    \n    if (cap - sm > 0)\n   \
    \     strongest_extension = class_name + \".\" + extensions[0];\n    else if (cap\
    \ - sm == 0)\n        strongest_extension = class_name;\n    else\n        strongest_extension\
    \ = class_name + \".\" + extensions[(cap - sm)-1];\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg_2aguvn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap_counter = 0;\n    int\
    \ sm_counter = 0;\n    \n    for (auto &extension : extensions) {\n        if\
    \ (extension == class_name) {\n            strongest_extension = extension;\n\
    \            break;\n        }\n        \n        auto cap = std::toupper(extension[0]);\n\
    \        auto sm = std::tolower(extension[0]);\n        \n        if (cap == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        \n        if (sm == class_name[0])\
    \ {\n            sm_counter++;\n        }\n    }\n    \n    if (cap_counter >\
    \ sm_counter) {\n        strongest_extension = class_name;\n    }\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0epiyy1s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length();\n    }\n    double strength = cap_num - sm_num;\n  \
    \  int max_strength = -1;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ > max_strength) {\n            max_strength = ext.length();\n        }\n   \
    \ }\n    for (auto &ext : extensions) {\n        if (ext.length() == max_strength)\
    \ {\n            if (ext.compare(0, cap_num - sm_num, class_name) == 0) {\n  \
    \              return class_name + \".\" + ext;\n            }\n        }\n  \
    \  }\n    return class_name;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprretlm40.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto extension : extensions) {\n        cap_counter += extension.at(0)\
    \ - 'A';\n        sm_counter += extension.at(1) - 'a';\n    }\n    double strength\
    \ = cap_counter - sm_counter;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    if (strength > 1) {\n    \
    \    strongest_extension = class_name + \".\" + extensions[1];\n    }\n    if\
    \ (strength > 2) {\n        strongest_extension = class_name + \".\" + extensions[2];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpweciqaza.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    std::string extension_strength;\n    int cap_extension\
    \ = 0;\n    int sml_extension = 0;\n    for (auto &extension : extensions) {\n\
    \        if (extension == class_name) {\n            strongest_extension = class_name;\n\
    \            extension_strength = extension;\n        }\n        if (extension.at(0)\
    \ == class_name.at(0)) {\n            cap_extension++;\n        }\n        if\
    \ (extension.at(1) == class_name.at(1)){\n            sml_extension++;\n     \
    \   }\n    }\n    double strength = cap_extension - sml_extension;\n    if (strength\
    \ > 0) {\n        strongest_extension = class_name + extension_strength;\n   \
    \ }\n    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpioppl7zy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659799190
