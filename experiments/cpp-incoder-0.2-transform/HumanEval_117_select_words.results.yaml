language: cpp
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    if (s.empty()) {\n        return result;\n    }\n    \n    std::string\
    \ word = \"\";\n    \n    for (char c : s) {\n        if (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            word += c;\n        }\n\
    \        else if (c == 'n') {\n            if (word.length() == n) {\n       \
    \         result.push_back(word);\n                word = \"\";\n            }\n\
    \        }\n    }\n    \n    if (word.length() > 0) {\n        result.push_back(word);\n\
    \    }\n    \n    return result;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwly8ftpq.cpp: In function 'std::vector<std::basic_string<char>\
    \ > select_words(std::string, long int)':\n/tmp/tmpwly8ftpq.cpp:27:19: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (char c : s)\
    \ {\n                   ^\n/tmp/tmpwly8ftpq.cpp: In function 'int main()':\n/tmp/tmpwly8ftpq.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwly8ftpq.cpp:2:\n/tmp/tmpwly8ftpq.cpp:47:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpwly8ftpq.cpp:47:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmpwly8ftpq.cpp:47:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmpwly8ftpq.cpp:47:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpwly8ftpq.cpp:47:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpwly8ftpq.cpp:47:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    if(s.empty())\n        return res;\n    \n    for(auto &c: s)\
    \ {\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n  \
    \          continue;\n        \n        if(c == 'n')\n            continue;\n\
    \        \n        if(c == 't')\n            continue;\n        \n        if(c\
    \ == 's')\n            continue;\n        \n        if(c == 'h')\n           \
    \ continue;\n        \n        if(c == 'l')\n            continue;\n        \n\
    \        if(c == 'd')\n            continue;\n        \n        if(c == 'r')\n\
    \            continue;\n        \n        if(c == 'b')\n            continue;\n\
    \        \n        if(c == 'k')\n            continue;\n        \n        if(c\
    \ == 'm')\n            continue;\n        \n        if(c == 'v')\n           \
    \ continue;\n        \n        if(c == 'w')\n            continue;\n        \n\
    \        if(c == 'f')\n            continue;\n        \n        if(c == 'r')\n\
    \            continue;\n        \n        if(c == 'y')\n            continue;\n\
    \        \n        if(c == 'u')\n            continue;\n        \n        if(c\
    \ == 'g')\n            continue;\n        \n        if(c == 'p')\n           \
    \ continue;\n        \n        if(c == 'b')\n            continue;\n        \n\
    \        if(c == 'm')\n            continue;\n        \n        if(c == 't')\n\
    \            continue;\n        \n        if(c == 's')\n            continue;\n\
    \        \n        if(c == 'k')\n            continue;\n        \n        if(c\
    \ == 'b')\n            continue;\n        \n        if(c == 'a')\n           \
    \ continue;\n        \n        if(c == 'b')\n            continue;\n        \n\
    \        if(c == 'r')\n            continue;\n        \n        if(c == 'k')\n\
    \            continue;\n        \n        if(c == 'h')\n            continue;\n\
    \        \n        if(c == 'a')\n            continue;\n        \n        if(c\
    \ == 'b')\n            continue;\n        \n        if(c == 'r')\n           \
    \ continue;\n        \n        if(c == 'k')\n            continue;\n        \n\
    \        if(c == 'h')\n            continue;\n        \n        if(c == 'a')\n\
    \            continue;\n        \n        if(c == 'b')\n            continue;\n\
    \        \n        if(c == 'r')\n            continue;\n        \n        if(c\
    \ == 'k')\n            continue;\n        \n        if(c == 'h')\n           \
    \ continue;\n        \n        if(c == 'a')\n            continue;\n        \n\
    \        if(c == 'b')\n            continue;\n        \n        if(c == 'r')\n\
    \            continue;\n        \n        if(c == 'k')\n            continue;\n\
    \        \n        if(c == 'h')\n            continue;\n        \n\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmzhx15q5.cpp: In function 'std::vector<std::basic_string<char>\
    \ > select_words(std::string, long int)':\n/tmp/tmpmzhx15q5.cpp:25:15: error:\
    \ ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n     for(auto\
    \ &c: s) {\n               ^\n/tmp/tmpmzhx15q5.cpp:25:18: error: range-based 'for'\
    \ loops are not allowed in C++98 mode\n     for(auto &c: s) {\n              \
    \    ^\n/tmp/tmpmzhx15q5.cpp:163:12: error: a function-definition is not allowed\
    \ here before '{' token\n int main() {\n            ^\n/tmp/tmpmzhx15q5.cpp:172:1:\
    \ error: expected '}' at end of input\n }\n ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    \n    // Write your code here\n    \n    return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk9vxu_a6.cpp: In function 'int main()':\n/tmp/tmpk9vxu_a6.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk9vxu_a6.cpp:2:\n/tmp/tmpk9vxu_a6.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpk9vxu_a6.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmpk9vxu_a6.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmpk9vxu_a6.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpk9vxu_a6.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpk9vxu_a6.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpk9vxu_a6.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    if (s.empty()) {\n        return res;\n    }\n    \n    std::string\
    \ word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ' || c == '\\\
    t' || c == '\\n') {\n            if (word.size() == n) {\n                res.push_back(word);\n\
    \                word = \"\";\n            }\n        } else {\n            word\
    \ += c;\n        }\n    }\n    \n    if (word.size() == n) {\n        res.push_back(word);\n\
    \    }\n    \n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_tyhow2e.cpp: In function 'std::vector<std::basic_string<char>\
    \ > select_words(std::string, long int)':\n/tmp/tmp_tyhow2e.cpp:28:19: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (char c : s)\
    \ {\n                   ^\n/tmp/tmp_tyhow2e.cpp: In function 'int main()':\n/tmp/tmp_tyhow2e.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_tyhow2e.cpp:2:\n/tmp/tmp_tyhow2e.cpp:47:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp_tyhow2e.cpp:47:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp_tyhow2e.cpp:47:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp_tyhow2e.cpp:47:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp_tyhow2e.cpp:47:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_tyhow2e.cpp:47:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    for(auto &c: s) {\n        if(isalpha(c)) {\n            v.push_back((std::string)c);\n\
    \        }\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgjrq_0xs.cpp: In function 'std::vector<std::basic_string<char>\
    \ > select_words(std::string, long int)':\n/tmp/tmpgjrq_0xs.cpp:21:15: error:\
    \ ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n     for(auto\
    \ &c: s) {\n               ^\n/tmp/tmpgjrq_0xs.cpp:21:18: error: range-based 'for'\
    \ loops are not allowed in C++98 mode\n     for(auto &c: s) {\n              \
    \    ^\n/tmp/tmpgjrq_0xs.cpp:23:38: error: invalid conversion from 'int' to 'const\
    \ char*' [-fpermissive]\n             v.push_back((std::string)c);\n         \
    \                             ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmpgjrq_0xs.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpgjrq_0xs.cpp:57:1: error: expected unqualified-id\
    \ before '}' token\n }\n ^\n/tmp/tmpgjrq_0xs.cpp:57:1: error: expected ';' before\
    \ '}' token\n/tmp/tmpgjrq_0xs.cpp: In function 'int main()':\n/tmp/tmpgjrq_0xs.cpp:59:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgjrq_0xs.cpp:2:\n/tmp/tmpgjrq_0xs.cpp:60:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpgjrq_0xs.cpp:60:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    // Write your code here\n    \n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1lk04dso.cpp: In function 'int main()':\n/tmp/tmp1lk04dso.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1lk04dso.cpp:2:\n/tmp/tmp1lk04dso.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp1lk04dso.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp1lk04dso.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1lk04dso.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp1lk04dso.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    // Write your code here\n    \n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1lk04dso.cpp: In function 'int main()':\n/tmp/tmp1lk04dso.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1lk04dso.cpp:2:\n/tmp/tmp1lk04dso.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp1lk04dso.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp1lk04dso.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1lk04dso.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp1lk04dso.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    // Write your code here\n    \n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1lk04dso.cpp: In function 'int main()':\n/tmp/tmp1lk04dso.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1lk04dso.cpp:2:\n/tmp/tmp1lk04dso.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp1lk04dso.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp1lk04dso.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1lk04dso.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp1lk04dso.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    v.push_back(s);\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2_fxqj55.cpp: In function 'int main()':\n/tmp/tmp2_fxqj55.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2_fxqj55.cpp:2:\n/tmp/tmp2_fxqj55.cpp:26:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp2_fxqj55.cpp:26:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp2_fxqj55.cpp:26:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp2_fxqj55.cpp:26:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp2_fxqj55.cpp:26:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp2_fxqj55.cpp:26:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2_fxqj55.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    if (s.empty()) {\n        return result;\n    }\n    \n    // Your\
    \ code here\n    \n    return result;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37datw4r.cpp: In function 'int main()':\n/tmp/tmp37datw4r.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp37datw4r.cpp:2:\n/tmp/tmp37datw4r.cpp:31:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp37datw4r.cpp:31:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp37datw4r.cpp:31:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp37datw4r.cpp:31:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp37datw4r.cpp:31:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp37datw4r.cpp:31:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp37datw4r.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    v.push_back(s);\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2_fxqj55.cpp: In function 'int main()':\n/tmp/tmp2_fxqj55.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2_fxqj55.cpp:2:\n/tmp/tmp2_fxqj55.cpp:26:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp2_fxqj55.cpp:26:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp2_fxqj55.cpp:26:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp2_fxqj55.cpp:26:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp2_fxqj55.cpp:26:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp2_fxqj55.cpp:26:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2_fxqj55.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    \n    // Write your code here\n    \n    return ans;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpixi9bbkb.cpp: In function 'int main()':\n/tmp/tmpixi9bbkb.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpixi9bbkb.cpp:2:\n/tmp/tmpixi9bbkb.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpixi9bbkb.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmpixi9bbkb.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmpixi9bbkb.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpixi9bbkb.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpixi9bbkb.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpixi9bbkb.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    // Write your code here\n    \n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1lk04dso.cpp: In function 'int main()':\n/tmp/tmp1lk04dso.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1lk04dso.cpp:2:\n/tmp/tmp1lk04dso.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp1lk04dso.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp1lk04dso.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1lk04dso.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp1lk04dso.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    // Write your code here\n    \n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1lk04dso.cpp: In function 'int main()':\n/tmp/tmp1lk04dso.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1lk04dso.cpp:2:\n/tmp/tmp1lk04dso.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmp1lk04dso.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmp1lk04dso.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp1lk04dso.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp1lk04dso.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp1lk04dso.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    \n    // Write your code here\n    \n    return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk9vxu_a6.cpp: In function 'int main()':\n/tmp/tmpk9vxu_a6.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk9vxu_a6.cpp:2:\n/tmp/tmpk9vxu_a6.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpk9vxu_a6.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmpk9vxu_a6.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmpk9vxu_a6.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpk9vxu_a6.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpk9vxu_a6.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpk9vxu_a6.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // code here\n\
    \    std::vector<std::string> result;\n    \n    for(auto &i : s)\n    {\n   \
    \     if(isspace(i))\n        {\n            continue;\n        }\n        \n\
    \        for(auto &j : i)\n        {\n            if(j == 'a' || j == 'e' || j\
    \ == 'i' || j == 'o' || j == 'u')\n            {\n                continue;\n\
    \            }\n            \n            if(j == 'n')\n            {\n      \
    \          result.push_back(std::string(\"n\"));\n                continue;\n\
    \            }\n            \n            if(j == 't')\n            {\n      \
    \          result.push_back(std::string(\"t\"));\n                continue;\n\
    \            }\n            \n            if(j == 's')\n            {\n      \
    \          result.push_back(std::string(\"s\"));\n                continue;\n\
    \            }\n            \n            if(j == 'h')\n            {\n      \
    \          result.push_back(std::string(\"h\"));\n                continue;\n\
    \            }\n            \n            if(j == 'r')\n            {\n      \
    \          result.push_back(std::string(\"r\"));\n                continue;\n\
    \            }\n            \n            if(j == 'l')\n            {\n      \
    \          result.push_back(std::string(\"l\"));\n                continue;\n\
    \            }\n            \n            if(j == 'd')\n            {\n      \
    \          result.push_back(std::string(\"d\"));\n                continue;\n\
    \            }\n            \n            if(j == 'c')\n            {\n      \
    \          result.push_back(std::string(\"c\"));\n                continue;\n\
    \            }\n            \n            if(j == 'm')\n            {\n      \
    \          result.push_back(std::string(\"m\"));\n                continue;\n\
    \            }\n            \n            if(j == 'p')\n            {\n      \
    \          result.push_back(std::string(\"p\"));\n                continue;\n\
    \            }\n            \n            if(j == 'f')\n            {\n      \
    \          result.push_back(std::string(\"f\"));\n                continue;\n\
    \            }\n            \n            if(j == 'v')\n            {\n      \
    \          result.push_back(std::string(\"v\"));\n                continue;\n\
    \            }\n            \n            if(j == 'b')\n            {\n      \
    \          result.push_back(std::string(\"b\"));\n                continue;\n\
    \            }\n            \n            if(j == 'y')\n            {\n      \
    \          result.push_back(std::string(\"y\"));\n                continue;\n\
    \            }\n            \n            if(j == 'k')\n            {\n      \
    \          result.push_back(std::string(\"k\"));\n                continue;\n\
    \            }\n            \n            if(j == 'w')\n            {\n      \
    \          result.push_back(std::string(\"w\"));\n                continue;\n\
    \            }\n            \n            if(j == 'g')\n            {\n      \
    \          result.push_back(std::string(\"g\"));\n                continue;\n\
    \            }\n            \n            if(j == 'q')\n            {\n      \
    \          result.push_back(std::string(\"q\"));\n                continue;\n\
    \            }\n            \n            if(j == 'x')\n            {\n      \
    \          result.push_back(std::string(\"x\"));\n                continue;\n\
    \            }\n            \n            if(j == 'z')\n            {\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgt1ssutj.cpp: In function 'std::vector<std::basic_string<char>\
    \ > select_words(std::string, long int)':\n/tmp/tmpgt1ssutj.cpp:23:15: error:\
    \ ISO C++ forbids declaration of 'i' with no type [-fpermissive]\n     for(auto\
    \ &i : s)\n               ^\n/tmp/tmpgt1ssutj.cpp:23:19: error: range-based 'for'\
    \ loops are not allowed in C++98 mode\n     for(auto &i : s)\n               \
    \    ^\n/tmp/tmpgt1ssutj.cpp:30:19: error: ISO C++ forbids declaration of 'j'\
    \ with no type [-fpermissive]\n         for(auto &j : i)\n                   ^\n\
    /tmp/tmpgt1ssutj.cpp:30:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for(auto &j : i)\n                       ^\n/tmp/tmpgt1ssutj.cpp:154:12:\
    \ error: a function-definition is not allowed here before '{' token\n int main()\
    \ {\n            ^\n/tmp/tmpgt1ssutj.cpp:163:1: error: expected '}' at end of\
    \ input\n }\n ^\n/tmp/tmpgt1ssutj.cpp:163:1: error: expected '}' at end of input\n\
    /tmp/tmpgt1ssutj.cpp:163:1: error: expected '}' at end of input\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    for(int i = 0; i < s.length(); i++) {\n        for(int j = 0;\
    \ j < n; j++) {\n            if(s[i] == \" \") {\n                res.push_back(\"\
    \");\n            } else {\n                res.push_back(s[i]);\n           \
    \ }\n        }\n    }\n    \n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6g1q2_7g.cpp: In function 'std::vector<std::basic_string<char>\
    \ > select_words(std::string, long int)':\n/tmp/tmp6g1q2_7g.cpp:24:24: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n    \
    \         if(s[i] == \" \") {\n                        ^\n/tmp/tmp6g1q2_7g.cpp:27:35:\
    \ error: invalid user-defined conversion from 'char' to 'const value_type& {aka\
    \ const std::basic_string<char>&}' [-fpermissive]\n                 res.push_back(s[i]);\n\
    \                                   ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp6g1q2_7g.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ note: candidate is: std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>] <near match>\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5: note:\
    \   no known conversion for argument 1 from 'char' to 'const char*'\n/tmp/tmp6g1q2_7g.cpp:27:35:\
    \ error: invalid conversion from 'char' to 'const char*' [-fpermissive]\n    \
    \             res.push_back(s[i]);\n                                   ^\nIn file\
    \ included from /usr/include/c++/4.8.2/string:53:0,\n                 from /usr/include/c++/4.8.2/bitset:47,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6g1q2_7g.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmp6g1q2_7g.cpp: In function 'int main()':\n/tmp/tmp6g1q2_7g.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     au"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    \n    // Write your code here\n    \n    return result;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl7e76mpn.cpp: In function 'int main()':\n/tmp/tmpl7e76mpn.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl7e76mpn.cpp:2:\n/tmp/tmpl7e76mpn.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpl7e76mpn.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmpl7e76mpn.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmpl7e76mpn.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpl7e76mpn.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpl7e76mpn.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpl7e76mpn.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    \n    if (s.empty()) {\n        return res;\n    }\n    \n    std::string\
    \ word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n      \
    \      if (word.length() == 0) {\n                continue;\n            }\n \
    \           \n            if (word.length() == n) {\n                res.push_back(word);\n\
    \                word = \"\";\n            } else {\n                word += c;\n\
    \            }\n        } else {\n            word += c;\n        }\n    }\n \
    \   \n    if (word.length() > 0) {\n        res.push_back(word);\n    }\n    \n\
    \    return res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg4whmsj5.cpp: In function 'std::vector<std::basic_string<char>\
    \ > select_words(std::string, long int)':\n/tmp/tmpg4whmsj5.cpp:28:19: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (char c : s)\
    \ {\n                   ^\n/tmp/tmpg4whmsj5.cpp: In function 'int main()':\n/tmp/tmpg4whmsj5.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg4whmsj5.cpp:2:\n/tmp/tmpg4whmsj5.cpp:53:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpg4whmsj5.cpp:53:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmpg4whmsj5.cpp:53:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmpg4whmsj5.cpp:53:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpg4whmsj5.cpp:53:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpg4whmsj5.cpp:53:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    \n    // Write your code here\n    \n    return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk9vxu_a6.cpp: In function 'int main()':\n/tmp/tmpk9vxu_a6.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = select_words;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk9vxu_a6.cpp:2:\n/tmp/tmpk9vxu_a6.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n                                                     ^\n/tmp/tmpk9vxu_a6.cpp:28:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                    ^\n/tmp/tmpk9vxu_a6.cpp:28:107:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Mary had a little lamb\"), (4))\
    \ == (std::vector<std::string>({(std::string)\"little\"})));\n               \
    \                                                                            \
    \                ^\n/tmp/tmpk9vxu_a6.cpp:28:107: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpk9vxu_a6.cpp:28:107: error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpk9vxu_a6.cpp:28:107:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpk9vxu_a6.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_"
  stdout: ''
