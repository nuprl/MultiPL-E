name: HumanEval_90_next_smallest
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of integers.\n\
  // Write a function next_smallest() that returns the 2nd smallest element of the\
  \ list.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5,\
  \ (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n\
  // std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n\
  // std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n"
tests: "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5,\
  \ (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>()))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1})))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
  \ (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35,\
  \ (long)34, (long)12, (long)-45}))) == -35);\n}\n"
completions: ["    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (auto i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    }\n        if (i > max) {\n            max = i;\n        }\n    }\n    if\
    \ (min == max) {\n        return std::nullopt;\n    }\n    return max;", "   \
    \ if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    auto it = lst.begin();\n\
    \    auto prev = *it;\n    for (++it; it != lst.end(); ++it) {\n        if (*it\
    \ < prev) {\n            return prev;\n        }\n        prev = *it;\n    }\n\
    \    return prev;", "    long min = lst[0];\n    long max = lst[0];\n    for (long\
    \ i : lst) {\n        if (i < min) {\n            min = i;\n        } else if\
    \ (i > max) {\n            max = i;\n        }\n    }\n    return std::optional<long>(max);",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.begin() + 1);\n    if (second_smallest\
    \ == smallest)\n        return std::nullopt;\n    return second_smallest;", " \
    \   if (lst.empty()) return std::nullopt;\n    long min = lst[0];\n    for (long\
    \ i : lst) {\n        if (i < min) {\n            min = i;\n        }\n    }\n\
    \    return min;", "    long min = lst[0];\n    long max = lst[0];\n    for (long\
    \ i : lst) {\n        if (i < min) {\n            min = i;\n        } else if\
    \ (i > max) {\n            max = i;\n        }\n    }\n    return std::optional<long>(max);",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = lst.begin();\n\
    \    if (*it < lst.front())\n        ++it;\n    auto prev = *it;\n    ++it;\n\
    \    if (it == lst.end())\n        return prev;\n    if (*it < prev)\n       \
    \ ++it;\n    return *it;", "    if(lst.size() == 0)\n        return std::nullopt;\n\
    \    long min = lst[0];\n    long min_index = -1;\n    for(long i = 1; i < lst.size();\
    \ i++) {\n        if(lst[i] < min) {\n            min = lst[i];\n            min_index\
    \ = i;\n        }\n    }\n    return min_index == lst.size() - 1 ? std::nullopt\
    \ : lst[min_index + 1];", "    long min = lst[0];\n    long max = lst[0];\n  \
    \  for (long i : lst) {\n        if (i < min) {\n            min = i;\n      \
    \  } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return max;", "    long\
    \ min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (auto i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return std::optional<long>(min);",
  "    if (lst.empty()) return std::nullopt;\n    auto it = lst.begin();\n    auto\
    \ prev = *it;\n    ++it;\n    if (it == lst.end()) return std::nullopt;\n    auto\
    \ next = *it;\n    if (next < prev) return std::nullopt;\n    return next;", " \
    \   if(lst.size() == 0)\n        return std::nullopt;\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for(long i : lst) {\n        if(i < min)\n      \
    \      min = i;\n        if(i > max)\n            max = i;\n    }\n    return\
    \ std::optional<long>(max);", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    auto it = lst.begin();\n    auto prev = *it;\n    auto next = *it;\n\
    \    for (++it; it != lst.end(); ++it) {\n        if (*it < prev) {\n        \
    \    prev = *it;\n            next = *it;\n        }\n    }\n    return next;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.begin() + 1);\n    return std::optional<long>(second_smallest\
    \ < smallest ? second_smallest : smallest);", "    if(lst.size() == 0) return\
    \ std::nullopt;\n    long smallest = lst[0];\n    long second_smallest = lst[1];\n\
    \    for(long i = 2; i < lst.size(); i++) {\n        if(lst[i] < smallest) {\n\
    \            second_smallest = smallest;\n            smallest = lst[i];\n   \
    \     } else if(lst[i] < second_smallest) {\n            second_smallest = lst[i];\n\
    \        }\n    }\n    return second_smallest;", "    // Write your code here\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n  \
    \      if (i < min) {\n            min = i;\n        } else if (i > max) {\n \
    \           max = i;\n        }\n    }\n    return std::optional<long>(max);",
  "    long smallest = lst[0];\n    long second_smallest = lst[1];\n    for (auto\
    \ i : lst) {\n        if (i < smallest) {\n            second_smallest = smallest;\n\
    \            smallest = i;\n        } else if (i > second_smallest) {\n      \
    \      second_smallest = i;\n        }\n    }\n    return second_smallest == smallest\
    \ ? std::nullopt : second_smallest;", "    if (lst.size() == 0)\n        return\
    \ std::nullopt;\n    auto it = lst.begin();\n    auto prev = *it;\n    if (*it\
    \ == *lst.begin())\n        return std::nullopt;\n    for (++it; it != lst.end();\
    \ ++it) {\n        if (*it < prev)\n            return std::nullopt;\n       \
    \ prev = *it;\n    }\n    return prev;", "    if (lst.empty())\n        return\
    \ std::nullopt;\n    auto it = lst.begin();\n    auto prev = *it;\n    ++it;\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    auto next = *it;\n\
    \    if (next < prev)\n        return std::nullopt;\n    while (next < prev) {\n\
    \        prev = next;\n        ++it;\n        if (it == lst.end())\n         \
    \   return std::nullopt;\n        next = *it;\n    }\n    return prev;", "   \
    \ if (lst.empty()) return std::nullopt;\n    long min = lst[0];\n    long max\
    \ = lst[0];\n    for (long i : lst) {\n        if (i < min) min = i;\n       \
    \ if (i > max) max = i;\n    }\n    return std::optional<long>(max);"]
stop_tokens:
- "\n}"
