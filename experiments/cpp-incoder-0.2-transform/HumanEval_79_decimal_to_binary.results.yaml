language: cpp
name: HumanEval_79_decimal_to_binary
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    binary += \"1\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpdfsd9m7e: /tmp/tmpdfsd9m7e.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter++;\n        remainder = remainder / 2;\n    }\n \
    \   binary = to_string(counter) + binary;\n    binary.insert(0, \"db\");\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprv315_yn.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmprv315_yn.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmprv315_yn.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmprv315_yn.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(counter) + binary;\n      |              ^~~~~~~~~\n\
    \      |              std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprv315_yn.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = remainder + binary;\n  \
    \      remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2yjdkafa.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp2yjdkafa.cpp:18:28: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   18 |         binary = remainder +\
    \ binary;\n      |                  ~~~~~~~~~ ^ ~~~~~~\n      |              \
    \    |           |\n      |                  long int    std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp2yjdkafa.cpp:18:30:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         binary = remainder + binary;\n      |                            \
    \  ^~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     operator+(ty"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 32) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpoqr9nlar: /tmp/tmpoqr9nlar.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 32) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpoqr9nlar: /tmp/tmpoqr9nlar.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder;\n    while (decimal != 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += to_string(remainder);\n\
    \    }\n    binary.insert(binary.begin(), \"db\");\n    return binary;\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp20bb6h2p.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp20bb6h2p.cpp:19:19: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary += to_string(remainder);\n      |                   ^~~~~~~~~\n\
    \      |                   std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp20bb6h2p.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmp20bb6h2p.cpp:21:39: error: no matching\
    \ function for call to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp20bb6h2p.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_s"
  stdout: ''
  timestamp: 1660115748
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (decimal != 0) {\n        remainder *= 10;\n        decimal -= remainder;\n\
    \        binary += to_string(counter);\n        counter += 1;\n    }\n    binary\
    \ += \"db\";\n    binary += to_string(counter);\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_l945kgs.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp_l945kgs.cpp:20:19: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   20 |         binary += to_string(counter);\n      |                   ^~~~~~~~~\n\
    \      |                   std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_l945kgs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmp_l945kgs.cpp:24:15: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   24 |     binary += to_string(counter);\n      |               ^~~~~~~~~\n\
    \      |               std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_l945kgs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115748
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder;\n    long counter = 1;\n    while (decimal\
    \ != 0) {\n        remainder = decimal % 2;\n        decimal /= 2;\n        binary\
    \ += to_string(remainder);\n        counter *= 2;\n    }\n    std::string db =\
    \ \"db\";\n    binary = db + binary;\n    binary = binary + \"db\";\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4457z9r_.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp4457z9r_.cpp:20:19: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   20 |         binary += to_string(remainder);\n      |                   ^~~~~~~~~\n\
    \      |                   std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp4457z9r_.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115748
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = 0;\n    while (decimal != 0) {\n       \
    \ remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder\
    \ ? \"1\" : \"0\";\n    }\n    binary.insert(binary.begin(), \"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp30qa1xk7.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp30qa1xk7.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp30qa1xk7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115748
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary += \"0\";\n        binary\
    \ += remainder;\n        remainder = remainder / 2;\n    }\n    binary.insert(0,\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp7t0gwacg: /tmp/tmp7t0gwacg.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    long remainder_counter\
    \ = 0;\n    long decimal_counter = 0;\n    long decimal_counter2 = 0;\n    long\
    \ decimal_counter3 = 0;\n    long decimal_counter4 = 0;\n    long decimal_counter5\
    \ = 0;\n    long decimal_counter6 = 0;\n    long decimal_counter7 = 0;\n    long\
    \ decimal_counter8 = 0;\n    long decimal_counter9 = 0;\n    long decimal_counter10\
    \ = 0;\n    long decimal_counter11 = 0;\n    long decimal_counter12 = 0;\n   \
    \ long decimal_counter13 = 0;\n    long decimal_counter14 = 0;\n    long decimal_counter15\
    \ = 0;\n    long decimal_counter16 = 0;\n    long decimal_counter17 = 0;\n   \
    \ long decimal_counter18 = 0;\n    long decimal_counter19 = 0;\n    long decimal_counter20\
    \ = 0;\n    long decimal_counter21 = 0;\n    long decimal_counter22 = 0;\n   \
    \ long decimal_counter23 = 0;\n    long decimal_counter24 = 0;\n    long decimal_counter25\
    \ = 0;\n    long decimal_counter26 = 0;\n    long decimal_counter27 = 0;\n   \
    \ long decimal_counter28 = 0;\n    long decimal_counter29 = 0;\n    long decimal_counter30\
    \ = 0;\n    long decimal_counter31 = 0;\n    long decimal_counter32 = 0;\n   \
    \ long decimal_counter33 = 0;\n    long decimal_counter34 = 0;\n    long decimal_counter35\
    \ = 0;\n    long decimal_counter36 = 0;\n    long decimal_counter37 = 0;\n   \
    \ long decimal_counter38 = 0;\n    long decimal_counter39 = 0;\n    long decimal_counter40\
    \ = 0;\n    long decimal_counter41 = 0;\n    long decimal_counter42 = 0;\n   \
    \ long decimal_counter43 = 0;\n    long decimal_counter44 = 0;\n    long decimal_counter45\
    \ = 0;\n    long decimal_counter46 = 0;\n    long decimal_counter47 = 0;\n   \
    \ long decimal_counter48 = 0;\n    long decimal_counter49 = 0;\n    long decimal_counter50\
    \ = 0;\n    long decimal_counter51 = 0;\n    long decimal_counter52 = 0;\n   \
    \ long decimal_counter53 = 0;\n    long decimal_counter54 = 0;\n    long decimal_counter55\
    \ = 0;\n    long decimal_counter56 = 0;\n    long decimal_counter57 = 0;\n   \
    \ long decimal_counter58 = 0;\n    long decimal_counter59 = 0;\n    long decimal_counter60\
    \ = 0;\n    long decimal_counter61 = 0;\n    long decimal_counter62 = 0;\n   \
    \ long decimal_counter63 = 0;\n    long decimal_counter64 = 0;\n    long decimal_counter65\
    \ = 0;\n    long decimal_counter66 = 0;\n    long decimal_counter67 = 0;\n   \
    \ long decimal_counter68 = 0;\n    long decimal_counter69 = 0;\n    long decimal_counter70\
    \ = 0;\n    long decimal_counter\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8h8yzjhr.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp8h8yzjhr.cpp:89:1: error: expected initializer before \u2018\
    }\u2019 token\n   89 | }\n      | ^\n/tmp/tmp8h8yzjhr.cpp:89:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (decimal != 0) {\n        remainder *= 2;\n        decimal -= remainder;\n \
    \       binary += counter % 2 == 0 ? \"1\" : \"0\";\n        counter /= 2;\n \
    \   }\n    std::string db = \"db\";\n    binary = db + binary;\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpnxze3l2a: /tmp/tmpnxze3l2a.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = decimal;\n    int count = 0;\n    while\
    \ (decimal != 0) {\n        remainder *= 2;\n        count++;\n        decimal\
    \ -= remainder;\n    }\n    binary.resize(count + 2);\n    binary[0] = 'b';\n\
    \    binary[1] = '\\0';\n    int i = 2;\n    while (decimal != 0) {\n        binary[i]\
    \ = '0' + remainder % 2;\n        remainder = remainder / 2;\n        i++;\n \
    \   }\n    return binary + binary[0];\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpbe4o1uqc: /tmp/tmpbe4o1uqc.cpp:35: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpr1z1uq0_: /tmp/tmpr1z1uq0_.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    int i = 0;\n    while (decimal\
    \ != 0) {\n        remainder *= 2;\n        if (remainder >= 10) {\n         \
    \   binary += \"1\";\n            remainder -= 10;\n        } else {\n       \
    \     binary += \"0\";\n        }\n        decimal -= remainder;\n        i++;\n\
    \    }\n    std::string result = \"\";\n    result += binary;\n    result += \"\
    db\";\n    result += binary;\n    return result;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpyy4lj6fh: /tmp/tmpyy4lj6fh.cpp:36: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter++;\n    }\n \
    \   binary = std::to_string(counter) + binary;\n    binary = binary + \"db\";\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp53oxpadn: /tmp/tmp53oxpadn.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 1;\n    long remainder2;\n\
    \    long counter2 = 1;\n    long remainder3;\n    long counter3 = 1;\n    long\
    \ remainder4;\n    long counter4 = 1;\n    long remainder5;\n    long counter5\
    \ = 1;\n    long remainder6;\n    long counter6 = 1;\n    long remainder7;\n \
    \   long counter7 = 1;\n    long remainder8;\n    long counter8 = 1;\n    long\
    \ remainder9;\n    long counter9 = 1;\n    long remainder10;\n    long counter10\
    \ = 1;\n    long remainder11;\n    long counter11 = 1;\n    long remainder12;\n\
    \    long counter12 = 1;\n    long remainder13;\n    long counter13 = 1;\n   \
    \ long remainder14;\n    long counter14 = 1;\n    long remainder15;\n    long\
    \ counter15 = 1;\n    long remainder16;\n    long counter16 = 1;\n    long remainder17;\n\
    \    long counter17 = 1;\n    long remainder18;\n    long counter18 = 1;\n   \
    \ long remainder19;\n    long counter19 = 1;\n    long remainder20;\n    long\
    \ counter20 = 1;\n    long remainder21;\n    long counter21 = 1;\n    long remainder22;\n\
    \    long counter22 = 1;\n    long remainder23;\n    long counter23 = 1;\n   \
    \ long remainder24;\n    long counter24 = 1;\n    long remainder25;\n    long\
    \ counter25 = 1;\n    long remainder26;\n    long counter26 = 1;\n    long remainder27;\n\
    \    long counter27 = 1;\n    long remainder28;\n    long counter28 = 1;\n   \
    \ long remainder29;\n    long counter29 = 1;\n    long remainder30;\n    long\
    \ counter30 = 1;\n    long remainder31;\n    long counter31 = 1;\n    long remainder32;\n\
    \    long counter32 = 1;\n    long remainder33;\n    long counter33 = 1;\n   \
    \ long remainder34;\n    long counter34 = 1;\n    long remainder35;\n    long\
    \ counter35 = 1;\n    long remainder36;\n    long counter36 = 1;\n    long remainder37;\n\
    \    long counter37 = 1;\n    long remainder38;\n    long counter38 = 1;\n   \
    \ long remainder39;\n    long counter39 = 1;\n    long remainder40;\n    long\
    \ counter40 = 1;\n    long remainder41;\n    \n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp1vx8n4zu: /tmp/tmp1vx8n4zu.cpp:100: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpj_nc2sda: /tmp/tmpj_nc2sda.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary += \"0\" + std::to_string(remainder);\n\
    \        remainder = remainder / 2;\n    }\n    binary.insert(binary.begin(),\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8mgxmg3m.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp8mgxmg3m.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8mgxmg3m.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115748
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (decimal != 0) {\n        remainder *= 2;\n        decimal -= remainder;\n \
    \       counter += 1;\n    }\n    binary = std::to_string(counter);\n    binary.insert(0,\
    \ \"db\");\n    binary.insert(0, std::to_string(remainder));\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp4q1ipfgi: /tmp/tmp4q1ipfgi.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter++;\n        remainder = remainder / 2;\n    }\n \
    \   binary = to_string(counter) + binary;\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnmcecexe.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpnmcecexe.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnmcecexe.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpnmcecexe.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(counter) + binary;\n      |              ^~~~~~~~~\n\
    \      |              std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnmcecexe.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder *= 2;\n        counter += 1;\n    }\n \
    \   binary = std::to_string(counter);\n    binary.insert(0, \"db\");\n    binary.insert(0,\
    \ std::to_string(remainder));\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpvu259qkg: /tmp/tmpvu259qkg.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0){\n        binary += \"0\";\n       \
    \ decimal %= 2;\n    }\n    binary.insert(binary.begin(), \"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf8y8a8of.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpf8y8a8of.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpf8y8a8of.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = std::to_string(decimal)\
    \ + binary;\n    binary = binary + \"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpdord5bt7: /tmp/tmpdord5bt7.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = binary + \"db\";\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp0734zgtr: /tmp/tmp0734zgtr.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary += decimal%2;\n  \
    \      decimal /= 2;\n    }\n    binary.insert(binary.begin(), 'b');\n    binary.insert(binary.end(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpdxvevshl: /tmp/tmpdxvevshl.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = remainder + binary;\n  \
    \      remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2yjdkafa.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp2yjdkafa.cpp:18:28: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   18 |         binary = remainder +\
    \ binary;\n      |                  ~~~~~~~~~ ^ ~~~~~~\n      |              \
    \    |           |\n      |                  long int    std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp2yjdkafa.cpp:18:30:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         binary = remainder + binary;\n      |                            \
    \  ^~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     operator+(ty"
  stdout: ''
  timestamp: 1660115681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        binary = to_string(remainder) + binary;\n        remainder = remainder\
    \ % 2;\n    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt035pgel.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpt035pgel.cpp:17:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   17 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpt035pgel.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    long digit;\n    long\
    \ power = 1;\n    long power2 = 1;\n    long power3 = 1;\n    long power4 = 1;\n\
    \    long power5 = 1;\n    long power6 = 1;\n    long power7 = 1;\n    long power8\
    \ = 1;\n    long power9 = 1;\n    long power10 = 1;\n    long power11 = 1;\n \
    \   long power12 = 1;\n    long power13 = 1;\n    long power14 = 1;\n    long\
    \ power15 = 1;\n    long power16 = 1;\n    long power17 = 1;\n    long power18\
    \ = 1;\n    long power19 = 1;\n    long power20 = 1;\n    long power21 = 1;\n\
    \    long power22 = 1;\n    long power23 = 1;\n    long power24 = 1;\n    long\
    \ power25 = 1;\n    long power26 = 1;\n    long power27 = 1;\n    long power28\
    \ = 1;\n    long power29 = 1;\n    long power30 = 1;\n    long power31 = 1;\n\
    \    long power32 = 1;\n    long power33 = 1;\n    long power34 = 1;\n    long\
    \ power35 = 1;\n    long power36 = 1;\n    long power37 = 1;\n    long power38\
    \ = 1;\n    long power39 = 1;\n    long power40 = 1;\n    long power41 = 1;\n\
    \    long power42 = 1;\n    long power43 = 1;\n    long power44 = 1;\n    long\
    \ power45 = 1;\n    long power46 = 1;\n    long power47 = 1;\n    long power48\
    \ = 1;\n    long power49 = 1;\n    long power50 = 1;\n    long power51 = 1;\n\
    \    long power52 = 1;\n    long power53 = 1;\n    long power54 = 1;\n    long\
    \ power55 = 1;\n    long power56 = 1;\n    long power57 = 1;\n    long power58\
    \ = 1;\n    long power59 = 1;\n    long power60 = 1;\n    long power61 = 1;\n\
    \    long power62 = 1;\n    long power63 = 1;\n    long power64 = 1;\n    long\
    \ power65 = 1;\n    long power66 = 1;\n    long power67 = 1;\n    long power68\
    \ = 1;\n    long power69 = 1;\n    long power70 = 1;\n    long power71 = 1;\n\
    \    long power72 = 1;\n    long power73 = 1;\n    long power74 = 1;\n    long\
    \ power75 = 1;\n    long power76 = 1;\n    long power77 = 1;\n    long power78\
    \ = 1;\n    long power79 = 1;\n    long power80 = 1;\n    long power81 = 1;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp193i9fyz: /tmp/tmp193i9fyz.cpp:102: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary += \"0\";\n      \
    \  decimal %= 2;\n    }\n    binary.insert(binary.begin(), \"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo3ji7crz.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpo3ji7crz.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpo3ji7crz.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder;\n    while (decimal != 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += remainder;\n    }\n\
    \    binary.insert(binary.begin(), 'b');\n    binary.insert(binary.end(), 'b');\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmphy4nr1ha: /tmp/tmphy4nr1ha.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter++;\n    }\n \
    \   binary = std::to_string(counter) + binary;\n    binary.insert(0, \"db\");\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp_paqmflf: /tmp/tmp_paqmflf.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    binary += \"1\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpdfsd9m7e: /tmp/tmpdfsd9m7e.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary += \"0\";\n    }\n    binary\
    \ += \"1\";\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpyrwxsye3: /tmp/tmpyrwxsye3.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary += \"0\";\n      \
    \  decimal /= 2;\n    }\n    for(int i = binary.length() - 1; i >= 0; i--) {\n\
    \        if(binary[i] == '1') {\n            binary[i] = '0';\n        } else\
    \ {\n            binary[i] = '1';\n        }\n    }\n    binary.insert(0, \"db\"\
    );\n    binary.append(\"db\");\n    return binary;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpi71p7dqx: /tmp/tmpi71p7dqx.cpp:32: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0){\n        binary += (decimal % 2) +\
    \ '0';\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(), 'b');\n\
    \    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmptoeuwkyg: /tmp/tmptoeuwkyg.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary.push_back((decimal%2)\
    \ + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(), 'b');\n\
    \    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp6exi5_53: /tmp/tmp6exi5_53.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpr1z1uq0_: /tmp/tmpr1z1uq0_.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = binary + \"db\";\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp2wtks__k: /tmp/tmp2wtks__k.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115685
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0){\n        binary += \"0\";\n       \
    \ decimal /= 2;\n    }\n    binary = binary + \"1\";\n    binary.insert(0, \"\
    db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpkdkectq3: /tmp/tmpkdkectq3.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary += decimal%2;\n \
    \       decimal /= 2;\n    }\n    binary.insert(binary.begin(), \"db\");\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpatam7ahi.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpatam7ahi.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpatam7ahi.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long digit;\n    long count = 0;\n    long\
    \ base = 1;\n    long temp;\n    while (decimal != 0) {\n        remainder = decimal\
    \ % base;\n        digit = decimal / base;\n        binary.push_back('0');\n \
    \       if (remainder > 0) {\n            binary.push_back('1');\n        }\n\
    \        decimal -= remainder;\n        temp = digit;\n        base = base * 2;\n\
    \        count += 1;\n    }\n    binary.insert(binary.begin(), 'd');\n    binary.insert(binary.end(),\
    \ std::to_string(count).c_str());\n    return binary;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpenlft25e.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpenlft25e.cpp:33:62: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char*)\u2019\n   33 |     binary.insert(binary.end(), std::to_string(count).c_str());\n\
    \      |                                                              ^\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpenlft25e.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_typ"
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder *= 2;\n        binary += \"1\";\n    }\n    while (remainder\
    \ != 0) {\n        remainder /= 2;\n        binary += \"0\";\n    }\n    binary.insert(0,\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp7yzeheog: /tmp/tmp7yzeheog.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary += \"0\";\n    }\n    binary\
    \ += \"1\";\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpyrwxsye3: /tmp/tmpyrwxsye3.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 8) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpn3qbzcjt: /tmp/tmpn3qbzcjt.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary += \"0\";\n     \
    \   decimal /= 2;\n    }\n    while (binary.length() < 8) {\n        binary +=\
    \ \"0\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpczfq30qy: /tmp/tmpczfq30qy.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder *= 2;\n        counter += 1;\n    }\n \
    \   binary.append(\"db\");\n    while (counter > 0) {\n        binary.append(\"\
    0\");\n        counter -= 1;\n    }\n    binary.append(remainder);\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo7zg31s4.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpo7zg31s4.cpp:26:28: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::append(long int&)\u2019\n   26 |\
    \     binary.append(remainder);\n      |                            ^\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpo7zg31s4.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1267:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::append(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019 <near match>\n 1267 |       append(const\
    \ _CharT* __s)\n      |       ^~~~~~\n/usr/include/c++/9/bits/basic_string.h:1267:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmpo7zg31s4.cpp:26:19:\
    \ error: invalid conversion from \u2018long int\u2019 to \u2018const char*\u2019\
    \ [-fpermissive]\n   26 |     binary.append(remainder);\n      |             \
    \      ^~~~~~~~~\n      |                   |\n      |                   long\
    \ int\nIn file included from /usr/include/c++/9/string:55,\n                 from\
    \ /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c+"
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 32) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpoqr9nlar: /tmp/tmpoqr9nlar.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (decimal != 0) {\n        remainder = decimal % 2;\n        decimal /= 2;\n\
    \        binary += (remainder == 1) ? \"1\" : \"0\";\n        counter++;\n   \
    \ }\n    binary = std::string(counter, 'b') + binary;\n    return binary + \"\
    db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpxj786swe: /tmp/tmpxj786swe.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115750
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    binary += \"1\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpdfsd9m7e: /tmp/tmpdfsd9m7e.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary += \"0\";\n      \
    \  decimal /= 2;\n    }\n    binary.insert(binary.begin(), \"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc750zv_s.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpc750zv_s.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpc750zv_s.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        counter++;\n        remainder = remainder / 2;\n    }\n \
    \   binary = std::to_string(counter) + binary;\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpiemdlqwm: /tmp/tmpiemdlqwm.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    long digit;\n    long\
    \ remainder2;\n    long counter2 = 0;\n    long digit2;\n    long remainder3;\n\
    \    long counter3 = 0;\n    long digit3;\n    long remainder4;\n    long counter4\
    \ = 0;\n    long digit4;\n    long remainder5;\n    long counter5 = 0;\n    long\
    \ digit5;\n    long remainder6;\n    long counter6 = 0;\n    long digit6;\n  \
    \  long remainder7;\n    long counter7 = 0;\n    long digit7;\n    long remainder8;\n\
    \    long counter8 = 0;\n    long digit8;\n    long remainder9;\n    long counter9\
    \ = 0;\n    long digit9;\n    long remainder10;\n    long counter10 = 0;\n   \
    \ long digit10;\n    long remainder11;\n    long counter11 = 0;\n    long digit11;\n\
    \    long remainder12;\n    long counter12 = 0;\n    long digit12;\n    long remainder13;\n\
    \    long counter13 = 0;\n    long digit13;\n    long remainder14;\n    long counter14\
    \ = 0;\n    long digit14;\n    long remainder15;\n    long counter15 = 0;\n  \
    \  long digit15;\n    long remainder16;\n    long counter16 = 0;\n    long digit16;\n\
    \    long remainder17;\n    long counter17 = 0;\n    long digit17;\n    long remainder18;\n\
    \    long counter18 = 0;\n    long digit18;\n    long remainder19;\n    long counter19\
    \ = 0;\n    long digit19;\n    long remainder20;\n    long counter20 = 0;\n  \
    \  long digit20;\n    long remainder21;\n    long counter21 = 0;\n    long digit21;\n\
    \    long remainder22;\n    long counter22 = 0;\n    long digit22;\n    long remainder23;\n\
    \    long counter23 = 0;\n    long digit23;\n    long remainder24;\n    long counter24\
    \ = 0;\n    long digit24;\n    long remainder25;\n    long counter25 = 0;\n  \
    \  long digit25;\n    long remainder26;\n    long counter26 = 0;\n    long digit26;\n\
    \    long remainder27;\n    long counter27 = 0;\n    long digit27;\n    long remainder28;\n\
    \    long counter28 = 0;\n    long digit28;\n    long remainder29;\n    long counter29\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpfv3usx_r: /tmp/tmpfv3usx_r.cpp:105: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = std::to_string(decimal)\
    \ + binary;\n    binary = binary + \"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpc0141hta: /tmp/tmpc0141hta.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (remainder != 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter++;\n        remainder = remainder / 2;\n    }\n \
    \   binary = to_string(counter) + \"db\" + binary;\n    return binary;\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplz_6rumd.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmplz_6rumd.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmplz_6rumd.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmplz_6rumd.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(counter) + \"db\" + binary;\n      |       \
    \       ^~~~~~~~~\n      |              std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmplz_6rumd.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter++;\n    }\n \
    \   binary = to_string(counter) + binary;\n    binary = binary + \"db\";\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr0r00zx7.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpr0r00zx7.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpr0r00zx7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpr0r00zx7.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(counter) + binary;\n      |              ^~~~~~~~~\n\
    \      |              std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpr0r00zx7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder;\n    while (decimal != 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += remainder;\n    }\n\
    \    binary.insert(binary.begin(), 'b');\n    binary.insert(binary.end(), 'b');\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmptpjiugmh: /tmp/tmptpjiugmh.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.size() < 8) {\n        binary += \"\
    1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp89wpdvw9: /tmp/tmp89wpdvw9.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary.push_back(remainder);\n  \
    \      remainder = remainder / 2;\n    }\n    binary.push_back(remainder);\n \
    \   binary.insert(binary.begin(), \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdc6gexml.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpdc6gexml.cpp:22:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   22 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdc6gexml.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpr1z1uq0_: /tmp/tmpr1z1uq0_.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder\
    \ ? \"1\" : \"0\";\n    }\n    binary = binary + \"db\";\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp8ykz7zcc: /tmp/tmp8ykz7zcc.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    while (decimal != 0)\
    \ {\n        remainder = decimal % 2;\n        decimal = decimal / 2;\n      \
    \  binary.push_back(remainder);\n        counter++;\n    }\n    binary.insert(binary.begin(),\
    \ \"db\");\n    binary.insert(binary.end(), counter, '0');\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb5wgynln.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpb5wgynln.cpp:23:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   23 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpb5wgynln.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    long temp = 0;\n  \
    \  while (decimal != 0) {\n        remainder = decimal % 2;\n        decimal =\
    \ decimal / 2;\n        temp = remainder * counter;\n        binary.push_back(temp\
    \ % 2);\n        counter = temp / 2;\n    }\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp8h88goze: /tmp/tmp8h88goze.cpp:31: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter = counter + 1;\n\
    \    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkz1r_xez.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkz1r_xez.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpkz1r_xez.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115684
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long quotient;\n    long digit;\n    long\
    \ power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits = 1;\n\
    \    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits\
    \ = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long\
    \ digits = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n\
    \    long digits = 1;\n    long power = 1;\n    long digits = 1;\n    long power\
    \ = 1;\n    long digits = 1;\n    long power = 1;\n    long digits = 1;\n    long\
    \ power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits = 1;\n\
    \    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits\
    \ = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long\
    \ digits = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n\
    \    long digits = 1;\n    long power = 1;\n    long digits = 1;\n    long power\
    \ = 1;\n    long digits = 1;\n    long power = 1;\n    long digits = 1;\n    long\
    \ power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits = 1;\n\
    \    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits\
    \ = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long\
    \ digits = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n\
    \    long digits = 1;\n    long power = 1;\n    long digits = 1;\n    long power\
    \ = 1;\n    long digits = 1;\n    long power = 1;\n    long digits = 1;\n    long\
    \ power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits = 1;\n\
    \    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long digits\
    \ = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n    long\
    \ digits = 1;\n    long power = 1;\n    long digits = 1;\n    long power = 1;\n\
    \    long digits = \n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgpk70_b5.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpgpk70_b5.cpp:20:10: error: redeclaration of \u2018long\
    \ int power\u2019\n   20 |     long power = 1;\n      |          ^~~~~\n/tmp/tmpgpk70_b5.cpp:18:10:\
    \ note: \u2018long int power\u2019 previously declared here\n   18 |     long\
    \ power = 1;\n      |          ^~~~~\n/tmp/tmpgpk70_b5.cpp:21:10: error: redeclaration\
    \ of \u2018long int digits\u2019\n   21 |     long digits = 1;\n      |      \
    \    ^~~~~~\n/tmp/tmpgpk70_b5.cpp:19:10: note: \u2018long int digits\u2019 previously\
    \ declared here\n   19 |     long digits = 1;\n      |          ^~~~~~\n/tmp/tmpgpk70_b5.cpp:22:10:\
    \ error: redeclaration of \u2018long int power\u2019\n   22 |     long power =\
    \ 1;\n      |          ^~~~~\n/tmp/tmpgpk70_b5.cpp:18:10: note: \u2018long int\
    \ power\u2019 previously declared here\n   18 |     long power = 1;\n      | \
    \         ^~~~~\n/tmp/tmpgpk70_b5.cpp:23:10: error: redeclaration of \u2018long\
    \ int digits\u2019\n   23 |     long digits = 1;\n      |          ^~~~~~\n/tmp/tmpgpk70_b5.cpp:19:10:\
    \ note: \u2018long int digits\u2019 previously declared here\n   19 |     long\
    \ digits = 1;\n      |          ^~~~~~\n/tmp/tmpgpk70_b5.cpp:24:10: error: redeclaration\
    \ of \u2018long int power\u2019\n   24 |     long power = 1;\n      |        \
    \  ^~~~~\n/tmp/tmpgpk70_b5.cpp:18:10: note: \u2018long int power\u2019 previously\
    \ declared here\n   18 |     long power = 1;\n      |          ^~~~~\n/tmp/tmpgpk70_b5.cpp:25:10:\
    \ error: redeclaration of \u2018long int digits\u2019\n   25 |     long digits\
    \ = 1;\n      |          ^~~~~~\n/tmp/tmpgpk70_b5.cpp:19:10: note: \u2018long\
    \ int digits\u2019 previously declared here\n   19 |     long digits = 1;\n  \
    \    |          ^~~~~~\n/tmp/tmpgpk70_b5.cpp:26:10: error: redeclaration of \u2018\
    long int power\u2019\n   26 |     long power = 1;\n      |          ^~~~~\n/tmp/tmpgpk70_b5.cpp:18:10:\
    \ note: \u2018long int power\u2019 previously declared here\n   18 |     long\
    \ power = 1;\n      |          ^~~~~\n/tmp/tmpgpk70_b5.cpp:27:10: error: redeclaration\
    \ of \u2018long int digits\u2019\n   27 |     long digits = 1;\n      |      \
    \    ^~~~~~\n/tmp/tmpgpk70_b5.cpp:19:10: note: \u2018"
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = to_string(remainder) + binary;\n\
    \        remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n  \
    \  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkr1blxy6.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkr1blxy6.cpp:18:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpkr1blxy6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary += \"0\";\n      \
    \  decimal /= 2;\n    }\n    binary = binary + \"1\";\n    return binary;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpcmezqf7c: /tmp/tmpcmezqf7c.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = 0;\n    while (decimal != 0) {\n       \
    \ remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder\
    \ ? \"1\" : \"0\";\n    }\n    std::string db = \"db\";\n    binary = db + binary;\n\
    \    binary = binary + \"db\";\n    return binary;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp_7fv_n8r: /tmp/tmp_7fv_n8r.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpr1z1uq0_: /tmp/tmpr1z1uq0_.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = 0;\n    while (decimal != 0) {\n       \
    \ remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder;\n\
    \    }\n    binary.insert(binary.begin(), \"db\");\n    return binary;\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37mpx81v.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp37mpx81v.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp37mpx81v.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115748
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = remainder + binary;\n  \
    \      remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2yjdkafa.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp2yjdkafa.cpp:18:28: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   18 |         binary = remainder +\
    \ binary;\n      |                  ~~~~~~~~~ ^ ~~~~~~\n      |              \
    \    |           |\n      |                  long int    std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp2yjdkafa.cpp:18:30:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         binary = remainder + binary;\n      |                            \
    \  ^~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     operator+(ty"
  stdout: ''
  timestamp: 1660115681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += to_string(remainder);\n\
    \    }\n    binary.insert(binary.begin(), \"db\");\n    return binary;\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphcuc9aj_.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmphcuc9aj_.cpp:19:19: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary += to_string(remainder);\n      |                   ^~~~~~~~~\n\
    \      |                   std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmphcuc9aj_.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmphcuc9aj_.cpp:21:39: error: no matching\
    \ function for call to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmphcuc9aj_.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_s"
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter++;\n        remainder = remainder / 2;\n    }\n \
    \   binary = to_string(counter) + binary;\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnmcecexe.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpnmcecexe.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnmcecexe.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpnmcecexe.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(counter) + binary;\n      |              ^~~~~~~~~\n\
    \      |              std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnmcecexe.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqpypy1vh.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpqpypy1vh.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqpypy1vh.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter++;\n        remainder = remainder / 2;\n    }\n \
    \   binary = to_string(counter) + binary;\n    binary.insert(0, \"db\");\n   \
    \ binary.append(\"db\");\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyxtnqf8s.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpyxtnqf8s.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpyxtnqf8s.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpyxtnqf8s.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(counter) + binary;\n      |              ^~~~~~~~~\n\
    \      |              std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpyxtnqf8s.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115748
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    binary += \"1\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpdfsd9m7e: /tmp/tmpdfsd9m7e.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        int remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        binary += remainder;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp8hr2p2l7: /tmp/tmp8hr2p2l7.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0){\n        binary += decimal%2;\n   \
    \     decimal /= 2;\n    }\n    binary.insert(0, \"db\");\n    binary.append(\"\
    db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp1ets8vc7: /tmp/tmp1ets8vc7.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder\
    \ ? \"1\" : \"0\";\n    }\n    std::string db = \"db\";\n    binary = db + binary;\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpm4jyp4q1: /tmp/tmpm4jyp4q1.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = binary + \"db\";\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp2wtks__k: /tmp/tmp2wtks__k.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115685
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    while (decimal != 0)\
    \ {\n        remainder = decimal % 2;\n        decimal = decimal / 2;\n      \
    \  binary.push_back(remainder);\n        counter++;\n    }\n    binary.insert(binary.begin(),\
    \ \"db\");\n    binary.insert(binary.end(), counter, '0');\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb5wgynln.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpb5wgynln.cpp:23:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   23 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpb5wgynln.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = to_string(remainder) + binary;\n\
    \        remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n  \
    \  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkr1blxy6.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkr1blxy6.cpp:18:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpkr1blxy6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115679
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter = counter + 1;\n\
    \    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660115684
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = to_string(remainder) + binary;\n\
    \        remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n  \
    \  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkr1blxy6.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkr1blxy6.cpp:18:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpkr1blxy6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = 0;\n    while (decimal != 0) {\n       \
    \ remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder;\n\
    \    }\n    binary.insert(binary.begin(), 'b');\n    binary.insert(binary.end(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaeeezkjz: /tmp/tmpaeeezkjz.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary += \"0\";\n     \
    \   decimal /= 2;\n    }\n    binary.insert(binary.begin(), \"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3kc8j5ly.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp3kc8j5ly.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp3kc8j5ly.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"1\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.size() < 32) {\n        binary += \"\
    0\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmphwnjzabv: /tmp/tmphwnjzabv.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder\
    \ ? \"1\" : \"0\";\n    }\n    binary.insert(0, \"db\");\n    binary.append(\"\
    db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpm_6yung8: /tmp/tmpm_6yung8.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter = counter * 2;\n        remainder = remainder / 2;\n\
    \    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8eucpiaa.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp8eucpiaa.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp8eucpiaa.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpr1z1uq0_: /tmp/tmpr1z1uq0_.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter++;\n        remainder = remainder / 2;\n    }\n \
    \   binary = to_string(counter) + binary;\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnmcecexe.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpnmcecexe.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnmcecexe.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpnmcecexe.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(counter) + binary;\n      |              ^~~~~~~~~\n\
    \      |              std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnmcecexe.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder *= 2;\n        binary += \"1\";\n    }\n    binary += \"0\"\
    ; // add extra zero at the end\n    while (binary.size() < 32) {\n        binary\
    \ += \"0\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate =\
    \ decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpe4kuh2eo: /tmp/tmpe4kuh2eo.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary += (decimal % 2) +\
    \ '0';\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(), 'b');\n\
    \    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpm7os6x00: /tmp/tmpm7os6x00.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (remainder > 0) {\n        counter++;\n        remainder = remainder % 2;\n\
    \        binary += (remainder > 0 ? \"1\" : \"0\");\n    }\n    binary = binary\
    \ + \"db\";\n    binary = binary + std::to_string(counter);\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpc62k65uo: /tmp/tmpc62k65uo.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    int digit;\n    while (remainder\
    \ > 0) {\n        digit = remainder % 2;\n        remainder = remainder / 2;\n\
    \        binary = std::to_string(digit) + binary;\n    }\n    binary = std::to_string(digit)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpu9ui_nyi: /tmp/tmpu9ui_nyi.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqpypy1vh.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpqpypy1vh.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqpypy1vh.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        binary = to_string(remainder) + binary;\n        remainder = remainder\
    \ % 2;\n    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt035pgel.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpt035pgel.cpp:17:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   17 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpt035pgel.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder *= 2;\n        binary += counter % 2 ==\
    \ 0 ? \"1\" : \"0\";\n        counter /= 2;\n    }\n    std::string db = \"db\"\
    ;\n    binary = db + binary;\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpg2uiiqql: /tmp/tmpg2uiiqql.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = remainder + binary;\n  \
    \      remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2yjdkafa.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp2yjdkafa.cpp:18:28: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   18 |         binary = remainder +\
    \ binary;\n      |                  ~~~~~~~~~ ^ ~~~~~~\n      |              \
    \    |           |\n      |                  long int    std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp2yjdkafa.cpp:18:30:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         binary = remainder + binary;\n      |                            \
    \  ^~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2yjdkafa.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     operator+(ty"
  stdout: ''
  timestamp: 1660115681
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        binary = to_string(remainder) + binary;\n        remainder = remainder\
    \ % 2;\n    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt035pgel.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpt035pgel.cpp:17:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   17 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpt035pgel.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"1\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 32) {\n        binary +=\
    \ \"0\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpagbk05pu: /tmp/tmpagbk05pu.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (remainder > 0) {\n        remainder *= 2;\n        counter += 1;\n    }\n \
    \   while (counter > 0) {\n        binary += \"1\";\n        counter -= 1;\n \
    \   }\n    binary = \"db\" + binary + \"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpb7xuucmm: /tmp/tmpb7xuucmm.cpp:30: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary.push_back((decimal%2)\
    \ + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(), 'b');\n\
    \    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp6exi5_53: /tmp/tmp6exi5_53.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 1;\n    long remainder_counter\
    \ = 1;\n    long decimal_counter = 1;\n    long decimal_remainder = 1;\n    long\
    \ decimal_remainder_counter = 1;\n    long decimal_remainder_remainder = 1;\n\
    \    long decimal_remainder_remainder_counter = 1;\n    long decimal_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_counter = 1;\n    long\
    \ decimal_remainder_remainder_remainder_remainder = 1;\n    long decimal_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder = 1;\n\
    \    long decimal_remainder_remainder_remainder_remainder_counter = 1;\n    long\
    \ decimal_remainder_remainder_remainder_remainder_remainder_counter = 1;\n   \
    \ long decimal_remainder_remainder_remainder_remainder_remainder_remainder = 1;\n\
    \    long decimal_remainder_remainder_remainder_remainder_remainder_counter =\
    \ 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 1;\n    long decimal_remainder_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n    long decimal_remainder_remainder_remain\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphvgtcyj9.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmphvgtcyj9.cpp:28:10: error: redeclaration of \u2018long\
    \ int decimal_remainder_remainder_remainder_remainder_counter\u2019\n   28 | \
    \    long decimal_remainder_remainder_remainder_remainder_counter = 1;\n     \
    \ |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphvgtcyj9.cpp:26:10:\
    \ note: \u2018long int decimal_remainder_remainder_remainder_remainder_counter\u2019\
    \ previously declared here\n   26 |     long decimal_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphvgtcyj9.cpp:31:10: error: redeclaration of \u2018long int decimal_remainder_remainder_remainder_remainder_remainder_counter\u2019\
    \n   31 |     long decimal_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphvgtcyj9.cpp:29:10: note: \u2018long int decimal_remainder_remainder_remainder_remainder_remainder_counter\u2019\
    \ previously declared here\n   29 |     long decimal_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphvgtcyj9.cpp:34:10: error: redeclaration of \u2018long int decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\u2019\
    \n   34 |     long decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphvgtcyj9.cpp:32:10: note: \u2018long int decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\u2019\
    \ previously declared here\n   32 |     long decimal_remainder_remainder_remainder_remainder_remainder_remainder_counter\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphvgtcyj9.cpp:35:10: error: redeclaration of \u2018long int decimal_remainder_remainder_remainder_remainder_remainder_"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder = decimal;\n    long counter = 1;\n    while (counter\
    \ > 0) {\n        remainder = remainder % 2;\n        binary.push_back(remainder\
    \ + '0');\n        counter /= 2;\n    }\n    binary.push_back('d');\n    binary.push_back('b');\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpivva9mh_: /tmp/tmpivva9mh_.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 1;\n    long temp = decimal;\n\
    \    while(temp > 0) {\n        remainder = temp % 2;\n        temp = temp / 2;\n\
    \        binary.push_back(remainder);\n    }\n    binary.push_back('d');\n   \
    \ binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back('b');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    binary.push_back\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptotdf8l1.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmptotdf8l1.cpp:80:21: error: expected \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   80 |     binary.push_back\n      |                 \
    \    ^\n      |                     ;\n   81 | }\n      | ~                  \
    \  \n/tmp/tmptotdf8l1.cpp:80:12: error: invalid use of non-static member function\
    \ \u2018void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::push_back(_CharT)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n   80 |     binary.push_back\n      |     ~~~~~~~^~~~~~~~~\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptotdf8l1.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1353:7: note:\
    \ declared here\n 1353 |       push_back(_CharT __c)\n      |       ^~~~~~~~~\n\
    /tmp/tmptotdf8l1.cpp:81:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   81 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"1\";\n      \
    \  decimal -= 1;\n    }\n    binary.insert(0, \"db\");\n    return binary;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpqpnletpf: /tmp/tmpqpnletpf.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 32) {\n        binary +=\
    \ \"1\";\n    }\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp13qkuobp: /tmp/tmp13qkuobp.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += (remainder\
    \ ? \"1\" : \"0\");\n    }\n    binary.insert(binary.begin(), \"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprersb4ae.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmprersb4ae.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprersb4ae.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp1rejry8v: /tmp/tmp1rejry8v.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpx_i5d0jr: /tmp/tmpx_i5d0jr.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    long temp = 0;\n  \
    \  long power = 1;\n    long digit;\n    long decimal_temp = decimal;\n    while(decimal_temp\
    \ != 0) {\n        digit = decimal_temp % 2;\n        temp = temp * 10 + digit;\n\
    \        decimal_temp = decimal_temp / 2;\n    }\n    while(counter < temp) {\n\
    \        remainder = temp % 2;\n        temp = temp / 2;\n        binary = binary\
    \ + remainder;\n        counter++;\n    }\n    binary = binary + \"db\";\n   \
    \ while(counter > 0) {\n        remainder = temp % 2;\n        temp = temp / 2;\n\
    \        binary = binary + remainder;\n        counter--;\n    }\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmiqj_93i.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpmiqj_93i.cpp:29:25: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   29 |         binary = binary + remainder;\n  \
    \    |                  ~~~~~~ ^ ~~~~~~~~~\n      |                  |       \
    \ |\n      |                  |        long int\n      |                  std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmiqj_93i.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpmiqj_93i.cpp:29:27:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   29 |         binary = binary + remainder;\n   \
    \   |                           ^~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmiqj_93i.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     operator+(typename move_iterato"
  stdout: ''
  timestamp: 1660115751
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal%2)\
    \ + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(), \"\
    db\");\n    binary.insert(binary.end(), binary.begin(), binary.end());\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp22jcs0ra.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp22jcs0ra.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp22jcs0ra.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115751
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary += (decimal % 2)\
    \ == 0 ? \"1\" : \"0\";\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxuile6c5.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpxuile6c5.cpp:19:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpxuile6c5.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    int digit;\n    bool isNegative = false;\n\
    \    if (decimal < 0) {\n        isNegative = true;\n        decimal = -decimal;\n\
    \    }\n    remainder = 0;\n    while (decimal != 0) {\n        digit = decimal\
    \ % 2;\n        decimal = decimal / 2;\n        remainder = remainder * 10 + digit;\n\
    \    }\n    binary.push_back('0');\n    while (binary.size() < remainder) {\n\
    \        binary.push_back('0');\n    }\n    if (isNegative) {\n        binary.insert(0,\
    \ \"db\");\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpexlkj9wq: /tmp/tmpexlkj9wq.cpp:39: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder;\n    while (decimal > 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += remainder ? \"1\" :\
    \ \"0\";\n    }\n    std::string db = \"db\";\n    binary = db + binary;\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp82boe7jq: /tmp/tmp82boe7jq.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary += \"0\";\n      \
    \  decimal /= 2;\n    }\n    while(binary.length() < 32) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpjmxl202z: /tmp/tmpjmxl202z.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (decimal != 0) {\n        remainder = decimal % 2;\n        decimal /= 2;\n\
    \        binary += (remainder == 1) ? \"1\" : \"0\";\n        counter++;\n   \
    \ }\n    std::string db = \"db\";\n    binary = db + binary;\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmprt7lwehf: /tmp/tmprt7lwehf.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary += (decimal % 2)\
    \ == 0 ? \"1\" : \"0\";\n        decimal /= 2;\n    }\n    binary = \"db\" + binary\
    \ + \"db\";\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpmgzo3s15: /tmp/tmpmgzo3s15.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder *= 2;\n        counter --;\n    }\n    while\
    \ (decimal > remainder) {\n        binary += \"1\";\n        decimal -= remainder;\n\
    \    }\n    binary += \"0\";\n    while (decimal > 0) {\n        binary += \"\
    0\";\n        decimal --;\n    }\n    binary.insert(0, \"db\");\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpkhy_8twl: /tmp/tmpkhy_8twl.cpp:35: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder;\n    while (decimal != 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += remainder ? \"1\" :\
    \ \"0\";\n    }\n    binary.insert(binary.begin(), \"db\");\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpycqeiuzr.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpycqeiuzr.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpycqeiuzr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter = counter * 2;\n\
    \    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp3malhkf3: /tmp/tmp3malhkf3.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal > 0) {\n        binary += \"0\";\n       \
    \ decimal %= 2;\n    }\n    while(decimal > 0) {\n        binary += \"1\";\n \
    \       decimal /= 2;\n    }\n    binary = binary + \"db\";\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpp350g6yx: /tmp/tmpp350g6yx.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder = decimal;\n    while (remainder > 0) {\n      \
    \  remainder *= 2;\n        binary += '1';\n    }\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n    binary += '0';\n    binary\
    \ += '0';\n    binary += '0';\n    binary += '0';\n\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmppw5fhfgj: /tmp/tmppw5fhfgj.cpp:104: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = decimal;\n    int counter = 0;\n    while\
    \ (decimal != 0) {\n        remainder = decimal % 2;\n        decimal /= 2;\n\
    \        binary += to_string(remainder);\n        counter++;\n    }\n    binary.insert(0,\
    \ \"db\");\n    binary.insert(binary.length(), \"db\");\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmrr9jbb2.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpmrr9jbb2.cpp:20:19: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   20 |         binary += to_string(remainder);\n      |                   ^~~~~~~~~\n\
    \      |                   std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpmrr9jbb2.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = binary + \"db\";\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp2wtks__k: /tmp/tmp2wtks__k.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115685
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder = decimal;\n    long counter = 1;\n    while (counter\
    \ > 0) {\n        remainder = remainder % 2;\n        binary.push_back(remainder\
    \ + '0');\n        counter /= 2;\n    }\n    binary.push_back('d');\n    binary.push_back('b');\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpivva9mh_: /tmp/tmpivva9mh_.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.size() < 8) {\n        binary += \"\
    1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp89wpdvw9: /tmp/tmp89wpdvw9.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = binary +\
    \ \"db\";\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp3i8ih2y6: /tmp/tmp3i8ih2y6.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = 0;\n    while (decimal != 0) {\n       \
    \ remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder;\n\
    \    }\n    binary.insert(binary.begin(), 'b');\n    binary.insert(binary.end(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaeeezkjz: /tmp/tmpaeeezkjz.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long digit;\n    long power = 1;\n    long\
    \ i = 0;\n    long remainder2;\n    long remainder3;\n    long remainder4;\n \
    \   long remainder5;\n    long remainder6;\n    long remainder7;\n    long remainder8;\n\
    \    long remainder9;\n    long remainder10;\n    long remainder11;\n    long\
    \ remainder12;\n    long remainder13;\n    long remainder14;\n    long remainder15;\n\
    \    long remainder16;\n    long remainder17;\n    long remainder18;\n    long\
    \ remainder19;\n    long remainder20;\n    long remainder21;\n    long remainder22;\n\
    \    long remainder23;\n    long remainder24;\n    long remainder25;\n    long\
    \ remainder26;\n    long remainder27;\n    long remainder28;\n    long remainder29;\n\
    \    long remainder30;\n    long remainder31;\n    long remainder32;\n    long\
    \ remainder33;\n    long remainder34;\n    long remainder35;\n    long remainder36;\n\
    \    long remainder37;\n    long remainder38;\n    long remainder39;\n    long\
    \ remainder40;\n    long remainder41;\n    long remainder42;\n    long remainder43;\n\
    \    long remainder44;\n    long remainder45;\n    long remainder46;\n    long\
    \ remainder47;\n    long remainder48;\n    long remainder49;\n    long remainder50;\n\
    \    long remainder51;\n    long remainder52;\n    long remainder53;\n    long\
    \ remainder54;\n    long remainder55;\n    long remainder56;\n    long remainder57;\n\
    \    long remainder58;\n    long remainder59;\n    long remainder60;\n    long\
    \ remainder61;\n    long remainder62;\n    long remainder63;\n    long remainder64;\n\
    \    long remainder65;\n    long remainder66;\n    long remainder67;\n    long\
    \ remainder68;\n    long remainder69;\n    long remainder70;\n    long remainder71;\n\
    \    long remainder72;\n    long remainder73;\n    \n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpumkqxd2r: /tmp/tmpumkqxd2r.cpp:95: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder;\n    while (decimal != 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += remainder ? \"1\" :\
    \ \"0\";\n    }\n    binary.insert(0, \"db\");\n    binary.append(\"db\");\n \
    \   return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpnoslf0ao: /tmp/tmpnoslf0ao.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal = decimal / 2;\n        binary +=\
    \ to_string(remainder);\n    }\n    binary.insert(0, \"db\");\n    binary.append(\"\
    db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnhb9jf40.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpnhb9jf40.cpp:19:19: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary += to_string(remainder);\n      |                   ^~~~~~~~~\n\
    \      |                   std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnhb9jf40.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder = decimal;\n    long counter = 0;\n    while (remainder\
    \ > 0) {\n        counter++;\n        remainder = remainder % 2;\n    }\n    binary.resize(counter);\n\
    \    long counter2 = 0;\n    while (remainder > 0) {\n        binary[counter2]\
    \ = remainder % 2;\n        remainder = remainder / 2;\n        counter2++;\n\
    \    }\n    binary.insert(binary.begin(), 'b');\n    binary.insert(binary.end(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpc8xn5ai6: /tmp/tmpc8xn5ai6.cpp:34: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 1;\n    long temp;\n    while\
    \ (decimal != 0) {\n        remainder = decimal % 2;\n        decimal = decimal\
    \ / 2;\n        temp = remainder * counter;\n        binary.push_back((char)(temp\
    \ + '0'));\n        counter = counter * 2;\n    }\n    binary.push_back('d');\n\
    \    binary.push_back('b');\n    binary.push_back('b');\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmph7xub0_c: /tmp/tmph7xub0_c.cpp:32: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 1;\n    long temp = decimal;\n\
    \    while(temp != 0) {\n        remainder = temp % 2;\n        temp = temp /\
    \ 2;\n        binary.push_back(remainder);\n        counter++;\n    }\n    binary.insert(binary.begin(),\
    \ \"db\");\n    binary.insert(binary.end(), counter);\n    return binary;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgima2nmw.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpgima2nmw.cpp:24:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   24 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpgima2nmw.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115751
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (remainder != 0) {\n        remainder *= 2;\n        counter += 1;\n    }\n\
    \    std::string binary_string = std::to_string(counter);\n    std::string binary_string_reversed\
    \ = binary_string[binary_string.length() - 1];\n    binary_string_reversed = binary_string_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed = binary_string_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed_reversed = binary_string_reversed_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed + \"b\";\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed + \"b\";\n    std::string\
    \ binary_string_reversed_reversed_reversed_reversed_reversed_reversed = binary_string_reversed_reversed_reversed_reversed_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed + \"b\"\
    ;\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed + \"b\"\
    ;\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + \"b\";\n    std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed + \"b\"\
    ;\n    std::string binary_string_reversed_reversed_reversed_reversed_\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3i8mi34q.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp3i8mi34q.cpp:22:82: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   22 |     std::string\
    \ binary_string_reversed = binary_string[binary_string.length() - 1];\n      |\
    \                                                                            \
    \      ^\n/tmp/tmp3i8mi34q.cpp:30:17: error: redeclaration of \u2018std::string\
    \ binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   30 |     std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed + \"b\"\
    ;\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3i8mi34q.cpp:29:17: note: \u2018std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   29 |     std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed + \"b\"\
    ;\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3i8mi34q.cpp:32:17: error: redeclaration of \u2018std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   32 |     std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + \"b\";\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3i8mi34q.cpp:31:17: note: \u2018std::string binary_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   31 |     std::string binary_string_reversed_reversed_reversed_rev"
  stdout: ''
  timestamp: 1660115751
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter = counter + 1;\n\
    \    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkz1r_xez.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkz1r_xez.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpkz1r_xez.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115684
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    int count = 0;\n    while\
    \ (decimal != 0) {\n        remainder = decimal % 2;\n        decimal /= 2;\n\
    \        binary = to_string(remainder) + binary;\n        count++;\n    }\n  \
    \  binary = to_string(count) + \"db\" + binary;\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp25djm6va.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp25djm6va.cpp:20:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   20 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp25djm6va.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmp25djm6va.cpp:23:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     binary = to_string(count) + \"db\" + binary;\n      |         \
    \     ^~~~~~~~~\n      |              std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp25djm6va.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    int decimal_places = 1;\n    while (decimal\
    \ != 0) {\n        remainder = decimal % 2;\n        decimal /= 2;\n        binary\
    \ += remainder + '0';\n        decimal_places++;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), decimal_places, 'd');\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpg1nlw197: /tmp/tmpg1nlw197.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 8) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpn3qbzcjt: /tmp/tmpn3qbzcjt.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder;\n    while (decimal > 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += (remainder ? \"1\"\
    \ : \"0\");\n    }\n    binary.insert(0, \"db\");\n    return binary;\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpqkduk427: /tmp/tmpqkduk427.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (counter < 32) {\n        remainder *= 2;\n        if (remainder >= 1) {\n \
    \           binary += \"1\";\n            remainder -= 1;\n        } else {\n\
    \            binary += \"0\";\n        }\n        counter += 1;\n    }\n    binary\
    \ += \"db\";\n    counter += 1;\n    while (counter < 32) {\n        remainder\
    \ *= 2;\n        if (remainder >= 1) {\n            binary += \"1\";\n       \
    \     remainder -= 1;\n        } else {\n            binary += \"0\";\n      \
    \  }\n        counter += 1;\n    }\n    return binary;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpkt_qffb1: /tmp/tmpkt_qffb1.cpp:43: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 0;\n    while\
    \ (decimal != 0) {\n        remainder *= 2;\n        decimal -= remainder;\n \
    \       counter += 1;\n    }\n    while (counter > 0) {\n        binary += \"\
    1\";\n        counter -= 1;\n    }\n    binary += \"db\";\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpu8r_0igg: /tmp/tmpu8r_0igg.cpp:31: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder *= 2;\n        binary += \"1\";\n    }\n    binary += \"0\"\
    ;\n    while (binary.size() < 32) {\n        binary += \"0\";\n    }\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp_uh6ejmv: /tmp/tmp_uh6ejmv.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long temp;\n    int count = 0;\n    temp =\
    \ decimal;\n    while (temp != 0) {\n        remainder = temp % 2;\n        temp\
    \ = temp / 2;\n        binary.push_back(remainder);\n        count++;\n    }\n\
    \    binary.insert(binary.begin(), \"db\");\n    binary.insert(binary.end(), std::to_string(count).c_str());\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1rolrz3c.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp1rolrz3c.cpp:25:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   25 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp1rolrz3c.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long quotient;\n    long remainder_temp;\n\
    \    long quotient_temp;\n    long remainder_temp_temp;\n    long quotient_temp_temp;\n\
    \    long remainder_temp_temp_temp;\n    long quotient_temp_temp_temp;\n    long\
    \ remainder_temp_temp_temp_temp;\n    long quotient_temp_temp_temp_temp;\n   \
    \ long remainder_temp_temp_temp_temp_temp;\n    long quotient_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp;\n    long quotient_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp;\n    long quotient_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp;\n    long quotient_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    long\
    \ quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n \
    \   long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxjjaxy80.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpxjjaxy80.cpp:43:10: error: redeclaration of \u2018long\
    \ int remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   43 |     long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxjjaxy80.cpp:41:10: note: \u2018long int remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   41 |     long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxjjaxy80.cpp:46:10: error: redeclaration of \u2018long int quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   46 |     long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxjjaxy80.cpp:44:10: note: \u2018long int quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   44 |     long quotient_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxjjaxy80.cpp:47:10: error: redeclaration of \u2018long int remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   47 |     long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxjjaxy80.cpp:45:10: note: \u2018long int remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   45 |     long remainder_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \      |          ^~~~~~~~~~"
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder *= 2;\n        binary += counter % 2 ==\
    \ 0 ? \"1\" : \"0\";\n        counter /= 2;\n    }\n    binary += \"db\";\n  \
    \  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp9e9yx62e: /tmp/tmp9e9yx62e.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal /= 2;\n    }\n    while (decimal > 0) {\n        binary += \"1\";\n\
    \        decimal /= 2;\n    }\n    binary = binary + \"db\";\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmph_jbeg4n: /tmp/tmph_jbeg4n.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"1\";\n      \
    \  decimal -= 1;\n    }\n    binary += \"0\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpt70pofbc: /tmp/tmpt70pofbc.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter = counter * 2;\n        remainder = remainder / 2;\n\
    \    }\n    return binary + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcxbt3yel.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpcxbt3yel.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpcxbt3yel.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += to_string(remainder);\n\
    \    }\n    binary.insert(0, \"db\");\n    binary.append(\"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjq0twj8n.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpjq0twj8n.cpp:19:19: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary += to_string(remainder);\n      |                   ^~~~~~~~~\n\
    \      |                   std::__cxx11::to_string\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpjq0twj8n.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115752
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.size() < 8) {\n        binary += \"\
    1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp89wpdvw9: /tmp/tmp89wpdvw9.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary += \"0\";\n     \
    \   decimal /= 2;\n    }\n    while (binary.length() < 8) {\n        binary +=\
    \ \"0\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpczfq30qy: /tmp/tmpczfq30qy.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = binary + \"db\";\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp2wtks__k: /tmp/tmp2wtks__k.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115685
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary = std::to_string(decimal\
    \ % 2) + binary;\n        decimal /= 2;\n    }\n    binary = std::to_string(decimal)\
    \ + binary;\n    binary.insert(binary.begin(), 'b');\n    binary.insert(binary.end(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpsqdm446e: /tmp/tmpsqdm446e.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        counter++;\n    }\n    binary = std::to_string(counter) +\
    \ binary;\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpt9mx2d6t: /tmp/tmpt9mx2d6t.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder\
    \ ? \"1\" : \"0\";\n    }\n    binary.insert(0, \"db\");\n    binary.append(\"\
    db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpm_6yung8: /tmp/tmpm_6yung8.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115751
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        int remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        binary += remainder;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp8hr2p2l7: /tmp/tmp8hr2p2l7.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary = std::bitset<sizeof(long)>::to_string(decimal);\n\
    \        decimal /= 2;\n    }\n    binary = binary + \"db\";\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp569bifp1.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp569bifp1.cpp:16:62: error: cannot call member function\
    \ \u2018std::__cxx11::basic_string<_CharT> std::bitset<_Nb>::to_string(_CharT,\
    \ _CharT) const [with _CharT = long int; long unsigned int _Nb = 8]\u2019 without\
    \ object\n   16 |         binary = std::bitset<sizeof(long)>::to_string(decimal);\n\
    \      |                                                              ^\n"
  stdout: ''
  timestamp: 1660115753
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = 0;\n    while (decimal > 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += remainder ? \"1\" :\
    \ \"0\";\n    }\n    binary.insert(binary.begin(), \"db\");\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x6fnrbx.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp8x6fnrbx.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8x6fnrbx.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpr1z1uq0_: /tmp/tmpr1z1uq0_.cpp:25: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115682
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder;\n    while (decimal > 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        binary += remainder;\n    }\n\
    \    binary.insert(0, \"db\");\n    return binary;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp51w5ajbt: /tmp/tmp51w5ajbt.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    int count = 0;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        count++;\n    }\n   \
    \ binary = std::to_string(count) + binary;\n    binary.insert(0, \"db\");\n  \
    \  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpk5z01pr1: /tmp/tmpk5z01pr1.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary.push_back((decimal\
    \ % 2) + '0');\n        decimal /= 2;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpa4xinaxi: /tmp/tmpa4xinaxi.cpp:24: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (remainder > 0) {\n        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter++;\n    }\n \
    \   binary = std::to_string(counter) + binary;\n    binary.insert(0, \"db\");\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp_paqmflf: /tmp/tmp_paqmflf.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long counter = 0;\n    long temp = 0;\n  \
    \  long power = 1;\n    long sum = 0;\n    long digit = 0;\n    long digits =\
    \ 0;\n    long power2 = 0;\n    long power3 = 0;\n    long power4 = 0;\n    long\
    \ power5 = 0;\n    long power6 = 0;\n    long power7 = 0;\n    long power8 = 0;\n\
    \    long power9 = 0;\n    long power10 = 0;\n    long power11 = 0;\n    long\
    \ power12 = 0;\n    long power13 = 0;\n    long power14 = 0;\n    long power15\
    \ = 0;\n    long power16 = 0;\n    long power17 = 0;\n    long power18 = 0;\n\
    \    long power19 = 0;\n    long power20 = 0;\n    long power21 = 0;\n    long\
    \ power22 = 0;\n    long power23 = 0;\n    long power24 = 0;\n    long power25\
    \ = 0;\n    long power26 = 0;\n    long power27 = 0;\n    long power28 = 0;\n\
    \    long power29 = 0;\n    long power30 = 0;\n    long power31 = 0;\n    long\
    \ power32 = 0;\n    long power33 = 0;\n    long power34 = 0;\n    long power35\
    \ = 0;\n    long power36 = 0;\n    long power37 = 0;\n    long power38 = 0;\n\
    \    long power39 = 0;\n    long power40 = 0;\n    long power41 = 0;\n    long\
    \ power42 = 0;\n    long power43 = 0;\n    long power44 = 0;\n    long power45\
    \ = 0;\n    long power46 = 0;\n    long power47 = 0;\n    long power48 = 0;\n\
    \    long power49 = 0;\n    long power50 = 0;\n    long power51 = 0;\n    long\
    \ power52 = 0;\n    long power53 = 0;\n    long power54 = 0;\n    long power55\
    \ = 0;\n    long power56 = 0;\n    long power57 = 0;\n    long power58 = 0;\n\
    \    long power59 = 0;\n    long power60 = 0;\n    long power61 = 0;\n    long\
    \ power62 = 0;\n    long power63 = 0;\n    long power64 = 0;\n    long power65\
    \ = 0;\n    long power66 = 0;\n    long power67 = 0;\n    long power68 = 0;\n\
    \    long power69 = 0;\n    long power70 = 0;\n    long power71 = 0;\n    long\
    \ power72 = 0;\n    long power73 = 0;\n    long power74 = 0;\n    long power75\
    \ = 0;\n    long power76 = 0;\n    long power77 = 0;\n    long power78 = 0;\n\
    \    long power79 = 0;\n    long power80 = 0;\n\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpiagm0pdt: /tmp/tmpiagm0pdt.cpp:105: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal %= 2;\n    }\n    while (binary.length() < 32) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp_dbnvptv: /tmp/tmp_dbnvptv.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder *= 2;\n        binary += \"1\";\n    }\n    while (remainder\
    \ != 0) {\n        remainder /= 2;\n        binary += \"0\";\n    }\n    binary.insert(0,\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp7yzeheog: /tmp/tmp7yzeheog.cpp:29: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder;\n    long quotient;\n    long temp;\n    long digit;\n\
    \    long power;\n    long i;\n    long j;\n    long k;\n    long l;\n    long\
    \ m;\n    long n;\n    long o;\n    long p;\n    long q;\n    long r;\n    long\
    \ s;\n    long t;\n    long u;\n    long v;\n    long w;\n    long x;\n    long\
    \ y;\n    long z;\n    long A;\n    long B;\n    long C;\n    long D;\n    long\
    \ E;\n    long F;\n    long G;\n    long H;\n    long I;\n    long J;\n    long\
    \ K;\n    long L;\n    long M;\n    long N;\n    long O;\n    long P;\n    long\
    \ Q;\n    long R;\n    long S;\n    long T;\n    long U;\n    long V;\n    long\
    \ W;\n    long X;\n    long Y;\n    long Z;\n    long A;\n    long B;\n    long\
    \ C;\n    long D;\n    long E;\n    long F;\n    long G;\n    long H;\n    long\
    \ I;\n    long J;\n    long K;\n    long L;\n    long M;\n    long N;\n    long\
    \ O;\n    long P;\n    long Q;\n    long R;\n    long S;\n    long T;\n    long\
    \ U;\n    long V;\n    long W;\n    long X;\n    long Y;\n    long Z;\n    long\
    \ A;\n    long B;\n    long C;\n    long D;\n    long E;\n    long F;\n    long\
    \ G;\n    long H;\n    long I;\n    long J;\n    long K;\n    long L;\n    long\
    \ M;\n    long N;\n    long O;\n    long P;\n    long Q;\n    long R;\n    long\
    \ S;\n    long T;\n    long U;\n    long V;\n    long W;\n    long X;\n    long\
    \ Y;\n    long Z;\n    long A;\n    long B;\n    long C;\n    long D;\n    long\
    \ \n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpujtkypky.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpujtkypky.cpp:64:10: error: redeclaration of \u2018long\
    \ int A\u2019\n   64 |     long A;\n      |          ^\n/tmp/tmpujtkypky.cpp:38:10:\
    \ note: \u2018long int A\u2019 previously declared here\n   38 |     long A;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:65:10: error: redeclaration of \u2018\
    long int B\u2019\n   65 |     long B;\n      |          ^\n/tmp/tmpujtkypky.cpp:39:10:\
    \ note: \u2018long int B\u2019 previously declared here\n   39 |     long B;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:66:10: error: redeclaration of \u2018\
    long int C\u2019\n   66 |     long C;\n      |          ^\n/tmp/tmpujtkypky.cpp:40:10:\
    \ note: \u2018long int C\u2019 previously declared here\n   40 |     long C;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:67:10: error: redeclaration of \u2018\
    long int D\u2019\n   67 |     long D;\n      |          ^\n/tmp/tmpujtkypky.cpp:41:10:\
    \ note: \u2018long int D\u2019 previously declared here\n   41 |     long D;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:68:10: error: redeclaration of \u2018\
    long int E\u2019\n   68 |     long E;\n      |          ^\n/tmp/tmpujtkypky.cpp:42:10:\
    \ note: \u2018long int E\u2019 previously declared here\n   42 |     long E;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:69:10: error: redeclaration of \u2018\
    long int F\u2019\n   69 |     long F;\n      |          ^\n/tmp/tmpujtkypky.cpp:43:10:\
    \ note: \u2018long int F\u2019 previously declared here\n   43 |     long F;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:70:10: error: redeclaration of \u2018\
    long int G\u2019\n   70 |     long G;\n      |          ^\n/tmp/tmpujtkypky.cpp:44:10:\
    \ note: \u2018long int G\u2019 previously declared here\n   44 |     long G;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:71:10: error: redeclaration of \u2018\
    long int H\u2019\n   71 |     long H;\n      |          ^\n/tmp/tmpujtkypky.cpp:45:10:\
    \ note: \u2018long int H\u2019 previously declared here\n   45 |     long H;\n\
    \      |          ^\n/tmp/tmpujtkypky.cpp:72:10: error: redeclaration of \u2018\
    long int I\u2019\n   72 |     long I;\n      |          ^\n/tmp/tmpujtkypky.cpp:46:10:\
    \ note: \u2018long int I\u2019 previously declared here"
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal /= 2;\n    }\n    while (decimal > 0) {\n        binary += \"1\";\n\
    \        decimal /= 2;\n    }\n    binary.insert(0, \"db\");\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp2j41fii6: /tmp/tmp2j41fii6.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter > 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        counter = counter * 2;\n        remainder = remainder / 2;\n\
    \    }\n    binary = binary + \"db\";\n    return binary;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8eucpiaa.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp8eucpiaa.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp8eucpiaa.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115681
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = binary +\
    \ \"db\";\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp3i8ih2y6: /tmp/tmp3i8ih2y6.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115752
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = 0;\n    while (decimal != 0) {\n       \
    \ remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder;\n\
    \    }\n    binary.insert(binary.begin(), \"db\");\n    return binary;\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37mpx81v.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp37mpx81v.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp37mpx81v.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115748
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    int remainder = decimal;\n    while (remainder > 0) {\n\
    \        int digit = remainder % 2;\n        remainder = remainder / 2;\n    \
    \    binary = std::to_string(digit) + binary;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpb1ofyeo8: /tmp/tmpb1ofyeo8.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = 0;\n    while (decimal != 0) {\n      \
    \  remainder = decimal % 2;\n        decimal /= 2;\n        binary += remainder\
    \ ? \"1\" : \"0\";\n    }\n    binary.insert(binary.begin(), \"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfrmaapn8.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpfrmaapn8.cpp:21:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   21 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpfrmaapn8.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115753
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    long counter = 1;\n    while\
    \ (counter != 0) {\n        remainder = remainder % 2;\n        binary = to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n        counter++;\n    }\n \
    \   binary = binary + \"db\";\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzj8tzfh3.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpzj8tzfh3.cpp:19:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   19 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpzj8tzfh3.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 8) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpn3qbzcjt: /tmp/tmpn3qbzcjt.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        int remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        binary += remainder;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp8hr2p2l7: /tmp/tmp8hr2p2l7.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 8) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpn3qbzcjt: /tmp/tmpn3qbzcjt.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary.push_back(remainder);\n  \
    \      decimal /= 2;\n    }\n    binary.push_back(remainder);\n    binary.insert(binary.begin(),\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8i0762zo.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp8i0762zo.cpp:22:39: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   22 |     binary.insert(binary.begin(), \"db\");\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8i0762zo.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1538:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1538 |       insert(const_iterator __p, size_type\
    \ __n, _CharT __c)\n      |       ^~~~~~\n/us"
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal != 0) {\n        int remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        binary += remainder;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    binary.insert(binary.end(), 'b');\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp8hr2p2l7: /tmp/tmp8hr2p2l7.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = to_string(remainder) + binary;\n\
    \        remainder = remainder / 2;\n    }\n    binary = binary + \"db\";\n  \
    \  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkr1blxy6.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkr1blxy6.cpp:18:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpkr1blxy6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6601:3: note:\
    \ \u2018std::__cxx11::to_string\u2019 declared here\n 6601 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal != 0) {\n        binary = std::to_string(decimal%2)\
    \ + binary;\n        decimal /= 2;\n    }\n    binary = std::to_string(decimal)\
    \ + binary;\n    binary.insert(0, \"db\");\n    binary.append(\"db\");\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpe60vwu6h: /tmp/tmpe60vwu6h.cpp:27: int main(): Assertion `candidate((32))
    == ("db100000db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder = decimal;\n    long counter = 1;\n    while (counter\
    \ > 0) {\n        remainder *= 2;\n        counter --;\n    }\n    long remainder2\
    \ = remainder;\n    long counter2 = 1;\n    while (remainder2 > 0) {\n       \
    \ remainder2 /= 2;\n        counter2 --;\n    }\n    binary.push_back('0');\n\
    \    while (remainder > 0) {\n        binary.push_back('1');\n        remainder\
    \ --;\n    }\n    binary.push_back('0');\n    while (remainder2 > 0) {\n     \
    \   binary.push_back('1');\n        remainder2 --;\n    }\n    binary.push_back('d');\n\
    \    binary.push_back('b');\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmphjbrj_b3: /tmp/tmphjbrj_b3.cpp:43: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary += \"0\";\n        binary\
    \ += remainder;\n        remainder = remainder / 2;\n    }\n    binary.insert(0,\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmp7t0gwacg: /tmp/tmp7t0gwacg.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115749
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    long remainder = decimal;\n    while (remainder > 0) {\n\
    \        remainder = remainder % 2;\n        binary = std::to_string(remainder)\
    \ + binary;\n        remainder = remainder / 2;\n    }\n    binary = std::to_string(remainder)\
    \ + binary;\n    binary.insert(0, \"db\");\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpaiiynt7_: /tmp/tmpaiiynt7_.cpp:27: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115679
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary;\n    long remainder = decimal;\n    long counter = 1;\n    while (counter\
    \ > 0) {\n        remainder *= 2;\n        counter -= 1;\n    }\n    long remainder2\
    \ = remainder;\n    long counter2 = 1;\n    while (remainder2 > 0) {\n       \
    \ remainder2 *= 2;\n        counter2 -= 1;\n    }\n    long remainder3 = remainder2;\n\
    \    long counter3 = 1;\n    while (remainder3 > 0) {\n        remainder3 *= 2;\n\
    \        counter3 -= 1;\n    }\n    long remainder4 = remainder3;\n    long counter4\
    \ = 1;\n    while (remainder4 > 0) {\n        remainder4 *= 2;\n        counter4\
    \ -= 1;\n    }\n    long remainder5 = remainder4;\n    long counter5 = 1;\n  \
    \  while (remainder5 > 0) {\n        remainder5 *= 2;\n        counter5 -= 1;\n\
    \    }\n    long remainder6 = remainder5;\n    long counter6 = 1;\n    while (remainder6\
    \ > 0) {\n        remainder6 *= 2;\n        counter6 -= 1;\n    }\n    long remainder7\
    \ = remainder6;\n    long counter7 = 1;\n    while (remainder7 > 0) {\n      \
    \  remainder7 *= 2;\n        counter7 -= 1;\n    }\n    long remainder8 = remainder7;\n\
    \    long counter8 = 1;\n    while (remainder8 > 0) {\n        remainder8 *= 2;\n\
    \        counter8 -= 1;\n    }\n    long remainder9 = remainder8;\n    long counter9\
    \ = 1;\n    while (remainder9 > 0) {\n        remainder9 *= 2;\n        counter9\
    \ -= 1;\n    }\n    long remainder10 = remainder9;\n    long counter10 = 1;\n\
    \    while (remainder10 > 0) {\n        remainder10 *= 2;\n        counter10 -=\
    \ 1;\n    }\n    long remainder11 = remainder10;\n    long counter11 = 1;\n  \
    \  while (remainder11 > 0) {\n        remainder11 *= 2;\n        counter11 -=\
    \ 1;\n    }\n    long remainder12 = remainder11;\n    long counter12 = 1;\n  \
    \  while (remainder12 > 0) {\n        remainder12 *= 2;\n        counter12 -=\
    \ 1;\n    }\n    long remainder13 = remainder12;\n    long counter13 = 1;\n  \
    \  while (remainder13 > 0) {\n        remainder13 *= 2;\n        counter13 -=\
    \ 1;\n    }\n    long remainder14 = remainder13;\n    long counter14 = 1;\n  \
    \  while (remainder14 > 0) {\n        re\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3eozkj9l.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp3eozkj9l.cpp:96:9: error: \u2018re\u2019 was not declared\
    \ in this scope\n   96 |         re\n      |         ^~\n/tmp/tmp3eozkj9l.cpp:98:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   98 | int main() {\n      |            ^\n/tmp/tmp3eozkj9l.cpp:104:1: error:\
    \ expected \u2018}\u2019 at end of input\n  104 | }\n      | ^\n/tmp/tmp3eozkj9l.cpp:13:45:\
    \ note: to match this \u2018{\u2019\n   13 | std::string decimal_to_binary(long\
    \ decimal) {\n      |                                             ^\n/tmp/tmp3eozkj9l.cpp:104:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  104 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660115753
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        binary += \"0\";\n      \
    \  decimal -= 1;\n    }\n    while (binary.length() < 8) {\n        binary +=\
    \ \"1\";\n    }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmpn3qbzcjt: /tmp/tmpn3qbzcjt.cpp:26: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115684
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// >>>\
    \ decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n\
    // (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string\
    \ binary = \"\";\n    while(decimal > 0) {\n        binary += \"0\";\n       \
    \ decimal /= 2;\n    }\n    while(decimal) {\n        binary += \"1\";\n     \
    \   decimal /= 2;\n    }\n    binary.insert(0, \"db\");\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'tmplmexgf58: /tmp/tmplmexgf58.cpp:28: int main(): Assertion `candidate((0))
    == ("db0db")'' failed.

    '
  stdout: ''
  timestamp: 1660115753
