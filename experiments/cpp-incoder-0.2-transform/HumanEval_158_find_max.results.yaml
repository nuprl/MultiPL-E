language: cpp
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Your code here\n    std::string\
    \ maxWord = \"\";\n    int maxCount = 0;\n    for (auto word : words) {\n    \
    \    int count = 0;\n        for (auto c : word) {\n            count += 1;\n\
    \        }\n        if (count > maxCount) {\n            maxCount = count;\n \
    \           maxWord = word;\n        }\n    }\n    return maxWord;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmsfxuput.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpmsfxuput.cpp:17:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpmsfxuput.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return maxWord;\n     ^\n/tmp/tmpmsfxuput.cpp:27:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpmsfxuput.cpp:27:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpmsfxuput.cpp:27:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpmsfxuput.cpp:27:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpmsfxuput.cpp: In function 'int main()':\n/tmp/tmpmsfxuput.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmsfxuput.cpp:2:\n/tmp/tmpmsfxuput.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpmsfxuput.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpmsfxuput.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpmsfxuput.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpmsfxuput.cpp:31:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Your code here\n    std::string\
    \ max;\n    int maxCount = 0;\n    for (auto &word : words) {\n        int count\
    \ = 0;\n        for (auto &c : word) {\n            count += 1;\n        }\n \
    \       if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqrucx3rd.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpqrucx3rd.cpp:17:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmpqrucx3rd.cpp:17:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmpqrucx3rd.cpp:19:20:\
    \ error: ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n    \
    \     for (auto &c : word) {\n                    ^\n/tmp/tmpqrucx3rd.cpp:19:24:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &c : word) {\n                        ^\n/tmp/tmpqrucx3rd.cpp: In function 'int\
    \ main()':\n/tmp/tmpqrucx3rd.cpp:30:10: error: 'candidate' does not name a type\n\
    \     auto candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqrucx3rd.cpp:2:\n/tmp/tmpqrucx3rd.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpqrucx3rd.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpqrucx3rd.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqrucx3rd.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpqrucx3rd.cpp:31:111: note"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string maxWord = \"\";\n\
    \    int maxCount = 0;\n    for (auto word : words) {\n        int count = 0;\n\
    \        for (auto c : word) {\n            count += (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u');\n        }\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            maxWord = word;\n        }\n \
    \   }\n    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk8be6obu.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpk8be6obu.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpk8be6obu.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return maxWord;\n     ^\n/tmp/tmpk8be6obu.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpk8be6obu.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpk8be6obu.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpk8be6obu.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpk8be6obu.cpp: In function 'int main()':\n/tmp/tmpk8be6obu.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk8be6obu.cpp:2:\n/tmp/tmpk8be6obu.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpk8be6obu.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpk8be6obu.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpk8be6obu.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpk8be6obu.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max = \"\";\n  \
    \  int max_count = 0;\n    for (auto &word : words) {\n        int count = 0;\n\
    \        for (auto &c : word) {\n            if (std::count(max.begin(), max.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            max = word;\n  \
    \      }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp18iyh387.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp18iyh387.cpp:16:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmp18iyh387.cpp:16:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmp18iyh387.cpp:18:20:\
    \ error: ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n    \
    \     for (auto &c : word) {\n                    ^\n/tmp/tmp18iyh387.cpp:18:24:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &c : word) {\n                        ^\n/tmp/tmp18iyh387.cpp: In function 'int\
    \ main()':\n/tmp/tmp18iyh387.cpp:31:10: error: 'candidate' does not name a type\n\
    \     auto candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp18iyh387.cpp:2:\n/tmp/tmp18iyh387.cpp:32:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp18iyh387.cpp:32:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmp18iyh387.cpp:32:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp18iyh387.cpp:32:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp18iyh387.cpp:32:111: note"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max = \"\";\n  \
    \  int max_count = 0;\n    for (auto &word : words) {\n        auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > max_count) {\n            max = word;\n\
    \            max_count = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq6g6yffz.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpq6g6yffz.cpp:16:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmpq6g6yffz.cpp:16:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmpq6g6yffz.cpp:17:14:\
    \ error: 'count' does not name a type\n         auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n              ^\n/tmp/tmpq6g6yffz.cpp:18:13: error: 'count'\
    \ was not declared in this scope\n         if (count > max_count) {\n        \
    \     ^\n/tmp/tmpq6g6yffz.cpp:18:13: note: suggested alternative:\nIn file included\
    \ from /usr/include/c++/4.8.2/algorithm:62:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmpq6g6yffz.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algo.h:4622:5:\
    \ note:   'std::count'\n     count(_InputIterator __first, _InputIterator __last,\
    \ const _Tp& __value)\n     ^\n/tmp/tmpq6g6yffz.cpp: In function 'int main()':\n\
    /tmp/tmpq6g6yffz.cpp:26:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq6g6yffz.cpp:2:\n/tmp/tmpq6g6yffz.cpp:27:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpq6g6yffz.cpp:27:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                             "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int n = words.size();\n    int\
    \ max_count = 0;\n    std::string max_word = \"\";\n    for (int i = 0; i < n;\
    \ i++) {\n        int count = 0;\n        for (int j = 0; j < n; j++) {\n    \
    \        if (i == j) continue;\n            if (words[i] == words[j]) {\n    \
    \            count++;\n            }\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_word = words[i];\n      \
    \  }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdbp25web.cpp: In function 'int main()':\n/tmp/tmpdbp25web.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdbp25web.cpp:2:\n/tmp/tmpdbp25web.cpp:34:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpdbp25web.cpp:34:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpdbp25web.cpp:34:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdbp25web.cpp:34:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpdbp25web.cpp:34:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpdbp25web.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Your code here\n    std::string\
    \ max;\n    int maxCount = 0;\n    for (auto word : words) {\n        int count\
    \ = 0;\n        for (auto c : word) {\n            count += 1;\n        }\n  \
    \      if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpde7dkoa2.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpde7dkoa2.cpp:17:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpde7dkoa2.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return max;\n     ^\n/tmp/tmpde7dkoa2.cpp:27:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmpde7dkoa2.cpp:27:5: error:\
    \ expected ';' before 'return'\n/tmp/tmpde7dkoa2.cpp:27:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpde7dkoa2.cpp:27:5: error: expected ')' before 'return'\n\
    /tmp/tmpde7dkoa2.cpp: In function 'int main()':\n/tmp/tmpde7dkoa2.cpp:30:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = find_max;\n        \
    \  ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n           \
    \      from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n   \
    \              from /tmp/tmpde7dkoa2.cpp:2:\n/tmp/tmpde7dkoa2.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpde7dkoa2.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpde7dkoa2.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpde7dkoa2.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpde7dkoa2.cpp:31:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string maxWord = words[0];\n\
    \    int maxCount = 0;\n    for (auto word : words) {\n        int count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > maxCount) {\n            maxCount = count;\n\
    \            maxWord = word;\n        }\n    }\n    return maxWord;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcr0csep2.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpcr0csep2.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpcr0csep2.cpp:23:5: error: expected\
    \ ';' before 'return'\n     return maxWord;\n     ^\n/tmp/tmpcr0csep2.cpp:23:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpcr0csep2.cpp:23:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpcr0csep2.cpp:23:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpcr0csep2.cpp:23:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpcr0csep2.cpp: In function 'int main()':\n/tmp/tmpcr0csep2.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcr0csep2.cpp:2:\n/tmp/tmpcr0csep2.cpp:27:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpcr0csep2.cpp:27:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpcr0csep2.cpp:27:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpcr0csep2.cpp:27:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpcr0csep2.cpp:27:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max = \"\";\n  \
    \  int maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n\
    \        for (auto &c : word) {\n            count += 1;\n        }\n        if\
    \ (count > maxCount) {\n            max = word;\n            maxCount = count;\n\
    \        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn0pj7mpq.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpn0pj7mpq.cpp:16:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmpn0pj7mpq.cpp:16:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmpn0pj7mpq.cpp:18:20:\
    \ error: ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n    \
    \     for (auto &c : word) {\n                    ^\n/tmp/tmpn0pj7mpq.cpp:18:24:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &c : word) {\n                        ^\n/tmp/tmpn0pj7mpq.cpp: In function 'int\
    \ main()':\n/tmp/tmpn0pj7mpq.cpp:29:10: error: 'candidate' does not name a type\n\
    \     auto candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn0pj7mpq.cpp:2:\n/tmp/tmpn0pj7mpq.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpn0pj7mpq.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpn0pj7mpq.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpn0pj7mpq.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpn0pj7mpq.cpp:30:111: note"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Write your code here\n  \
    \  std::string maxWord = \"\";\n    int maxCount = 0;\n    for (auto word : words)\
    \ {\n        int count = 0;\n        for (char c : word) {\n            count\
    \ += 1;\n        }\n        if (count > maxCount) {\n            maxCount = count;\n\
    \            maxWord = word;\n        }\n    }\n    return maxWord;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv6s8dnjk.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpv6s8dnjk.cpp:17:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpv6s8dnjk.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return maxWord;\n     ^\n/tmp/tmpv6s8dnjk.cpp:27:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpv6s8dnjk.cpp:27:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpv6s8dnjk.cpp:27:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpv6s8dnjk.cpp:27:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpv6s8dnjk.cpp: In function 'int main()':\n/tmp/tmpv6s8dnjk.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv6s8dnjk.cpp:2:\n/tmp/tmpv6s8dnjk.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpv6s8dnjk.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpv6s8dnjk.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpv6s8dnjk.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpv6s8dnjk.cpp:31:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Your code here\n    std::string\
    \ maxWord = \"\";\n    int maxCount = 0;\n    for (auto word : words) {\n    \
    \    int count = 0;\n        for (auto c : word) {\n            if (std::count(word.begin(),\
    \ word.end(), c) > 0) {\n                count++;\n            }\n        }\n\
    \        if (count > maxCount) {\n            maxCount = count;\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwr8ooxqe.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpwr8ooxqe.cpp:17:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpwr8ooxqe.cpp:29:5: error: expected\
    \ ';' before 'return'\n     return maxWord;\n     ^\n/tmp/tmpwr8ooxqe.cpp:29:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpwr8ooxqe.cpp:29:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpwr8ooxqe.cpp:29:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpwr8ooxqe.cpp:29:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpwr8ooxqe.cpp: In function 'int main()':\n/tmp/tmpwr8ooxqe.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwr8ooxqe.cpp:2:\n/tmp/tmpwr8ooxqe.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpwr8ooxqe.cpp:33:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpwr8ooxqe.cpp:33:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpwr8ooxqe.cpp:33:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpwr8ooxqe.cpp:33:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max = \"\";\n  \
    \  int max_count = 0;\n    for (auto &word : words) {\n        auto count = std::count_if(word.begin(),\
    \ word.end(), [&](char c) {\n            return std::tolower(c) == std::tolower(max);\n\
    \        });\n        if (count > max_count) {\n            max_count = count;\n\
    \            max = word;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2i3gd9lo.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp2i3gd9lo.cpp:16:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmp2i3gd9lo.cpp:16:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmp2i3gd9lo.cpp:17:14:\
    \ error: 'count' does not name a type\n         auto count = std::count_if(word.begin(),\
    \ word.end(), [&](char c) {\n              ^\n/tmp/tmp2i3gd9lo.cpp:19:10: error:\
    \ expected primary-expression before ')' token\n         });\n          ^\n/tmp/tmp2i3gd9lo.cpp:19:10:\
    \ error: expected ';' before ')' token\n/tmp/tmp2i3gd9lo.cpp:20:13: error: 'count'\
    \ was not declared in this scope\n         if (count > max_count) {\n        \
    \     ^\n/tmp/tmp2i3gd9lo.cpp:20:13: note: suggested alternative:\nIn file included\
    \ from /usr/include/c++/4.8.2/algorithm:62:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmp2i3gd9lo.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algo.h:4622:5:\
    \ note:   'std::count'\n     count(_InputIterator __first, _InputIterator __last,\
    \ const _Tp& __value)\n     ^\n/tmp/tmp2i3gd9lo.cpp: In function 'int main()':\n\
    /tmp/tmp2i3gd9lo.cpp:28:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2i3gd9lo.cpp:2:\n/tmp/tmp2i3gd9lo.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp2i3gd9lo.cpp:29:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert("
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Write your code here\n  \
    \  std::string maxWord = \"\";\n    int maxCount = 0;\n    for (auto word : words)\
    \ {\n        int count = 0;\n        for (auto c : word) {\n            if (std::count(word.begin(),\
    \ word.end(), c) > 0) {\n                count++;\n            }\n        }\n\
    \        if (count > maxCount) {\n            maxCount = count;\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt4rmr6u4.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpt4rmr6u4.cpp:17:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpt4rmr6u4.cpp:29:5: error: expected\
    \ ';' before 'return'\n     return maxWord;\n     ^\n/tmp/tmpt4rmr6u4.cpp:29:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpt4rmr6u4.cpp:29:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpt4rmr6u4.cpp:29:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpt4rmr6u4.cpp:29:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpt4rmr6u4.cpp: In function 'int main()':\n/tmp/tmpt4rmr6u4.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt4rmr6u4.cpp:2:\n/tmp/tmpt4rmr6u4.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpt4rmr6u4.cpp:33:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpt4rmr6u4.cpp:33:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpt4rmr6u4.cpp:33:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpt4rmr6u4.cpp:33:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    int max = 0;\n    std::string\
    \ maxWord = \"\";\n    for (auto word : words) {\n        int count = 0;\n   \
    \     for (char c : word) {\n            count += 1;\n        }\n        if (count\
    \ > max) {\n            max = count;\n            maxWord = word;\n        }\n\
    \    }\n    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n   \
    \ assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"\
    bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpljm7f2on.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpljm7f2on.cpp:16:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpljm7f2on.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return maxWord;\n     ^\n/tmp/tmpljm7f2on.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpljm7f2on.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpljm7f2on.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpljm7f2on.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpljm7f2on.cpp: In function 'int main()':\n/tmp/tmpljm7f2on.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = find_max;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpljm7f2on.cpp:2:\n/tmp/tmpljm7f2on.cpp:30:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpljm7f2on.cpp:30:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpljm7f2on.cpp:30:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpljm7f2on.cpp:30:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpljm7f2on.cpp:30:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Write your code here\n  \
    \  std::string max = \"\";\n    int maxCount = 0;\n    for (auto word : words)\
    \ {\n        int count = 0;\n        for (auto c : word) {\n            if (std::count(max.begin(),\
    \ max.end(), c) == 0) {\n                max = std::to_string(maxCount) + c;\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            max = word;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5y7qgpy.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpa5y7qgpy.cpp:17:15: error: 'word' does not name a type\n     for\
    \ (auto word : words) {\n               ^\n/tmp/tmpa5y7qgpy.cpp:30:5: error: expected\
    \ ';' before 'return'\n     return max;\n     ^\n/tmp/tmpa5y7qgpy.cpp:30:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmpa5y7qgpy.cpp:30:5: error:\
    \ expected ';' before 'return'\n/tmp/tmpa5y7qgpy.cpp:30:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpa5y7qgpy.cpp:30:5: error: expected ')' before 'return'\n\
    /tmp/tmpa5y7qgpy.cpp: In function 'int main()':\n/tmp/tmpa5y7qgpy.cpp:33:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = find_max;\n        \
    \  ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n           \
    \      from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n   \
    \              from /tmp/tmpa5y7qgpy.cpp:2:\n/tmp/tmpa5y7qgpy.cpp:34:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpa5y7qgpy.cpp:34:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpa5y7qgpy.cpp:34:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpa5y7qgpy.cpp:34:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpa5y7qgpy.cpp:34:111: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max;\n    int max_count\
    \ = 0;\n    for (auto &word : words) {\n        auto count = std::count_if(word.begin(),\
    \ word.end(), [](char c) {\n            return std::isalpha(c);\n        });\n\
    \        if (count > max_count) {\n            max = word;\n            max_count\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprccfz06e.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmprccfz06e.cpp:16:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmprccfz06e.cpp:16:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmprccfz06e.cpp:17:14:\
    \ error: 'count' does not name a type\n         auto count = std::count_if(word.begin(),\
    \ word.end(), [](char c) {\n              ^\n/tmp/tmprccfz06e.cpp:19:10: error:\
    \ expected primary-expression before ')' token\n         });\n          ^\n/tmp/tmprccfz06e.cpp:19:10:\
    \ error: expected ';' before ')' token\n/tmp/tmprccfz06e.cpp:20:13: error: 'count'\
    \ was not declared in this scope\n         if (count > max_count) {\n        \
    \     ^\n/tmp/tmprccfz06e.cpp:20:13: note: suggested alternative:\nIn file included\
    \ from /usr/include/c++/4.8.2/algorithm:62:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmprccfz06e.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algo.h:4622:5:\
    \ note:   'std::count'\n     count(_InputIterator __first, _InputIterator __last,\
    \ const _Tp& __value)\n     ^\n/tmp/tmprccfz06e.cpp: In function 'int main()':\n\
    /tmp/tmprccfz06e.cpp:28:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprccfz06e.cpp:2:\n/tmp/tmprccfz06e.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmprccfz06e.cpp:29:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(c"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Your code here\n    std::string\
    \ max;\n    int maxCount = 0;\n    for (auto &word : words) {\n        int count\
    \ = 0;\n        for (auto &c : word) {\n            count += 1;\n        }\n \
    \       if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqrucx3rd.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpqrucx3rd.cpp:17:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmpqrucx3rd.cpp:17:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmpqrucx3rd.cpp:19:20:\
    \ error: ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n    \
    \     for (auto &c : word) {\n                    ^\n/tmp/tmpqrucx3rd.cpp:19:24:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &c : word) {\n                        ^\n/tmp/tmpqrucx3rd.cpp: In function 'int\
    \ main()':\n/tmp/tmpqrucx3rd.cpp:30:10: error: 'candidate' does not name a type\n\
    \     auto candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqrucx3rd.cpp:2:\n/tmp/tmpqrucx3rd.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpqrucx3rd.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpqrucx3rd.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqrucx3rd.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpqrucx3rd.cpp:31:111: note"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Your code here\n    std::string\
    \ max;\n    int maxCount = 0;\n    for (auto &word : words) {\n        int count\
    \ = 0;\n        for (auto &c : word) {\n            count += 1;\n        }\n \
    \       if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqrucx3rd.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpqrucx3rd.cpp:17:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmpqrucx3rd.cpp:17:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmpqrucx3rd.cpp:19:20:\
    \ error: ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n    \
    \     for (auto &c : word) {\n                    ^\n/tmp/tmpqrucx3rd.cpp:19:24:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &c : word) {\n                        ^\n/tmp/tmpqrucx3rd.cpp: In function 'int\
    \ main()':\n/tmp/tmpqrucx3rd.cpp:30:10: error: 'candidate' does not name a type\n\
    \     auto candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqrucx3rd.cpp:2:\n/tmp/tmpqrucx3rd.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpqrucx3rd.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpqrucx3rd.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqrucx3rd.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpqrucx3rd.cpp:31:111: note"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    std::string max;\n    int max_count\
    \ = 0;\n    for (auto &word : words) {\n        auto count = std::count_if(word.begin(),\
    \ word.end(), [&](char c) {\n            return std::isalpha(c);\n        });\n\
    \        if (count > max_count) {\n            max = word;\n            max_count\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1112_60v.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp1112_60v.cpp:16:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmp1112_60v.cpp:16:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmp1112_60v.cpp:17:14:\
    \ error: 'count' does not name a type\n         auto count = std::count_if(word.begin(),\
    \ word.end(), [&](char c) {\n              ^\n/tmp/tmp1112_60v.cpp:19:10: error:\
    \ expected primary-expression before ')' token\n         });\n          ^\n/tmp/tmp1112_60v.cpp:19:10:\
    \ error: expected ';' before ')' token\n/tmp/tmp1112_60v.cpp:20:13: error: 'count'\
    \ was not declared in this scope\n         if (count > max_count) {\n        \
    \     ^\n/tmp/tmp1112_60v.cpp:20:13: note: suggested alternative:\nIn file included\
    \ from /usr/include/c++/4.8.2/algorithm:62:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmp1112_60v.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algo.h:4622:5:\
    \ note:   'std::count'\n     count(_InputIterator __first, _InputIterator __last,\
    \ const _Tp& __value)\n     ^\n/tmp/tmp1112_60v.cpp: In function 'int main()':\n\
    /tmp/tmp1112_60v.cpp:28:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1112_60v.cpp:2:\n/tmp/tmp1112_60v.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmp1112_60v.cpp:29:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert("
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n//\
    \ >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string\
    \ find_max(std::vector<std::string> words) {\n    // Your code here\n    std::string\
    \ max;\n    int maxCount = 0;\n    for (auto &word : words) {\n        int count\
    \ = 0;\n        for (auto &c : word) {\n            count += 1;\n        }\n \
    \       if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"\
    enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n \
    \   assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"\
    cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"\
    footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"})))\
    \ == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"\
    nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) ==\
    \ (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqrucx3rd.cpp: In function 'std::string find_max(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpqrucx3rd.cpp:17:16: error: ISO C++ forbids declaration of 'word'\
    \ with no type [-fpermissive]\n     for (auto &word : words) {\n             \
    \   ^\n/tmp/tmpqrucx3rd.cpp:17:23: error: range-based 'for' loops are not allowed\
    \ in C++98 mode\n     for (auto &word : words) {\n                       ^\n/tmp/tmpqrucx3rd.cpp:19:20:\
    \ error: ISO C++ forbids declaration of 'c' with no type [-fpermissive]\n    \
    \     for (auto &c : word) {\n                    ^\n/tmp/tmpqrucx3rd.cpp:19:24:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &c : word) {\n                        ^\n/tmp/tmpqrucx3rd.cpp: In function 'int\
    \ main()':\n/tmp/tmpqrucx3rd.cpp:30:10: error: 'candidate' does not name a type\n\
    \     auto candidate = find_max;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqrucx3rd.cpp:2:\n/tmp/tmpqrucx3rd.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                              ^\n/tmp/tmpqrucx3rd.cpp:31:111:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n \
    \                                                                            \
    \                                  ^\n/tmp/tmpqrucx3rd.cpp:31:111: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqrucx3rd.cpp:31:111: error: no matching function for call\
    \ to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpqrucx3rd.cpp:31:111: note"
  stdout: ''
