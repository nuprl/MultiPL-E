language: cpp
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwpx5e7wg.cpp: In function 'int main()':\n/tmp/tmpwpx5e7wg.cpp:105:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwpx5e7wg.cpp:2:\n/tmp/tmpwpx5e7wg.cpp:106:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqwdlhu5f.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpqwdlhu5f.cpp:104:1: error: expected unqualified-id before '}' token\n\
    \ }\n ^\n/tmp/tmpqwdlhu5f.cpp: In function 'int main()':\n/tmp/tmpqwdlhu5f.cpp:106:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqwdlhu5f.cpp:2:\n/tmp/tmpqwdlhu5f.cpp:107:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0;\n\
    \  long x = stoi(value);\n  long y = x;\n  long z = 0;\n  long i = 0;\n  while\
    \ (i < value.size()) {\n    z = x + y;\n    ans = z;\n    if (z > 0) {\n     \
    \ x = z;\n    } else {\n      y = z;\n    }\n    i++;\n  }\n  return ans;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmz5yaipt.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpmz5yaipt.cpp:19:22: error: 'stoi' was not declared in this scope\n   long\
    \ x = stoi(value);\n                      ^\n/tmp/tmpmz5yaipt.cpp: In function\
    \ 'int main()':\n/tmp/tmpmz5yaipt.cpp:36:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = closest_integer;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmz5yaipt.cpp:2:\n/tmp/tmpmz5yaipt.cpp:37:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long\
    \ e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n\
    \    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long\
    \ n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n\
    \    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long\
    \ w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n\
    \    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long\
    \ F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n\
    \    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long\
    \ O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n\
    \    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long\
    \ X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n\
    \    long c = 0;\n    long d = 0;\n    long e\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvz5iwqz3.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpvz5iwqz3.cpp:72:10: error: redeclaration of 'long int i'\n     long i\
    \ = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:20:10: error: 'long int i' previously\
    \ declared here\n     long i = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:73:10: error:\
    \ redeclaration of 'long int j'\n     long j = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:21:10:\
    \ error: 'long int j' previously declared here\n     long j = 0;\n          ^\n\
    /tmp/tmpvz5iwqz3.cpp:74:10: error: redeclaration of 'long int k'\n     long k\
    \ = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:22:10: error: 'long int k' previously\
    \ declared here\n     long k = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:75:10: error:\
    \ redeclaration of 'long int l'\n     long l = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:23:10:\
    \ error: 'long int l' previously declared here\n     long l = 0;\n          ^\n\
    /tmp/tmpvz5iwqz3.cpp:76:10: error: redeclaration of 'long int m'\n     long m\
    \ = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:24:10: error: 'long int m' previously\
    \ declared here\n     long m = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:77:10: error:\
    \ redeclaration of 'long int n'\n     long n = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:25:10:\
    \ error: 'long int n' previously declared here\n     long n = 0;\n          ^\n\
    /tmp/tmpvz5iwqz3.cpp:78:10: error: redeclaration of 'long int o'\n     long o\
    \ = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:26:10: error: 'long int o' previously\
    \ declared here\n     long o = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:79:10: error:\
    \ redeclaration of 'long int p'\n     long p = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:27:10:\
    \ error: 'long int p' previously declared here\n     long p = 0;\n          ^\n\
    /tmp/tmpvz5iwqz3.cpp:80:10: error: redeclaration of 'long int q'\n     long q\
    \ = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:28:10: error: 'long int q' previously\
    \ declared here\n     long q = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:81:10: error:\
    \ redeclaration of 'long int r'\n     long r = 0;\n          ^\n/tmp/tmpvz5iwqz3.cpp:29:10:\
    \ error: 'long int r' previously declared here\n     long r = 0;\n          ^\n\
    /tmp/tmpvz5iw"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0;\n\
    \  long long temp = 0;\n  long long temp2 = 0;\n  long long temp3 = 0;\n  long\
    \ long temp4 = 0;\n  long long temp5 = 0;\n  long long temp6 = 0;\n  long long\
    \ temp7 = 0;\n  long long temp8 = 0;\n  long long temp9 = 0;\n  long long temp10\
    \ = 0;\n  long long temp11 = 0;\n  long long temp12 = 0;\n  long long temp13 =\
    \ 0;\n  long long temp14 = 0;\n  long long temp15 = 0;\n  long long temp16 = 0;\n\
    \  long long temp17 = 0;\n  long long temp18 = 0;\n  long long temp19 = 0;\n \
    \ long long temp20 = 0;\n  long long temp21 = 0;\n  long long temp22 = 0;\n  long\
    \ long temp23 = 0;\n  long long temp24 = 0;\n  long long temp25 = 0;\n  long long\
    \ temp26 = 0;\n  long long temp27 = 0;\n  long long temp28 = 0;\n  long long temp29\
    \ = 0;\n  long long temp30 = 0;\n  long long temp31 = 0;\n  long long temp32 =\
    \ 0;\n  long long temp33 = 0;\n  long long temp34 = 0;\n  long long temp35 = 0;\n\
    \  long long temp36 = 0;\n  long long temp37 = 0;\n  long long temp38 = 0;\n \
    \ long long temp39 = 0;\n  long long temp40 = 0;\n  long long temp41 = 0;\n  long\
    \ long temp42 = 0;\n  long long temp43 = 0;\n  long long temp44 = 0;\n  long long\
    \ temp45 = 0;\n  long long temp46 = 0;\n  long long temp47 = 0;\n  long long temp48\
    \ = 0;\n  long long temp49 = 0;\n  long long temp50 = 0;\n  long long temp51 =\
    \ 0;\n  long long temp52 = 0;\n  long long temp53 = 0;\n  long long temp54 = 0;\n\
    \  long long temp55 = 0;\n  long long temp56 = 0;\n  long long temp57 = 0;\n \
    \ long long temp58 = 0;\n  long long temp59 = 0;\n  long long temp60 = 0;\n  long\
    \ long temp61 = 0;\n  long long temp62 = 0;\n  long long temp63 = 0;\n  long long\
    \ temp64 = 0;\n  long long temp65 = 0;\n  long long temp66 = 0;\n  long long temp67\
    \ = 0;\n  long long temp68 = 0;\n  long long temp69 = 0;\n  long long temp70 =\
    \ 0;\n  long long temp71 = 0;\n  long long temp72 = 0;\n  long long \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv1fpul84.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpv1fpul84.cpp:92:1: error: expected unqualified-id before '}' token\n }\n\
    \ ^\n/tmp/tmpv1fpul84.cpp: In function 'int main()':\n/tmp/tmpv1fpul84.cpp:94:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv1fpul84.cpp:2:\n/tmp/tmpv1fpul84.cpp:95:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int lower = 0, upper = std::stoll(value);\n\
    \    long long int mid = (lower + upper) / 2;\n    if (lower == upper) {\n   \
    \     return mid;\n    }\n    if (mid < lower) {\n        lower = mid;\n    }\n\
    \    if (mid > upper) {\n        upper = mid;\n    }\n    if (lower == upper)\
    \ {\n        return mid;\n    }\n    if (lower > upper) {\n        lower = upper;\n\
    \    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7kejcbtq.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmp7kejcbtq.cpp:17:38: error: 'stoll' is not a member of 'std'\n     long\
    \ long int lower = 0, upper = std::stoll(value);\n                           \
    \           ^\n/tmp/tmp7kejcbtq.cpp: In function 'int main()':\n/tmp/tmp7kejcbtq.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7kejcbtq.cpp:2:\n/tmp/tmp7kejcbtq.cpp:38:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = std::stoll(value);\n\
    \    long long int low = std::floor(num);\n    long long int high = std::ceil(num);\n\
    \    if (low == high) {\n        return low;\n    }\n    if (low == 0) {\n   \
    \     return high;\n    }\n    if (high == 0) {\n        return low;\n    }\n\
    \    if (num == low) {\n        return high;\n    }\n    if (num == high) {\n\
    \        return low;\n    }\n    if (num < low) {\n        return low;\n    }\n\
    \    if (num > high) {\n        return high;\n    }\n    if (num == low + 1) {\n\
    \        return high;\n    }\n    if (num == high - 1) {\n        return low;\n\
    \    }\n    if (num == low + 2) {\n        return high;\n    }\n    if (num ==\
    \ high - 2) {\n        return low;\n    }\n    if (num == low + 3) {\n       \
    \ return high;\n    }\n    if (num == high - 3) {\n        return low;\n    }\n\
    \    if (num == low + 4) {\n        return high;\n    }\n    if (num == high -\
    \ 4) {\n        return low;\n    }\n    if (num == low + 5) {\n        return\
    \ high;\n    }\n    if (num == high - 5) {\n        return low;\n    }\n    if\
    \ (num == low + 6) {\n        return high;\n    }\n    if (num == high - 6) {\n\
    \        return low;\n    }\n    if (num == low + 7) {\n        return high;\n\
    \    }\n    if (num == high - 7) {\n        return low;\n    }\n    if (num ==\
    \ low + 8) {\n        return high;\n    }\n    if (num == high - 8) {\n      \
    \  return low;\n    }\n    if (num == low + 9) {\n        return high;\n    }\n\
    \    if (num == high - 9) {\n        return low;\n    }\n    if (num == low +\
    \ 10) {\n        return high;\n    }\n    if (num == high - 10) {\n        return\
    \ low;\n    }\n    if (num == low + 11) {\n        return high;\n    }\n    if\
    \ (num == high - 11) {\n        return low;\n    }\n    if (num == low + 12) {\n\
    \        return high;\n    }\n    if (num == high - 12) {\n        return low;\n\
    \    }\n    if (num == low + 13) {\n        return high;\n    }\n    if (num ==\
    \ high - 13) {\n        return low;\n    }\n    if (num == low + 14) {\n     \
    \   return high;\n    }\n    if (num == high - 14) {\n        return low;\n  \
    \  }\n    if (num == low + 15) {\n        return high;\n    }\n\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcxwd5cba.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpcxwd5cba.cpp:17:25: error: 'stoll' is not a member of 'std'\n     long\
    \ long int num = std::stoll(value);\n                         ^\n/tmp/tmpcxwd5cba.cpp:\
    \ In function 'int main()':\n/tmp/tmpcxwd5cba.cpp:131:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = closest_integer;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcxwd5cba.cpp:2:\n/tmp/tmpcxwd5cba.cpp:132:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzx0j7g7x.cpp: In function 'int main()':\n/tmp/tmpzx0j7g7x.cpp:87:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzx0j7g7x.cpp:2:\n/tmp/tmpzx0j7g7x.cpp:88:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, i = 0;\n    long temp;\n    while(i < value.size()) {\n        temp = std::stoll(value.substr(i,\
    \ 1));\n        if(temp > ans) {\n            ans = temp;\n        }\n       \
    \ i++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeyy8g1ty.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpeyy8g1ty.cpp:21:16: error: 'stoll' is not a member of 'std'\n        \
    \ temp = std::stoll(value.substr(i, 1));\n                ^\n/tmp/tmpeyy8g1ty.cpp:\
    \ In function 'int main()':\n/tmp/tmpeyy8g1ty.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = closest_integer;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeyy8g1ty.cpp:2:\n/tmp/tmpeyy8g1ty.cpp:31:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff = diff * -1;\n    }\n    ans = temp;\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpec6h4k3u.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpec6h4k3u.cpp:19:12: error: 'stoll' is not a member of 'std'\n     temp\
    \ = std::stoll(value);\n            ^\n/tmp/tmpec6h4k3u.cpp: In function 'int\
    \ main()':\n/tmp/tmpec6h4k3u.cpp:28:10: error: 'candidate' does not name a type\n\
    \     auto candidate = closest_integer;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpec6h4k3u.cpp:2:\n/tmp/tmpec6h4k3u.cpp:29:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, power = 1;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxclxq3y5.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpxclxq3y5.cpp:91:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpxclxq3y5.cpp: In function 'int main()':\n/tmp/tmpxclxq3y5.cpp:93:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxclxq3y5.cpp:2:\n/tmp/tmpxclxq3y5.cpp:94:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long n = stoi(value);\n    long d = n - 1;\n    while (d >=\
    \ 0) {\n        ans += d;\n        diff += d;\n        d /= 10;\n    }\n    ans\
    \ -= diff;\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy2_frt0w.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpy2_frt0w.cpp:19:24: error: 'stoi' was not declared in this scope\n   \
    \  long n = stoi(value);\n                        ^\n/tmp/tmpy2_frt0w.cpp: In\
    \ function 'int main()':\n/tmp/tmpy2_frt0w.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = closest_integer;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy2_frt0w.cpp:2:\n/tmp/tmpy2_frt0w.cpp:31:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    std::stringstream\
    \ ss(value);\n    ss >> num;\n    long long int lower = 0, upper = INT_MAX;\n\
    \    long long int mid = 0;\n    while (lower <= upper) {\n        mid = (lower\
    \ + upper) / 2;\n        if (mid * mid <= num) {\n            lower = mid + 1;\n\
    \        } else {\n            upper = mid - 1;\n        }\n    }\n    return\
    \ mid;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpun5ib55c.cpp: In function 'int main()':\n/tmp/tmpun5ib55c.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpun5ib55c.cpp:2:\n/tmp/tmpun5ib55c.cpp:34:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (upper < lower) {\n        std::swap(lower, upper);\n    }\n    long mid\
    \ = (lower + upper) / 2;\n    if (mid % 2 == 0) {\n        return mid;\n    }\n\
    \    if (mid % 3 == 0) {\n        return mid - 1;\n    }\n    if (mid % 5 == 0)\
    \ {\n        return mid - 3;\n    }\n    return mid;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi4jmdvzm.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpi4jmdvzm.cpp:17:29: error: 'stoll' is not a member of 'std'\n     long\
    \ lower = 0, upper = std::stoll(value);\n                             ^\n/tmp/tmpi4jmdvzm.cpp:\
    \ In function 'int main()':\n/tmp/tmpi4jmdvzm.cpp:34:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = closest_integer;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi4jmdvzm.cpp:2:\n/tmp/tmpi4jmdvzm.cpp:35:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long lvalue = std::stoll(value);\n\
    \    long rvalue = std::stoull(value);\n    if (lvalue < rvalue) {\n        ans\
    \ = lvalue;\n    } else {\n        ans = rvalue;\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt402i3rc.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpt402i3rc.cpp:18:19: error: 'stoll' is not a member of 'std'\n     long\
    \ lvalue = std::stoll(value);\n                   ^\n/tmp/tmpt402i3rc.cpp:19:19:\
    \ error: 'stoull' is not a member of 'std'\n     long rvalue = std::stoull(value);\n\
    \                   ^\n/tmp/tmpt402i3rc.cpp: In function 'int main()':\n/tmp/tmpt402i3rc.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt402i3rc.cpp:2:\n/tmp/tmpt402i3rc.cpp:29:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n\
    \    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long\
    \ q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n\
    \    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long\
    \ z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n\
    \    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long\
    \ I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n\
    \    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long\
    \ R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n\
    \    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long\
    \ aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee =\
    \ 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n\
    \    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long\
    \ nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long rr =\
    \ 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n\
    \    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long\
    \ aaa = 0;\n    long bbb = 0;\n    long ccc = 0;\n    long ddd = 0;\n    long\
    \ eee = 0;\n    long fff = 0;\n    long ggg = 0;\n    long hhh = 0;\n    long\
    \ iii = 0;\n    long jjj = 0;\n    long kkk = 0;\n    long lll = 0;\n    long\
    \ mmm = 0;\n    long nnn = 0;\n    long ooo = 0;\n    long ppp = 0;\n    long\
    \ qqq = 0;\n    long rrr = 0;\n    long sss = 0;\n    long ttt = 0;\n    long\
    \ uuu = 0;\n    long vvv = 0;\n    long www = 0;\n    long xxx = 0;\n    long\
    \ yyy = 0;\n    long zzz = 0;\n    long \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpixezfj8f.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpixezfj8f.cpp:116:1: error: expected unqualified-id before '}' token\n\
    \ }\n ^\n/tmp/tmpixezfj8f.cpp: In function 'int main()':\n/tmp/tmpixezfj8f.cpp:118:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpixezfj8f.cpp:2:\n/tmp/tmpixezfj8f.cpp:119:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzx0j7g7x.cpp: In function 'int main()':\n/tmp/tmpzx0j7g7x.cpp:87:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzx0j7g7x.cpp:2:\n/tmp/tmpzx0j7g7x.cpp:88:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long l = 0;\n    long r = value.size() - 1;\n    while (l\
    \ <= r) {\n        long mid = (l + r) / 2;\n        long midVal = std::stoll(value.substr(mid,\
    \ value.size() - mid));\n        if (midVal < ans) {\n            l = mid + 1;\n\
    \        } else if (midVal > ans) {\n            r = mid - 1;\n        } else\
    \ {\n            return midVal;\n        }\n    }\n    if (l > r) {\n        return\
    \ ans;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmiils9__.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpmiils9__.cpp:23:23: error: 'stoll' is not a member of 'std'\n        \
    \ long midVal = std::stoll(value.substr(mid, value.size() - mid));\n         \
    \              ^\n/tmp/tmpmiils9__.cpp: In function 'int main()':\n/tmp/tmpmiils9__.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmiils9__.cpp:2:\n/tmp/tmpmiils9__.cpp:39:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int n = stoi(value);\n \
    \   long long int m = (n - 1) / 2;\n    long long int b = n - m;\n    if (b ==\
    \ 0) return n;\n    if (m == 0) return m;\n    if (m > 0 && b > 0) return m;\n\
    \    if (m > 0 && b < 0) return m;\n    if (m < 0 && b > 0) return m;\n    if\
    \ (m < 0 && b < 0) return m;\n    if (m == 0 && b > 0) return m;\n    if (m ==\
    \ 0 && b < 0) return m;\n    if (m > 0 && b == 0) return m;\n    if (m < 0 &&\
    \ b == 0) return m;\n    if (m == 0 && b == 0) return m;\n    return m;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbmcba0an.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpbmcba0an.cpp:17:33: error: 'stoi' was not declared in this scope\n   \
    \  long long int n = stoi(value);\n                                 ^\n/tmp/tmpbmcba0an.cpp:\
    \ In function 'int main()':\n/tmp/tmpbmcba0an.cpp:34:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = closest_integer;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbmcba0an.cpp:2:\n/tmp/tmpbmcba0an.cpp:35:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans =\
    \ temp;\n    if (diff < 0) {\n        diff *= -1;\n    }\n    if (diff > 100)\
    \ {\n        diff = 100;\n    }\n    if (diff < -100) {\n        diff = -100;\n\
    \    }\n    return ans + diff;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbi3fia3c.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpbi3fia3c.cpp:19:12: error: 'stoll' is not a member of 'std'\n     temp\
    \ = std::stoll(value);\n            ^\n/tmp/tmpbi3fia3c.cpp: In function 'int\
    \ main()':\n/tmp/tmpbi3fia3c.cpp:34:10: error: 'candidate' does not name a type\n\
    \     auto candidate = closest_integer;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbi3fia3c.cpp:2:\n/tmp/tmpbi3fia3c.cpp:35:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
