language: cpp
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (!kv.first.compare(0, 2, kv.first.size(), ::tolower)) {\n         \
    \   return false;\n        }\n        if (!kv.first.compare(0, 2, kv.first.size(),\
    \ ::toupper)) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3cw6e5fq.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp3cw6e5fq.cpp:20:63: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(int,\
    \ int, std::__cxx11::basic_string<char>::size_type, int (&)(int) noexcept) const\u2019\
    \n   20 |         if (!kv.first.compare(0, 2, kv.first.size(), ::tolower)) {\n\
    \      |                                                               ^\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp3cw6e5fq.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 4 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp3cw6e5fq.cpp:20:63:\
    \ note:   ca"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (item.first != item.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeckcza82.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpeckcza82.cpp:20:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (item.first != item.second.toLower()) return\
    \ false;\n      |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &pair : dict) {\n \
    \       if(pair.first != pair.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuxis3mn9.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpuxis3mn9.cpp:20:38: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if(pair.first != pair.second.toLower()) return\
    \ false;\n      |                                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    if(dict.empty()){\n        return\
    \ false;\n    }\n    for(auto &x: dict){\n        if(x.first < 'a' || x.first\
    \ > 'z'){\n            return false;\n        }\n        if(x.first < 'A' || x.first\
    \ > 'Z'){\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgku9mcuo.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpgku9mcuo.cpp:23:20: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   23 |         if(x.first < 'a' || x.first > 'z'){\n\
    \      |            ~~~~~~~ ^ ~~~\n      |              |       |\n      |   \
    \           |       char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgku9mcuo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpgku9mcuo.cpp:23:22:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   23 |         if(x.first\
    \ < 'a' || x.first > 'z'){\n      |                      ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgku9mcuo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpgku9mcuo.cpp:23:22: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and "
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (item.first != item.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeckcza82.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpeckcza82.cpp:20:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (item.first != item.second.toLower()) return\
    \ false;\n      |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first >= 'A' && kv.first <= 'Z') return true;\n        if(kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpenusq8_b.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpenusq8_b.cpp:20:21: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(kv.first >= 'A' && kv.first <= 'Z')\
    \ return true;\n      |            ~~~~~~~~ ^~ ~~~\n      |               |  \
    \      |\n      |               |        char\n      |               const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpenusq8_b.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpenusq8_b.cpp:20:24:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n      |                        ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpenusq8_b.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpenusq8_b.cpp:20:24: note:   mismatched types \u2018c"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict)\n    {\n     \
    \   auto key = item.first;\n        auto value = item.second;\n        auto lower\
    \ = std::tolower(key);\n        auto upper = std::toupper(key);\n        if (lower\
    \ != key || upper != key)\n        {\n            result = false;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqowoe_sc.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpqowoe_sc.cpp:23:38: error:\
    \ no matching function for call to \u2018tolower(std::__cxx11::basic_string<char>&)\u2019\
    \n   23 |         auto lower = std::tolower(key);\n      |                   \
    \                   ^\nIn file included from /usr/include/c++/9/cctype:42,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpqowoe_sc.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpqowoe_sc.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpqowoe_sc.cpp:23:38: note:   candidate expects 2 arguments,\
    \ 1 provided\n   23 |         auto lower = std::tolower(key);\n      |       \
    \                               ^\n/tmp/tmpqowoe_sc.cpp:24:38: error: no matching\
    \ function for call to \u2018toupper(std::__cxx11::basic_string<char>&)\u2019\n\
    \   24 |         auto upper = std::toupper(key);\n      |                    \
    \                  ^\nIn file included "
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.first.to_lower()) {\n            return false;\n  \
    \      }\n        if (kv.first != kv.first.to_upper()) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptd9gn4by.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmptd9gn4by.cpp:20:34: error:\
    \ \u2018const class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018to_lower\u2019\n   20 |         if (kv.first != kv.first.to_lower()) {\n\
    \      |                                  ^~~~~~~~\n/tmp/tmptd9gn4by.cpp:23:34:\
    \ error: \u2018const class std::__cxx11::basic_string<char>\u2019 has no member\
    \ named \u2018to_upper\u2019\n   23 |         if (kv.first != kv.first.to_upper())\
    \ {\n      |                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        if (kv.first != kv.second.tolower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn6jx8vny.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpn6jx8vny.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (kv.first != kv.second.tolower()) return false;\n\
    \      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131085
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict)\n    {\n       \
    \ if (!item.first.compare(item.first.at(0)))\n        {\n            flag = false;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg0cu3pjw.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpg0cu3pjw.cpp:21:49: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ value_type&) const\u2019\n   21 |         if (!item.first.compare(item.first.at(0)))\n\
    \      |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpg0cu3pjw.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:35:\
    \ note:   no known conversion for argument 1 from \u2018const value_type\u2019\
    \ {aka \u2018const char\u2019} to \u2018const std::__cxx11::basic_string<char>&\u2019\
    \n 2857 |       compare(const basic_string& __str) const\n      |            \
    \   ~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_str"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); ++it) {\n        if(it->first < 'A' || it->first > 'Z') {\n    \
    \        return false;\n        }\n    }\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); ++it) {\n        if(it->first > 'A' || it->first < 'Z') {\n    \
    \        return false;\n        }\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpywjprtz_.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpywjprtz_.cpp:20:22: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(it->first < 'A' || it->first > 'Z')\
    \ {\n      |            ~~~~~~~~~ ^ ~~~\n      |                |       |\n  \
    \    |                |       char\n      |                const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpywjprtz_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpywjprtz_.cpp:20:24:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(it->first\
    \ < 'A' || it->first > 'Z') {\n      |                        ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpywjprtz_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpywjprtz_.cpp:20:24: note:   mismatched types \u2018const std::__cxx11::sub_mat"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        if (kv.first >= 'a' && kv.first <= 'z') return true;\n        if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiw59y9o_.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpiw59y9o_.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'a' && kv.first <= 'z')\
    \ return true;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpiw59y9o_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpiw59y9o_.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpiw59y9o_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpiw59y9o_.cpp:20:25: note:   mismatched typ"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd6lk1exu.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpd6lk1exu.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (kv.first != kv.second.toLower()) return false;\n\
    \      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {\n            return std::islower(c) || std::isupper(c);\n\
    \        })) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmppagy5nju: /tmp/tmppagy5nju.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    \n    for (auto &kv : dict)\
    \ {\n        if (kv.first < 'A' || kv.first > 'Z') return false;\n    }\n    \n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm42h7p5x.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpm42h7p5x.cpp:21:22: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if (kv.first < 'A' || kv.first > 'Z')\
    \ return false;\n      |             ~~~~~~~~ ^ ~~~\n      |                |\
    \       |\n      |                |       char\n      |                const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm42h7p5x.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm42h7p5x.cpp:21:24:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if (kv.first\
    \ < 'A' || kv.first > 'Z') return false;\n      |                        ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm42h7p5x.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm42h7p5x.cpp:21:24: note:   mismatched types \u2018const"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool ret = true;\n    for(auto &x: dict) {\n        if(x.first\
    \ != x.second.toLower()) {\n            ret = false;\n            break;\n   \
    \     }\n    }\n    return ret;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_g7ify3y.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp_g7ify3y.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if(x.first != x.second.toLower()) {\n      |  \
    \                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &x: dict) {\n        flag = flag\
    \ && x.first == x.first.substr(0, 1) && (x.first == x.first.substr(0, 1) || x.first\
    \ == x.first.substr(0, 2));\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp2id5pr0g: /tmp/tmp2id5pr0g.cpp:27: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &pair : dict) {\n\
    \        if (pair.first < 'A' || pair.first > 'Z') return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt4k730ss.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpt4k730ss.cpp:20:24: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (pair.first < 'A' || pair.first >\
    \ 'Z') return false;\n      |             ~~~~~~~~~~ ^ ~~~\n      |          \
    \        |       |\n      |                  |       char\n      |           \
    \       const std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpt4k730ss.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpt4k730ss.cpp:20:26:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (pair.first\
    \ < 'A' || pair.first > 'Z') return false;\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpt4k730ss.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpt4k730ss.cpp:20:26: note:   mismatc"
  stdout: ''
  timestamp: 1660131086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) { return std::islower(c); })) {\n            return\
    \ true;\n        } else if (std::all_of(value.begin(), value.end(), [](char c)\
    \ { return std::isupper(c); })) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmptug1xcy4: /tmp/tmptug1xcy4.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first >= 'a' && kv.first <= 'z') return false;\n        if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm3hdnu31.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpm3hdnu31.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'a' && kv.first <= 'z')\
    \ return false;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm3hdnu31.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm3hdnu31.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'a' && kv.first <= 'z') return false;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm3hdnu31.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm3hdnu31.cpp:20:25: note:   mismatched t"
  stdout: ''
  timestamp: 1660131086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {return (c >= 'a' && c <= 'z') || (c >= 'A' && c <=\
    \ 'Z');})) {\n            if (std::all_of(value.begin(), value.end(), [](char\
    \ c) {return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');})) {\n        \
    \        return true;\n            }\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmps_d9d8zt: /tmp/tmps_d9d8zt.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {return (c >= 'a' && c <= 'z') || (c >= 'A' && c <=\
    \ 'Z');})) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpeu275t97: /tmp/tmpeu275t97.cpp:31: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131088
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ >= 'a' && x.first <= 'z') {\n            return true;\n        }\n        if(x.first\
    \ >= 'A' && x.first <= 'Z') {\n            return true;\n        }\n    }\n  \
    \  return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n   \
    \ assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"},\
    \ {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfyy3zon6.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpfyy3zon6.cpp:20:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(x.first >= 'a' && x.first <= 'z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfyy3zon6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpfyy3zon6.cpp:20:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(x.first\
    \ >= 'a' && x.first <= 'z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfyy3zon6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpfyy3zon6.cpp:20:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.size() == 0) return false;\n    for (auto &kv : dict)\
    \ {\n        if (kv.first >= 'a' && kv.first <= 'z') return true;\n        if\
    \ (kv.first >= 'A' && kv.first <= 'Z') return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuhezhcoz.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpuhezhcoz.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'a' && kv.first <= 'z')\
    \ return true;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuhezhcoz.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpuhezhcoz.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuhezhcoz.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpuhezhcoz.cpp:20:25: note:   mismatched typ"
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        auto &key = item.first;\n        auto &value = item.second;\n       \
    \ if (std::all_of(value.begin(), value.end(), ::isupper)) return false;\n    \
    \    if (std::all_of(value.begin(), value.end(), ::islower)) return false;\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpvhjmqgsz: /tmp/tmpvhjmqgsz.cpp:29: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto it = dict.begin(); it != dict.end();\
    \ ++it) {\n        auto key = it->first;\n        auto value = it->second;\n \
    \       if (std::all_of(value.begin(), value.end(), [](char c) {return std::islower(c)\
    \ || std::isupper(c);})) {\n            result = false;\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp3um0qtm0: /tmp/tmp3um0qtm0.cpp:31: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &i : dict) {\n        if (!(i.second.size()\
    \ == 1 && i.second.at(0) == i.first)) {\n            flag = false;\n         \
    \   break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3ikvtrog.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp3ikvtrog.cpp:20:54: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} and \u2018const std::__cxx11::basic_string<char>\u2019\
    )\n   20 |         if (!(i.second.size() == 1 && i.second.at(0) == i.first)) {\n\
    \      |                                       ~~~~~~~~~~~~~~ ^~ ~~~~~~~\n   \
    \   |                                                  |        |\n      |   \
    \                                               |        const std::__cxx11::basic_string<char>\n\
    \      |                                                  __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3ikvtrog.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp3ikvtrog.cpp:20:59:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   20 |         if (!(i.second.size() == 1 && i.second.at(0)\
    \ == i.first)) {\n      |                                                    \
    \       ^~~~~\nIn file included from /usr/include/c++/9/regex:62,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n        \
    \         from /tmp/tmp3ikvtrog.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx1"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first == x.second.tolower()) {\n            return true;\n        }\n\
    \        if(x.first == x.second.toupper()) {\n            return true;\n     \
    \   }\n    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp89zwdjbz.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp89zwdjbz.cpp:21:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   21 |         if(x.first == x.second.tolower()) {\n      |  \
    \                              ^~~~~~~\n/tmp/tmp89zwdjbz.cpp:24:32: error: \u2018\
    class std::__cxx11::basic_string<char>\u2019 has no member named \u2018toupper\u2019\
    \n   24 |         if(x.first == x.second.toupper()) {\n      |               \
    \                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &pair : dict) {\n        if\
    \ (!(std::all_of(pair.second.begin(), pair.second.end(), ::tolower)))\n      \
    \      result = false;\n        if (!(std::all_of(pair.second.begin(), pair.second.end(),\
    \ ::toupper)))\n            result = false;\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpdcb79u7s: /tmp/tmpdcb79u7s.cpp:30: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (item.first == item.second.tolower()) return true;\n        if (item.first\
    \ == item.second.toupper()) return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk4p22xa5.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpk4p22xa5.cpp:20:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (item.first == item.second.tolower()) return\
    \ true;\n      |                                       ^~~~~~~\n/tmp/tmpk4p22xa5.cpp:21:39:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toupper\u2019\n   21 |         if (item.first == item.second.toupper())\
    \ return true;\n      |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ == x.second.toLower()) {\n            return true;\n        }\n        if(x.first\
    \ == x.second.toUpper()) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfu82h3cg.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpfu82h3cg.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if(x.first == x.second.toLower()) {\n      |  \
    \                              ^~~~~~~\n/tmp/tmpfu82h3cg.cpp:23:32: error: \u2018\
    class std::__cxx11::basic_string<char>\u2019 has no member named \u2018toUpper\u2019\
    \n   23 |         if(x.first == x.second.toUpper()) {\n      |               \
    \                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.size() == 0) return false;\n    for (auto it = dict.begin();\
    \ it != dict.end(); ++it) {\n        if (it->first >= 'A' && it->first <= 'Z'\
    \ || it->first >= 'a' && it->first <= 'z') {\n            return true;\n     \
    \   }\n    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmaklh4l5.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpmaklh4l5.cpp:20:23: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (it->first >= 'A' && it->first <=\
    \ 'Z' || it->first >= 'a' && it->first <= 'z') {\n      |             ~~~~~~~~~\
    \ ^~ ~~~\n      |                 |        |\n      |                 |      \
    \  char\n      |                 const std::__cxx11::basic_string<char>\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmaklh4l5.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpmaklh4l5.cpp:20:26:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (it->first\
    \ >= 'A' && it->first <= 'Z' || it->first >= 'a' && it->first <= 'z') {\n    \
    \  |                          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmaklh4l5.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/subs"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto it = dict.begin(); it != dict.end(); ++it) {\n       \
    \ if(it->first != it->second.toLower()) {\n            return false;\n       \
    \ }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpecygp2h2.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpecygp2h2.cpp:19:36: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   19 |         if(it->first != it->second.toLower()) {\n     \
    \ |                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), ::islower)) {\n            if (std::all_of(value.begin(), value.end(),\
    \ ::isupper)) {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpldrr4j_i: /tmp/tmpldrr4j_i.cpp:32: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first == x.second.toLower()) {\n            return true;\n        }\n\
    \        if(x.first == x.second.toUpper()) {\n            return true;\n     \
    \   }\n    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjagbmbc7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpjagbmbc7.cpp:21:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if(x.first == x.second.toLower()) {\n      |  \
    \                              ^~~~~~~\n/tmp/tmpjagbmbc7.cpp:24:32: error: \u2018\
    class std::__cxx11::basic_string<char>\u2019 has no member named \u2018toUpper\u2019\
    \n   24 |         if(x.first == x.second.toUpper()) {\n      |               \
    \                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict) {\n        if\
    \ (item.first != item.second.toLower()) {\n            result = false;\n     \
    \       break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpck0t_wiv.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpck0t_wiv.cpp:20:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (item.first != item.second.toLower()) {\n  \
    \    |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &x: dict) {\n        if(x.first != x.second.toLower())\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpab4jz4ow.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpab4jz4ow.cpp:19:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   19 |         if(x.first != x.second.toLower()) {\n      |  \
    \                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool ret = true;\n    for (auto &x: dict) {\n        if (x.first\
    \ != x.second.toLower()) {\n            ret = false;\n            break;\n   \
    \     }\n    }\n    return ret;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx16axcsz.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpx16axcsz.cpp:20:33: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (x.first != x.second.toLower()) {\n      | \
    \                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &pair : dict) {\n\
    \        auto &key = pair.first;\n        auto &value = pair.second;\n       \
    \ if (std::all_of(value.begin(), value.end(), ::islower)) {\n            if (std::all_of(value.begin(),\
    \ value.end(), ::isupper)) {\n                return true;\n            }\n  \
    \      } else {\n            if (std::all_of(value.begin(), value.end(), ::isupper))\
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp70ayv5s9: /tmp/tmp70ayv5s9.cpp:36: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131088
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty())\n        return false;\n    for(auto &x: dict)\
    \ {\n        if(x.first == x.second.toLower()) {\n            return true;\n \
    \       }\n        if(x.first == x.second.toUpper()) {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsy4pm5uj.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpsy4pm5uj.cpp:21:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if(x.first == x.second.toLower()) {\n      |  \
    \                              ^~~~~~~\n/tmp/tmpsy4pm5uj.cpp:24:32: error: \u2018\
    class std::__cxx11::basic_string<char>\u2019 has no member named \u2018toUpper\u2019\
    \n   24 |         if(x.first == x.second.toUpper()) {\n      |               \
    \                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->second.size()==0) return false;\n        for(auto it2=it->second.begin();\
    \ it2!=it->second.end(); ++it2) {\n            if((*it2).size()==0) return false;\n\
    \            for(auto it3=(*it2).begin(); it3!=(*it2).end(); ++it3) {\n      \
    \          if((*it3).size()==0) return false;\n            }\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfhh49c65.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpfhh49c65.cpp:22:23: error:\
    \ request for member \u2018size\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |             if((*it2).size()==0) return false;\n\
    \      |                       ^~~~\n/tmp/tmpfhh49c65.cpp:23:33: error: request\
    \ for member \u2018begin\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |             for(auto it3=(*it2).begin(); it3!=(*it2).end();\
    \ ++it3) {\n      |                                 ^~~~~\n/tmp/tmpfhh49c65.cpp:23:54:\
    \ error: request for member \u2018end\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |             for(auto it3=(*it2).begin(); it3!=(*it2).end();\
    \ ++it3) {\n      |                                                      ^~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->first.compare(it->first,0,strlen(it->first.c_str()),0)!=0)\
    \ return false;\n        if(it->first.compare(it->first,0,strlen(it->first.c_str()),0)==0)\
    \ return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjiya5rp1.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpjiya5rp1.cpp:20:69: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, int, size_t, int) const\u2019\n   20 |  \
    \       if(it->first.compare(it->first,0,strlen(it->first.c_str()),0)!=0) return\
    \ false;\n      |                                                            \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpjiya5rp1.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note: candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 4 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpjiya5rp1.cpp:20:69:\
    \ no"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    \n    for(auto it = dict.begin(); it !=\
    \ dict.end(); ++it) {\n        if(it->first == it->second.toLower()) {\n     \
    \       return true;\n        }\n        if(it->first == it->second.toUpper())\
    \ {\n            return true;\n        }\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpstgcu1os.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpstgcu1os.cpp:21:36: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if(it->first == it->second.toLower()) {\n     \
    \ |                                    ^~~~~~~\n/tmp/tmpstgcu1os.cpp:24:36: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toUpper\u2019\n   24 |         if(it->first == it->second.toUpper()) {\n     \
    \ |                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (!(item.second.size() == 1 && item.second.at(0) == item.first[0] &&\
    \ item.first.size() == 1)) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp8zp_2hd_: /tmp/tmp8zp_2hd_.cpp:26: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131088
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.size() == 0)\n        return false;\n    for (auto &kv\
    \ : dict) {\n        auto &key = kv.first;\n        auto &value = kv.second;\n\
    \        if (std::tolower(key) != key)\n            return false;\n        if\
    \ (std::toupper(key) != value)\n            return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpaa23dzkq.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpaa23dzkq.cpp:23:29: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   23 |         if (std::tolower(key) != key)\n      |                     \
    \        ^\nIn file included from /usr/include/c++/9/cctype:42,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n           \
    \      from /tmp/tmpaa23dzkq.cpp:2:\n/usr/include/ctype.h:122:12: note: candidate:\
    \ \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c) __THROW;\n\
    \      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no known conversion\
    \ for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019 to \u2018\
    int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      |            \
    \         ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpaa23dzkq.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpaa23dzkq.cpp:23:29: note:   candidate expects 2 arguments,\
    \ 1 provided\n   23 |         if (std::tolower(key) != key)\n      |         \
    \                    ^\n/tmp/tmpaa23dzkq.cpp:25:29: error: no matching function\
    \ for call to \u2018toupper(const std::__cxx11::basic_string<char>&)\u2019\n \
    \  25 |         if (std::toupper(key) != value)\n      |                     \
    \        ^\nIn file included from /usr/inc"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first >= 'a' && x.first <= 'z') return false;\n        if(x.first >=\
    \ 'A' && x.first <= 'Z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5bxqmdxo.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp5bxqmdxo.cpp:20:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(x.first >= 'a' && x.first <= 'z')\
    \ return false;\n      |            ~~~~~~~ ^~ ~~~\n      |              |   \
    \     |\n      |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp5bxqmdxo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp5bxqmdxo.cpp:20:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(x.first\
    \ >= 'a' && x.first <= 'z') return false;\n      |                       ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp5bxqmdxo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp5bxqmdxo.cpp:20:23: note:   mismatched types \u2018const st"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &x: dict) {\n        if (x.first\
    \ != x.second.toLower()) {\n            flag = false;\n            break;\n  \
    \      }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2_ucc_a5.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2_ucc_a5.cpp:20:33: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (x.first != x.second.toLower()) {\n      | \
    \                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &item : dict) {\n\
    \        if (item.first >= 'A' && item.first <= 'Z') return true;\n        if\
    \ (item.first >= 'a' && item.first <= 'z') return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy2glpt1l.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpy2glpt1l.cpp:20:24: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (item.first >= 'A' && item.first <=\
    \ 'Z') return true;\n      |             ~~~~~~~~~~ ^~ ~~~\n      |          \
    \        |        |\n      |                  |        char\n      |         \
    \         const std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy2glpt1l.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy2glpt1l.cpp:20:27:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (item.first\
    \ >= 'A' && item.first <= 'Z') return true;\n      |                         \
    \  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n                 from\
    \ /tmp/tmpy2glpt1l.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5: note: candidate:\
    \ \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc> bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148\
    \ |     operator>=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1148:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy2glpt1l.cpp:20:27:\
    \ note"
  stdout: ''
  timestamp: 1660131088
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &item : dict) {\n \
    \       if(item.first < 'A' || item.first > 'Z') return false;\n        if(item.second\
    \ < 'a' || item.second > 'z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg7zs55td.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpg7zs55td.cpp:20:23: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(item.first < 'A' || item.first > 'Z')\
    \ return false;\n      |            ~~~~~~~~~~ ^ ~~~\n      |                \
    \ |       |\n      |                 |       char\n      |                 const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpg7zs55td.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpg7zs55td.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(item.first\
    \ < 'A' || item.first > 'Z') return false;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpg7zs55td.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpg7zs55td.cpp:20:25: note:   mismatched typ"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::tolower(key)\
    \ != key || std::toupper(key) != key) return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa_sliwdq.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpa_sliwdq.cpp:22:29: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower(key) != key || std::toupper(key) != key) return\
    \ false;\n      |                             ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpa_sliwdq.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa_sliwdq.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa_sliwdq.cpp:22:29: note:   candidate expects 2 arguments,\
    \ 1 provided\n   22 |         if (std::tolower(key) != key || std::toupper(key)\
    \ != key) return false;\n      |                             ^\n/tmp/tmpa_sliwdq.cpp:22:57:\
    \ error: no matching function for call to \u2018toupper(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty())\n        return false;\n    for(auto &x: dict)\n\
    \        if(x.first != x.second.toLower())\n            return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9qe8puq1.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp9qe8puq1.cpp:21:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if(x.first != x.second.toLower())\n      |    \
    \                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first == x.second.toLower()) return true;\n        if(x.first == x.second.toUpper())\
    \ return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa1nwjjx0.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpa1nwjjx0.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if(x.first == x.second.toLower()) return true;\n\
    \      |                                ^~~~~~~\n/tmp/tmpa1nwjjx0.cpp:21:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toUpper\u2019\n   21 |         if(x.first == x.second.toUpper()) return true;\n\
    \      |                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->second.size() == 0) return false;\n        for(auto\
    \ it2=it->second.begin(); it2!=it->second.end(); ++it2) {\n            if((*it2).size()\
    \ == 0) return false;\n            for(auto it3=(*it2).begin(); it3!=(*it2).end();\
    \ ++it3) {\n                if((*it3).size() == 0) return false;\n           \
    \     for(auto it4=(*it3).begin(); it4!=(*it3).end(); ++it4) {\n             \
    \       if((*it4).size() == 0) return false;\n                }\n            }\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_lrscaif.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp_lrscaif.cpp:22:23: error:\
    \ request for member \u2018size\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |             if((*it2).size() == 0) return false;\n\
    \      |                       ^~~~\n/tmp/tmp_lrscaif.cpp:23:33: error: request\
    \ for member \u2018begin\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |             for(auto it3=(*it2).begin(); it3!=(*it2).end();\
    \ ++it3) {\n      |                                 ^~~~~\n/tmp/tmp_lrscaif.cpp:23:54:\
    \ error: request for member \u2018end\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |             for(auto it3=(*it2).begin(); it3!=(*it2).end();\
    \ ++it3) {\n      |                                                      ^~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first >= 'A' && kv.first <= 'Z') return true;\n        if (kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe7zwe93x.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpe7zwe93x.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'A' && kv.first <= 'Z')\
    \ return true;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe7zwe93x.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpe7zwe93x.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe7zwe93x.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpe7zwe93x.cpp:20:25: note:   mismatched typ"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &item : dict) {\n\
    \        if (!item.first.compare(0, 2, item.first.size(), item.first))\n     \
    \       return false;\n        if (!item.first.compare(2, item.first.size(), item.first.size(),\
    \ item.first))\n            return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwo_azcac.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpwo_azcac.cpp:20:68: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(int,\
    \ int, std::__cxx11::basic_string<char>::size_type, const std::__cxx11::basic_string<char>&)\
    \ const\u2019\n   20 |         if (!item.first.compare(0, 2, item.first.size(),\
    \ item.first))\n      |                                                      \
    \              ^\nIn file included from /usr/include/c++/9/string:55,\n      \
    \           from /usr/include/c++/9/bits/locale_classes.h:40,\n              \
    \   from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwo_azcac.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note: candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 4 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpwo_a"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &it : dict)\n    {\n        flag\
    \ = flag && std::all_of(it.second.begin(), it.second.end(), [](char &c){return\
    \ (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');});\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpvo7bqg2s: /tmp/tmpvo7bqg2s.cpp:28: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first >= 'a' && kv.first <= 'z') return true;\n        if(kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp1a4d1cs.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpp1a4d1cs.cpp:20:21: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(kv.first >= 'a' && kv.first <= 'z')\
    \ return true;\n      |            ~~~~~~~~ ^~ ~~~\n      |               |  \
    \      |\n      |               |        char\n      |               const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpp1a4d1cs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpp1a4d1cs.cpp:20:24:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n      |                        ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpp1a4d1cs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpp1a4d1cs.cpp:20:24: note:   mismatched types \u2018c"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first >= 'A' && kv.first <= 'Z') return false;\n        if (kv.first\
    \ >= 'a' && kv.first <= 'z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiuhhr8fb.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpiuhhr8fb.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'A' && kv.first <= 'Z')\
    \ return false;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpiuhhr8fb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpiuhhr8fb.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return false;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpiuhhr8fb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpiuhhr8fb.cpp:20:25: note:   mismatched t"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ == x.second.tolower()) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkyob1yxm.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpkyob1yxm.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if(x.first == x.second.tolower()) {\n      |  \
    \                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &it : dict)\n    {\n        if\
    \ (it.first != it.second.toLower())\n        {\n            flag = false;\n  \
    \          break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1spf_y5t.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp1spf_y5t.cpp:21:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if (it.first != it.second.toLower())\n      | \
    \                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), ::isupper)) return false;\n        if (std::all_of(value.begin(),\
    \ value.end(), ::islower)) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmphakaf3xm: /tmp/tmphakaf3xm.cpp:29: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    if(dict.empty())\n        return false;\n\
    \    for(auto &x: dict)\n    {\n        if(x.first == x.second.toupper())\n  \
    \          return true;\n        if(x.first == x.second.tolower())\n         \
    \   return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqk2sbwfg.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpqk2sbwfg.cpp:23:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toupper\u2019\n   23 |         if(x.first == x.second.toupper())\n      |    \
    \                            ^~~~~~~\n/tmp/tmpqk2sbwfg.cpp:25:32: error: \u2018\
    class std::__cxx11::basic_string<char>\u2019 has no member named \u2018tolower\u2019\
    \n   25 |         if(x.first == x.second.tolower())\n      |                 \
    \               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), ::isupper)) {\n            if (std::all_of(value.begin(), value.end(),\
    \ ::islower)) {\n                return true;\n            }\n        }\n    \
    \    if (std::all_of(value.begin(), value.end(), ::islower)) {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmprujq2sf5: /tmp/tmprujq2sf5.cpp:36: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {return (c >= 'a' && c <= 'z') || (c >= 'A' && c <=\
    \ 'Z');})) {\n            if (std::all_of(value.begin(), value.end(), [](char\
    \ c) {return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');})) {\n        \
    \        return true;\n            }\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmps_d9d8zt: /tmp/tmps_d9d8zt.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto it = dict.begin(); it != dict.end();\
    \ ++it) {\n        auto key = it->first;\n        auto value = it->second;\n \
    \       flag = flag && key.size() == value.size() && std::all_of(key.begin(),\
    \ key.end(), [&](char c) {\n            return std::islower(c) || std::isupper(c);\n\
    \        });\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp3r2xcgeo: /tmp/tmp3r2xcgeo.cpp:30: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    \n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        std::string key = it->first;\n        std::string value = it->second;\n\
    \        if(!key.compare(0, 2, ::tolower)) {\n            if(!value.compare(0,\
    \ 2, ::tolower)) {\n                return true;\n            }\n        } else\
    \ if(!key.compare(0, 2, ::toupper)) {\n            if(!value.compare(0, 2, ::toupper))\
    \ {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5_z0qat7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp5_z0qat7.cpp:23:40: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(int,\
    \ int, int (&)(int) noexcept)\u2019\n   23 |         if(!key.compare(0, 2, ::tolower))\
    \ {\n      |                                        ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5_z0qat7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note: candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp5_z0qat7.cpp:23:40:\
    \ note:   candidate expects 1 argument, 3 provided\n   23 |         if(!key.compare(0,\
    \ 2, ::tolower)) {\n      "
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto it = dict.begin(); it != dict.end();\
    \ ++it) {\n        auto it2 = it;\n        ++it2;\n        if (it2->first != it->first)\
    \ {\n            flag = false;\n            break;\n        }\n        if (it2->second\
    \ != it->second) {\n            flag = false;\n            break;\n        }\n\
    \    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpo8au8pun: /tmp/tmpo8au8pun.cpp:35: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->second.size() > 1) return false;\n        if(it->second.size()\
    \ == 1 && it->second[0] < 'A' || it->second[0] > 'Z') return false;\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n   \
    \ assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"},\
    \ {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpgbk174sj: /tmp/tmpgbk174sj.cpp:27: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict) {\n        if\
    \ (!item.first.compare(item.first.c_str(), 0, item.first.length(), \n        \
    \                      std::locale(), std::ctype<char>::tolower())) {\n      \
    \      result = false;\n        }\n        if (!item.first.compare(item.first.c_str(),\
    \ 0, item.first.length(), \n                              std::locale(), std::ctype<char>::toupper()))\
    \ {\n            result = false;\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuz_bkjgb.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpuz_bkjgb.cpp:21:72: error:\
    \ no matching function for call to \u2018std::ctype<char>::tolower()\u2019\n \
    \  21 |                               std::locale(), std::ctype<char>::tolower()))\
    \ {\n      |                                                                 \
    \       ^\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n   \
    \              from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpuz_bkjgb.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:835:7: note:\
    \ candidate: \u2018std::ctype<char>::char_type std::ctype<char>::tolower(std::ctype<char>::char_type)\
    \ const\u2019\n  835 |       tolower(char_type __c) const\n      |       ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:835:7: note:   candidate expects 1 argument,\
    \ 0 provided\n/usr/include/c++/9/bits/locale_facets.h:852:7: note: candidate:\
    \ \u2018const char_type* std::ctype<char>::tolower(std::ctype<char>::char_type*,\
    \ const char_type*) const\u2019\n  852 |       tolower(char_type* __lo, const\
    \ char_type* __hi) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/locale_facets.h:852:7:\
    \ note:   candidate expects 2 arguments, 0 provided\n/tmp/tmpuz_bkjgb.cpp:25:72:\
    \ error: no matching function for call to \u2018std::ctype<char>::toupper()\u2019\
    \n   25 |                               std::locale(), std::ctype<char>::toupper()))\
    \ {\n      |                                                                 \
    \       ^\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n   \
    \              from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (!(item.first == item.second.toLower()))\n            return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2vc9duo_.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2vc9duo_.cpp:20:41: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (!(item.first == item.second.toLower()))\n \
    \     |                                         ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (!item.first.compare(item.first.begin(), item.first.end(), ::tolower))\
    \ {\n            return false;\n        }\n        if (!item.first.compare(item.first.begin(),\
    \ item.first.end(), ::toupper)) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprkdd7s1r.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmprkdd7s1r.cpp:20:80: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(std::__cxx11::basic_string<char>::const_iterator,\
    \ std::__cxx11::basic_string<char>::const_iterator, int (&)(int) noexcept) const\u2019\
    \n   20 |         if (!item.first.compare(item.first.begin(), item.first.end(),\
    \ ::tolower)) {\n      |                                                     \
    \                           ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprkdd7s1r.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note: candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template"
  stdout: ''
  timestamp: 1660131090
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto it = dict.begin();\
    \ it != dict.end(); ++it) {\n        auto key = it->first;\n        auto value\
    \ = it->second;\n        if (std::all_of(value.begin(), value.end(), ::isupper))\
    \ {\n            return true;\n        } else if (std::all_of(value.begin(), value.end(),\
    \ ::islower)) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpls0id3ht: /tmp/tmpls0id3ht.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    bool flag = true;\n    for\
    \ (auto &x: dict) {\n        if ((x.first >= 'a' && x.first <= 'z') || (x.first\
    \ >= 'A' && x.first <= 'Z')) {\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplhjycd4q.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmplhjycd4q.cpp:21:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if ((x.first >= 'a' && x.first <= 'z')\
    \ || (x.first >= 'A' && x.first <= 'Z')) {\n      |              ~~~~~~~ ^~ ~~~\n\
    \      |                |        |\n      |                |        char\n   \
    \   |                const std::__cxx11::basic_string<char>\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplhjycd4q.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmplhjycd4q.cpp:21:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if ((x.first\
    \ >= 'a' && x.first <= 'z') || (x.first >= 'A' && x.first <= 'Z')) {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplhjycd4q.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ fail"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &x: dict) {\n        if(x.first >= 'A' && x.first <= 'Z')\
    \ {\n            return true;\n        }\n        if(x.first >= 'a' && x.first\
    \ <= 'z') {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbvd9bmdh.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpbvd9bmdh.cpp:19:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   19 |         if(x.first >= 'A' && x.first <= 'Z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbvd9bmdh.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpbvd9bmdh.cpp:19:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   19 |         if(x.first\
    \ >= 'A' && x.first <= 'Z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbvd9bmdh.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpbvd9bmdh.cpp:19:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131090
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->second.size()!=1 && (it->second.at(0)>='a' && it->second.at(0)<='z')\
    \ || (it->second.at(0)>='A' && it->second.at(0)<='Z')) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpitx306ep: /tmp/tmpitx306ep.cpp:29: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for(auto it = dict.begin(); it != dict.end();\
    \ ++it) {\n        if(it->first != it->first.toLower()) {\n            flag =\
    \ false;\n            break;\n        }\n        if(it->first != it->first.toUpper())\
    \ {\n            flag = false;\n            break;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmrw7uau5.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpmrw7uau5.cpp:20:35: error:\
    \ \u2018const class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toLower\u2019\n   20 |         if(it->first != it->first.toLower()) {\n\
    \      |                                   ^~~~~~~\n/tmp/tmpmrw7uau5.cpp:24:35:\
    \ error: \u2018const class std::__cxx11::basic_string<char>\u2019 has no member\
    \ named \u2018toUpper\u2019\n   24 |         if(it->first != it->first.toUpper())\
    \ {\n      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first >= 'a' && x.first <= 'z') {\n            return true;\n       \
    \ }\n        if(x.first >= 'A' && x.first <= 'Z') {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprylxxzc7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmprylxxzc7.cpp:21:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if(x.first >= 'a' && x.first <= 'z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprylxxzc7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmprylxxzc7.cpp:21:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if(x.first\
    \ >= 'a' && x.first <= 'z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprylxxzc7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmprylxxzc7.cpp:21:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), ::isupper)) return false;\n        if (std::all_of(value.begin(),\
    \ value.end(), ::islower)) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmphakaf3xm: /tmp/tmphakaf3xm.cpp:29: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &x: dict) {\n        if(x.first != x.second.toLower())\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpab4jz4ow.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpab4jz4ow.cpp:19:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   19 |         if(x.first != x.second.toLower()) {\n      |  \
    \                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &it : dict) {\n        flag =\
    \ flag && is_lower_case(it.first) || is_upper_case(it.first);\n        flag =\
    \ flag && is_lower_case(it.second) || is_upper_case(it.second);\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptcipqd7f.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmptcipqd7f.cpp:20:24: error:\
    \ \u2018is_lower_case\u2019 was not declared in this scope; did you mean \u2018\
    iswlower_l\u2019?\n   20 |         flag = flag && is_lower_case(it.first) || is_upper_case(it.first);\n\
    \      |                        ^~~~~~~~~~~~~\n      |                       \
    \ iswlower_l\n/tmp/tmptcipqd7f.cpp:20:51: error: \u2018is_upper_case\u2019 was\
    \ not declared in this scope; did you mean \u2018iswupper_l\u2019?\n   20 |  \
    \       flag = flag && is_lower_case(it.first) || is_upper_case(it.first);\n \
    \     |                                                   ^~~~~~~~~~~~~\n    \
    \  |                                                   iswupper_l\n"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ >= 'a' && x.first <= 'z') {\n            return true;\n        }\n        if(x.first\
    \ >= 'A' && x.first <= 'Z') {\n            return true;\n        }\n    }\n  \
    \  return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n   \
    \ assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"},\
    \ {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfyy3zon6.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpfyy3zon6.cpp:20:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(x.first >= 'a' && x.first <= 'z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfyy3zon6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpfyy3zon6.cpp:20:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(x.first\
    \ >= 'a' && x.first <= 'z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfyy3zon6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpfyy3zon6.cpp:20:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict) {\n        if (item.first\
    \ != item.second.tolower()) {\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvfsusocy.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpvfsusocy.cpp:20:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (item.first != item.second.tolower()) {\n  \
    \    |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131090
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpwrx6vfz4: /tmp/tmpwrx6vfz4.cpp:276: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict) {\n        if\
    \ (item.first != item.second.toLower()) {\n            result = false;\n     \
    \   }\n    }\n    return result;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwnxf_naw.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpwnxf_naw.cpp:20:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (item.first != item.second.toLower()) {\n  \
    \    |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    return dict.size() == 0;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpnpimzkbe: /tmp/tmpnpimzkbe.cpp:24: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict) {\n        if\
    \ (!item.first.compare(0, 2, \"_\") && !item.first.compare(0, 1, \"_\") && !item.first.compare(0,\
    \ 3, \"_\")) {\n            result = false;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpr6y2mbrq: /tmp/tmpr6y2mbrq.cpp:29: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto it = dict.begin();\
    \ it != dict.end(); ++it) {\n        auto key = it->first;\n        auto value\
    \ = it->second;\n        if (std::all_of(value.begin(), value.end(), ::islower))\
    \ {\n            if (std::all_of(value.begin(), value.end(), ::isupper)) {\n \
    \               return true;\n            }\n        } else {\n            if\
    \ (std::all_of(value.begin(), value.end(), ::isupper)) {\n                return\
    \ false;\n            }\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpfzo5zyxr: /tmp/tmpfzo5zyxr.cpp:36: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &pair : dict) {\n\
    \        auto &key = pair.first;\n        auto &value = pair.second;\n       \
    \ if (std::tolower(key) != key || std::toupper(key) != key) return false;\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjuki0f_z.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpjuki0f_z.cpp:22:29: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower(key) != key || std::toupper(key) != key) return\
    \ false;\n      |                             ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpjuki0f_z.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpjuki0f_z.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpjuki0f_z.cpp:22:29: note:   candidate expects 2 arguments,\
    \ 1 provided\n   22 |         if (std::tolower(key) != key || std::toupper(key)\
    \ != key) return false;\n      |                             ^\n/tmp/tmpjuki0f_z.cpp:22:57:\
    \ error: no matching function for call to \u2018toupper(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty())\n        return false;\n    for(auto &x: dict)\n\
    \        if(x.first != x.second.toLower())\n            return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9qe8puq1.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp9qe8puq1.cpp:21:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if(x.first != x.second.toLower())\n      |    \
    \                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    bool flag = true;\n    for\
    \ (auto &item : dict) {\n        flag = flag && item.first == item.second.tolower();\n\
    \        flag = flag && item.first == item.second.toupper();\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjlq7ed2v.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpjlq7ed2v.cpp:21:50: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   21 |         flag = flag && item.first == item.second.tolower();\n\
    \      |                                                  ^~~~~~~\n/tmp/tmpjlq7ed2v.cpp:22:50:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toupper\u2019\n   22 |         flag = flag && item.first == item.second.toupper();\n\
    \      |                                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first < 'A' || kv.first > 'Z') return false;\n        if(kv.second\
    \ < 'a' || kv.second > 'z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2q4o57u3.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2q4o57u3.cpp:20:21: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(kv.first < 'A' || kv.first > 'Z')\
    \ return false;\n      |            ~~~~~~~~ ^ ~~~\n      |               |  \
    \     |\n      |               |       char\n      |               const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2q4o57u3.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp2q4o57u3.cpp:20:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(kv.first\
    \ < 'A' || kv.first > 'Z') return false;\n      |                       ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2q4o57u3.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp2q4o57u3.cpp:20:23: note:   mismatched types \u2018const std::_"
  stdout: ''
  timestamp: 1660131090
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpwrx6vfz4: /tmp/tmpwrx6vfz4.cpp:276: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (item.first >= 'a' && item.first <= 'z') return true;\n        if\
    \ (item.first >= 'A' && item.first <= 'Z') return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg7z1_feo.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpg7z1_feo.cpp:20:24: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (item.first >= 'a' && item.first <=\
    \ 'z') return true;\n      |             ~~~~~~~~~~ ^~ ~~~\n      |          \
    \        |        |\n      |                  |        char\n      |         \
    \         const std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpg7z1_feo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpg7z1_feo.cpp:20:27:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (item.first\
    \ >= 'a' && item.first <= 'z') return true;\n      |                         \
    \  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n                 from\
    \ /tmp/tmpg7z1_feo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5: note: candidate:\
    \ \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc> bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148\
    \ |     operator>=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1148:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpg7z1_feo.cpp:20:27:\
    \ note"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &kv : dict) {\n        if(kv.first != kv.second.tolower())\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptr5_htmo.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmptr5_htmo.cpp:19:34: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   19 |         if(kv.first != kv.second.tolower()) {\n      |\
    \                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &kv : dict) {\n        if(kv.first != kv.second.toLower())\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppk4oh80i.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmppk4oh80i.cpp:19:34: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   19 |         if(kv.first != kv.second.toLower()) {\n      |\
    \                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ >= 'a' && x.first <= 'z') {\n            return true;\n        }\n        if(x.first\
    \ >= 'A' && x.first <= 'Z') {\n            return true;\n        }\n    }\n  \
    \  return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n   \
    \ assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"},\
    \ {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfyy3zon6.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpfyy3zon6.cpp:20:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(x.first >= 'a' && x.first <= 'z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfyy3zon6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpfyy3zon6.cpp:20:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(x.first\
    \ >= 'a' && x.first <= 'z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfyy3zon6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpfyy3zon6.cpp:20:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &p: dict)\n        if(p.first != p.second.toLower())\n\
    \            return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd3_4lff4.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpd3_4lff4.cpp:19:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   19 |         if(p.first != p.second.toLower())\n      |    \
    \                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict)\n \
    \       if (!item.first.compare(0, 2, item.first.front()) || !item.first.compare(2,\
    \ item.first.size(), item.first.back()))\n            return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa5a79gw4.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpa5a79gw4.cpp:20:57: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(int,\
    \ int, const value_type&) const\u2019\n   20 |         if (!item.first.compare(0,\
    \ 2, item.first.front()) || !item.first.compare(2, item.first.size(), item.first.back()))\n\
    \      |                                                         ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa5a79gw4.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa5a79gw4.cpp:20:57:\
    \ note:   c"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &i : dict) {\n        if (!i.first.compare(0,\
    \ 2, ::tolower)) {\n            flag = false;\n            break;\n        }\n\
    \        if (!i.first.compare(0, 2, ::toupper)) {\n            flag = false;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm0l62rnj.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpm0l62rnj.cpp:20:45: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(int,\
    \ int, int (&)(int) noexcept) const\u2019\n   20 |         if (!i.first.compare(0,\
    \ 2, ::tolower)) {\n      |                                             ^\nIn\
    \ file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm0l62rnj.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm0l62rnj.cpp:20:45:\
    \ note:   candidate expects 1 argument, 3 provided\n   20 |         if (!i.first.compare(0,\
    \ 2,"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first >= 'a' && x.first <= 'z') {\n            return true;\n       \
    \ }\n        if(x.first >= 'A' && x.first <= 'Z') {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprylxxzc7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmprylxxzc7.cpp:21:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if(x.first >= 'a' && x.first <= 'z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprylxxzc7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmprylxxzc7.cpp:21:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if(x.first\
    \ >= 'a' && x.first <= 'z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprylxxzc7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmprylxxzc7.cpp:21:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {return (c >= 'a' && c <= 'z') || (c >= 'A' && c <=\
    \ 'Z');})) {\n            if (std::all_of(value.begin(), value.end(), [](char\
    \ c) {return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');})) {\n        \
    \        return true;\n            }\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmps_d9d8zt: /tmp/tmps_d9d8zt.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->first != it->second.toLower()) {\n            flag =\
    \ false;\n            break;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp__5h93qa.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp__5h93qa.cpp:20:36: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if(it->first != it->second.toLower()) {\n     \
    \ |                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict)\n    {\n       \
    \ if (item.first != item.second.toLower())\n        {\n            flag = false;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp916x7mj7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp916x7mj7.cpp:21:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if (item.first != item.second.toLower())\n    \
    \  |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first >= 'A' && x.first <= 'Z') return false;\n        if(x.first >=\
    \ 'a' && x.first <= 'z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfmkij8k1.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpfmkij8k1.cpp:20:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(x.first >= 'A' && x.first <= 'Z')\
    \ return false;\n      |            ~~~~~~~ ^~ ~~~\n      |              |   \
    \     |\n      |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfmkij8k1.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpfmkij8k1.cpp:20:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(x.first\
    \ >= 'A' && x.first <= 'Z') return false;\n      |                       ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfmkij8k1.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpfmkij8k1.cpp:20:23: note:   mismatched types \u2018const st"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first >= 'A' && kv.first <= 'Z') return true;\n        if (kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe7zwe93x.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpe7zwe93x.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'A' && kv.first <= 'Z')\
    \ return true;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe7zwe93x.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpe7zwe93x.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe7zwe93x.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpe7zwe93x.cpp:20:25: note:   mismatched typ"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.second.tolower()) return false; \n        if (kv.first\
    \ != kv.second.toupper()) return false; \n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkh9m5q18.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpkh9m5q18.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (kv.first != kv.second.tolower()) return false;\n\
    \      |                                   ^~~~~~~\n/tmp/tmpkh9m5q18.cpp:21:35:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toupper\u2019\n   21 |         if (kv.first != kv.second.toupper()) return\
    \ false;\n      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &x: dict) {\n        if (x.first\
    \ != x.second.toLower()) {\n            flag = false;\n            break;\n  \
    \      }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2_ucc_a5.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2_ucc_a5.cpp:20:33: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (x.first != x.second.toLower()) {\n      | \
    \                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &kv : dict) {\n        if (kv.first\
    \ != kv.second.toLower()) {\n            result = false;\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqgq0m556.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpqgq0m556.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (kv.first != kv.second.toLower()) {\n      |\
    \                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (item.first != item.second.tolower()) return false;\n        if (item.first\
    \ != item.second.toupper()) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppdo5xeo2.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmppdo5xeo2.cpp:20:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (item.first != item.second.tolower()) return\
    \ false;\n      |                                       ^~~~~~~\n/tmp/tmppdo5xeo2.cpp:21:39:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toupper\u2019\n   21 |         if (item.first != item.second.toupper())\
    \ return false;\n      |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &x: dict) {\n        if(x.first.compare(x.first,::tolower)\
    \ == 0) {\n            return true;\n        }\n        if(x.first.compare(x.first,::toupper)\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnied6eap.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpnied6eap.cpp:19:45: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, int (&)(int) noexcept) const\u2019\n   19\
    \ |         if(x.first.compare(x.first,::tolower) == 0) {\n      |           \
    \                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnied6eap.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note: candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnied6eap.cpp:19:45:\
    \ note:   candidate expects 1 argument, 2 provided\n   19 "
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict)\n    {\n       \
    \ if (item.first != item.second.toLower())\n        {\n            flag = false;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp916x7mj7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp916x7mj7.cpp:21:39: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if (item.first != item.second.toLower())\n    \
    \  |                                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd6lk1exu.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpd6lk1exu.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (kv.first != kv.second.toLower()) return false;\n\
    \      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131086
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {return std::islower(c) || std::isupper(c);})) {\n \
    \           return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpz6so8z_6: /tmp/tmpz6so8z_6.cpp:31: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131092
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    \n    // Write your code here\n    \n    return dict.empty();\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmph450n1i7: /tmp/tmph450n1i7.cpp:25: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool ret = true;\n    for (auto &kv : dict) {\n        if (!kv.first.compare(0,\
    \ 2, kv.first.size(), ::tolower)) {\n            ret = false;\n            break;\n\
    \        }\n        if (!kv.first.compare(0, 2, kv.first.size(), ::toupper)) {\n\
    \            ret = false;\n            break;\n        }\n    }\n    return ret;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2l9o9bxx.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2l9o9bxx.cpp:20:63: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(int,\
    \ int, std::__cxx11::basic_string<char>::size_type, int (&)(int) noexcept) const\u2019\
    \n   20 |         if (!kv.first.compare(0, 2, kv.first.size(), ::tolower)) {\n\
    \      |                                                               ^\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp2l9o9bxx.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 4 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp2l9o9bxx.cpp:20:63:\
    \ note:   ca"
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.size() == 0) return false;\n    for (auto &item : dict)\
    \ {\n        if (item.first < 'A' || item.first > 'Z') return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptbs6hq46.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmptbs6hq46.cpp:20:24: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (item.first < 'A' || item.first >\
    \ 'Z') return false;\n      |             ~~~~~~~~~~ ^ ~~~\n      |          \
    \        |       |\n      |                  |       char\n      |           \
    \       const std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptbs6hq46.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptbs6hq46.cpp:20:26:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (item.first\
    \ < 'A' || item.first > 'Z') return false;\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptbs6hq46.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptbs6hq46.cpp:20:26: note:   mismatc"
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &x: dict) {\n        if (x.first\
    \ != x.second.toLower()) {\n            flag = false;\n            break;\n  \
    \      }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2_ucc_a5.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2_ucc_a5.cpp:20:33: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if (x.first != x.second.toLower()) {\n      | \
    \                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first != kv.first.to_lower()) {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwkvxl2zk.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpwkvxl2zk.cpp:20:33: error:\
    \ \u2018const class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018to_lower\u2019\n   20 |         if(kv.first != kv.first.to_lower()) {\n\
    \      |                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660131092
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first.compare(x.first) == 0) {\n            if(x.second.compare(x.second)\
    \ == 0) {\n                continue;\n            }\n            else {\n    \
    \            return false;\n            }\n        }\n        else {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp26w6616o: /tmp/tmp26w6616o.cpp:37: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &item : dict) {\n \
    \       if(item.first != item.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxgfrt0yi.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpxgfrt0yi.cpp:20:38: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if(item.first != item.second.toLower()) return\
    \ false;\n      |                                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131092
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char ch) { return std::islower(ch) || std::isupper(ch); }))\n\
    \            return true;\n        if (std::all_of(value.begin(), value.end(),\
    \ [](char ch) { return std::isupper(ch); }))\n            return true;\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp1wgux5pi: /tmp/tmp1wgux5pi.cpp:32: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &x: dict) {\n        if(x.first == x.second.tolower())\
    \ return true;\n        if(x.first == x.second.toupper()) return true;\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn61i7xjz.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpn61i7xjz.cpp:19:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   19 |         if(x.first == x.second.tolower()) return true;\n\
    \      |                                ^~~~~~~\n/tmp/tmpn61i7xjz.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toupper\u2019\n   20 |         if(x.first == x.second.toupper()) return true;\n\
    \      |                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131092
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    \n    bool flag = true;\n    \n    for (auto &item : dict)\n  \
    \  {\n        flag = flag && item.second.size() > 0;\n    }\n    \n    return\
    \ flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpegevn11i: /tmp/tmpegevn11i.cpp:31: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131093
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->second.size()!=2) {\n            return false;\n   \
    \     }\n        \n        if(it->second.at(0)>='A' && it->second.at(0)<='Z')\
    \ {\n            return false;\n        }\n        \n        if(it->second.at(1)>='a'\
    \ && it->second.at(1)<='z') {\n            return false;\n        }\n    }\n \
    \   \n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpspwrg6fa: /tmp/tmpspwrg6fa.cpp:38: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first >= 'a' && kv.first <= 'z') return false;\n        if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm3hdnu31.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpm3hdnu31.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'a' && kv.first <= 'z')\
    \ return false;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm3hdnu31.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm3hdnu31.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'a' && kv.first <= 'z') return false;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm3hdnu31.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm3hdnu31.cpp:20:25: note:   mismatched t"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &x: dict) {\n        if(x.first.compare(x.first,0,1) !=\
    \ 0) {\n            return false;\n        }\n        if(x.first.compare(x.first,0,2)\
    \ != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg0lgsx5i.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpg0lgsx5i.cpp:19:39: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, int, int) const\u2019\n   19 |         if(x.first.compare(x.first,0,1)\
    \ != 0) {\n      |                                       ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpg0lgsx5i.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpg0lgsx5i.cpp:19:39:\
    \ note:   candidate expects 1 argument, 3 provided\n   19 |         if(x.first.comp"
  stdout: ''
  timestamp: 1660131092
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char ch) {\n            return std::islower(ch) || std::isupper(ch);\n\
    \        })) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmprplt6qic: /tmp/tmprplt6qic.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return false;\n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->first < 'A' || it->first > 'Z') return false;\n    \
    \    if(it->second < 'A' || it->second > 'Z') return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpft_c6vcj.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpft_c6vcj.cpp:20:22: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(it->first < 'A' || it->first > 'Z')\
    \ return false;\n      |            ~~~~~~~~~ ^ ~~~\n      |                |\
    \       |\n      |                |       char\n      |                const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpft_c6vcj.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpft_c6vcj.cpp:20:24:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(it->first\
    \ < 'A' || it->first > 'Z') return false;\n      |                        ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpft_c6vcj.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpft_c6vcj.cpp:20:24: note:   mismatched types \u2018con"
  stdout: ''
  timestamp: 1660131092
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ == x.second.tolower()) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkyob1yxm.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpkyob1yxm.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if(x.first == x.second.tolower()) {\n      |  \
    \                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &pair : dict) {\n \
    \       if(pair.first >= 'a' && pair.first <= 'z') return false;\n        if(pair.first\
    \ >= 'A' && pair.first <= 'Z') return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl3lyf9yv.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpl3lyf9yv.cpp:20:23: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(pair.first >= 'a' && pair.first <=\
    \ 'z') return false;\n      |            ~~~~~~~~~~ ^~ ~~~\n      |          \
    \       |        |\n      |                 |        char\n      |           \
    \      const std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpl3lyf9yv.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpl3lyf9yv.cpp:20:26:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(pair.first\
    \ >= 'a' && pair.first <= 'z') return false;\n      |                        \
    \  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n                 from\
    \ /tmp/tmpl3lyf9yv.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5: note: candidate:\
    \ \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc> bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148\
    \ |     operator>=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1148:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpl3lyf9yv.cpp:20:26:\
    \ note:   m"
  stdout: ''
  timestamp: 1660131092
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto it = dict.begin();\
    \ it != dict.end(); ++it) {\n        auto key = it->first;\n        auto value\
    \ = it->second;\n        if (std::all_of(value.begin(), value.end(), ::isupper))\
    \ return false;\n        if (std::all_of(value.begin(), value.end(), ::islower))\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpcdp9ib6t: /tmp/tmpcdp9ib6t.cpp:29: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    bool flag = true;\n    for\
    \ (auto &it : dict)\n    {\n        flag = flag && is_str_lower(it.first) || is_str_upper(it.first);\n\
    \    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0_qa98ky.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp0_qa98ky.cpp:22:24: error:\
    \ \u2018is_str_lower\u2019 was not declared in this scope\n   22 |         flag\
    \ = flag && is_str_lower(it.first) || is_str_upper(it.first);\n      |       \
    \                 ^~~~~~~~~~~~\n/tmp/tmp0_qa98ky.cpp:22:50: error: \u2018is_str_upper\u2019\
    \ was not declared in this scope\n   22 |         flag = flag && is_str_lower(it.first)\
    \ || is_str_upper(it.first);\n      |                                        \
    \          ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first < x.second.tolower()) {\n            return false;\n        }\n\
    \        if(x.first > x.second.toupper()) {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgr3j03x0.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpgr3j03x0.cpp:21:31: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   21 |         if(x.first < x.second.tolower()) {\n      |   \
    \                            ^~~~~~~\n/tmp/tmpgr3j03x0.cpp:24:31: error: \u2018\
    class std::__cxx11::basic_string<char>\u2019 has no member named \u2018toupper\u2019\
    \n   24 |         if(x.first > x.second.toupper()) {\n      |                \
    \               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131092
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict)\n \
    \   {\n        auto &key = item.first;\n        auto &value = item.second;\n \
    \       if (std::all_of(value.begin(), value.end(), [](char c) { return std::islower(c)\
    \ || std::isupper(c); }))\n            return true;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) { return std::isupper(c); }))\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp_gpkkuim: /tmp/tmp_gpkkuim.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {\n            return std::islower(c) || std::isupper(c);\n\
    \        })) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp_931lhky: /tmp/tmp_931lhky.cpp:32: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    \n    // Write your code here\n    \n    return false; // Write\
    \ your code here\n}\nint main() {\n    auto candidate = check_dict_case;\n   \
    \ assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"},\
    \ {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpxyeo5d0r: /tmp/tmpxyeo5d0r.cpp:25: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &x: dict) {\n        if(x.first >= 'a' && x.first <= 'z')\
    \ {\n            return true;\n        }\n        if(x.first >= 'A' && x.first\
    \ <= 'Z') {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0c090q77.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp0c090q77.cpp:19:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   19 |         if(x.first >= 'a' && x.first <= 'z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0c090q77.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0c090q77.cpp:19:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   19 |         if(x.first\
    \ >= 'a' && x.first <= 'z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0c090q77.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0c090q77.cpp:19:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.second.tolower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk64azwbl.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpk64azwbl.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (kv.first != kv.second.tolower()) return false;\n\
    \      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &it : dict)\n   \
    \     if (it.first != it.second.tolower()) return false; \n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpckn5p0go.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpckn5p0go.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (it.first != it.second.tolower()) return false;\n\
    \      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ == x.second.toupper()) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjy9i8jja.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpjy9i8jja.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toupper\u2019\n   20 |         if(x.first == x.second.toupper()) {\n      |  \
    \                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::tolower(key)\
    \ != key || std::toupper(key) != key) return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa_sliwdq.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpa_sliwdq.cpp:22:29: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower(key) != key || std::toupper(key) != key) return\
    \ false;\n      |                             ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpa_sliwdq.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa_sliwdq.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa_sliwdq.cpp:22:29: note:   candidate expects 2 arguments,\
    \ 1 provided\n   22 |         if (std::tolower(key) != key || std::toupper(key)\
    \ != key) return false;\n      |                             ^\n/tmp/tmpa_sliwdq.cpp:22:57:\
    \ error: no matching function for call to \u2018toupper(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto it = dict.begin(); it != dict.end();\
    \ it++) {\n        auto key = it->first;\n        auto value = it->second;\n \
    \       if (std::all_of(value.begin(), value.end(), [](char ch) {\n          \
    \  return std::islower(ch) || std::isupper(ch);\n        })) {\n            result\
    \ = false;\n            break;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpp28566_i: /tmp/tmpp28566_i.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    bool flag = true;\n    for\
    \ (auto &x: dict) {\n        if ((x.first >= 'a' && x.first <= 'z') || (x.first\
    \ >= 'A' && x.first <= 'Z')) {\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplhjycd4q.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmplhjycd4q.cpp:21:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if ((x.first >= 'a' && x.first <= 'z')\
    \ || (x.first >= 'A' && x.first <= 'Z')) {\n      |              ~~~~~~~ ^~ ~~~\n\
    \      |                |        |\n      |                |        char\n   \
    \   |                const std::__cxx11::basic_string<char>\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplhjycd4q.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmplhjycd4q.cpp:21:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if ((x.first\
    \ >= 'a' && x.first <= 'z') || (x.first >= 'A' && x.first <= 'Z')) {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplhjycd4q.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ fail"
  stdout: ''
  timestamp: 1660131090
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto it = dict.begin();\
    \ it != dict.end(); ++it) {\n        for(auto it2 = it->second.begin(); it2 !=\
    \ it->second.end(); ++it2) {\n            if(std::tolower(it->first) == std::tolower(it2->first)\
    \ || std::toupper(it->first) == std::toupper(it2->first)) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnx0ejcgu.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpnx0ejcgu.cpp:22:38: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |             if(std::tolower(it->first) == std::tolower(it2->first) ||\
    \ std::toupper(it->first) == std::toupper(it2->first)) {\n      |            \
    \                          ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpnx0ejcgu.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnx0ejcgu.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnx0ejcgu.cpp:22:38: note:   candidate expects 2 arguments,\
    \ 1 provided\n   22 |             if(std::tolower(it->first) == std::tolower(it2->first)\
    \ || std::toupper(it->first) == std::toupper(it2->first)) {\n      |         \
    \                             ^\n/tmp/tmpnx0ejcgu.cpp:22:61: error: request for "
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto &pair : dict) {\n        if(pair.first >= 'a' && pair.first\
    \ <= 'z') {\n            return true;\n        }\n        if(pair.first >= 'A'\
    \ && pair.first <= 'Z') {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpick4v2rt.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpick4v2rt.cpp:19:23: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   19 |         if(pair.first >= 'a' && pair.first <=\
    \ 'z') {\n      |            ~~~~~~~~~~ ^~ ~~~\n      |                 |    \
    \    |\n      |                 |        char\n      |                 const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpick4v2rt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpick4v2rt.cpp:19:26:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   19 |         if(pair.first\
    \ >= 'a' && pair.first <= 'z') {\n      |                          ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpick4v2rt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpick4v2rt.cpp:19:26: note:   mismatched types \u2018const"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first != kv.second.tolower()) return false;\n        if(kv.first !=\
    \ kv.second.toupper()) return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0bljyq69.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp0bljyq69.cpp:20:34: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if(kv.first != kv.second.tolower()) return false;\n\
    \      |                                  ^~~~~~~\n/tmp/tmp0bljyq69.cpp:21:34:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toupper\u2019\n   21 |         if(kv.first != kv.second.toupper()) return\
    \ false;\n      |                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first >= 'a' && x.first <= 'z') {\n            return true;\n       \
    \ }\n        if(x.first >= 'A' && x.first <= 'Z') {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprylxxzc7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmprylxxzc7.cpp:21:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if(x.first >= 'a' && x.first <= 'z')\
    \ {\n      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n    \
    \  |              |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprylxxzc7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmprylxxzc7.cpp:21:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if(x.first\
    \ >= 'a' && x.first <= 'z') {\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprylxxzc7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmprylxxzc7.cpp:21:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_B"
  stdout: ''
  timestamp: 1660131089
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first.compare(x.first,0,1) != 0) return false;\n        if(x.first.compare(x.first,0,2)\
    \ != 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7etnnc0u.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp7etnnc0u.cpp:20:39: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, int, int) const\u2019\n   20 |         if(x.first.compare(x.first,0,1)\
    \ != 0) return false;\n      |                                       ^\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp7etnnc0u.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp7etnnc0u.cpp:20:39:\
    \ note:   candidate expects 1 argument, 3 provided\n   20 |         if("
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::tolower(key)\
    \ != key || std::toupper(key) != key) return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa_sliwdq.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpa_sliwdq.cpp:22:29: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower(key) != key || std::toupper(key) != key) return\
    \ false;\n      |                             ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpa_sliwdq.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa_sliwdq.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa_sliwdq.cpp:22:29: note:   candidate expects 2 arguments,\
    \ 1 provided\n   22 |         if (std::tolower(key) != key || std::toupper(key)\
    \ != key) return false;\n      |                             ^\n/tmp/tmpa_sliwdq.cpp:22:57:\
    \ error: no matching function for call to \u2018toupper(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |         if (std::tolower"
  stdout: ''
  timestamp: 1660131089
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto it = dict.begin();\
    \ it != dict.end(); it++) {\n        auto key = it->first;\n        auto value\
    \ = it->second;\n        if (std::all_of(value.begin(), value.end(), ::islower))\
    \ {\n            if (std::all_of(value.begin(), value.end(), ::isupper)) {\n \
    \               return true;\n            }\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpt1a2lzaw: /tmp/tmpt1a2lzaw.cpp:32: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto it=dict.begin();it!=dict.end();it++){\n\
    \        if(it->second.size()==0){\n            return false;\n        }\n   \
    \     for(auto it2=it->second.begin();it2!=it->second.end();it2++){\n        \
    \    if((*it2).size()==0){\n                return false;\n            }\n   \
    \         for(auto it3=(*it2).begin();it3!=(*it2).end();it3++){\n            \
    \    if((*it3).size()==0){\n                    return false;\n              \
    \  }\n            }\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1p5s23qh.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp1p5s23qh.cpp:25:23: error:\
    \ request for member \u2018size\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   25 |             if((*it2).size()==0){\n      |  \
    \                     ^~~~\n/tmp/tmp1p5s23qh.cpp:28:33: error: request for member\
    \ \u2018begin\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >::operator*()\u2019, which is of non-class type \u2018char\u2019\n   28 | \
    \            for(auto it3=(*it2).begin();it3!=(*it2).end();it3++){\n      |  \
    \                               ^~~~~\n/tmp/tmp1p5s23qh.cpp:28:53: error: request\
    \ for member \u2018end\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   28 |             for(auto it3=(*it2).begin();it3!=(*it2).end();it3++){\n\
    \      |                                                     ^~~\n"
  stdout: ''
  timestamp: 1660131093
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char ch) { return (ch >= 'a' && ch <= 'z') || (ch >= 'A' &&\
    \ ch <= 'Z'); })) {\n            if (std::all_of(value.begin(), value.end(), [](char\
    \ ch) { return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'); })) {\n \
    \               return true;\n            }\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp6qmky4df: /tmp/tmp6qmky4df.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    return dict.size() == 0;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpnpimzkbe: /tmp/tmpnpimzkbe.cpp:24: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv: dict)\n      \
    \  if(kv.first != kv.second.tolower()) return false;\n    return true;\n}\nint\
    \ main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyyfiw8n7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpyyfiw8n7.cpp:20:34: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if(kv.first != kv.second.tolower()) return false;\n\
    \      |                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        if (kv.first >= 'a' && kv.first <= 'z') return true;\n        if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiw59y9o_.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpiw59y9o_.cpp:20:22: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first >= 'a' && kv.first <= 'z')\
    \ return true;\n      |             ~~~~~~~~ ^~ ~~~\n      |                |\
    \        |\n      |                |        char\n      |                const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpiw59y9o_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpiw59y9o_.cpp:20:25:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpiw59y9o_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpiw59y9o_.cpp:20:25: note:   mismatched typ"
  stdout: ''
  timestamp: 1660131086
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict) {\n        if\
    \ (!(item.first == item.second.compare(0, item.first.size(), item.first, 0, item.first.size())))\
    \ return false;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8dxl73vb.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp8dxl73vb.cpp:20:26: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018int\u2019)\n   20 |         if (!(item.first == item.second.compare(0,\
    \ item.first.size(), item.first, 0, item.first.size()))) return false;\n     \
    \ |               ~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                    |                           |\n      |           \
    \         |                           int\n      |                    const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8dxl73vb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp8dxl73vb.cpp:20:103:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (!(item.first\
    \ == item.second.compare(0, item.first.size(), item.first, 0, item.first.size())))\
    \ return false;\n      |                                                     \
    \                                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8dxl73vb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_tra"
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict) {\n        flag\
    \ = flag && item.first == item.first.at(0).tolower() || item.first == item.first.at(0).toupper();\n\
    \    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo628l_jz.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpo628l_jz.cpp:20:55: error:\
    \ request for member \u2018tolower\u2019 in \u2018item.std::pair<const std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >::first.std::__cxx11::basic_string<char>::at(0)\u2019\
    , which is of non-class type \u2018const value_type\u2019 {aka \u2018const char\u2019\
    }\n   20 |         flag = flag && item.first == item.first.at(0).tolower() ||\
    \ item.first == item.first.at(0).toupper();\n      |                         \
    \                              ^~~~~~~\n/tmp/tmpo628l_jz.cpp:20:99: error: request\
    \ for member \u2018toupper\u2019 in \u2018item.std::pair<const std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >::first.std::__cxx11::basic_string<char>::at(0)\u2019\
    , which is of non-class type \u2018const value_type\u2019 {aka \u2018const char\u2019\
    }\n   20 |         flag = flag && item.first == item.first.at(0).tolower() ||\
    \ item.first == item.first.at(0).toupper();\n      |                         \
    \                                                                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first.compare(x.first,0,1) != 0) {\n            return false;\n     \
    \   }\n        if(x.first.compare(x.first,0,2) != 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6l5isupm.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp6l5isupm.cpp:21:39: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, int, int) const\u2019\n   21 |         if(x.first.compare(x.first,0,1)\
    \ != 0) {\n      |                                       ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6l5isupm.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp6l5isupm.cpp:21:39:\
    \ note:   candidate expects 1 argument, 3 provided\n   21 |         if(x.first.comp"
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    \n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->first.compare(it->first,0,1)==0) {\n            return\
    \ false;\n        }\n        if(it->first.compare(it->first,0,2)==0) {\n     \
    \       return true;\n        }\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo3ick6x9.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpo3ick6x9.cpp:21:43: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, int, int) const\u2019\n   21 |         if(it->first.compare(it->first,0,1)==0)\
    \ {\n      |                                           ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpo3ick6x9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpo3ick6x9.cpp:21:43:\
    \ note:   candidate expects 1 argument, 3 provided\n   21 |         if(it->fi"
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    \n    // Write your code here\n    \n    return dict.size() ==\
    \ 0;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp2dcfispu: /tmp/tmp2dcfispu.cpp:25: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &x: dict) {\n   \
    \     if (!(x.first.compare(x.first) == 0 || x.first.compare(x.first) == 1)) \n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpobrzki3v: /tmp/tmpobrzki3v.cpp:28: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (!kv.first.compare(kv.first))\n            return false;\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n   \
    \ assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"},\
    \ {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpcozkqfzg: /tmp/tmpcozkqfzg.cpp:27: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first >= 'a' && kv.first <= 'z') return false;\n        if(kv.first\
    \ >= 'A' && kv.first <= 'Z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmho7drnr.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpmho7drnr.cpp:20:21: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(kv.first >= 'a' && kv.first <= 'z')\
    \ return false;\n      |            ~~~~~~~~ ^~ ~~~\n      |               | \
    \       |\n      |               |        char\n      |               const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmho7drnr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpmho7drnr.cpp:20:24:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(kv.first\
    \ >= 'a' && kv.first <= 'z') return false;\n      |                        ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmho7drnr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpmho7drnr.cpp:20:24: note:   mismatched types "
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &pair : dict) {\n \
    \       if(pair.first.compare(0, 2, \"_\") != 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpyfwb6mnh: /tmp/tmpyfwb6mnh.cpp:28: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first.compare(x.first,0,1) != 0) {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmecna_xm.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpmecna_xm.cpp:21:39: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, int, int) const\u2019\n   21 |         if(x.first.compare(x.first,0,1)\
    \ != 0) {\n      |                                       ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpmecna_xm.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpmecna_xm.cpp:21:39:\
    \ note:   candidate expects 1 argument, 3 provided\n   21 |         if(x.first.comp"
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    for(auto it=dict.begin(); it!=dict.end(); ++it) {\n        if(it->second.size()!=1\
    \ || it->second[0]!='\"' || it->second[it->second.size()-1]!='\"')\n         \
    \   return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp5wazxcw4: /tmp/tmp5wazxcw4.cpp:26: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    \n    return true;\n}\nint main() {\n  \
    \  auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpexaudymw: /tmp/tmpexaudymw.cpp:25: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char ch) {\n            return std::islower(ch) || std::isupper(ch);\n\
    \        })) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpq44nhj87: /tmp/tmpq44nhj87.cpp:33: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   for(auto &y: x.second) {\n            if(std::tolower(x.first) == std::tolower(y))\
    \ {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp3442a6d.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpp3442a6d.cpp:22:36: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |             if(std::tolower(x.first) == std::tolower(y)) {\n      |\
    \                                    ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpp3442a6d.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpp3442a6d.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpp3442a6d.cpp:22:36: note:   candidate expects 2 arguments,\
    \ 1 provided\n   22 |             if(std::tolower(x.first) == std::tolower(y))\
    \ {\n      |                                    ^\n"
  stdout: ''
  timestamp: 1660131094
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &pair : dict) {\n \
    \       if(pair.first != pair.second.tolower()) return false;\n        if(pair.first\
    \ != pair.second.toupper()) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp908nwmlc.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp908nwmlc.cpp:20:38: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if(pair.first != pair.second.tolower()) return\
    \ false;\n      |                                      ^~~~~~~\n/tmp/tmp908nwmlc.cpp:21:38:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toupper\u2019\n   21 |         if(pair.first != pair.second.toupper())\
    \ return false;\n      |                                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    return dict.size() == 0;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpnpimzkbe: /tmp/tmpnpimzkbe.cpp:24: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    \n    // Write your code here\n    \n    \n    return true;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpfss98z8u: /tmp/tmpfss98z8u.cpp:27: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {return std::islower(c) || std::isupper(c);})) {\n \
    \           return true;\n        }\n        if (std::all_of(value.begin(), value.end(),\
    \ [](char c) {return std::isupper(c);})) {\n            return true;\n       \
    \ }\n        return false;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpfsomhs9w: /tmp/tmpfsomhs9w.cpp:35: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.size() == 0) {\n        return false;\n    }\n    for\
    \ (auto &pair : dict) {\n        if (pair.first >= 'a' && pair.first <= 'z') {\n\
    \            continue;\n        }\n        if (pair.first >= 'A' && pair.first\
    \ <= 'Z') {\n            continue;\n        }\n        return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmcjavzpm.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpmcjavzpm.cpp:22:24: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   22 |         if (pair.first >= 'a' && pair.first <=\
    \ 'z') {\n      |             ~~~~~~~~~~ ^~ ~~~\n      |                  |  \
    \      |\n      |                  |        char\n      |                  const\
    \ std::__cxx11::basic_string<char>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmcjavzpm.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpmcjavzpm.cpp:22:27:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   22 |         if (pair.first\
    \ >= 'a' && pair.first <= 'z') {\n      |                           ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmcjavzpm.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpmcjavzpm.cpp:22:27: note:   mismatched types "
  stdout: ''
  timestamp: 1660131094
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) { return std::islower(c); })) {\n            if (std::all_of(value.begin(),\
    \ value.end(), [](char c) { return std::isupper(c); })) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpgh1vgxzb: /tmp/tmpgh1vgxzb.cpp:32: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &pair : dict) {\n \
    \       if(pair.first != pair.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuxis3mn9.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpuxis3mn9.cpp:20:38: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   20 |         if(pair.first != pair.second.toLower()) return\
    \ false;\n      |                                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first < 'A' || kv.first > 'Z') return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl4p_njrh.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpl4p_njrh.cpp:20:22: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if (kv.first < 'A' || kv.first > 'Z')\
    \ return false;\n      |             ~~~~~~~~ ^ ~~~\n      |                |\
    \       |\n      |                |       char\n      |                const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpl4p_njrh.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpl4p_njrh.cpp:20:24:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (kv.first\
    \ < 'A' || kv.first > 'Z') return false;\n      |                        ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpl4p_njrh.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpl4p_njrh.cpp:20:24: note:   mismatched types \u2018const"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    if(dict.empty())\n        return false;\n\
    \    for(auto &x: dict)\n    {\n        if(x.first == x.second.tolower())\n  \
    \          return true;\n        if(x.first == x.second.toupper())\n         \
    \   return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp72512vx7.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp72512vx7.cpp:23:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   23 |         if(x.first == x.second.tolower())\n      |    \
    \                            ^~~~~~~\n/tmp/tmp72512vx7.cpp:25:32: error: \u2018\
    class std::__cxx11::basic_string<char>\u2019 has no member named \u2018toupper\u2019\
    \n   25 |         if(x.first == x.second.toupper())\n      |                 \
    \               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto it = dict.begin();\
    \ it != dict.end(); ++it) {\n        if(it->first != it->second.toLower()) {\n\
    \            return false;\n        }\n    }\n    \n    for(auto it = dict.begin();\
    \ it != dict.end(); ++it) {\n        if(it->first != it->second.toUpper()) {\n\
    \            return false;\n        }\n    }\n    \n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3vqddkja.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp3vqddkja.cpp:21:36: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toLower\u2019\n   21 |         if(it->first != it->second.toLower()) {\n     \
    \ |                                    ^~~~~~~\n/tmp/tmp3vqddkja.cpp:27:36: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    toUpper\u2019\n   27 |         if(it->first != it->second.toUpper()) {\n     \
    \ |                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.second.tolower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk64azwbl.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpk64azwbl.cpp:20:35: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if (kv.first != kv.second.tolower()) return false;\n\
    \      |                                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131093
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    // return true;\n    \n    for(auto\
    \ &x: dict) {\n        if(x.first == x.second.tolower()) {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwkanrujp.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpwkanrujp.cpp:23:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   23 |         if(x.first == x.second.tolower()) {\n      |  \
    \                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty())\n        return false;\n    for (auto &kv : dict)\n\
    \        for (auto &s : kv.first)\n            if (std::tolower(s) == std::tolower(kv.first))\n\
    \                return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9tvwuvda.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp9tvwuvda.cpp:22:57: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   22 |             if (std::tolower(s) == std::tolower(kv.first))\n      |\
    \                                                         ^\nIn file included\
    \ from /usr/include/c++/9/cctype:42,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmp9tvwuvda.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9tvwuvda.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9tvwuvda.cpp:22:57: note:   candidate expects 2 arguments,\
    \ 1 provided\n   22 |             if (std::tolower(s) == std::tolower(kv.first))\n\
    \      |                                                         ^\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpwrx6vfz4: /tmp/tmpwrx6vfz4.cpp:276: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict)\n    {\n     \
    \   auto &key = item.first;\n        auto &value = item.second;\n        if (std::tolower(key)\
    \ != key)\n        {\n            result = false;\n            break;\n      \
    \  }\n        if (std::toupper(key) != key)\n        {\n            result = false;\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2ou66np3.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2ou66np3.cpp:23:29: error:\
    \ no matching function for call to \u2018tolower(const std::__cxx11::basic_string<char>&)\u2019\
    \n   23 |         if (std::tolower(key) != key)\n      |                     \
    \        ^\nIn file included from /usr/include/c++/9/cctype:42,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n           \
    \      from /tmp/tmp2ou66np3.cpp:2:\n/usr/include/ctype.h:122:12: note: candidate:\
    \ \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c) __THROW;\n\
    \      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no known conversion\
    \ for argument 1 from \u2018const std::__cxx11::basic_string<char>\u2019 to \u2018\
    int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      |            \
    \         ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp2ou66np3.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp2ou66np3.cpp:23:29: note:   candidate expects 2 arguments,\
    \ 1 provided\n   23 |         if (std::tolower(key) != key)\n      |         \
    \                    ^\n/tmp/tmp2ou66np3.cpp:28:29: error: no matching function\
    \ for call to \u2018toupper(const std::__cxx11::basic_string<char>&)\u2019\n \
    \  28 |         if (std::toupper(key) != key)\n      |                       \
    \      ^\nIn file included from /usr/inclu"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict) {\n        flag\
    \ = flag && item.first == item.second.tolower();\n        flag = flag && item.first\
    \ == item.second.toupper();\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoi_h48nb.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpoi_h48nb.cpp:20:50: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         flag = flag && item.first == item.second.tolower();\n\
    \      |                                                  ^~~~~~~\n/tmp/tmpoi_h48nb.cpp:21:50:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toupper\u2019\n   21 |         flag = flag && item.first == item.second.toupper();\n\
    \      |                                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto it=dict.begin(); it!=dict.end();\
    \ ++it) {\n        if(it->second.size()==0) return false;\n        for(auto it2=it->second.begin();\
    \ it2!=it->second.end(); ++it2) {\n            if((*it2).size()==0) return false;\n\
    \            for(auto it3=(*it2).begin(); it3!=(*it2).end(); ++it3) {\n      \
    \          if((*it3).size()==0) return false;\n                for(auto it4=(*it3).begin();\
    \ it4!=(*it3).end(); ++it4) {\n                    if((*it4).size()==0) return\
    \ false;\n                    for(auto it5=(*it4).begin(); it5!=(*it4).end();\
    \ ++it5) {\n                        if((*it5).size()==0) return false;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0w1hqlh8.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp0w1hqlh8.cpp:22:23: error:\
    \ request for member \u2018size\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |             if((*it2).size()==0) return false;\n\
    \      |                       ^~~~\n/tmp/tmp0w1hqlh8.cpp:23:33: error: request\
    \ for member \u2018begin\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |             for(auto it3=(*it2).begin(); it3!=(*it2).end();\
    \ ++it3) {\n      |                                 ^~~~~\n/tmp/tmp0w1hqlh8.cpp:23:54:\
    \ error: request for member \u2018end\u2019 in \u2018it2.__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |             for(auto it3=(*it2).begin(); it3!=(*it2).end();\
    \ ++it3) {\n      |                                                      ^~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &x: dict) {\n        auto &y =\
    \ x.first;\n        auto &z = x.second;\n        if ((y.size() == 0) && (z.size()\
    \ == 0)) {\n            flag = false;\n            break;\n        }\n       \
    \ if ((y.size() == 0) && (z.size() > 0)) {\n            flag = false;\n      \
    \      break;\n        }\n        if ((y.size() > 0) && (z.size() == 0)) {\n \
    \           flag = false;\n            break;\n        }\n        if ((y.size()\
    \ > 0) && (z.size() > 0)) {\n            auto &y = y.front();\n            auto\
    \ &z = z.front();\n            if ((y.size() == 0) && (z.size() == 0)) {\n   \
    \             flag = false;\n                break;\n            }\n         \
    \   if ((y.size() == 0) && (z.size() > 0)) {\n                flag = false;\n\
    \                break;\n            }\n            if ((y.size() > 0) && (z.size()\
    \ == 0)) {\n                flag = false;\n                break;\n          \
    \  }\n            if ((y.size() > 0) && (z.size() > 0)) {\n                auto\
    \ &y = y.front();\n                auto &z = z.front();\n                if ((y.size()\
    \ == 0) && (z.size() == 0)) {\n                    flag = false;\n           \
    \         break;\n                }\n                if ((y.size() == 0) && (z.size()\
    \ > 0)) {\n                    flag = false;\n                    break;\n   \
    \             }\n                if ((y.size() > 0) && (z.size() == 0)) {\n  \
    \                  flag = false;\n                    break;\n               \
    \ }\n                if ((y.size() > 0) && (z.size() > 0)) {\n               \
    \     auto &y = y.front();\n                    auto &z = z.front();\n       \
    \             if ((y.size() == 0) && (z.size() == 0)) {\n                    \
    \    flag = false;\n                        break;\n                    }\n  \
    \                  if ((y.size() == 0) && (z.size() > 0)) {\n                \
    \        flag = false;\n                        break;\n                    }\n\
    \                    if ((y.size() > 0) && (z.size() == 0)) {\n              \
    \          flag = false;\n                        break;\n                   \
    \ }\n                    if ((y.size() > 0) && (z.size() > 0)) {\n           \
    \             auto &y = y.front();\n                        auto &z = z.front();\n\
    \                        if ((y.size() == 0) && (z.size() == 0)) {\n         \
    \                   flag = false;\n                            break;\n      \
    \                  }\n                        if ((y.size() == 0) && (z.size()\
    \ > 0)) {\n                            flag = false;\n                       \
    \     break;\n                        }\n                        if ((y.size()\
    \ > 0) && (z.size() == 0)) {\n                            flag = false;\n    \
    \                        break;\n                        }\n                 \
    \       if ((y.size() > 0) && (z.size() > 0)) {\n                            auto\
    \ &y = y.front();\n                            auto &z = z.front();\n        \
    \                    if ((y.size() == 0) && (z.size() == 0)) {\n             \
    \                   flag = false;\n                                break;\n  \
    \                          }\n                            if ((y.size() == 0)\
    \ && (z.size() > 0)) {\n                                flag = false;\n      \
    \                          \n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpswwvrql8.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpswwvrql8.cpp:35:23: error:\
    \ use of \u2018y\u2019 before deduction of \u2018auto\u2019\n   35 |         \
    \    auto &y = y.front();\n      |                       ^\n/tmp/tmpswwvrql8.cpp:36:23:\
    \ error: use of \u2018z\u2019 before deduction of \u2018auto\u2019\n   36 |  \
    \           auto &z = z.front();\n      |                       ^\n/tmp/tmpswwvrql8.cpp:50:27:\
    \ error: use of \u2018y\u2019 before deduction of \u2018auto\u2019\n   50 |  \
    \               auto &y = y.front();\n      |                           ^\n/tmp/tmpswwvrql8.cpp:51:27:\
    \ error: use of \u2018z\u2019 before deduction of \u2018auto\u2019\n   51 |  \
    \               auto &z = z.front();\n      |                           ^\n/tmp/tmpswwvrql8.cpp:65:31:\
    \ error: use of \u2018y\u2019 before deduction of \u2018auto\u2019\n   65 |  \
    \                   auto &y = y.front();\n      |                            \
    \   ^\n/tmp/tmpswwvrql8.cpp:66:31: error: use of \u2018z\u2019 before deduction\
    \ of \u2018auto\u2019\n   66 |                     auto &z = z.front();\n    \
    \  |                               ^\n/tmp/tmpswwvrql8.cpp:80:35: error: use of\
    \ \u2018y\u2019 before deduction of \u2018auto\u2019\n   80 |                \
    \         auto &y = y.front();\n      |                                   ^\n\
    /tmp/tmpswwvrql8.cpp:81:35: error: use of \u2018z\u2019 before deduction of \u2018\
    auto\u2019\n   81 |                         auto &z = z.front();\n      |    \
    \                               ^\n/tmp/tmpswwvrql8.cpp:95:39: error: use of \u2018\
    y\u2019 before deduction of \u2018auto\u2019\n   95 |                        \
    \     auto &y = y.front();\n      |                                       ^\n\
    /tmp/tmpswwvrql8.cpp:96:39: error: use of \u2018z\u2019 before deduction of \u2018\
    auto\u2019\n   96 |                             auto &z = z.front();\n      |\
    \                                       ^\n/tmp/tmpswwvrql8.cpp:105:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n  105\
    \ | int main() {\n      |            ^\n/tmp/tmpswwvrql8.cpp:114:1: error: expected\
    \ \u2018}\u2019 at end of inpu"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty())\n        return false;\n    for(auto &x: dict)\
    \ {\n        if(x.first >= 'a' && x.first <= 'z')\n            return true;\n\
    \        if(x.first >= 'A' && x.first <= 'Z')\n            return true;\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr_y1aoou.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpr_y1aoou.cpp:21:20: error:\
    \ no match for \u2018operator>=\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if(x.first >= 'a' && x.first <= 'z')\n\
    \      |            ~~~~~~~ ^~ ~~~\n      |              |        |\n      | \
    \             |        char\n      |              const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpr_y1aoou.cpp:2:\n/usr/include/c++/9/bits/regex.h:1070:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1070 |     operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1070:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpr_y1aoou.cpp:21:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if(x.first\
    \ >= 'a' && x.first <= 'z')\n      |                       ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpr_y1aoou.cpp:2:\n/usr/include/c++/9/bits/regex.h:1148:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1148 |     operator>=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpr_y1aoou.cpp:21:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIte"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        if (kv.first != kv.first.to_lower()) {\n            return false;\n \
    \       }\n        if (kv.first != kv.first.to_upper()) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyr3x49rc.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpyr3x49rc.cpp:20:34: error:\
    \ \u2018const class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018to_lower\u2019\n   20 |         if (kv.first != kv.first.to_lower()) {\n\
    \      |                                  ^~~~~~~~\n/tmp/tmpyr3x49rc.cpp:23:34:\
    \ error: \u2018const class std::__cxx11::basic_string<char>\u2019 has no member\
    \ named \u2018to_upper\u2019\n   23 |         if (kv.first != kv.first.to_upper())\
    \ {\n      |                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpwrx6vfz4: /tmp/tmpwrx6vfz4.cpp:276: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131091
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &x: dict) {\n   \
    \     if (x.first < x.second.size()) continue;\n        if (x.first > x.second.size())\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp762it42j.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp762it42j.cpp:20:21: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   20 |         if (x.first < x.second.size()) continue;\n\
    \      |             ~~~~~~~ ^ ~~~~~~~~~~~~~~~\n      |               |      \
    \              |\n      |               |                    std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\n      |               const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp762it42j.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp762it42j.cpp:20:37:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if (x.first\
    \ < x.second.size()) continue;\n      |                                     ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp762it42j.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /us"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &item : dict)\n\
    \    {\n        if (!(item.first == item.second.tolower()) && !(item.first ==\
    \ item.second.toupper()))\n            return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpao02rut6.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpao02rut6.cpp:21:41: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   21 |         if (!(item.first == item.second.tolower()) && !(item.first\
    \ == item.second.toupper()))\n      |                                        \
    \ ^~~~~~~\n/tmp/tmpao02rut6.cpp:21:83: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018toupper\u2019\n   21 |         if (!(item.first ==\
    \ item.second.tolower()) && !(item.first == item.second.toupper()))\n      | \
    \                                                                            \
    \      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    if(dict.empty())\n        return false;\n\
    \    for(auto it=dict.begin(); it!=dict.end(); ++it)\n    {\n        if(it->first.compare(it->first,std::locale(),\"\
    en_US\")!=0) return false;\n        if(it->first.compare(it->first,std::locale(),\"\
    en_UK\")!=0) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn2twjn2v.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpn2twjn2v.cpp:23:61: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(const\
    \ std::__cxx11::basic_string<char>&, std::locale, const char [6]) const\u2019\n\
    \   23 |         if(it->first.compare(it->first,std::locale(),\"en_US\")!=0) return\
    \ false;\n      |                                                            \
    \ ^\nIn file included from /usr/include/c++/9/string:55,\n                 from\
    \ /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpn2twjn2v.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7: note:\
    \ candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpn2twjn2v.cpp:23:61:\
    \ note:  "
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict)\n \
    \       if (!item.second.compare(item.first))\n            return false;\n   \
    \ return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpz2p_lwa8: /tmp/tmpz2p_lwa8.cpp:27: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131096
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict)\n    {\n       \
    \ flag = flag && item.first == item.first.substr(0, item.first.length()-1);\n\
    \    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmp5clki5lb: /tmp/tmp5clki5lb.cpp:27: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), ::islower)) {\n            if (std::all_of(value.begin(), value.end(),\
    \ ::isupper)) {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpldrr4j_i: /tmp/tmpldrr4j_i.cpp:32: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"b", "banana"}}))) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660131087
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty())\n        return false;\n    for(auto &x: dict)\n\
    \        if(x.first != x.second.tolower())\n            return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn5zcfpdo.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpn5zcfpdo.cpp:21:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   21 |         if(x.first != x.second.tolower())\n      |    \
    \                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    \n    // Write your code here\n    \n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: Exception
  stderr: 'tmpb3vx241y: /tmp/tmpb3vx241y.cpp:26: int main(): Assertion `candidate((std::map<std::string,std::string>({{"p",
    "pineapple"}, {"A", "banana"}, {"B", "banana"}}))) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660131096
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first != x.second.tolower()) return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3dda7z0.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmph3dda7z0.cpp:20:32: error:\
    \ \u2018class std::__cxx11::basic_string<char>\u2019 has no member named \u2018\
    tolower\u2019\n   20 |         if(x.first != x.second.tolower()) return false;\n\
    \      |                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660131095
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first < 'A' || kv.first > 'Z') return false;\n        if(kv.second\
    \ < 'a' || kv.second > 'z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2q4o57u3.cpp: In function \u2018bool check_dict_case(std::map<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp2q4o57u3.cpp:20:21: error:\
    \ no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         if(kv.first < 'A' || kv.first > 'Z')\
    \ return false;\n      |            ~~~~~~~~ ^ ~~~\n      |               |  \
    \     |\n      |               |       char\n      |               const std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2q4o57u3.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1048:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp2q4o57u3.cpp:20:23:\
    \ note:   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from\
    \ \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         if(kv.first\
    \ < 'A' || kv.first > 'Z') return false;\n      |                       ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2q4o57u3.cpp:2:\n/usr/include/c++/9/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1124:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp2q4o57u3.cpp:20:23: note:   mismatched types \u2018const std::_"
  stdout: ''
  timestamp: 1660131090
