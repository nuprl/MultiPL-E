language: cpp
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (!kv.first.compare(0, 2, kv.first.size(), ::tolower)) {\n         \
    \   return false;\n        }\n        if (!kv.first.compare(0, 2, kv.first.size(),\
    \ ::toupper)) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprqwz3ygm.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmprqwz3ygm.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmprqwz3ygm.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmprqwz3ygm.cpp:20:17: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if (!kv.first.compare(0, 2, kv.first.size(),\
    \ ::tolower)) {\n                 ^\n/tmp/tmprqwz3ygm.cpp:20:40: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if (!kv.first.compare(0,\
    \ 2, kv.first.size(), ::tolower)) {\n                                        ^\n\
    /tmp/tmprqwz3ygm.cpp:23:17: error: request for member 'first' in 'kv', which is\
    \ of non-class type 'int'\n         if (!kv.first.compare(0, 2, kv.first.size(),\
    \ ::toupper)) {\n                 ^\n/tmp/tmprqwz3ygm.cpp:23:40: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if (!kv.first.compare(0,\
    \ 2, kv.first.size(), ::toupper)) {\n                                        ^\n\
    /tmp/tmprqwz3ygm.cpp: In function 'int main()':\n/tmp/tmprqwz3ygm.cpp:30:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = check_dict_case;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprqwz3ygm.cpp:2:\n/tmp/tmprqwz3ygm.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmprqwz3ygm.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (item.first != item.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuuiij901.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpuuiij901.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'item' with no type [-fpermissive]\n     for (auto &item : dict)\
    \ {\n                ^\n/tmp/tmpuuiij901.cpp:19:23: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &item : dict) {\n            \
    \           ^\n/tmp/tmpuuiij901.cpp:20:18: error: request for member 'first' in\
    \ 'item', which is of non-class type 'int'\n         if (item.first != item.second.toLower())\
    \ return false;\n                  ^\n/tmp/tmpuuiij901.cpp:20:32: error: request\
    \ for member 'second' in 'item', which is of non-class type 'int'\n         if\
    \ (item.first != item.second.toLower()) return false;\n                      \
    \          ^\n/tmp/tmpuuiij901.cpp: In function 'int main()':\n/tmp/tmpuuiij901.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuuiij901.cpp:2:\n/tmp/tmpuuiij901.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpuuiij901.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpuuiij901.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuuiij901.cpp:26:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [en"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &pair : dict) {\n \
    \       if(pair.first != pair.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk43yqovl.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpk43yqovl.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'pair' with no type [-fpermissive]\n     for(auto &pair : dict)\
    \ {\n               ^\n/tmp/tmpk43yqovl.cpp:19:22: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &pair : dict) {\n             \
    \         ^\n/tmp/tmpk43yqovl.cpp:20:17: error: request for member 'first' in\
    \ 'pair', which is of non-class type 'int'\n         if(pair.first != pair.second.toLower())\
    \ return false;\n                 ^\n/tmp/tmpk43yqovl.cpp:20:31: error: request\
    \ for member 'second' in 'pair', which is of non-class type 'int'\n         if(pair.first\
    \ != pair.second.toLower()) return false;\n                               ^\n\
    /tmp/tmpk43yqovl.cpp: In function 'int main()':\n/tmp/tmpk43yqovl.cpp:25:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = check_dict_case;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk43yqovl.cpp:2:\n/tmp/tmpk43yqovl.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpk43yqovl.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpk43yqovl.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpk43yqovl.cpp:26:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    if(dict.empty()){\n        return\
    \ false;\n    }\n    for(auto &x: dict){\n        if(x.first < 'a' || x.first\
    \ > 'z'){\n            return false;\n        }\n        if(x.first < 'A' || x.first\
    \ > 'Z'){\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpflrfbjgl.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpflrfbjgl.cpp:22:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict){\n \
    \              ^\n/tmp/tmpflrfbjgl.cpp:22:18: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for(auto &x: dict){\n                  ^\n/tmp/tmpflrfbjgl.cpp:23:14:\
    \ error: request for member 'first' in 'x', which is of non-class type 'int'\n\
    \         if(x.first < 'a' || x.first > 'z'){\n              ^\n/tmp/tmpflrfbjgl.cpp:23:31:\
    \ error: request for member 'first' in 'x', which is of non-class type 'int'\n\
    \         if(x.first < 'a' || x.first > 'z'){\n                              \
    \ ^\n/tmp/tmpflrfbjgl.cpp:26:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first < 'A' || x.first > 'Z'){\n \
    \             ^\n/tmp/tmpflrfbjgl.cpp:26:31: error: request for member 'first'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first < 'A' || x.first\
    \ > 'Z'){\n                               ^\n/tmp/tmpflrfbjgl.cpp: In function\
    \ 'int main()':\n/tmp/tmpflrfbjgl.cpp:33:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpflrfbjgl.cpp:2:\n/tmp/tmpflrfbjgl.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpflrfbjgl.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                              "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict) {\n\
    \        if (item.first != item.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuuiij901.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpuuiij901.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'item' with no type [-fpermissive]\n     for (auto &item : dict)\
    \ {\n                ^\n/tmp/tmpuuiij901.cpp:19:23: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &item : dict) {\n            \
    \           ^\n/tmp/tmpuuiij901.cpp:20:18: error: request for member 'first' in\
    \ 'item', which is of non-class type 'int'\n         if (item.first != item.second.toLower())\
    \ return false;\n                  ^\n/tmp/tmpuuiij901.cpp:20:32: error: request\
    \ for member 'second' in 'item', which is of non-class type 'int'\n         if\
    \ (item.first != item.second.toLower()) return false;\n                      \
    \          ^\n/tmp/tmpuuiij901.cpp: In function 'int main()':\n/tmp/tmpuuiij901.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuuiij901.cpp:2:\n/tmp/tmpuuiij901.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpuuiij901.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpuuiij901.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuuiij901.cpp:26:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [en"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &kv : dict) {\n   \
    \     if(kv.first >= 'A' && kv.first <= 'Z') return true;\n        if(kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjh90j4__.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpjh90j4__.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for(auto &kv : dict) {\n\
    \               ^\n/tmp/tmpjh90j4__.cpp:19:20: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &kv : dict) {\n               \
    \     ^\n/tmp/tmpjh90j4__.cpp:20:15: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if(kv.first >= 'A' && kv.first <=\
    \ 'Z') return true;\n               ^\n/tmp/tmpjh90j4__.cpp:20:34: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if(kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n                                  ^\n\
    /tmp/tmpjh90j4__.cpp:21:15: error: request for member 'first' in 'kv', which is\
    \ of non-class type 'int'\n         if(kv.first >= 'a' && kv.first <= 'z') return\
    \ true;\n               ^\n/tmp/tmpjh90j4__.cpp:21:34: error: request for member\
    \ 'first' in 'kv', which is of non-class type 'int'\n         if(kv.first >= 'a'\
    \ && kv.first <= 'z') return true;\n                                  ^\n/tmp/tmpjh90j4__.cpp:\
    \ In function 'int main()':\n/tmp/tmpjh90j4__.cpp:26:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjh90j4__.cpp:2:\n/tmp/tmpjh90j4__.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpjh90j4__.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool result = true;\n    for (auto &item : dict)\n    {\n     \
    \   auto key = item.first;\n        auto value = item.second;\n        auto lower\
    \ = std::tolower(key);\n        auto upper = std::toupper(key);\n        if (lower\
    \ != key || upper != key)\n        {\n            result = false;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsxrzv21n.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpsxrzv21n.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'item' with no type [-fpermissive]\n     for (auto &item : dict)\n\
    \                ^\n/tmp/tmpsxrzv21n.cpp:19:23: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &item : dict)\n              \
    \         ^\n/tmp/tmpsxrzv21n.cpp:21:14: error: 'key' does not name a type\n \
    \        auto key = item.first;\n              ^\n/tmp/tmpsxrzv21n.cpp:22:14:\
    \ error: 'value' does not name a type\n         auto value = item.second;\n  \
    \            ^\n/tmp/tmpsxrzv21n.cpp:23:14: error: 'lower' does not name a type\n\
    \         auto lower = std::tolower(key);\n              ^\n/tmp/tmpsxrzv21n.cpp:24:14:\
    \ error: 'upper' does not name a type\n         auto upper = std::toupper(key);\n\
    \              ^\n/tmp/tmpsxrzv21n.cpp:25:13: error: 'lower' was not declared\
    \ in this scope\n         if (lower != key || upper != key)\n             ^\n\
    /tmp/tmpsxrzv21n.cpp:25:22: error: 'key' was not declared in this scope\n    \
    \     if (lower != key || upper != key)\n                      ^\n/tmp/tmpsxrzv21n.cpp:25:29:\
    \ error: 'upper' was not declared in this scope\n         if (lower != key ||\
    \ upper != key)\n                             ^\n/tmp/tmpsxrzv21n.cpp: In function\
    \ 'int main()':\n/tmp/tmpsxrzv21n.cpp:33:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsxrzv21n.cpp:2:\n/tmp/tmpsxrzv21n.cpp:34:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpsxrzv21n.cpp:34:94: warning: extended\
    \ initializer lists only available with -std=c++11 or"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.first.to_lower()) {\n            return false;\n  \
    \      }\n        if (kv.first != kv.first.to_upper()) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp10y1fjnx.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp10y1fjnx.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmp10y1fjnx.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmp10y1fjnx.cpp:20:16: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if (kv.first != kv.first.to_lower())\
    \ {\n                ^\n/tmp/tmp10y1fjnx.cpp:20:28: error: request for member\
    \ 'first' in 'kv', which is of non-class type 'int'\n         if (kv.first !=\
    \ kv.first.to_lower()) {\n                            ^\n/tmp/tmp10y1fjnx.cpp:23:16:\
    \ error: request for member 'first' in 'kv', which is of non-class type 'int'\n\
    \         if (kv.first != kv.first.to_upper()) {\n                ^\n/tmp/tmp10y1fjnx.cpp:23:28:\
    \ error: request for member 'first' in 'kv', which is of non-class type 'int'\n\
    \         if (kv.first != kv.first.to_upper()) {\n                           \
    \ ^\n/tmp/tmp10y1fjnx.cpp: In function 'int main()':\n/tmp/tmp10y1fjnx.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp10y1fjnx.cpp:2:\n/tmp/tmp10y1fjnx.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp10y1fjnx.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                   "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        if (kv.first != kv.second.tolower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpakklin5b.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpakklin5b.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmpakklin5b.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmpakklin5b.cpp:20:16: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if (kv.first != kv.second.tolower())\
    \ return false;\n                ^\n/tmp/tmpakklin5b.cpp:20:28: error: request\
    \ for member 'second' in 'kv', which is of non-class type 'int'\n         if (kv.first\
    \ != kv.second.tolower()) return false;\n                            ^\n/tmp/tmpakklin5b.cpp:\
    \ In function 'int main()':\n/tmp/tmpakklin5b.cpp:25:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpakklin5b.cpp:2:\n/tmp/tmpakklin5b.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpakklin5b.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpakklin5b.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpakklin5b.cpp:26:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &item : dict)\n    {\n       \
    \ if (!item.first.compare(item.first.at(0)))\n        {\n            flag = false;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpazfzqmwq.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpazfzqmwq.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'item' with no type [-fpermissive]\n     for (auto &item : dict)\n\
    \                ^\n/tmp/tmpazfzqmwq.cpp:19:23: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &item : dict)\n              \
    \         ^\n/tmp/tmpazfzqmwq.cpp:21:19: error: request for member 'first' in\
    \ 'item', which is of non-class type 'int'\n         if (!item.first.compare(item.first.at(0)))\n\
    \                   ^\n/tmp/tmpazfzqmwq.cpp:21:38: error: request for member 'first'\
    \ in 'item', which is of non-class type 'int'\n         if (!item.first.compare(item.first.at(0)))\n\
    \                                      ^\n/tmp/tmpazfzqmwq.cpp: In function 'int\
    \ main()':\n/tmp/tmpazfzqmwq.cpp:30:10: error: 'candidate' does not name a type\n\
    \     auto candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpazfzqmwq.cpp:2:\n/tmp/tmpazfzqmwq.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpazfzqmwq.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpazfzqmwq.cpp:31:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpazfzqmwq.cpp:31:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); ++it) {\n        if(it->first < 'A' || it->first > 'Z') {\n    \
    \        return false;\n        }\n    }\n    for(auto it = dict.begin(); it !=\
    \ dict.end(); ++it) {\n        if(it->first > 'A' || it->first < 'Z') {\n    \
    \        return false;\n        }\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuj3ju728.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpuj3ju728.cpp:19:14: error: 'it' does not\
    \ name a type\n     for(auto it = dict.begin(); it != dict.end(); ++it) {\n  \
    \            ^\n/tmp/tmpuj3ju728.cpp:19:33: error: expected ';' before 'it'\n\
    \     for(auto it = dict.begin(); it != dict.end(); ++it) {\n                \
    \                 ^\n/tmp/tmpuj3ju728.cpp:19:33: error: 'it' was not declared\
    \ in this scope\n/tmp/tmpuj3ju728.cpp:24:14: error: 'it' does not name a type\n\
    \     for(auto it = dict.begin(); it != dict.end(); ++it) {\n              ^\n\
    /tmp/tmpuj3ju728.cpp:24:33: error: expected ';' before 'it'\n     for(auto it\
    \ = dict.begin(); it != dict.end(); ++it) {\n                                \
    \ ^\n/tmp/tmpuj3ju728.cpp:24:33: error: 'it' was not declared in this scope\n\
    /tmp/tmpuj3ju728.cpp: In function 'int main()':\n/tmp/tmpuj3ju728.cpp:32:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = check_dict_case;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuj3ju728.cpp:2:\n/tmp/tmpuj3ju728.cpp:33:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpuj3ju728.cpp:33:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpuj3ju728.cpp:33:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuj3ju728.cpp:33:94: warning: extended initializer\
    \ lists only available wit"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &kv : dict) {\n\
    \        if (kv.first >= 'a' && kv.first <= 'z') return true;\n        if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpepehidgx.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpepehidgx.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmpepehidgx.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmpepehidgx.cpp:20:16: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if (kv.first >= 'a' && kv.first <=\
    \ 'z') return true;\n                ^\n/tmp/tmpepehidgx.cpp:20:35: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if (kv.first\
    \ >= 'a' && kv.first <= 'z') return true;\n                                  \
    \ ^\n/tmp/tmpepehidgx.cpp:21:16: error: request for member 'first' in 'kv', which\
    \ is of non-class type 'int'\n         if (kv.first >= 'A' && kv.first <= 'Z')\
    \ return true;\n                ^\n/tmp/tmpepehidgx.cpp:21:35: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return true;\n                                  \
    \ ^\n/tmp/tmpepehidgx.cpp: In function 'int main()':\n/tmp/tmpepehidgx.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpepehidgx.cpp:2:\n/tmp/tmpepehidgx.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpepehidgx.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first != kv.second.toLower()) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfgu1_c92.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpfgu1_c92.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmpfgu1_c92.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmpfgu1_c92.cpp:20:16: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if (kv.first != kv.second.toLower())\
    \ return false;\n                ^\n/tmp/tmpfgu1_c92.cpp:20:28: error: request\
    \ for member 'second' in 'kv', which is of non-class type 'int'\n         if (kv.first\
    \ != kv.second.toLower()) return false;\n                            ^\n/tmp/tmpfgu1_c92.cpp:\
    \ In function 'int main()':\n/tmp/tmpfgu1_c92.cpp:25:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfgu1_c92.cpp:2:\n/tmp/tmpfgu1_c92.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpfgu1_c92.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpfgu1_c92.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpfgu1_c92.cpp:26:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {\n            return std::islower(c) || std::isupper(c);\n\
    \        })) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn1nfwo63.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpn1nfwo63.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmpn1nfwo63.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmpn1nfwo63.cpp:20:15: error: ISO C++ forbids declaration of 'key'\
    \ with no type [-fpermissive]\n         auto &key = kv.first;\n              \
    \ ^\n/tmp/tmpn1nfwo63.cpp:20:24: error: request for member 'first' in 'kv', which\
    \ is of non-class type 'int'\n         auto &key = kv.first;\n               \
    \         ^\n/tmp/tmpn1nfwo63.cpp:21:15: error: ISO C++ forbids declaration of\
    \ 'value' with no type [-fpermissive]\n         auto &value = kv.second;\n   \
    \            ^\n/tmp/tmpn1nfwo63.cpp:21:26: error: request for member 'second'\
    \ in 'kv', which is of non-class type 'int'\n         auto &value = kv.second;\n\
    \                          ^\n/tmp/tmpn1nfwo63.cpp:22:13: error: 'all_of' is not\
    \ a member of 'std'\n         if (std::all_of(value.begin(), value.end(), [](char\
    \ c) {\n             ^\n/tmp/tmpn1nfwo63.cpp:22:31: error: request for member\
    \ 'begin' in 'value', which is of non-class type 'int'\n         if (std::all_of(value.begin(),\
    \ value.end(), [](char c) {\n                               ^\n/tmp/tmpn1nfwo63.cpp:22:46:\
    \ error: request for member 'end' in 'value', which is of non-class type 'int'\n\
    \         if (std::all_of(value.begin(), value.end(), [](char c) {\n         \
    \                                     ^\n/tmp/tmpn1nfwo63.cpp:24:9: warning: lambda\
    \ expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \         })) {\n         ^\n/tmp/tmpn1nfwo63.cpp: In function 'int main()':\n\
    /tmp/tmpn1nfwo63.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linu"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    \n    for (auto &kv : dict)\
    \ {\n        if (kv.first < 'A' || kv.first > 'Z') return false;\n    }\n    \n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwylna2yy.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpwylna2yy.cpp:20:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmpwylna2yy.cpp:20:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmpwylna2yy.cpp:21:16: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if (kv.first < 'A' || kv.first >\
    \ 'Z') return false;\n                ^\n/tmp/tmpwylna2yy.cpp:21:34: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if (kv.first\
    \ < 'A' || kv.first > 'Z') return false;\n                                  ^\n\
    /tmp/tmpwylna2yy.cpp: In function 'int main()':\n/tmp/tmpwylna2yy.cpp:27:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = check_dict_case;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwylna2yy.cpp:2:\n/tmp/tmpwylna2yy.cpp:28:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpwylna2yy.cpp:28:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpwylna2yy.cpp:28:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpwylna2yy.cpp:28:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n/"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool ret = true;\n    for(auto &x: dict) {\n        if(x.first\
    \ != x.second.toLower()) {\n            ret = false;\n            break;\n   \
    \     }\n    }\n    return ret;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqzk5jdxv.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpqzk5jdxv.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmpqzk5jdxv.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmpqzk5jdxv.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first != x.second.toLower()) {\n \
    \             ^\n/tmp/tmpqzk5jdxv.cpp:20:25: error: request for member 'second'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first != x.second.toLower())\
    \ {\n                         ^\n/tmp/tmpqzk5jdxv.cpp: In function 'int main()':\n\
    /tmp/tmpqzk5jdxv.cpp:28:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqzk5jdxv.cpp:2:\n/tmp/tmpqzk5jdxv.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpqzk5jdxv.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpqzk5jdxv.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqzk5jdxv.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpqzk5jdxv.cpp:29:94: warning: extended initialize"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &x: dict) {\n        flag = flag\
    \ && x.first == x.first.substr(0, 1) && (x.first == x.first.substr(0, 1) || x.first\
    \ == x.first.substr(0, 2));\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwiazspab.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpwiazspab.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for (auto &x: dict) {\n\
    \                ^\n/tmp/tmpwiazspab.cpp:19:19: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &x: dict) {\n                \
    \   ^\n/tmp/tmpwiazspab.cpp:20:26: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         flag = flag && x.first == x.first.substr(0,\
    \ 1) && (x.first == x.first.substr(0, 1) || x.first == x.first.substr(0, 2));\n\
    \                          ^\n/tmp/tmpwiazspab.cpp:20:37: error: request for member\
    \ 'first' in 'x', which is of non-class type 'int'\n         flag = flag && x.first\
    \ == x.first.substr(0, 1) && (x.first == x.first.substr(0, 1) || x.first == x.first.substr(0,\
    \ 2));\n                                     ^\n/tmp/tmpwiazspab.cpp:20:62: error:\
    \ request for member 'first' in 'x', which is of non-class type 'int'\n      \
    \   flag = flag && x.first == x.first.substr(0, 1) && (x.first == x.first.substr(0,\
    \ 1) || x.first == x.first.substr(0, 2));\n                                  \
    \                            ^\n/tmp/tmpwiazspab.cpp:20:73: error: request for\
    \ member 'first' in 'x', which is of non-class type 'int'\n         flag = flag\
    \ && x.first == x.first.substr(0, 1) && (x.first == x.first.substr(0, 1) || x.first\
    \ == x.first.substr(0, 2));\n                                                \
    \                         ^\n/tmp/tmpwiazspab.cpp:20:97: error: request for member\
    \ 'first' in 'x', which is of non-class type 'int'\n         flag = flag && x.first\
    \ == x.first.substr(0, 1) && (x.first == x.first.substr(0, 1) || x.first == x.first.substr(0,\
    \ 2));\n                                                                     \
    \                            ^\n/tmp/tmpwiazspab.cpp:20:108: error: request for\
    \ member 'first' in 'x', which is of non-class type 'int'\n         flag = flag\
    \ && x.first == x.first.substr(0, 1) && (x.first == x.first.s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &pair : dict) {\n\
    \        if (pair.first < 'A' || pair.first > 'Z') return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmcp48h4i.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpmcp48h4i.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'pair' with no type [-fpermissive]\n     for (auto &pair : dict)\
    \ {\n                ^\n/tmp/tmpmcp48h4i.cpp:19:23: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &pair : dict) {\n            \
    \           ^\n/tmp/tmpmcp48h4i.cpp:20:18: error: request for member 'first' in\
    \ 'pair', which is of non-class type 'int'\n         if (pair.first < 'A' || pair.first\
    \ > 'Z') return false;\n                  ^\n/tmp/tmpmcp48h4i.cpp:20:38: error:\
    \ request for member 'first' in 'pair', which is of non-class type 'int'\n   \
    \      if (pair.first < 'A' || pair.first > 'Z') return false;\n             \
    \                         ^\n/tmp/tmpmcp48h4i.cpp: In function 'int main()':\n\
    /tmp/tmpmcp48h4i.cpp:25:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmcp48h4i.cpp:2:\n/tmp/tmpmcp48h4i.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpmcp48h4i.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpmcp48h4i.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmcp48h4i.cpp:26:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu+"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       auto &key = kv.first;\n        auto &value = kv.second;\n        if (std::all_of(value.begin(),\
    \ value.end(), [](char c) { return std::islower(c); })) {\n            return\
    \ true;\n        } else if (std::all_of(value.begin(), value.end(), [](char c)\
    \ { return std::isupper(c); })) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n \
    \   assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbz1q55jp.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpbz1q55jp.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmpbz1q55jp.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmpbz1q55jp.cpp:20:15: error: ISO C++ forbids declaration of 'key'\
    \ with no type [-fpermissive]\n         auto &key = kv.first;\n              \
    \ ^\n/tmp/tmpbz1q55jp.cpp:20:24: error: request for member 'first' in 'kv', which\
    \ is of non-class type 'int'\n         auto &key = kv.first;\n               \
    \         ^\n/tmp/tmpbz1q55jp.cpp:21:15: error: ISO C++ forbids declaration of\
    \ 'value' with no type [-fpermissive]\n         auto &value = kv.second;\n   \
    \            ^\n/tmp/tmpbz1q55jp.cpp:21:26: error: request for member 'second'\
    \ in 'kv', which is of non-class type 'int'\n         auto &value = kv.second;\n\
    \                          ^\n/tmp/tmpbz1q55jp.cpp:22:13: error: 'all_of' is not\
    \ a member of 'std'\n         if (std::all_of(value.begin(), value.end(), [](char\
    \ c) { return std::islower(c); })) {\n             ^\n/tmp/tmpbz1q55jp.cpp:22:31:\
    \ error: request for member 'begin' in 'value', which is of non-class type 'int'\n\
    \         if (std::all_of(value.begin(), value.end(), [](char c) { return std::islower(c);\
    \ })) {\n                               ^\n/tmp/tmpbz1q55jp.cpp:22:46: error:\
    \ request for member 'end' in 'value', which is of non-class type 'int'\n    \
    \     if (std::all_of(value.begin(), value.end(), [](char c) { return std::islower(c);\
    \ })) {\n                                              ^\n/tmp/tmpbz1q55jp.cpp:22:90:\
    \ warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n         if (std::all_of(value.begin(), value.end(), [](char c)\
    \ { return std::islower(c); })) {\n                                          \
    \                                                ^\n/tmp/tmpbz1q55jp.cpp:24:20:\
    \ error: '"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return\
    \ True if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return False.\n// The function should return False is the given dictionary\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &kv : dict) {\n \
    \       if (kv.first >= 'a' && kv.first <= 'z') return false;\n        if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptu2aovye.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmptu2aovye.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'kv' with no type [-fpermissive]\n     for (auto &kv : dict)\
    \ {\n                ^\n/tmp/tmptu2aovye.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &kv : dict) {\n              \
    \       ^\n/tmp/tmptu2aovye.cpp:20:16: error: request for member 'first' in 'kv',\
    \ which is of non-class type 'int'\n         if (kv.first >= 'a' && kv.first <=\
    \ 'z') return false;\n                ^\n/tmp/tmptu2aovye.cpp:20:35: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if (kv.first\
    \ >= 'a' && kv.first <= 'z') return false;\n                                 \
    \  ^\n/tmp/tmptu2aovye.cpp:21:16: error: request for member 'first' in 'kv', which\
    \ is of non-class type 'int'\n         if (kv.first >= 'A' && kv.first <= 'Z')\
    \ return false;\n                ^\n/tmp/tmptu2aovye.cpp:21:35: error: request\
    \ for member 'first' in 'kv', which is of non-class type 'int'\n         if (kv.first\
    \ >= 'A' && kv.first <= 'Z') return false;\n                                 \
    \  ^\n/tmp/tmptu2aovye.cpp: In function 'int main()':\n/tmp/tmptu2aovye.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptu2aovye.cpp:2:\n/tmp/tmptu2aovye.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmptu2aovye.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"},"
  stdout: ''
