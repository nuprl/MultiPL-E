language: cpp
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4sgenx0d.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp4sgenx0d.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp4sgenx0d.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return true;\n     ^\n/tmp/tmp4sgenx0d.cpp:25:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmp4sgenx0d.cpp:25:5: error:\
    \ expected ';' before 'return'\n/tmp/tmp4sgenx0d.cpp:25:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp4sgenx0d.cpp:25:5: error: expected ')' before 'return'\n\
    /tmp/tmp4sgenx0d.cpp: In function 'int main()':\n/tmp/tmp4sgenx0d.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = will_it_fly;\n     \
    \     ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n        \
    \         from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4sgenx0d.cpp:2:\n/tmp/tmp4sgenx0d.cpp:29:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp4sgenx0d.cpp:29:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp4sgenx0d.cpp:29:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp4sgenx0d.cpp:29:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp4sgenx0d.cpp:29:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp4sgenx0d.cpp:2:\n/usr/include/c++/4.8.2/bit"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long max_sum = 0;\n    for (long i : q)\
    \ {\n        max_sum += i;\n    }\n    if (max_sum > w) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4j0w04gv.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp4j0w04gv.cpp:21:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp4j0w04gv.cpp:28:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmp4j0w04gv.cpp: In function 'int main()':\n\
    /tmp/tmp4j0w04gv.cpp:37:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4j0w04gv.cpp:2:\n/tmp/tmp4j0w04gv.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp4j0w04gv.cpp:38:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp4j0w04gv.cpp:38:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp4j0w04gv.cpp:38:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp4j0w04gv.cpp:38:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp4j0w04gv.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        sum += i;\n        if (sum\
    \ > max_sum) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt_j78brf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpt_j78brf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp: In function 'int main()':\n\
    /tmp/tmpt_j78brf.cpp:32:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt_j78brf.cpp:2:\n/tmp/tmpt_j78brf.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpt_j78brf.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpt_j78brf.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpt_j78brf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgej4uqrf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpgej4uqrf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp: In function 'int main()':\n\
    /tmp/tmpgej4uqrf.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgej4uqrf.cpp:2:\n/tmp/tmpgej4uqrf.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpgej4uqrf.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgej4uqrf.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgej4uqrf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8o2qasfi.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp8o2qasfi.cpp:21:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp8o2qasfi.cpp:\
    \ In function 'int main()':\n/tmp/tmp8o2qasfi.cpp:33:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8o2qasfi.cpp:2:\n/tmp/tmp8o2qasfi.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp8o2qasfi.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8o2qasfi.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8o2qasfi.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file inc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long maxSum = sum;\n    for (auto i : q) {\n        maxSum -= i;\n\
    \        if (maxSum < 0) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdzvvusx3.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpdzvvusx3.cpp:20:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmpdzvvusx3.cpp:23:5: error: expected\
    \ ';' before 'if'\n     if (sum < w) {\n     ^\n/tmp/tmpdzvvusx3.cpp:23:5: error:\
    \ expected primary-expression before 'if'\n/tmp/tmpdzvvusx3.cpp:23:5: error: expected\
    \ ';' before 'if'\n/tmp/tmpdzvvusx3.cpp:23:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpdzvvusx3.cpp:23:5: error: expected ')' before 'if'\n/tmp/tmpdzvvusx3.cpp:27:15:\
    \ error: 'i' does not name a type\n     for (auto i : q) {\n               ^\n\
    /tmp/tmpdzvvusx3.cpp:33:5: error: expected ';' before 'return'\n     return true;\n\
    \     ^\n/tmp/tmpdzvvusx3.cpp:33:5: error: expected primary-expression before\
    \ 'return'\n/tmp/tmpdzvvusx3.cpp:33:5: error: expected ';' before 'return'\n/tmp/tmpdzvvusx3.cpp:33:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpdzvvusx3.cpp:33:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpdzvvusx3.cpp: In function 'int\
    \ main()':\n/tmp/tmpdzvvusx3.cpp:36:10: error: 'candidate' does not name a type\n\
    \     auto candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdzvvusx3.cpp:2:\n/tmp/tmpdzvvusx3.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpdzvvusx3.cpp:37:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpdzvvusx3.cpp:37:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum > max) {\n\
    \            max = sum;\n        }\n    }\n    if (sum == w) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsolcehnv.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpsolcehnv.cpp:21:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpsolcehnv.cpp:\
    \ In function 'int main()':\n/tmp/tmpsolcehnv.cpp:33:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsolcehnv.cpp:2:\n/tmp/tmpsolcehnv.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpsolcehnv.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpsolcehnv.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpsolcehnv.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpsolcehnv.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpsolcehnv.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file inc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    bool fly_it = false;\n    for (auto i : q) {\n        sum\
    \ += i;\n        if (sum > max_weight) {\n            fly_it = true;\n       \
    \     break;\n        }\n    }\n    return fly_it;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj5sf5fom.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpj5sf5fom.cpp:22:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmpj5sf5fom.cpp:29:5: error: expected\
    \ ';' before 'return'\n     return fly_it;\n     ^\n/tmp/tmpj5sf5fom.cpp:29:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpj5sf5fom.cpp:29:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpj5sf5fom.cpp:29:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpj5sf5fom.cpp:29:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpj5sf5fom.cpp: In function 'int main()':\n/tmp/tmpj5sf5fom.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj5sf5fom.cpp:2:\n/tmp/tmpj5sf5fom.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpj5sf5fom.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpj5sf5fom.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpj5sf5fom.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpj5sf5fom.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpj5sf5fom.cpp:2:\n/usr/include/c++/4.8.2/b"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    return max_sum == w &&\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpox6avkxq.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpox6avkxq.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmpox6avkxq.cpp:27:5: error: expected\
    \ ';' before 'return'\n     return max_sum == w && std::equal(q.begin(), q.end(),\
    \ q.rbegin());\n     ^\n/tmp/tmpox6avkxq.cpp:27:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpox6avkxq.cpp:27:5: error: expected ';' before 'return'\n\
    /tmp/tmpox6avkxq.cpp:27:5: error: expected primary-expression before 'return'\n\
    /tmp/tmpox6avkxq.cpp:27:5: error: expected ')' before 'return'\n/tmp/tmpox6avkxq.cpp:\
    \ In function 'int main()':\n/tmp/tmpox6avkxq.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpox6avkxq.cpp:2:\n/tmp/tmpox6avkxq.cpp:31:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpox6avkxq.cpp:31:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpox6avkxq.cpp:31:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpox6avkxq.cpp:31:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpox6avkxq.cpp:31:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    f"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        sum += i;\n        if (sum\
    \ > max_sum) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt_j78brf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpt_j78brf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp: In function 'int main()':\n\
    /tmp/tmpt_j78brf.cpp:32:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt_j78brf.cpp:2:\n/tmp/tmpt_j78brf.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpt_j78brf.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpt_j78brf.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpt_j78brf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\
    \ (g++ 5.4.0) or C++11 (g++ 4.9.2)\n    long max_weight = w;\n    long sum = 0;\n\
    \    for (auto i : q) {\n        sum += i;\n        if (sum > max_weight) {\n\
    \            max_weight = sum;\n        }\n    }\n    return max_weight == w &&\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_g4loexj.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp_g4loexj.cpp:22:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp_g4loexj.cpp:28:5: error: expected\
    \ ';' before 'return'\n     return max_weight == w && std::equal(q.begin(), q.end(),\
    \ q.rbegin());\n     ^\n/tmp/tmp_g4loexj.cpp:28:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp_g4loexj.cpp:28:5: error: expected ';' before 'return'\n\
    /tmp/tmp_g4loexj.cpp:28:5: error: expected primary-expression before 'return'\n\
    /tmp/tmp_g4loexj.cpp:28:5: error: expected ')' before 'return'\n/tmp/tmp_g4loexj.cpp:\
    \ In function 'int main()':\n/tmp/tmp_g4loexj.cpp:31:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_g4loexj.cpp:2:\n/tmp/tmp_g4loexj.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp_g4loexj.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp_g4loexj.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp_g4loexj.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_g4loexj.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \  "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = sum - w;\n    long max_weight = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        max_weight = std::max(max_weight, q[i]);\n\
    \    }\n    return max_sum == max_weight;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsiudxh3r.cpp: In function 'int main()':\n/tmp/tmpsiudxh3r.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsiudxh3r.cpp:2:\n/tmp/tmpsiudxh3r.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpsiudxh3r.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpsiudxh3r.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpsiudxh3r.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpsiudxh3r.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpsiudxh3r.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsiudxh3r.cpp:2:\n/tmp/tmpsiudxh3r.cpp:33:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) return false;\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > w) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw4li7uhk.cpp: In function 'int main()':\n/tmp/tmpw4li7uhk.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw4li7uhk.cpp:2:\n/tmp/tmpw4li7uhk.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpw4li7uhk.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpw4li7uhk.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpw4li7uhk.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpw4li7uhk.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpw4li7uhk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw4li7uhk.cpp:2:\n/tmp/tmpw4li7uhk.cpp:33:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \        if (max_sum > w) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdme7mvnr.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpdme7mvnr.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpdme7mvnr.cpp:27:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpdme7mvnr.cpp: In function 'int main()':\n\
    /tmp/tmpdme7mvnr.cpp:36:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdme7mvnr.cpp:2:\n/tmp/tmpdme7mvnr.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpdme7mvnr.cpp:37:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpdme7mvnr.cpp:37:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpdme7mvnr.cpp:37:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpdme7mvnr.cpp:37:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpdme7mvnr.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++17\n\
    \    long sum = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long max_sum = 0;\n    for (auto i\
    \ : q) {\n        max_sum += i;\n    }\n    if (max_sum < w) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp29gu3z48.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp29gu3z48.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp29gu3z48.cpp:24:5: error: expected\
    \ ';' before 'if'\n     if (sum < w) {\n     ^\n/tmp/tmp29gu3z48.cpp:24:5: error:\
    \ expected primary-expression before 'if'\n/tmp/tmp29gu3z48.cpp:24:5: error: expected\
    \ ';' before 'if'\n/tmp/tmp29gu3z48.cpp:24:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmp29gu3z48.cpp:24:5: error: expected ')' before 'if'\n/tmp/tmp29gu3z48.cpp:28:15:\
    \ error: 'i' does not name a type\n     for (auto i : q) {\n               ^\n\
    /tmp/tmp29gu3z48.cpp:31:5: error: expected ';' before 'if'\n     if (max_sum <\
    \ w) {\n     ^\n/tmp/tmp29gu3z48.cpp:31:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmp29gu3z48.cpp:31:5: error: expected ';' before 'if'\n/tmp/tmp29gu3z48.cpp:31:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmp29gu3z48.cpp:31:5: error:\
    \ expected ')' before 'if'\n/tmp/tmp29gu3z48.cpp: In function 'int main()':\n\
    /tmp/tmp29gu3z48.cpp:37:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp29gu3z48.cpp:2:\n/tmp/tmp29gu3z48.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp29gu3z48.cpp:38:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp29gu3z48.cpp:38:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp29gu3z"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdt4jgnrd.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpdt4jgnrd.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpdt4jgnrd.cpp:27:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpdt4jgnrd.cpp: In function 'int main()':\n\
    /tmp/tmpdt4jgnrd.cpp:35:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdt4jgnrd.cpp:2:\n/tmp/tmpdt4jgnrd.cpp:36:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpdt4jgnrd.cpp:36:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpdt4jgnrd.cpp:36:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpdt4jgnrd.cpp:36:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpdt4jgnrd.cpp:36:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpdt4jgnrd.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    long max_weight = 0;\n    for (long i\
    \ : q) {\n        max_weight = max(max_weight, i);\n    }\n    if (max_sum ==\
    \ max_weight) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9i16se5s.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp9i16se5s.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp9i16se5s.cpp:28:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmp9i16se5s.cpp:29:39: error: 'max' was\
    \ not declared in this scope\n         max_weight = max(max_weight, i);\n    \
    \                                   ^\n/tmp/tmp9i16se5s.cpp:29:39: note: suggested\
    \ alternative:\nIn file included from /usr/include/c++/4.8.2/algorithm:61:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmp9i16se5s.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:260:5:\
    \ note:   'std::max'\n     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n\
    \     ^\n/tmp/tmp9i16se5s.cpp: In function 'int main()':\n/tmp/tmp9i16se5s.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9i16se5s.cpp:2:\n/tmp/tmp9i16se5s.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp9i16se5s.cpp:38:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp9i16se5s.cpp:38:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp9i16se5s.cpp:38:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    if (sum == w) {\n\
    \        return true;\n    }\n    long max_sum = 0;\n    for (long i = 0; i <\
    \ q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum == w) {\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpogrjdydc.cpp: In function 'int main()':\n/tmp/tmpogrjdydc.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpogrjdydc.cpp:2:\n/tmp/tmpogrjdydc.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpogrjdydc.cpp:41:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpogrjdydc.cpp:41:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpogrjdydc.cpp:41:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpogrjdydc.cpp:41:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpogrjdydc.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpogrjdydc.cpp:2:\n/tmp/tmpogrjdydc.cpp:41:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplhtiyabf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmplhtiyabf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmplhtiyabf.cpp:27:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmplhtiyabf.cpp: In function 'int main()':\n\
    /tmp/tmplhtiyabf.cpp:33:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplhtiyabf.cpp:2:\n/tmp/tmplhtiyabf.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmplhtiyabf.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmplhtiyabf.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmplhtiyabf.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmplhtiyabf.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmplhtiyabf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n        if (max_sum\
    \ > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfldnvmku.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpfldnvmku.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpfldnvmku.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpfldnvmku.cpp: In function 'int main()':\n\
    /tmp/tmpfldnvmku.cpp:32:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfldnvmku.cpp:2:\n/tmp/tmpfldnvmku.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpfldnvmku.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpfldnvmku.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpfldnvmku.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpfldnvmku.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpfldnvmku.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0;\
    \ i < q.size(); i++) {\n        sum += q[i];\n        if (sum < w) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpen50qhog: /tmp/tmpen50qhog.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long maxSum = sum;\n    for (auto\
    \ i : q) {\n        maxSum -= i;\n        if (maxSum < 0) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpermn568s: /tmp/tmpermn568s.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n\
    \    if (max_sum < w) {\n        return false;\n    }\n    long sum = 0;\n   \
    \ for (long i : q) {\n        sum += i;\n    }\n    return sum == w && max_sum\
    \ == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpct7awa8g: /tmp/tmpct7awa8g.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgej4uqrf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpgej4uqrf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp: In function 'int main()':\n\
    /tmp/tmpgej4uqrf.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgej4uqrf.cpp:2:\n/tmp/tmpgej4uqrf.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpgej4uqrf.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgej4uqrf.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgej4uqrf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) return false;\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > w) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw4li7uhk.cpp: In function 'int main()':\n/tmp/tmpw4li7uhk.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = will_it_fly;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw4li7uhk.cpp:2:\n/tmp/tmpw4li7uhk.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpw4li7uhk.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpw4li7uhk.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpw4li7uhk.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpw4li7uhk.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpw4li7uhk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw4li7uhk.cpp:2:\n/tmp/tmpw4li7uhk.cpp:33:68: note:\
    \   candidat"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    long max_weight = 0;\n    for (auto i\
    \ : q) {\n        max_weight = max(max_weight, i);\n    }\n    return max_sum\
    \ == max_weight;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf40j23st.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpf40j23st.cpp:29:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   29 |    \
    \     max_weight = max(max_weight, i);\n      |                      ^~~\n   \
    \   |                      std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf40j23st.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ <= 0) {\n        return false;\n    }\n    long maxSum = 0;\n    for (long i\
    \ : q) {\n        maxSum += i;\n    }\n    return maxSum == maxWeight;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp3waf7kvd: /tmp/tmp3waf7kvd.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i : q) {\n        sum += i;\n    }\n    if(sum < w) return\
    \ false;\n    for(long i : q) {\n        if(i != sum) return false;\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcr0rhjcw: /tmp/tmpcr0rhjcw.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp94e9wfq4: /tmp/tmp94e9wfq4.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpvuozexuc: /tmp/tmpvuozexuc.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum >= w && is_palindromic(q, max_sum);\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpivizlva5.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpivizlva5.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum >= w && is_palindromic(q,\
    \ max_sum);\n      |                            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == sum;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp16yjk4m5: /tmp/tmp16yjk4m5.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    if (max_sum < 0) {\n        return false;\n\
    \    }\n    long max_element = q.back();\n    for (long i : q) {\n        if (i\
    \ > max_element) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp2wgvf8_9: /tmp/tmp2wgvf8_9.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum, i);\n\
    \    }\n    return max_sum == sum;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4jv3pdgw: /tmp/tmp4jv3pdgw.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum == w) {\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpeuyve2yx: /tmp/tmpeuyve2yx.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_weight = w;\n    for (long i : q) {\n        max_weight = max(max_weight,\
    \ i);\n    }\n    long min_weight = w;\n    for (long i : q) {\n        min_weight\
    \ = min(min_weight, i);\n    }\n    if (max_weight == min_weight) return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9yjathey.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp9yjathey.cpp:26:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   26 |    \
    \     max_weight = max(max_weight, i);\n      |                      ^~~\n   \
    \   |                      std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9yjathey.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmp9yjathey.cpp:30:22: error: \u2018\
    min\u2019 was not declared in this scope; did you mean \u2018std::min\u2019?\n\
    \   30 |         min_weight = min(min_weight, i);\n      |                   \
    \   ^~~\n      |                      std::min\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9yjathey.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3450:5:\
    \ note: \u2018std::min\u2019 declared here\n 3450 |     min(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long maxWeight = w;\n    long sum = 0;\n    for(auto i : q) {\n        sum\
    \ += i;\n        if(sum > maxWeight) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvn37d4y8: /tmp/tmpvn37d4y8.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum > max) {\n\
    \            max = sum;\n        }\n    }\n    if (sum < w) {\n        return\
    \ false;\n    }\n    long mid = sum / 2;\n    for (long i : q) {\n        if (i\
    \ > mid) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp54jmg9d0: /tmp/tmp54jmg9d0.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \    }\n    if (max_sum == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpx1mof8gf: /tmp/tmpx1mof8gf.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpaeq_xgxl: /tmp/tmpaeq_xgxl.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum, i);\n\
    \    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4qzd9hmw: /tmp/tmp4qzd9hmw.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max_sum\
    \ = w;\n    for (auto i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    return max_sum == w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp2zzak50y: /tmp/tmp2zzak50y.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) return false;\n    long max_weight = 0;\n    for (long i = 0; i < q.size();\
    \ i++) {\n        max_weight += q[i];\n        if (max_weight > w) return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp33ry11us: /tmp/tmp33ry11us.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && q == std::reverse(q);\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdepfdevd.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpdepfdevd.cpp:27:50: error: no matching function\
    \ for call to \u2018reverse(std::vector<long int>&)\u2019\n   27 |     return\
    \ max_weight == w && q == std::reverse(q);\n      |                          \
    \                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdepfdevd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:1180:5:\
    \ note: candidate: \u2018template<class _BIter> void std::reverse(_BIter, _BIter)\u2019\
    \n 1180 |     reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n\
    \      |     ^~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:1180:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdepfdevd.cpp:27:50:\
    \ note:   candidate expects 2 arguments, 1 provided\n   27 |     return max_weight\
    \ == w && q == std::reverse(q);\n      |                                     \
    \             ^\n"
  stdout: ''
  timestamp: 1659800394
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max_sum\
    \ = w;\n    for (long i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    return max_sum == w &&\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    long n = q.size();\n    for(long i = 0; i < n; i++) {\n\
    \        sum += q[i];\n        if(sum > max_weight) return false;\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpglfhdh6q: /tmp/tmpglfhdh6q.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n\
    \    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplhtiyabf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmplhtiyabf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmplhtiyabf.cpp:27:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmplhtiyabf.cpp: In function 'int main()':\n\
    /tmp/tmplhtiyabf.cpp:33:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplhtiyabf.cpp:2:\n/tmp/tmplhtiyabf.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmplhtiyabf.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmplhtiyabf.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmplhtiyabf.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmplhtiyabf.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmplhtiyabf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1thnf9o1: /tmp/tmp1thnf9o1.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800396
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for(long i : q) {\n        sum += i;\n        if(sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    return max_sum == w &&\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwdy2fjpa: /tmp/tmpwdy2fjpa.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpo5hwsy8f: /tmp/tmpo5hwsy8f.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n\
    \        return false;\n    }\n    if (sum == w) {\n        return true;\n   \
    \ }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplkgdnmg2: /tmp/tmplkgdnmg2.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (auto i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjuiy37rv: /tmp/tmpjuiy37rv.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w)\n        return false;\n    long sum = 0;\n\
    \    for (auto i : q) {\n        sum += i;\n        if (sum > w)\n           \
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp897763l4: /tmp/tmp897763l4.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_weight = w;\n    long sum = 0;\n    for(long i : q) {\n        sum\
    \ += i;\n        if(sum > max_weight) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2xz4uy54: /tmp/tmp2xz4uy54.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum +=\
    \ q[i];\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp93w9kget: /tmp/tmp93w9kget.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800396
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum <= w && is_palindromic(q, max_sum);\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp87ca20la.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp87ca20la.cpp:20:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum <= w && is_palindromic(q,\
    \ max_sum);\n      |                            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    long max_weight = 0;\n    for (auto i : q) {\n       \
    \ sum += i;\n        max_weight = std::max(max_weight, i);\n    }\n    if (sum\
    \ < w) return false;\n    if (sum == w) return true;\n    if (sum > w) return\
    \ true;\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1gmo3x9c: /tmp/tmp1gmo3x9c.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long max_weight = w;\n    long sum = 0;\n    for(long i : q) {\n        sum\
    \ += i;\n        if(sum > max_weight) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj5rj3baf: /tmp/tmpj5rj3baf.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\
    \ (g++ 5.4.0) or C++11 (g++ 4.9.2)\n    long sum = 0;\n    for(auto i : q) {\n\
    \        sum += i;\n    }\n    if(sum < w) return false;\n    for(auto i : q)\
    \ {\n        if(i != sum) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp9x4bdzqc: /tmp/tmp9x4bdzqc.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4sgenx0d.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp4sgenx0d.cpp:21:15: error: 'i' does not name a type\n \
    \    for (auto i : q) {\n               ^\n/tmp/tmp4sgenx0d.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return true;\n     ^\n/tmp/tmp4sgenx0d.cpp:25:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmp4sgenx0d.cpp:25:5: error:\
    \ expected ';' before 'return'\n/tmp/tmp4sgenx0d.cpp:25:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp4sgenx0d.cpp:25:5: error: expected ')' before 'return'\n\
    /tmp/tmp4sgenx0d.cpp: In function 'int main()':\n/tmp/tmp4sgenx0d.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = will_it_fly;\n     \
    \     ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n        \
    \         from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4sgenx0d.cpp:2:\n/tmp/tmp4sgenx0d.cpp:29:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp4sgenx0d.cpp:29:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp4sgenx0d.cpp:29:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp4sgenx0d.cpp:29:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp4sgenx0d.cpp:29:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp4sgenx0d.cpp:2:\n/usr/include/c++/4.8.2/bit"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_sum) {\n            max_sum = sum;\n        }\n    }\n\
    \    return max_sum == w && is_palindromic(q) && sum < w;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuufxta8j.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpuufxta8j.cpp:27:28: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   27 |     return max_sum == w && is_palindromic(q)\
    \ && sum < w;\n      |                            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q, w);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzqn0gvlr.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpzqn0gvlr.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q,\
    \ w);\n      |                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpaeq_xgxl: /tmp/tmpaeq_xgxl.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0;\
    \ i < q.size(); i++) {\n        sum += q[i];\n        if (sum < w) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpen50qhog: /tmp/tmpen50qhog.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ maxWeight = std::max(w, sum);\n    long maxSum = sum - maxWeight;\n    for (auto\
    \ i : q) {\n        if (maxWeight - i < 0) return false;\n        if (maxSum +\
    \ i > maxWeight) return false;\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpxwuybju7: /tmp/tmpxwuybju7.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum == w)\
    \ {\n        return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpfmyqnzoo: /tmp/tmpfmyqnzoo.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpaeq_xgxl: /tmp/tmpaeq_xgxl.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long max_sum = sum - w;\n    for (long\
    \ i : q) {\n        sum += i;\n        if (sum > max_sum) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp35uqwz5w: /tmp/tmp35uqwz5w.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxSum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return maxSum < w && is_palindromic(q, w);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsq6tmrq5.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpsq6tmrq5.cpp:20:26: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return maxSum < w && is_palindromic(q,\
    \ w);\n      |                          ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max_weight\
    \ = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    \
    \    if (sum > max_weight) {\n            max_weight = sum;\n        }\n    }\n\
    \    return max_weight <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4aqbkmo8: /tmp/tmp4aqbkmo8.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n\
    \    if (max_sum < w) {\n        return false;\n    }\n    long sum = 0;\n   \
    \ for (long i : q) {\n        sum += i;\n    }\n    if (sum == w) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpmz5g8vw8: /tmp/tmpmz5g8vw8.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == sum;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1dz_jki3: /tmp/tmp1dz_jki3.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800398
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0;\
    \ i < q.size(); i++) {\n        sum += q[i];\n        if (sum > w) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp180wbbwa: /tmp/tmp180wbbwa.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgej4uqrf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpgej4uqrf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp: In function 'int main()':\n\
    /tmp/tmpgej4uqrf.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgej4uqrf.cpp:2:\n/tmp/tmpgej4uqrf.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpgej4uqrf.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgej4uqrf.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgej4uqrf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ <= 0) {\n        return false;\n    }\n    long mid = max_weight / 2;\n    long\
    \ left = max_weight - mid;\n    long right = max_weight - mid;\n    long mid2\
    \ = max_weight / 2;\n    long left2 = max_weight - mid2;\n    long right2 = max_weight\
    \ - mid2;\n    long mid3 = max_weight / 2;\n    long left3 = max_weight - mid3;\n\
    \    long right3 = max_weight - mid3;\n    long mid4 = max_weight / 2;\n    long\
    \ left4 = max_weight - mid4;\n    long right4 = max_weight - mid4;\n    long mid5\
    \ = max_weight / 2;\n    long left5 = max_weight - mid5;\n    long right5 = max_weight\
    \ - mid5;\n    long mid6 = max_weight / 2;\n    long left6 = max_weight - mid6;\n\
    \    long right6 = max_weight - mid6;\n    long mid7 = max_weight / 2;\n    long\
    \ left7 = max_weight - mid7;\n    long right7 = max_weight - mid7;\n    long mid8\
    \ = max_weight / 2;\n    long left8 = max_weight - mid8;\n    long right8 = max_weight\
    \ - mid8;\n    long mid9 = max_weight / 2;\n    long left9 = max_weight - mid9;\n\
    \    long right9 = max_weight - mid9;\n    long mid10 = max_weight / 2;\n    long\
    \ left10 = max_weight - mid10;\n    long right10 = max_weight - mid10;\n    long\
    \ mid11 = max_weight / 2;\n    long left11 = max_weight - mid11;\n    long right11\
    \ = max_weight - mid11;\n    long mid12 = max_weight / 2;\n    long left12 = max_weight\
    \ - mid12;\n    long right12 = max_weight - mid12;\n    long mid13 = max_weight\
    \ / 2;\n    long left13 = max_weight - mid13;\n    long right13 = max_weight -\
    \ mid13;\n    long mid14 = max_weight / 2;\n    long left14 = max_weight - mid14;\n\
    \    long right14 = max_weight - mid14;\n    long mid15 = max_weight / 2;\n  \
    \  long left15 = max_weight - mid15;\n    long right15 = max_weight - mid15;\n\
    \    long mid16 = max_weight / 2;\n    long left16 = max_weight - mid16;\n\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpk6253_85: /tmp/tmpk6253_85.cpp:81: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\
    \ (g++ 5.4.0) or C++11 (g++ 4.9.2)\n    long sum = 0;\n    for(auto &i : q) {\n\
    \        sum += i;\n    }\n    if(sum < w) return false;\n    long max_sum = w;\n\
    \    for(auto &i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    return\
    \ max_sum == sum;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp55gyvxz7: /tmp/tmp55gyvxz7.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ >= w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprc85aczf: /tmp/tmprc85aczf.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwdy2fjpa: /tmp/tmpwdy2fjpa.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n\
    \    if (sum < w) {\n        return false;\n    }\n    long max_weight = 0;\n\
    \    for (long i = 0; i < q.size(); i++) {\n        max_weight = max(max_weight,\
    \ q[i]);\n    }\n    if (max_weight < w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphofdtgae.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphofdtgae.cpp:29:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   29 |    \
    \     max_weight = max(max_weight, q[i]);\n      |                      ^~~\n\
    \      |                      std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphofdtgae.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if(sum < w) return\
    \ false;\n    long max_sum = sum - w;\n    for(long i = 0; i < q.size(); i++)\
    \ {\n        if(q[i] > max_sum) return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7s944rze: /tmp/tmp7s944rze.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i : q) {\n        sum += i;\n    }\n    if(sum < w) {\n\
    \        return false;\n    }\n    long max = 0;\n    for(long i : q) {\n    \
    \    if(i > max) {\n            max = i;\n        }\n    }\n    long mid = max\
    \ / 2;\n    long left = 0;\n    long right = 0;\n    for(long i : q) {\n     \
    \   if(i < mid) {\n            left += i;\n        } else {\n            right\
    \ += i;\n        }\n    }\n    if(left == right) {\n        return true;\n   \
    \ }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3p4aauwj: /tmp/tmp3p4aauwj.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == 0) {\n        return true;\n    }\n    long max_sum = 0;\n    for (auto i\
    \ : q) {\n        max_sum += i;\n    }\n    return max_sum == max_weight;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpmtvf_6cq: /tmp/tmpmtvf_6cq.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    bool flag\
    \ = false;\n    for (long i : q) {\n        sum += i;\n        if (sum >= w) {\n\
    \            flag = true;\n            break;\n        }\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprdl4fwdy: /tmp/tmprdl4fwdy.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == 0) {\n        return true;\n    }\n    if (max_weight < sum) {\n        return\
    \ false;\n    }\n    long max_sum = 0;\n    for (auto i : q) {\n        max_sum\
    \ += i;\n        if (max_sum > max_weight) {\n            max_sum = max_weight;\n\
    \        }\n    }\n    if (max_sum == max_weight) {\n        return true;\n  \
    \  }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmplm7y3vhb: /tmp/tmplm7y3vhb.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (auto i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjuiy37rv: /tmp/tmpjuiy37rv.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    bool isBalanced = true;\n    for (auto i : q) {\n       \
    \ sum += i;\n        if (sum > maxWeight) {\n            isBalanced = false;\n\
    \            break;\n        }\n    }\n    if (isBalanced) {\n        long reverseSum\
    \ = 0;\n        for (auto i : q) {\n            reverseSum += i;\n        }\n\
    \        if (sum == reverseSum) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpns44qc1o: /tmp/tmpns44qc1o.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    if (sum > w) return true;\n    long max_weight = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        max_weight = max(max_weight, q[i]);\n \
    \   }\n    if (max_weight == 0) return true;\n    long max_sum = max_weight -\
    \ sum;\n    for (long i = 0; i < q.size(); i++) {\n        if (q[i] > max_sum)\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeqeyvfg0.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpeqeyvfg0.cpp:27:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   27 |    \
    \     max_weight = max(max_weight, q[i]);\n      |                      ^~~\n\
    \      |                      std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpeqeyvfg0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659800399
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_weight = w;\n    for (auto i : q) {\n        max_weight =\
    \ max(max_weight, i);\n    }\n    long min_weight = w;\n    for (auto i : q) {\n\
    \        min_weight = min(min_weight, i);\n    }\n    if (max_weight == min_weight)\
    \ {\n        return true;\n    }\n    long mid = max_weight / 2;\n    long left_sum\
    \ = sum - mid;\n    long right_sum = sum + mid;\n    if (left_sum < w && right_sum\
    \ < w) {\n        return will_it_fly(q, w);\n    }\n    if (left_sum > w && right_sum\
    \ > w) {\n        return will_it_fly(q, w);\n    }\n    if (left_sum < w && right_sum\
    \ > w) {\n        return will_it_fly(q, w);\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjnm1r264.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpjnm1r264.cpp:28:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   28 |    \
    \     max_weight = max(max_weight, i);\n      |                      ^~~\n   \
    \   |                      std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjnm1r264.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmpjnm1r264.cpp:32:22: error: \u2018\
    min\u2019 was not declared in this scope; did you mean \u2018std::min\u2019?\n\
    \   32 |         min_weight = min(min_weight, i);\n      |                   \
    \   ^~~\n      |                      std::min\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjnm1r264.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3450:5:\
    \ note: \u2018std::min\u2019 declared here\n 3450 |     min(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659800399
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    return max_weight == w && is_palindromic(q, max_weight);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq00ie8ql.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpq00ie8ql.cpp:27:31: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   27 |     return max_weight == w && is_palindromic(q,\
    \ max_weight);\n      |                               ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    long min_sum = sum + w;\n    bool is_balanced = true;\n\
    \    for (long i : q) {\n        if (i > max_sum) return false;\n        if (i\
    \ < min_sum) return false;\n        is_balanced = !is_balanced;\n    }\n    return\
    \ is_balanced;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp42jodbnq: /tmp/tmp42jodbnq.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = w;\n    for (long i = 0; i < q.size(); i++) {\n \
    \       max_sum = std::max(max_sum, q[i]);\n    }\n    return max_sum == w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmplaa3lkk_: /tmp/tmplaa3lkk_.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800399
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && q == std::reverse(q.begin(), q.end());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3b06ydgw.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp3b06ydgw.cpp:27:33: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    void\u2019)\n   27 |     return max_weight == w && q == std::reverse(q.begin(),\
    \ q.end());\n      |                               ~ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |                |\n      |           \
    \                    |                void\n      |                          \
    \     std::vector<long int>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3b06ydgw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp3b06ydgw.cpp:27:67:\
    \ note:   \u2018std::vector<long int>\u2019 is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   27 |     return max_weight == w && q == std::reverse(q.begin(), q.end());\n\
    \      |                                                                   ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3b06ydgw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>"
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    bool fly_it = true;\n    for(long i : q) {\n        sum\
    \ += i;\n        if(sum > max_weight) {\n            fly_it = false;\n       \
    \     break;\n        }\n    }\n    return fly_it;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpvyy5f5yb: /tmp/tmpvyy5f5yb.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ == w) {\n        return true;\n    }\n    if (max_sum > w) {\n        return\
    \ false;\n    }\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n\
    \        sum += q[i];\n        if (sum > w) {\n            return false;\n   \
    \     }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp3nkj7739: /tmp/tmp3nkj7739.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgej4uqrf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpgej4uqrf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp: In function 'int main()':\n\
    /tmp/tmpgej4uqrf.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgej4uqrf.cpp:2:\n/tmp/tmpgej4uqrf.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpgej4uqrf.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgej4uqrf.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgej4uqrf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    bool fly\
    \ = true;\n    for (long i : q) {\n        sum += i;\n        if (sum > w) {\n\
    \            fly = false;\n            break;\n        }\n    }\n    return fly;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpjd_yvxzg: /tmp/tmpjd_yvxzg.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) return false;\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum == w) return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp5ez6o8aw: /tmp/tmp5ez6o8aw.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    bool isBalanced = true;\n    for (auto i : q) {\n       \
    \ sum += i;\n        if (sum > maxWeight) {\n            isBalanced = false;\n\
    \            break;\n        }\n    }\n    if (isBalanced) {\n        long maxSum\
    \ = sum;\n        for (auto i : q) {\n            maxSum += i;\n        }\n  \
    \      if (maxSum == maxWeight) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpxmeamihi: /tmp/tmpxmeamihi.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7kk8i1u6: /tmp/tmp7kk8i1u6.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    long max_weight = 0;\n    for (auto i : q) {\n       \
    \ sum += i;\n        max_weight = std::max(max_weight, i);\n    }\n    if (sum\
    \ < max_weight) {\n        return false;\n    }\n    long max_weight_without_palindrome\
    \ = max_weight - 1;\n    for (auto i : q) {\n        sum += i;\n        max_weight_without_palindrome\
    \ = std::max(max_weight_without_palindrome, i);\n    }\n    if (sum < max_weight_without_palindrome)\
    \ {\n        return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpf4z3f8rx: /tmp/tmpf4z3f8rx.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && q == std::reverse(q.begin(), q.end());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3b06ydgw.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp3b06ydgw.cpp:27:33: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    void\u2019)\n   27 |     return max_weight == w && q == std::reverse(q.begin(),\
    \ q.end());\n      |                               ~ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |                |\n      |           \
    \                    |                void\n      |                          \
    \     std::vector<long int>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3b06ydgw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp3b06ydgw.cpp:27:67:\
    \ note:   \u2018std::vector<long int>\u2019 is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   27 |     return max_weight == w && q == std::reverse(q.begin(), q.end());\n\
    \      |                                                                   ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3b06ydgw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>"
  stdout: ''
  timestamp: 1659800399
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp94e9wfq4: /tmp/tmp94e9wfq4.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    long max_weight = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > max_weight) {\n            max_weight\
    \ = sum;\n        }\n    }\n    if (max_weight <= w) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp45ba8a1i: /tmp/tmp45ba8a1i.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgej4uqrf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpgej4uqrf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp: In function 'int main()':\n\
    /tmp/tmpgej4uqrf.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgej4uqrf.cpp:2:\n/tmp/tmpgej4uqrf.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpgej4uqrf.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgej4uqrf.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgej4uqrf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        sum += i;\n        if (sum\
    \ > max_sum) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt_j78brf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpt_j78brf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp: In function 'int main()':\n\
    /tmp/tmpt_j78brf.cpp:32:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt_j78brf.cpp:2:\n/tmp/tmpt_j78brf.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpt_j78brf.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpt_j78brf.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpt_j78brf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i : q){\n        sum += i;\n    }\n    if(sum < w){\n\
    \        return false;\n    }\n    long max_weight = w;\n    for(long i : q){\n\
    \        max_weight = max(max_weight, i);\n    }\n    for(long i : q){\n     \
    \   if(i != max_weight){\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8_qf2xwn.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp8_qf2xwn.cpp:29:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   29 |    \
    \     max_weight = max(max_weight, i);\n      |                      ^~~\n   \
    \   |                      std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8_qf2xwn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659800401
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q, max_sum);\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpygeh7svu.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpygeh7svu.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q,\
    \ max_sum);\n      |                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_weight = w;\n    long sum = 0;\n    for(long i : q) {\n        sum\
    \ += i;\n        if(sum > max_weight) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2xz4uy54: /tmp/tmp2xz4uy54.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpo5hwsy8f: /tmp/tmpo5hwsy8f.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = sum - w;\n    for (long i : q) {\n        if (max_sum\
    \ < 0) return false;\n        max_sum -= i;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmplhmaao4k: /tmp/tmplhmaao4k.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n\
    \        return false;\n    }\n    long max_sum = w;\n    for (long i : q) {\n\
    \        max_sum = std::max(max_sum, i);\n    }\n    if (max_sum == w) {\n   \
    \     return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpo_5ub9ag: /tmp/tmpo_5ub9ag.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for(auto i : q) {\n        sum += i;\n        if(sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if(sum == max_sum) {\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4pgp8a8x: /tmp/tmp4pgp8a8x.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp94e9wfq4: /tmp/tmp94e9wfq4.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0;\
    \ i < q.size(); i++) {\n        sum += q[i];\n        if (sum < w) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpen50qhog: /tmp/tmpen50qhog.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1thnf9o1: /tmp/tmp1thnf9o1.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_weight = w;\n    long sum = 0;\n    for(auto &i : q) {\n       \
    \ sum += i;\n        if(sum > max_weight) {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0_m7zp_z: /tmp/tmp0_m7zp_z.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i + w);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpr7s567rm: /tmp/tmpr7s567rm.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp65uigus_: /tmp/tmp65uigus_.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1thnf9o1: /tmp/tmp1thnf9o1.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800396
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > max_sum) {\n            max_sum =\
    \ sum;\n            max_weight = w;\n        }\n    }\n    if (max_sum == sum\
    \ && max_weight == w) {\n        return true;\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpj4gg7i6r: /tmp/tmpj4gg7i6r.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    long max_weight = 0;\n    for(long i : q) {\n        sum\
    \ += i;\n        if(sum > max_weight) {\n            max_weight = sum;\n     \
    \   }\n    }\n    if(max_weight <= w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpefo6sa2u: /tmp/tmpefo6sa2u.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    if (max_weight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpyrhp417e: /tmp/tmpyrhp417e.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long max_sum = 0;\n    for (long i : q)\
    \ {\n        max_sum += i;\n    }\n    if (max_sum < w) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvreefiyt: /tmp/tmpvreefiyt.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n \
    \       max_sum += q[i];\n        if (max_sum > w) return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcx6vmpsr: /tmp/tmpcx6vmpsr.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    long max_weight = 0;\n    for (long i = 0; i < q.size(); i++) {\n\
    \        sum += q[i];\n        if (sum > max_weight) {\n            max_weight\
    \ = sum;\n        }\n    }\n    if (max_weight == 0) {\n        return false;\n\
    \    }\n    if (max_weight < w) {\n        return false;\n    }\n    long max_sum\
    \ = 0;\n    for (long i = 0; i < q.size(); i++) {\n        long temp = q[i];\n\
    \        sum += temp;\n        if (sum > max_sum) {\n            max_sum = sum;\n\
    \        }\n    }\n    if (max_sum == max_weight) {\n        return true;\n  \
    \  }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1fbrbq7d: /tmp/tmp1fbrbq7d.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8o2qasfi.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp8o2qasfi.cpp:21:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp8o2qasfi.cpp:\
    \ In function 'int main()':\n/tmp/tmp8o2qasfi.cpp:33:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8o2qasfi.cpp:2:\n/tmp/tmp8o2qasfi.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp8o2qasfi.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8o2qasfi.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8o2qasfi.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file inc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && is_palindromic(q) && sum < max_weight;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmhi70z89.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpmhi70z89.cpp:27:31: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   27 |     return max_weight == w && is_palindromic(q)\
    \ && sum < max_weight;\n      |                               ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4owi_ukp: /tmp/tmp4owi_ukp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    long max_weight = 0;\n    for (auto i : q) {\n        sum += i;\n\
    \        max_weight = std::max(max_weight, i);\n    }\n    if (sum < max_weight)\
    \ {\n        return false;\n    }\n    long max_sum = 0;\n    for (auto i : q)\
    \ {\n        max_sum += i;\n    }\n    return max_sum == max_weight;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmppnzm_yq8: /tmp/tmppnzm_yq8.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800402
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n\
    \        return false;\n    }\n    long max_weight = w;\n    for (long i : q)\
    \ {\n        max_weight = std::max(max_weight, i);\n    }\n    bool is_balanced\
    \ = true;\n    for (long i : q) {\n        is_balanced = is_balanced && (i ==\
    \ sum);\n    }\n    return is_balanced && max_weight == sum;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp18fscsq5: /tmp/tmp18fscsq5.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800402
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    return max_weight == w && is_palindromic(q) && sum < max_weight;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx8q2df5e.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpx8q2df5e.cpp:27:31: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   27 |     return max_weight == w && is_palindromic(q)\
    \ && sum < max_weight;\n      |                               ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800401
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxW = w;\n    long\
    \ sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum > maxW)\
    \ {\n            maxW = sum;\n        }\n    }\n    return sum == maxW && is_palindromic(q)\
    \ && is_balanced(q);\n}\nint main() {\n    auto candidate = will_it_fly;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n\
    \    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpax3nidq8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpax3nidq8.cpp:27:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   27 |     return sum == maxW && is_palindromic(q)\
    \ && is_balanced(q);\n      |                           ^~~~~~~~~~~~~~\n/tmp/tmpax3nidq8.cpp:27:48:\
    \ error: \u2018is_balanced\u2019 was not declared in this scope\n   27 |     return\
    \ sum == maxW && is_palindromic(q) && is_balanced(q);\n      |               \
    \                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800403
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    for(auto i : q) {\n        sum += i;\n    }\n    if(sum\
    \ < w) return false;\n    long max_sum = sum - w;\n    for(auto i : q) {\n   \
    \     if(i > max_sum) return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmphkfk5dvk: /tmp/tmphkfk5dvk.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800403
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    long max = 0;\n    for (long i = 0; i < q.size(); i++) {\n   \
    \     sum += q[i];\n        if (sum > max) {\n            max = sum;\n       \
    \ }\n    }\n    if (sum == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmptt3xu8rp: /tmp/tmptt3xu8rp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800403
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp65uigus_: /tmp/tmp65uigus_.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n        if (max_sum\
    \ > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfldnvmku.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpfldnvmku.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpfldnvmku.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpfldnvmku.cpp: In function 'int main()':\n\
    /tmp/tmpfldnvmku.cpp:32:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfldnvmku.cpp:2:\n/tmp/tmpfldnvmku.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpfldnvmku.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpfldnvmku.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpfldnvmku.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpfldnvmku.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpfldnvmku.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i : q) {\n        max_sum += i;\n    }\n    if (max_sum < w) {\n     \
    \   return false;\n    }\n    long sum = 0;\n    for (long i : q) {\n        sum\
    \ += i;\n        if (sum > w) {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpt0xkfzs7: /tmp/tmpt0xkfzs7.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800403
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for(auto i : q) {\n        sum += i;\n        if(sum > max_weight)\
    \ {\n            max_weight = sum;\n        }\n    }\n    if(max_weight == 0)\
    \ {\n        return true;\n    }\n    long max_sum = 0;\n    for(auto i : q) {\n\
    \        max_sum += i;\n        if(max_sum > max_weight) {\n            max_sum\
    \ = max_weight;\n        }\n    }\n    return max_sum == max_weight;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpjh02n0yk: /tmp/tmpjh02n0yk.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800403
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgej4uqrf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpgej4uqrf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp: In function 'int main()':\n\
    /tmp/tmpgej4uqrf.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgej4uqrf.cpp:2:\n/tmp/tmpgej4uqrf.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpgej4uqrf.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgej4uqrf.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgej4uqrf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4owi_ukp: /tmp/tmp4owi_ukp.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    if (max_weight == w) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpyrhp417e: /tmp/tmpyrhp417e.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    long max = 0;\n\
    \    for (long i = 0; i < q.size(); i++) {\n        if (q[i] > max) {\n      \
    \      max = q[i];\n        }\n    }\n    if (sum == max) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjfwaa20n: /tmp/tmpjfwaa20n.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800403
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (long i : q) {\n        max_sum = std::max(max_sum, i);\n    }\n    bool is_balanced\
    \ = max_sum == w;\n    long sum = 0;\n    for (long i : q) {\n        sum += i;\n\
    \    }\n    return is_balanced && sum <= w;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpm1gkjd_j: /tmp/tmpm1gkjd_j.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800403
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwdy2fjpa: /tmp/tmpwdy2fjpa.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum, i);\n\
    \    }\n    return max_sum == sum;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp4jv3pdgw: /tmp/tmp4jv3pdgw.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    if (max_sum == w) return\
    \ true;\n    long sum = 0;\n    for (long i : q) {\n        sum += i;\n      \
    \  if (sum > w) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1r51_pnx: /tmp/tmp1r51_pnx.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    long n = q.size();\n    long mid = n / 2;\n    long left\
    \ = q[mid];\n    long right = q[n - 1];\n    while (left < right) {\n        sum\
    \ += left;\n        sum += right;\n        left += q[mid];\n        right -= q[mid];\n\
    \        mid = n / 2;\n        left = q[mid];\n        right = q[n - 1];\n   \
    \ }\n    if (sum < max_weight) {\n        return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659800409
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // code here\n    long sum\
    \ = 0;\n    long max_weight = w;\n    for(long i = 0; i < q.size(); i++) {\n \
    \       sum += q[i];\n        if(sum > max_weight) {\n            max_weight =\
    \ sum;\n        }\n    }\n    return max_weight == w && sum == 0;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6oo3os7y: /tmp/tmp6oo3os7y.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ < w) {\n        return false;\n    }\n    long sum = 0;\n    for (long i = 0;\
    \ i < q.size(); i++) {\n        sum += q[i];\n        if (sum < w) {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\nint main() {\n   \
    \ auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpen50qhog: /tmp/tmpen50qhog.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (auto i : q) {\n        sum += i;\n        if (sum\
    \ > max_sum) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpnsrzrw9k: /tmp/tmpnsrzrw9k.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    if (max_sum < w) return false;\n    long sum = 0;\n    for\
    \ (long i : q) {\n        sum += i;\n        if (sum > w) return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcsbu5z8a: /tmp/tmpcsbu5z8a.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++17\n\
    \    long max_sum = 0;\n    long sum = 0;\n    for(auto i : q) {\n        sum\
    \ += i;\n        max_sum = std::max(max_sum, sum);\n    }\n    return max_sum\
    \ <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmphnr67jt4: /tmp/tmphnr67jt4.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (auto i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpjuiy37rv: /tmp/tmpjuiy37rv.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for(auto i : q) {\n        sum += i;\n        if(sum > max_weight)\
    \ {\n            max_weight = sum;\n        }\n    }\n    return max_weight ==\
    \ w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800404
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpaeq_xgxl: /tmp/tmpaeq_xgxl.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    return max_sum == w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6wodek7j: /tmp/tmp6wodek7j.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max_weight\
    \ = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    \
    \    if (sum > max_weight) {\n            max_weight = sum;\n        }\n    }\n\
    \    if (max_weight == 0) {\n        return false;\n    }\n    if (max_weight\
    \ < w) {\n        return false;\n    }\n    long mid = max_weight / 2;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        if (q[i] < mid) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpvp_p39xl: /tmp/tmpvp_p39xl.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0);\n    return max_sum < w && is_palindromic(q, max_sum);\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpygeh7svu.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpygeh7svu.cpp:20:27: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   20 |     return max_sum < w && is_palindromic(q,\
    \ max_sum);\n      |                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659800401
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmptu_3c6do: /tmp/tmptu_3c6do.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (auto i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwdy2fjpa: /tmp/tmpwdy2fjpa.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    long max_weight\
    \ = 0;\n    for (long i : q) {\n        sum += i;\n        max_weight = std::max(max_weight,\
    \ i);\n    }\n    if (sum < w) return false;\n    if (sum == w) return true;\n\
    \    if (sum > w) return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpluboueqk: /tmp/tmpluboueqk.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    bool isBalanced = true;\n    for (auto i : q) {\n       \
    \ sum += i;\n        if (sum > maxWeight) {\n            isBalanced = false;\n\
    \            break;\n        }\n    }\n    if (isBalanced) {\n        long sumOfElements\
    \ = 0;\n        for (auto i : q) {\n            sumOfElements += i;\n        }\n\
    \        if (sumOfElements <= maxWeight) {\n            return true;\n       \
    \ }\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpb3i4awrz: /tmp/tmpb3i4awrz.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    bool flag = false;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > max_weight) {\n            flag =\
    \ true;\n            break;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp5w410wy4: /tmp/tmp5w410wy4.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_weight = 0;\n    for (long i : q) {\n        max_weight =\
    \ max(max_weight, i);\n    }\n    if (max_weight == 0) {\n        return true;\n\
    \    }\n    long max_weight_index = q.size() - 1;\n    for (long i : q) {\n  \
    \      if (max_weight - i < 0) {\n            return false;\n        }\n     \
    \   max_weight_index--;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkkjy0flv.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpkkjy0flv.cpp:28:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   28 |    \
    \     max_weight = max(max_weight, i);\n      |                      ^~~\n   \
    \   |                      std::max\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkkjy0flv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > max_weight) {\n            max_weight = sum;\n        }\n \
    \   }\n    if (max_weight == 0) {\n        return true;\n    }\n    if (max_weight\
    \ < q.size()) {\n        return false;\n    }\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        long sum = q[i];\n        for (long\
    \ j = i + 1; j < q.size(); j++) {\n            sum += q[j];\n            if (sum\
    \ > max_sum) {\n                max_sum = sum;\n            }\n        }\n   \
    \ }\n    return max_sum == max_weight;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqn77aq9t: /tmp/tmpqn77aq9t.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        if (i > max_sum) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgej4uqrf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpgej4uqrf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpgej4uqrf.cpp: In function 'int main()':\n\
    /tmp/tmpgej4uqrf.cpp:31:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgej4uqrf.cpp:2:\n/tmp/tmpgej4uqrf.cpp:32:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpgej4uqrf.cpp:32:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpgej4uqrf.cpp:32:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgej4uqrf.cpp:32:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgej4uqrf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(long\
    \ i : q) {\n        sum += i;\n    }\n    if(sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for(long i : q) {\n        if(i > max_sum) return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpj4ncapcd: /tmp/tmpj4ncapcd.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    long n = q.size();\n    long mid = n / 2;\n    long left\
    \ = q[mid];\n    long right = q[n - 1];\n    while (left != right) {\n       \
    \ sum += left;\n        sum += right;\n        if (sum > maxWeight) {\n      \
    \      maxWeight = sum;\n        }\n        mid = (mid + n) / 2;\n        left\
    \ = q[mid];\n        right = q[n - 1];\n    }\n    if (sum == maxWeight) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpx1f5k95u: /tmp/tmpx1f5k95u.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800405
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    for (long i : q) {\n        sum += i;\n\
    \        if (sum > max_sum) {\n            return false;\n        }\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpbcgez9_2: /tmp/tmpbcgez9_2.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800405
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i : q) {\n        sum += i;\n    }\n    if(sum < w) return\
    \ false;\n    long max = 0;\n    for(long i : q) {\n        if(i > max) max =\
    \ i;\n    }\n    if(sum == max) return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpn487f0b6: /tmp/tmpn487f0b6.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800405
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        sum += q[i];\n        if (sum > max_sum) {\n            max_sum =\
    \ sum;\n            max_weight = w;\n        }\n    }\n    if (max_sum == sum\
    \ && max_weight <= w) {\n        return true;\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp33xg32jy: /tmp/tmp33xg32jy.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800405
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum\
    \ += q[i];\n    }\n    if (max_sum < w) {\n        return false;\n    }\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > w) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp0bcufcx5: /tmp/tmp0bcufcx5.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800405
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (long i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (max_sum == w) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7ly5hltk: /tmp/tmp7ly5hltk.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    long min_sum = sum + w;\n    long mid\
    \ = max_sum / 2;\n    long left_sum = max_sum - mid;\n    long right_sum = min_sum\
    \ - mid;\n    if (left_sum < right_sum) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpf2ba1y0k: /tmp/tmpf2ba1y0k.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long max_sum = 0;\n    long sum = 0;\n    for (long i : q) {\n        sum\
    \ += i;\n        max_sum = std::max(max_sum, sum);\n    }\n    return max_sum\
    \ <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpbvihfj1y: /tmp/tmpbvihfj1y.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    long min_sum = sum + w;\n    long mid\
    \ = max_sum / 2;\n    long left_sum = max_sum - mid;\n    long right_sum = min_sum\
    \ - mid;\n    if (left_sum > right_sum) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpgo1kgyhd: /tmp/tmpgo1kgyhd.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_weight = w;\n    for (long i : q) {\n        max_weight =\
    \ std::max(max_weight, i);\n    }\n    long min_weight = w;\n    for (long i :\
    \ q) {\n        min_weight = std::min(min_weight, i);\n    }\n    if (max_weight\
    \ == min_weight) {\n        return true;\n    }\n    long mid = (max_weight +\
    \ min_weight) / 2;\n    if (will_it_fly(q, mid)) {\n        return true;\n   \
    \ }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpx30qh6f7: /tmp/tmpx30qh6f7.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = sum - w;\n    long max_weight = 0;\n    for (long i\
    \ : q) {\n        max_weight = std::max(max_weight, i);\n    }\n    if (max_sum\
    \ < max_weight) {\n        return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpfn_1qwms: /tmp/tmpfn_1qwms.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum < w) return\
    \ false;\n    long max_sum = sum - w;\n    for (long i = 0; i < q.size(); i++)\
    \ {\n        if (q[i] > max_sum) return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4z4mjkhh: /tmp/tmp4z4mjkhh.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8o2qasfi.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp8o2qasfi.cpp:21:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp8o2qasfi.cpp:\
    \ In function 'int main()':\n/tmp/tmp8o2qasfi.cpp:33:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8o2qasfi.cpp:2:\n/tmp/tmp8o2qasfi.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp8o2qasfi.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8o2qasfi.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8o2qasfi.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file inc"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for(long i : q) {\n        sum += i;\n    }\n    if(sum < w) return\
    \ false;\n    long max = 0;\n    for(long i : q) {\n        if(i > max) max =\
    \ i;\n    }\n    if(sum == max) return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpn487f0b6: /tmp/tmpn487f0b6.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800405
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) {\n        return false;\n\
    \    }\n    long max_sum = w;\n    for (auto i : q) {\n        max_sum = std::max(max_sum,\
    \ i);\n    }\n    if (sum > max_sum) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpv5ax3dgn: /tmp/tmpv5ax3dgn.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (auto i : q) {\n        sum += i;\n        if (sum\
    \ > max_sum) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpnsrzrw9k: /tmp/tmpnsrzrw9k.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800404
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    if (max_weight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8o2qasfi.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmp8o2qasfi.cpp:21:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmp8o2qasfi.cpp:\
    \ In function 'int main()':\n/tmp/tmp8o2qasfi.cpp:33:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = will_it_fly;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8o2qasfi.cpp:2:\n/tmp/tmp8o2qasfi.cpp:34:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmp8o2qasfi.cpp:34:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp8o2qasfi.cpp:34:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp8o2qasfi.cpp:34:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8o2qasfi.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file inc"
  stdout: ''
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ max_weight) {\n            max_weight = sum;\n        }\n    }\n    return max_weight\
    \ == w && std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800397
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    long sum = 0;\n    long max_weight = 0;\n    for (auto i : q) {\n       \
    \ sum += i;\n        max_weight = std::max(max_weight, i);\n    }\n    if (sum\
    \ < max_weight) {\n        return false;\n    }\n    long max_sum = 0;\n    for\
    \ (auto i : q) {\n        max_sum += i;\n    }\n    if (max_sum == max_weight)\
    \ {\n        return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpmy0d4iyo: /tmp/tmpmy0d4iyo.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long max_sum = sum - w;\n    for (long\
    \ i : q) {\n        if (i > max_sum) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp2eta3hkw: /tmp/tmp2eta3hkw.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = sum - w;\n    for (long i : q) {\n        sum += i;\n        if (sum\
    \ > max_sum) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt_j78brf.cpp: In function 'bool will_it_fly(std::vector<long int>,\
    \ long int)':\n/tmp/tmpt_j78brf.cpp:20:19: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (long i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp:25:19:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (long\
    \ i : q) {\n                   ^\n/tmp/tmpt_j78brf.cpp: In function 'int main()':\n\
    /tmp/tmpt_j78brf.cpp:32:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = will_it_fly;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt_j78brf.cpp:2:\n/tmp/tmpt_j78brf.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n                                        ^\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9)) == (true));\n                                             \
    \                       ^\n/tmp/tmpt_j78brf.cpp:33:68: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpt_j78brf.cpp:33:68: error: no matching function for call to 'std::vector<long\
    \ int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpt_j78brf.cpp:33:68:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpt_j78brf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator _"
  stdout: ''
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum > max_sum)\
    \ {\n            max_sum = sum;\n        }\n    }\n    if (max_sum == w) {\n \
    \       return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpuktz_sag: /tmp/tmpuktz_sag.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (sum < w) return false;\n    long\
    \ max_sum = 0;\n    for (long i : q) {\n        max_sum += i;\n    }\n    return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpaeq_xgxl: /tmp/tmpaeq_xgxl.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800394
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum < w)\
    \ {\n        return false;\n    }\n    long max_sum = w;\n    for (long i : q)\
    \ {\n        max_sum = std::max(max_sum, i);\n    }\n    if (max_sum < w) {\n\
    \        return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcuydcbv3: /tmp/tmpcuydcbv3.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (long i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) {\n            maxWeight = sum;\n        }\n    }\n    if (maxWeight\
    \ == w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqb4zo0_o: /tmp/tmpqb4zo0_o.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long max_sum = sum - w;\n    for (long\
    \ i : q) {\n        sum += i;\n        if (sum > max_sum) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpnb_mkt3j: /tmp/tmpnb_mkt3j.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ max_sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        max_sum +=\
    \ q[i];\n    }\n    if (max_sum < w) {\n        return false;\n    }\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum > w) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpdiuqnz51: /tmp/tmpdiuqnz51.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns True if the object q will fly, and False otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++17\n\
    \    long sum = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    if (sum\
    \ < w) {\n        return false;\n    }\n    long maxSum = w;\n    for (auto i\
    \ : q) {\n        maxSum = std::max(maxSum, i);\n    }\n    return maxSum == w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpx9p_rkdj: /tmp/tmpx9p_rkdj.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1659800406
