name: HumanEval_20_find_closest_elements
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied list of numbers\
  \ (of length at least two) select and return two that are the closest to each\n\
  // other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0, (float)2.2})))\n// (std::make_tuple(2.0,\
  \ 2.2))\n// >>> find_closest_elements((std::vector<float>({(float)1.0, (float)2.0,\
  \ (float)3.0, (float)4.0, (float)5.0, (float)2.0})))\n// (std::make_tuple(2.0, 2.0))\n\
  std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n"
tests: "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.9, (float)4.0, (float)5.0, (float)2.2}))) == (std::make_tuple(3.9,\
  \ 4.0)));\n    assert(candidate((std::vector<float>({(float)1.0, (float)2.0, (float)5.9,\
  \ (float)4.0, (float)5.0}))) == (std::make_tuple(5.0, 5.9)));\n    assert(candidate((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0, (float)2.2}))) == (std::make_tuple(2.0,\
  \ 2.2)));\n    assert(candidate((std::vector<float>({(float)1.0, (float)2.0, (float)3.0,\
  \ (float)4.0, (float)5.0, (float)2.0}))) == (std::make_tuple(2.0, 2.0)));\n    assert(candidate((std::vector<float>({(float)1.1,\
  \ (float)2.2, (float)3.1, (float)4.1, (float)5.1}))) == (std::make_tuple(2.2, 3.1)));\n\
  }\n"
completions: ["    float smallest_difference = std::numeric_limits<float>::max();\n\
    \    float largest_difference = std::numeric_limits<float>::min();\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (float number : numbers) {\n        float difference = std::abs(number - smallest_number);\n\
    \        if (difference < smallest_difference) {\n            smallest_difference\
    \ = difference;\n            smallest_number = number;\n        }\n        difference\
    \ = std::abs(number - largest_number);\n        if (difference > largest_difference)\
    \ {\n            largest_difference = difference;\n            largest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest_number) {\n\
    \            smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest_number = numbers[0];\n    float largest_number\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest_number)\
    \ {\n            smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest_number = numbers[0];\n    float largest_number\
    \ = numbers[0];\n    for (auto number : numbers) {\n        if (number < smallest_number)\
    \ {\n            smallest_number = number;\n        } else if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    // Find the two closest numbers to each other\n    float\
    \ smallest_distance = std::numeric_limits<float>::max();\n    float second_smallest_distance\
    \ = std::numeric_limits<float>::max();\n    for (float number : numbers) {\n \
    \       float distance = std::abs(number - second_smallest_distance);\n      \
    \  if (distance < smallest_distance) {\n            second_smallest_distance =\
    \ smallest_distance;\n            smallest_distance = distance;\n        }\n \
    \   }\n    // Return the two closest numbers in order\n    return std::make_tuple(smallest_distance,\
    \ second_smallest_distance);", "    assert(numbers.size() > 1);\n    float smallest_distance\
    \ = std::numeric_limits<float>::max();\n    float largest_distance = std::numeric_limits<float>::min();\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); ++i) {\n        float distance = std::abs(numbers[i]\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = numbers[i];\n\
    \        }\n        distance = std::abs(numbers[i] - largest_number);\n      \
    \  if (distance > largest_distance) {\n            largest_distance = distance;\n\
    \            largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        } else if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        } else if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() >= 2);\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < smallest_number) {\n            smallest_number\
    \ = numbers[i];\n        }\n        if (numbers[i] > largest_number) {\n     \
    \       largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    // Sort numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Find two numbers that are closest to each other\n  \
    \  float closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < closest_1) {\n            closest_1\
    \ = number;\n        } else if (number > closest_2) {\n            closest_2 =\
    \ number;\n        }\n    }\n    // Return two closest numbers\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    assert(numbers.size() > 1);\n    float smallest_distance\
    \ = std::numeric_limits<float>::max();\n    float largest_distance = std::numeric_limits<float>::min();\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        float distance = std::abs(numbers[i]\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = numbers[i];\n\
    \        }\n        distance = std::abs(numbers[i] - largest_number);\n      \
    \  if (distance > largest_distance) {\n            largest_distance = distance;\n\
    \            largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() >= 2);\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (auto number\
    \ : numbers) {\n        if (number < smallest_number) {\n            smallest_number\
    \ = number;\n        }\n        if (number > largest_number) {\n            largest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    float smallest_number = sorted_numbers[0];\n   \
    \ float largest_number = sorted_numbers[0];\n    for (size_t i = 1; i < sorted_numbers.size();\
    \ ++i) {\n        if (sorted_numbers[i] < smallest_number) {\n            smallest_number\
    \ = sorted_numbers[i];\n        }\n        if (sorted_numbers[i] > largest_number)\
    \ {\n            largest_number = sorted_numbers[i];\n        }\n    }\n    return\
    \ std::make_tuple(smallest_number, largest_number);", "    assert(numbers.size()\
    \ > 1);\n    float smallest_distance = std::numeric_limits<float>::max();\n  \
    \  float largest_distance = std::numeric_limits<float>::min();\n    for (auto\
    \ number : numbers) {\n        float distance = std::abs(number - numbers[0]);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n        }\n        if (distance > largest_distance) {\n         \
    \   largest_distance = distance;\n        }\n    }\n    return std::make_tuple(smallest_distance,\
    \ largest_distance);", "    // Sort the numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n\n    // Find the two closest numbers to the first number\n\
    \    auto first_number = numbers[0];\n    auto second_number = numbers[0];\n \
    \   auto first_difference = std::abs(numbers[0] - numbers[1]);\n    auto second_difference\
    \ = std::abs(numbers[0] - numbers[2]);\n    if (first_difference < second_difference)\
    \ {\n        second_number = numbers[1];\n        second_difference = std::abs(numbers[1]\
    \ - numbers[2]);\n    } else {\n        first_number = numbers[2];\n        first_difference\
    \ = std::abs(numbers[2] - numbers[1]);\n    }\n\n    // Return the two closest\
    \ numbers\n    return std::make_tuple(first_number, second_number);", "    assert(numbers.size()\
    \ >= 2);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (auto number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        } else if (number > largest) {\n           \
    \ largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    float closest_to_one = sorted_numbers[0];\n    float\
    \ closest_to_two = sorted_numbers[1];\n    if (sorted_numbers.size() == 2) {\n\
    \        return std::make_tuple(closest_to_one, closest_to_two);\n    }\n    float\
    \ closest_to_three = sorted_numbers[2];\n    float closest_to_four = sorted_numbers[3];\n\
    \    float closest_to_five = sorted_numbers[4];\n    float closest_to_six = sorted_numbers[5];\n\
    \    float closest_to_seven = sorted_numbers[6];\n    float closest_to_eight =\
    \ sorted_numbers[7];\n    float closest_to_nine = sorted_numbers[8];\n    float\
    \ closest_to_ten = sorted_numbers[9];\n    float closest_to_eleven = sorted_numbers[10];\n\
    \    float closest_to_twelve = sorted_numbers[11];\n    float closest_to_thirteen\
    \ = sorted_numbers[12];\n    float closest_to_fourteen = sorted_numbers[13];\n\
    \    float closest_to_fifteen = sorted_numbers[14];\n    float closest_to_sixteen\
    \ = sorted_numbers[15];\n    float closest_to_seventeen = sorted_numbers[16];\n\
    \    float closest_to_eighteen = sorted_numbers[17];\n    float closest_to_nineteen\
    \ = sorted_numbers[18];\n    float closest_to_twenty = sorted_numbers[19];\n \
    \   float closest_to_twenty_one = sorted_numbers[20];\n    float closest_to_twenty_two\
    \ = sorted_numbers[21];\n    float closest_to_twenty_three = sorted_numbers[22];\n\
    \    float closest_to_twenty_four = sorted_numbers[23];\n    float closest_to_twenty_five\
    \ = sorted_numbers[24];\n    float closest_to_twenty_six = sorted_numbers[25];\n\
    \    float closest_to_twenty_seven = sorted_numbers[26];\n    float closest_to_twenty_eight\
    \ = sorted_numbers[27];\n    float closest_to_twenty_nine = sorted_numbers[28];\n\
    \    float closest_to_twenty_ten = sorted_numbers[29];\n    float closest_to_twenty_eleven\
    \ = sorted_numbers[30];\n    float closest_to_twenty_twelve = sorted_numbers[31];\n\
    \    float closest_to_twenty_thirteen = sorted_numbers[32];\n    float closest_to_twenty_fourteen\
    \ = sorted_numbers[33", "    // Sort numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Find the two numbers that are closest to each other\n\
    \    float closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for\
    \ (float number : numbers) {\n        if (number < closest_1) {\n            closest_1\
    \ = number;\n        } else if (number > closest_2) {\n            closest_2 =\
    \ number;\n        }\n    }\n    // Return the two closest numbers\n    return\
    \ std::make_tuple(closest_1, closest_2);", "    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (auto\
    \ number : numbers) {\n        float distance = std::abs(number - std::numeric_limits<float>::max());\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n        }\n        if (distance > largest_distance) {\n         \
    \   largest_distance = distance;\n        }\n    }\n    return std::make_tuple(smallest_distance,\
    \ largest_distance);", "    assert(numbers.size() >= 2);\n    float smallest =\
    \ numbers[0];\n    float largest = numbers[0];\n    for (float number : numbers)\
    \ {\n        if (number < smallest) {\n            smallest = number;\n      \
    \  } else if (number > largest) {\n            largest = number;\n        }\n\
    \    }\n    return std::make_tuple(smallest, largest);"]
stop_tokens:
- "\n}"
