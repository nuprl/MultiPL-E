language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string curr_level;\n\
    \    long curr_depth = 0;\n    for (size_t i = 0; i < paren_string.size(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            curr_level = paren_string.substr(0,\
    \ i);\n            curr_depth++;\n        } else if (paren_string[i] == ')') {\n\
    \            curr_depth--;\n            if (curr_depth == 0) {\n             \
    \   levels.push_back(curr_level.length());\n            }\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprxku4fh3.cpp: In function 'int main()':\n/tmp/tmprxku4fh3.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprxku4fh3.cpp:2:\n/tmp/tmprxku4fh3.cpp:27:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmprxku4fh3.cpp:27:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmprxku4fh3.cpp:27:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmprxku4fh3.cpp:27:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprxku4fh3.cpp:27:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmprxku4fh3.cpp:27:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmprxku4fh3.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n            assert(paren_level\
    \ >= 0);\n            paren_levels.push_back(paren_level);\n        } else {\n\
    \            assert(paren_level == 0);\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpusyugi31.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpusyugi31.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpusyugi31.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpusyugi31.cpp:25:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpusyugi31.cpp:25:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpusyugi31.cpp:25:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpusyugi31.cpp:25:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpusyugi31.cpp: In function 'int main()':\n/tmp/tmpusyugi31.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpusyugi31.cpp:2:\n/tmp/tmpusyugi31.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpusyugi31.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpusyugi31.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpusyugi31.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpusyugi31.cpp:29:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnbik9p63.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpnbik9p63.cpp:12:16: error: ISO C++ forbids declaration of 'c' with no\
    \ type [-fpermissive]\n     for (auto &c : paren_string) {\n                ^\n\
    /tmp/tmpnbik9p63.cpp:12:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &c : paren_string) {\n                    ^\n/tmp/tmpnbik9p63.cpp:\
    \ In function 'int main()':\n/tmp/tmpnbik9p63.cpp:24:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpnbik9p63.cpp:2:\n/tmp/tmpnbik9p63.cpp:25:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpnbik9p63.cpp:25:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpnbik9p63.cpp:25:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpnbik9p63.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnbik9p63.cpp:25:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnbik9p63.cpp:25:113: note: candidates are:\nIn file included from /usr/includ"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n            assert(level >= 0);\n\
    \            paren_levels.push_back(level);\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprl6w3pks.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmprl6w3pks.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmprl6w3pks.cpp:22:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmprl6w3pks.cpp:22:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmprl6w3pks.cpp:22:5:\
    \ error: expected ';' before 'return'\n/tmp/tmprl6w3pks.cpp:22:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmprl6w3pks.cpp:22:5: error: expected\
    \ ')' before 'return'\n/tmp/tmprl6w3pks.cpp: In function 'int main()':\n/tmp/tmprl6w3pks.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprl6w3pks.cpp:2:\n/tmp/tmprl6w3pks.cpp:26:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmprl6w3pks.cpp:26:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmprl6w3pks.cpp:26:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmprl6w3pks.cpp:26:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprl6w3pks.cpp:26:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3c9y6xcr.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp3c9y6xcr.cpp:12:13: error: 'c' does not name a type\n   for (auto c :\
    \ paren_string) {\n             ^\n/tmp/tmp3c9y6xcr.cpp:20:3: error: expected\
    \ ';' before 'return'\n   return paren_levels;\n   ^\n/tmp/tmp3c9y6xcr.cpp:20:3:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp3c9y6xcr.cpp:20:3:\
    \ error: expected ';' before 'return'\n/tmp/tmp3c9y6xcr.cpp:20:3: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp3c9y6xcr.cpp:20:3: error: expected\
    \ ')' before 'return'\n/tmp/tmp3c9y6xcr.cpp: In function 'int main()':\n/tmp/tmp3c9y6xcr.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3c9y6xcr.cpp:2:\n/tmp/tmp3c9y6xcr.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp3c9y6xcr.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp3c9y6xcr.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp3c9y6xcr.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3c9y6xcr.cpp:24:113: error: n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n        } else if (c == ')') {\n            is_open = false;\n\
    \        } else if (is_open) {\n            paren_levels.push_back(level);\n \
    \           level++;\n        }\n    }\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjw1ogtus.cpp: In function 'int main()':\n/tmp/tmpjw1ogtus.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjw1ogtus.cpp:2:\n/tmp/tmpjw1ogtus.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpjw1ogtus.cpp:28:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpjw1ogtus.cpp:28:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpjw1ogtus.cpp:28:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpjw1ogtus.cpp:28:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpjw1ogtus.cpp:28:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpjw1ogtus.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.push_back(0);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpts604e87.cpp: In function 'int main()':\n/tmp/tmpts604e87.cpp:85:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpts604e87.cpp:2:\n/tmp/tmpts604e87.cpp:86:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpts604e87.cpp:86:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpts604e87.cpp:86:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpts604e87.cpp:86:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpts604e87.cpp:86:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpts604e87.cpp:86:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpts604e87.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of('(')).split(' ');\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(paren_levels.size());\n    long paren_levels_size\
    \ = paren_levels_temp.size();\n    long paren_levels_index = 0;\n    long paren_levels_index_temp\
    \ = 0;\n    long paren_levels_index_temp2 = 0;\n    long paren_levels_index_temp3\
    \ = 0;\n    long paren_levels_index_temp4 = 0;\n    long paren_levels_index_temp5\
    \ = 0;\n    long paren_levels_index_temp6 = 0;\n    long paren_levels_index_temp7\
    \ = 0;\n    long paren_levels_index_temp8 = 0;\n    long paren_levels_index_temp9\
    \ = 0;\n    long paren_levels_index_temp10 = 0;\n    long paren_levels_index_temp11\
    \ = 0;\n    long paren_levels_index_temp12 = 0;\n    long paren_levels_index_temp13\
    \ = 0;\n    long paren_levels_index_temp14 = 0;\n    long paren_levels_index_temp15\
    \ = 0;\n    long paren_levels_index_temp16 = 0;\n    long paren_levels_index_temp17\
    \ = 0;\n    long paren_levels_index_temp18 = 0;\n    long paren_levels_index_temp19\
    \ = 0;\n    long paren_levels_index_temp20 = 0;\n    long paren_levels_index_temp21\
    \ = 0;\n    long paren_levels_index_temp22 = 0;\n    long paren_levels_index_temp23\
    \ = 0;\n    long paren_levels_index_temp24 = 0;\n    long paren_levels_index_temp25\
    \ = 0;\n    long paren_levels_index_temp26 = 0;\n    long paren_levels_index_temp27\
    \ = 0;\n    long paren_levels_index_temp28 = 0;\n    long paren_levels_index_temp29\
    \ = 0;\n    long paren_levels_index_temp30 = 0;\n    long paren_levels_index_temp31\
    \ = 0;\n    long paren_levels_index_temp32 = 0;\n    long paren_levels_index_temp33\
    \ = 0;\n    long paren_levels_index_temp34 = 0;\n    long paren_levels_index_temp35\
    \ = 0;\n    long paren_levels_index_temp36 = 0;\n    long paren_levels_index_temp37\
    \ = 0;\n    long paren_levels_index_temp38 = 0;\n    long paren_levels_index_temp39\
    \ = 0;\n    long paren_levels_index_temp\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmplnuq9ffm.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmplnuq9ffm.cpp:10:76: error: 'class std::basic_string<char>' has no member\
    \ named 'split'\n     paren_levels = paren_string.substr(0, paren_string.find_first_of('(')).split('\
    \ ');\n                                                                      \
    \      ^\n/tmp/tmplnuq9ffm.cpp:55:1: error: expected initializer before '}' token\n\
    \ }\n ^\n/tmp/tmplnuq9ffm.cpp: In function 'int main()':\n/tmp/tmplnuq9ffm.cpp:57:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplnuq9ffm.cpp:2:\n/tmp/tmplnuq9ffm.cpp:58:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmplnuq9ffm.cpp:58:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmplnuq9ffm.cpp:58:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmplnuq9ffm.cpp:58:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmplnuq9ffm.cpp:58:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmplnuq9ffm.cpp:58:113:\
    \ note: candidate"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long paren_level =\
    \ 0;\n    bool is_open = false;\n    std::string current_paren_string = \"\";\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            current_paren_string = c;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            current_paren_string\
    \ = \"\";\n            paren_level--;\n        } else if (is_open) {\n       \
    \     current_paren_string = current_paren_string + c;\n        }\n    }\n   \
    \ paren_levels[paren_level - 1]++;\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0tjrnftb.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp0tjrnftb.cpp:13:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp0tjrnftb.cpp:26:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels[paren_level - 1]++;\n     ^\n/tmp/tmp0tjrnftb.cpp:27:5:\
    \ error: expected primary-expression before 'return'\n     return paren_levels;\n\
    \     ^\n/tmp/tmp0tjrnftb.cpp:27:5: error: expected ')' before 'return'\n/tmp/tmp0tjrnftb.cpp:\
    \ In function 'int main()':\n/tmp/tmp0tjrnftb.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp0tjrnftb.cpp:2:\n/tmp/tmp0tjrnftb.cpp:31:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp0tjrnftb.cpp:31:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp0tjrnftb.cpp:31:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp0tjrnftb.cpp:31:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0tjrnftb.cpp:31:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed ini"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            paren_level = paren_string.substr(0,\
    \ i);\n            level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          level--;\n            if (level == 0) {\n                levels.push_back(level);\n\
    \            }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp8addjlub.cpp: In function 'int main()':\n/tmp/tmp8addjlub.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8addjlub.cpp:2:\n/tmp/tmp8addjlub.cpp:27:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp8addjlub.cpp:27:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp8addjlub.cpp:27:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp8addjlub.cpp:27:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp8addjlub.cpp:27:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp8addjlub.cpp:27:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8addjlub.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        char c = paren_string[i];\n\
    \        if (c == '(') {\n            is_open = true;\n        } else if (c ==\
    \ ')') {\n            is_closed = true;\n        } else if (c == ' ') {\n    \
    \        if (is_open && !is_closed) {\n                paren_levels.push_back(level);\n\
    \                is_open = false;\n                is_closed = false;\n      \
    \          level++;\n            }\n        } else {\n            is_open = false;\n\
    \            is_closed = false;\n        }\n    }\n    if (is_open && !is_closed)\
    \ {\n        paren_levels.push_back(level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgdas6208.cpp: In function 'int main()':\n/tmp/tmpgdas6208.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgdas6208.cpp:2:\n/tmp/tmpgdas6208.cpp:39:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpgdas6208.cpp:39:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpgdas6208.cpp:39:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpgdas6208.cpp:39:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpgdas6208.cpp:39:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgdas6208.cpp:39:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgdas6208.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  long level = 0;\n  std::string\
    \ current_paren = \"\";\n  for (size_t i = 0; i < paren_string.size(); ++i) {\n\
    \    if (paren_string[i] == '(') {\n      current_paren = paren_string[i];\n \
    \     ++level;\n    } else if (paren_string[i] == ')') {\n      --level;\n   \
    \   if (level == 0) {\n        result.push_back(std::stoll(current_paren));\n\
    \      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpb4_apgup.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpb4_apgup.cpp:19:26: error: 'stoll' is not a member of 'std'\n        \
    \ result.push_back(std::stoll(current_paren));\n                          ^\n\
    /tmp/tmpb4_apgup.cpp: In function 'int main()':\n/tmp/tmpb4_apgup.cpp:26:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb4_apgup.cpp:2:\n/tmp/tmpb4_apgup.cpp:27:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpb4_apgup.cpp:27:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpb4_apgup.cpp:27:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpb4_apgup.cpp:27:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpb4_apgup.cpp:27:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpb4_apgup.cpp:27:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3otylwz1.cpp: In function 'int main()':\n/tmp/tmp3otylwz1.cpp:84:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3otylwz1.cpp:2:\n/tmp/tmp3otylwz1.cpp:85:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp3otylwz1.cpp:85:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp3otylwz1.cpp:85:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3otylwz1.cpp:85:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp3otylwz1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (size_t i = 0;\
    \ i < paren_string.size(); i++) {\n        char c = paren_string[i];\n       \
    \ if (c == '(') {\n            is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_levels.pop_back();\n\
    \        } else if (is_open) {\n            paren_level++;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkrbc6aq6.cpp: In function 'int main()':\n/tmp/tmpkrbc6aq6.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkrbc6aq6.cpp:2:\n/tmp/tmpkrbc6aq6.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpkrbc6aq6.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpkrbc6aq6.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpkrbc6aq6.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpkrbc6aq6.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpkrbc6aq6.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpkrbc6aq6.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    long current_level_size = 0;\n    for (auto c : paren_string) {\n       \
    \ if (c == '(') {\n            current_level = current_level + c;\n          \
    \  current_level_size++;\n        } else if (c == ')') {\n            current_level\
    \ = current_level.substr(0, current_level.size() - 1);\n            current_level_size--;\n\
    \        } else {\n            current_level = current_level + c;\n        }\n\
    \        if (current_level_size > 0) {\n            levels.push_back(current_level_size);\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4yi_08l7.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp4yi_08l7.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp4yi_08l7.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return levels;\n     ^\n/tmp/tmp4yi_08l7.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp4yi_08l7.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp4yi_08l7.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp4yi_08l7.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp4yi_08l7.cpp: In function 'int main()':\n/tmp/tmp4yi_08l7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4yi_08l7.cpp:2:\n/tmp/tmp4yi_08l7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp4yi_08l7.cpp:30:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp4yi_08l7.cpp:30:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp4yi_08l7.cpp:30:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp4yi_08l7.cpp:30:113: error:"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels_t paren_levels_t;\n\
    \    paren_levels_t.clear();\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0pt7yh5_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp0pt7yh5_.cpp:10:5: error: 'paren_levels_t' was not declared in this scope\n\
    \     paren_levels_t paren_levels_t;\n     ^\n/tmp/tmp0pt7yh5_.cpp:10:20: error:\
    \ expected ';' before 'paren_levels_t'\n     paren_levels_t paren_levels_t;\n\
    \                    ^\n/tmp/tmp0pt7yh5_.cpp:12:30: error: 'paren_levels_t' is\
    \ not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:13:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:14:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:15:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:16:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:17:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:18:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:19:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:20:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:21:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:22:30: err"
  stdout: ''
