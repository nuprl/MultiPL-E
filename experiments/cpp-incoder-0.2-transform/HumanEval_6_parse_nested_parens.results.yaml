language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string curr_level;\n\
    \    long curr_depth = 0;\n    for (size_t i = 0; i < paren_string.size(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            curr_level = paren_string.substr(0,\
    \ i);\n            curr_depth++;\n        } else if (paren_string[i] == ')') {\n\
    \            curr_depth--;\n            if (curr_depth == 0) {\n             \
    \   levels.push_back(curr_level.length());\n            }\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprxku4fh3.cpp: In function 'int main()':\n/tmp/tmprxku4fh3.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprxku4fh3.cpp:2:\n/tmp/tmprxku4fh3.cpp:27:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmprxku4fh3.cpp:27:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmprxku4fh3.cpp:27:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmprxku4fh3.cpp:27:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprxku4fh3.cpp:27:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmprxku4fh3.cpp:27:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmprxku4fh3.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n            assert(paren_level\
    \ >= 0);\n            paren_levels.push_back(paren_level);\n        } else {\n\
    \            assert(paren_level == 0);\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpusyugi31.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpusyugi31.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpusyugi31.cpp:25:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpusyugi31.cpp:25:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpusyugi31.cpp:25:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpusyugi31.cpp:25:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpusyugi31.cpp:25:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpusyugi31.cpp: In function 'int main()':\n/tmp/tmpusyugi31.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpusyugi31.cpp:2:\n/tmp/tmpusyugi31.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpusyugi31.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpusyugi31.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpusyugi31.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpusyugi31.cpp:29:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnbik9p63.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpnbik9p63.cpp:12:16: error: ISO C++ forbids declaration of 'c' with no\
    \ type [-fpermissive]\n     for (auto &c : paren_string) {\n                ^\n\
    /tmp/tmpnbik9p63.cpp:12:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &c : paren_string) {\n                    ^\n/tmp/tmpnbik9p63.cpp:\
    \ In function 'int main()':\n/tmp/tmpnbik9p63.cpp:24:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpnbik9p63.cpp:2:\n/tmp/tmpnbik9p63.cpp:25:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpnbik9p63.cpp:25:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpnbik9p63.cpp:25:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpnbik9p63.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnbik9p63.cpp:25:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnbik9p63.cpp:25:113: note: candidates are:\nIn file included from /usr/includ"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n            assert(level >= 0);\n\
    \            paren_levels.push_back(level);\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprl6w3pks.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmprl6w3pks.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmprl6w3pks.cpp:22:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmprl6w3pks.cpp:22:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmprl6w3pks.cpp:22:5:\
    \ error: expected ';' before 'return'\n/tmp/tmprl6w3pks.cpp:22:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmprl6w3pks.cpp:22:5: error: expected\
    \ ')' before 'return'\n/tmp/tmprl6w3pks.cpp: In function 'int main()':\n/tmp/tmprl6w3pks.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprl6w3pks.cpp:2:\n/tmp/tmprl6w3pks.cpp:26:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmprl6w3pks.cpp:26:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmprl6w3pks.cpp:26:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmprl6w3pks.cpp:26:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmprl6w3pks.cpp:26:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3c9y6xcr.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp3c9y6xcr.cpp:12:13: error: 'c' does not name a type\n   for (auto c :\
    \ paren_string) {\n             ^\n/tmp/tmp3c9y6xcr.cpp:20:3: error: expected\
    \ ';' before 'return'\n   return paren_levels;\n   ^\n/tmp/tmp3c9y6xcr.cpp:20:3:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp3c9y6xcr.cpp:20:3:\
    \ error: expected ';' before 'return'\n/tmp/tmp3c9y6xcr.cpp:20:3: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp3c9y6xcr.cpp:20:3: error: expected\
    \ ')' before 'return'\n/tmp/tmp3c9y6xcr.cpp: In function 'int main()':\n/tmp/tmp3c9y6xcr.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3c9y6xcr.cpp:2:\n/tmp/tmp3c9y6xcr.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp3c9y6xcr.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp3c9y6xcr.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp3c9y6xcr.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3c9y6xcr.cpp:24:113: error: n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n        } else if (c == ')') {\n            is_open = false;\n\
    \        } else if (is_open) {\n            paren_levels.push_back(level);\n \
    \           level++;\n        }\n    }\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjw1ogtus.cpp: In function 'int main()':\n/tmp/tmpjw1ogtus.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjw1ogtus.cpp:2:\n/tmp/tmpjw1ogtus.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpjw1ogtus.cpp:28:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpjw1ogtus.cpp:28:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpjw1ogtus.cpp:28:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpjw1ogtus.cpp:28:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpjw1ogtus.cpp:28:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpjw1ogtus.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.push_back(0);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpts604e87.cpp: In function 'int main()':\n/tmp/tmpts604e87.cpp:85:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpts604e87.cpp:2:\n/tmp/tmpts604e87.cpp:86:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpts604e87.cpp:86:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpts604e87.cpp:86:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpts604e87.cpp:86:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpts604e87.cpp:86:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpts604e87.cpp:86:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpts604e87.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of('(')).split(' ');\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(paren_levels.size());\n    long paren_levels_size\
    \ = paren_levels_temp.size();\n    long paren_levels_index = 0;\n    long paren_levels_index_temp\
    \ = 0;\n    long paren_levels_index_temp2 = 0;\n    long paren_levels_index_temp3\
    \ = 0;\n    long paren_levels_index_temp4 = 0;\n    long paren_levels_index_temp5\
    \ = 0;\n    long paren_levels_index_temp6 = 0;\n    long paren_levels_index_temp7\
    \ = 0;\n    long paren_levels_index_temp8 = 0;\n    long paren_levels_index_temp9\
    \ = 0;\n    long paren_levels_index_temp10 = 0;\n    long paren_levels_index_temp11\
    \ = 0;\n    long paren_levels_index_temp12 = 0;\n    long paren_levels_index_temp13\
    \ = 0;\n    long paren_levels_index_temp14 = 0;\n    long paren_levels_index_temp15\
    \ = 0;\n    long paren_levels_index_temp16 = 0;\n    long paren_levels_index_temp17\
    \ = 0;\n    long paren_levels_index_temp18 = 0;\n    long paren_levels_index_temp19\
    \ = 0;\n    long paren_levels_index_temp20 = 0;\n    long paren_levels_index_temp21\
    \ = 0;\n    long paren_levels_index_temp22 = 0;\n    long paren_levels_index_temp23\
    \ = 0;\n    long paren_levels_index_temp24 = 0;\n    long paren_levels_index_temp25\
    \ = 0;\n    long paren_levels_index_temp26 = 0;\n    long paren_levels_index_temp27\
    \ = 0;\n    long paren_levels_index_temp28 = 0;\n    long paren_levels_index_temp29\
    \ = 0;\n    long paren_levels_index_temp30 = 0;\n    long paren_levels_index_temp31\
    \ = 0;\n    long paren_levels_index_temp32 = 0;\n    long paren_levels_index_temp33\
    \ = 0;\n    long paren_levels_index_temp34 = 0;\n    long paren_levels_index_temp35\
    \ = 0;\n    long paren_levels_index_temp36 = 0;\n    long paren_levels_index_temp37\
    \ = 0;\n    long paren_levels_index_temp38 = 0;\n    long paren_levels_index_temp39\
    \ = 0;\n    long paren_levels_index_temp\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmplnuq9ffm.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmplnuq9ffm.cpp:10:76: error: 'class std::basic_string<char>' has no member\
    \ named 'split'\n     paren_levels = paren_string.substr(0, paren_string.find_first_of('(')).split('\
    \ ');\n                                                                      \
    \      ^\n/tmp/tmplnuq9ffm.cpp:55:1: error: expected initializer before '}' token\n\
    \ }\n ^\n/tmp/tmplnuq9ffm.cpp: In function 'int main()':\n/tmp/tmplnuq9ffm.cpp:57:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplnuq9ffm.cpp:2:\n/tmp/tmplnuq9ffm.cpp:58:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmplnuq9ffm.cpp:58:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmplnuq9ffm.cpp:58:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmplnuq9ffm.cpp:58:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmplnuq9ffm.cpp:58:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmplnuq9ffm.cpp:58:113:\
    \ note: candidate"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long paren_level =\
    \ 0;\n    bool is_open = false;\n    std::string current_paren_string = \"\";\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            current_paren_string = c;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            current_paren_string\
    \ = \"\";\n            paren_level--;\n        } else if (is_open) {\n       \
    \     current_paren_string = current_paren_string + c;\n        }\n    }\n   \
    \ paren_levels[paren_level - 1]++;\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0tjrnftb.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp0tjrnftb.cpp:13:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp0tjrnftb.cpp:26:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels[paren_level - 1]++;\n     ^\n/tmp/tmp0tjrnftb.cpp:27:5:\
    \ error: expected primary-expression before 'return'\n     return paren_levels;\n\
    \     ^\n/tmp/tmp0tjrnftb.cpp:27:5: error: expected ')' before 'return'\n/tmp/tmp0tjrnftb.cpp:\
    \ In function 'int main()':\n/tmp/tmp0tjrnftb.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp0tjrnftb.cpp:2:\n/tmp/tmp0tjrnftb.cpp:31:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp0tjrnftb.cpp:31:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp0tjrnftb.cpp:31:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp0tjrnftb.cpp:31:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0tjrnftb.cpp:31:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed ini"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            paren_level = paren_string.substr(0,\
    \ i);\n            level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          level--;\n            if (level == 0) {\n                levels.push_back(level);\n\
    \            }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp8addjlub.cpp: In function 'int main()':\n/tmp/tmp8addjlub.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8addjlub.cpp:2:\n/tmp/tmp8addjlub.cpp:27:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp8addjlub.cpp:27:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp8addjlub.cpp:27:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp8addjlub.cpp:27:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp8addjlub.cpp:27:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp8addjlub.cpp:27:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8addjlub.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        char c = paren_string[i];\n\
    \        if (c == '(') {\n            is_open = true;\n        } else if (c ==\
    \ ')') {\n            is_closed = true;\n        } else if (c == ' ') {\n    \
    \        if (is_open && !is_closed) {\n                paren_levels.push_back(level);\n\
    \                is_open = false;\n                is_closed = false;\n      \
    \          level++;\n            }\n        } else {\n            is_open = false;\n\
    \            is_closed = false;\n        }\n    }\n    if (is_open && !is_closed)\
    \ {\n        paren_levels.push_back(level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgdas6208.cpp: In function 'int main()':\n/tmp/tmpgdas6208.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgdas6208.cpp:2:\n/tmp/tmpgdas6208.cpp:39:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpgdas6208.cpp:39:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpgdas6208.cpp:39:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpgdas6208.cpp:39:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpgdas6208.cpp:39:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpgdas6208.cpp:39:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgdas6208.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  long level = 0;\n  std::string\
    \ current_paren = \"\";\n  for (size_t i = 0; i < paren_string.size(); ++i) {\n\
    \    if (paren_string[i] == '(') {\n      current_paren = paren_string[i];\n \
    \     ++level;\n    } else if (paren_string[i] == ')') {\n      --level;\n   \
    \   if (level == 0) {\n        result.push_back(std::stoll(current_paren));\n\
    \      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpb4_apgup.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpb4_apgup.cpp:19:26: error: 'stoll' is not a member of 'std'\n        \
    \ result.push_back(std::stoll(current_paren));\n                          ^\n\
    /tmp/tmpb4_apgup.cpp: In function 'int main()':\n/tmp/tmpb4_apgup.cpp:26:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb4_apgup.cpp:2:\n/tmp/tmpb4_apgup.cpp:27:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpb4_apgup.cpp:27:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpb4_apgup.cpp:27:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpb4_apgup.cpp:27:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpb4_apgup.cpp:27:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpb4_apgup.cpp:27:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3otylwz1.cpp: In function 'int main()':\n/tmp/tmp3otylwz1.cpp:84:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3otylwz1.cpp:2:\n/tmp/tmp3otylwz1.cpp:85:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp3otylwz1.cpp:85:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp3otylwz1.cpp:85:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3otylwz1.cpp:85:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp3otylwz1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (size_t i = 0;\
    \ i < paren_string.size(); i++) {\n        char c = paren_string[i];\n       \
    \ if (c == '(') {\n            is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_levels.pop_back();\n\
    \        } else if (is_open) {\n            paren_level++;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkrbc6aq6.cpp: In function 'int main()':\n/tmp/tmpkrbc6aq6.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkrbc6aq6.cpp:2:\n/tmp/tmpkrbc6aq6.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpkrbc6aq6.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpkrbc6aq6.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpkrbc6aq6.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpkrbc6aq6.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpkrbc6aq6.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpkrbc6aq6.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    long current_level_size = 0;\n    for (auto c : paren_string) {\n       \
    \ if (c == '(') {\n            current_level = current_level + c;\n          \
    \  current_level_size++;\n        } else if (c == ')') {\n            current_level\
    \ = current_level.substr(0, current_level.size() - 1);\n            current_level_size--;\n\
    \        } else {\n            current_level = current_level + c;\n        }\n\
    \        if (current_level_size > 0) {\n            levels.push_back(current_level_size);\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4yi_08l7.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp4yi_08l7.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp4yi_08l7.cpp:26:5: error: expected\
    \ ';' before 'return'\n     return levels;\n     ^\n/tmp/tmp4yi_08l7.cpp:26:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp4yi_08l7.cpp:26:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp4yi_08l7.cpp:26:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp4yi_08l7.cpp:26:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp4yi_08l7.cpp: In function 'int main()':\n/tmp/tmp4yi_08l7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4yi_08l7.cpp:2:\n/tmp/tmp4yi_08l7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp4yi_08l7.cpp:30:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp4yi_08l7.cpp:30:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp4yi_08l7.cpp:30:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp4yi_08l7.cpp:30:113: error:"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels_t paren_levels_t;\n\
    \    paren_levels_t.clear();\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_levels_t.push_back(paren_levels_t::level0);\n\
    \    paren_levels_t.push_back(paren_levels_t::level0);\n    paren_\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0pt7yh5_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp0pt7yh5_.cpp:10:5: error: 'paren_levels_t' was not declared in this scope\n\
    \     paren_levels_t paren_levels_t;\n     ^\n/tmp/tmp0pt7yh5_.cpp:10:20: error:\
    \ expected ';' before 'paren_levels_t'\n     paren_levels_t paren_levels_t;\n\
    \                    ^\n/tmp/tmp0pt7yh5_.cpp:12:30: error: 'paren_levels_t' is\
    \ not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:13:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:14:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:15:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:16:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:17:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:18:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:19:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:20:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:21:30: error: 'paren_levels_t'\
    \ is not a class or namespace\n     paren_levels_t.push_back(paren_levels_t::level0);\n\
    \                              ^\n/tmp/tmp0pt7yh5_.cpp:22:30: err"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpechfbjd6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821954
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    std::string current_paren;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n            current_paren = \"\";\n        } else if (c\
    \ == ')') {\n            is_closed = true;\n            current_paren = \"\";\n\
    \        } else if (c == ' ') {\n            if (is_open && !is_closed) {\n  \
    \              paren_levels.push_back(level);\n            }\n            current_paren\
    \ = \"\";\n        } else {\n            current_paren += c;\n        }\n    }\n\
    \    if (is_open && !is_closed) {\n        paren_levels.push_back(level);\n  \
    \  }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsbxzsl5d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string current_paren_level;\n    for (auto &c : paren_string) {\n  \
    \      if (c == '(') {\n            current_paren_level = c;\n        } else if\
    \ (c == ')') {\n            paren_levels.push_back(std::stoll(current_paren_level));\n\
    \            current_paren_level.clear();\n        } else {\n            current_paren_level\
    \ += c;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppa40autp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    std::vector<long> paren_levels_temp2;\n    std::vector<long>\
    \ paren_levels_temp3;\n    std::vector<long> paren_levels_temp4;\n    std::vector<long>\
    \ paren_levels_temp5;\n    std::vector<long> paren_levels_temp6;\n    std::vector<long>\
    \ paren_levels_temp7;\n    std::vector<long> paren_levels_temp8;\n    std::vector<long>\
    \ paren_levels_temp9;\n    std::vector<long> paren_levels_temp10;\n    std::vector<long>\
    \ paren_levels_temp11;\n    std::vector<long> paren_levels_temp12;\n    std::vector<long>\
    \ paren_levels_temp13;\n    std::vector<long> paren_levels_temp14;\n    std::vector<long>\
    \ paren_levels_temp15;\n    std::vector<long> paren_levels_temp16;\n    std::vector<long>\
    \ paren_levels_temp17;\n    std::vector<long> paren_levels_temp18;\n    std::vector<long>\
    \ paren_levels_temp19;\n    std::vector<long> paren_levels_temp20;\n    std::vector<long>\
    \ paren_levels_temp21;\n    std::vector<long> paren_levels_temp22;\n    std::vector<long>\
    \ paren_levels_temp23;\n    std::vector<long> paren_levels_temp24;\n    std::vector<long>\
    \ paren_levels_temp25;\n    std::vector<long> paren_levels_temp26;\n    std::vector<long>\
    \ paren_levels_temp27;\n    std::vector<long> paren_levels_temp28;\n    std::vector<long>\
    \ paren_levels_temp29;\n    std::vector<long> paren_levels_temp30;\n    std::vector<long>\
    \ paren_levels_temp31;\n    std::vector<long> paren_levels_temp32;\n    std::vector<long>\
    \ paren_levels_temp33;\n    std::vector<long> paren_levels_temp34;\n    std::vector<long>\
    \ paren_levels_temp35;\n    std::vector<long> paren_levels_temp36;\n    std::vector<long>\
    \ paren_levels_temp37;\n    std::vector<long> paren_levels_temp38;\n    std::vector<long>\
    \ paren_levels_temp39;\n    std::vector<long> paren_levels_temp40;\n    std::vector<long>\
    \ paren_levels_temp41;\n    std::vector<long> paren_levels_temp42;\n    std::vector<long>\
    \ paren_levels_temp43;\n    std::vector<long> paren_\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptqu93t_h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool paren_found = false;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_found = true;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_found = false;\n          \
    \  paren_level--;\n        }\n        if (paren_found) {\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_ctos2js.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ljad_by.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp8ljad_by.cpp:13:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp8ljad_by.cpp:23:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(level);\n     ^\n/tmp/tmp8ljad_by.cpp:23:33:\
    \ error: could not convert 'paren_levels.std::vector<_Tp, _Alloc>::push_back<long\
    \ int, std::allocator<long int> >((*(const value_type*)(& level)))' from 'void'\
    \ to 'bool'\n     paren_levels.push_back(level);\n                           \
    \      ^\n/tmp/tmp8ljad_by.cpp:24:5: error: expected primary-expression before\
    \ 'return'\n     return paren_levels;\n     ^\n/tmp/tmp8ljad_by.cpp:24:5: error:\
    \ expected ')' before 'return'\n/tmp/tmp8ljad_by.cpp: In function 'int main()':\n\
    /tmp/tmp8ljad_by.cpp:27:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = parse_nested_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ljad_by.cpp:2:\n/tmp/tmp8ljad_by.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp8ljad_by.cpp:28:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp8ljad_by.cpp:28:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ljad_by.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp8ljad_by.cpp:13:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp8ljad_by.cpp:23:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(level);\n     ^\n/tmp/tmp8ljad_by.cpp:23:33:\
    \ error: could not convert 'paren_levels.std::vector<_Tp, _Alloc>::push_back<long\
    \ int, std::allocator<long int> >((*(const value_type*)(& level)))' from 'void'\
    \ to 'bool'\n     paren_levels.push_back(level);\n                           \
    \      ^\n/tmp/tmp8ljad_by.cpp:24:5: error: expected primary-expression before\
    \ 'return'\n     return paren_levels;\n     ^\n/tmp/tmp8ljad_by.cpp:24:5: error:\
    \ expected ')' before 'return'\n/tmp/tmp8ljad_by.cpp: In function 'int main()':\n\
    /tmp/tmp8ljad_by.cpp:27:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = parse_nested_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ljad_by.cpp:2:\n/tmp/tmp8ljad_by.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp8ljad_by.cpp:28:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp8ljad_by.cpp:28:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  paren_level = std::to_string(paren_level_count);\n        } else {\n      \
    \      paren_level += c;\n        }\n    }\n    paren_level_count = 0;\n    for\
    \ (auto c : paren_level) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n        }\n\
    \    }\n    paren_level_count = 0;\n    for (auto c : paren_level) {\n       \
    \ if (c == '(') {\n            paren_level_count++;\n        } else if (c == ')')\
    \ {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (auto c : paren_level)\
    \ {\n        if (c == '(') {\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (auto c : paren_level)\
    \ {\n        if (c == '(') {\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (auto c : paren_level)\
    \ {\n        if (c == '(') {\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (auto c : \n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb6h6p7on.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(paren_levels.size());\n    for (long i = 0; i\
    \ < paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    long max_level = 0;\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            max_level\
    \ = paren_levels_temp[i];\n        }\n    }\n    std::vector<long> paren_levels_temp2;\n\
    \    paren_levels_temp2.push_back(max_level);\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            paren_levels_temp2.push_back(max_level);\n\
    \        } else {\n            paren_levels_temp2.push_back(paren_levels_temp[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.push_back(max_level);\n\
    \    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i]\
    \ > max_level) {\n            paren_levels_temp3.push_back(max_level);\n     \
    \   } else {\n            paren_levels_temp3.push_back(paren_levels_temp[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.push_back(max_level);\n\
    \    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i]\
    \ > max_level) {\n            paren_levels_temp4.push_back(max_level);\n     \
    \   } else {\n            paren_levels_temp4.push_back(paren_levels_temp[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.push_back(max_level);\n\
    \    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i]\
    \ > max_level) {\n            paren_levels_temp5.push_back(max_level);\n     \
    \   } else {\n            paren_levels_temp5.push_back(paren_levels_temp[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp6;\n    paren_levels_temp6.push_back(max_level);\n\
    \    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i]\
    \ > max_level) {\n            paren_levels_temp6.push_back(max_level);\n     \
    \   } else {\n            paren_levels_temp6.push_back(paren_levels_temp[i]);\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppalwpmge.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpechfbjd6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821954
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3otylwz1.cpp: In function 'int main()':\n/tmp/tmp3otylwz1.cpp:84:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3otylwz1.cpp:2:\n/tmp/tmp3otylwz1.cpp:85:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp3otylwz1.cpp:85:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp3otylwz1.cpp:85:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3otylwz1.cpp:85:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp3otylwz1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_string2 = paren_string;\n    std::string paren_string3\
    \ = paren_string;\n    std::string paren_string4 = paren_string;\n    std::string\
    \ paren_string5 = paren_string;\n    std::string paren_string6 = paren_string;\n\
    \    std::string paren_string7 = paren_string;\n    std::string paren_string8\
    \ = paren_string;\n    std::string paren_string9 = paren_string;\n    std::string\
    \ paren_string10 = paren_string;\n    std::string paren_string11 = paren_string;\n\
    \    std::string paren_string12 = paren_string;\n    std::string paren_string13\
    \ = paren_string;\n    std::string paren_string14 = paren_string;\n    std::string\
    \ paren_string15 = paren_string;\n    std::string paren_string16 = paren_string;\n\
    \    std::string paren_string17 = paren_string;\n    std::string paren_string18\
    \ = paren_string;\n    std::string paren_string19 = paren_string;\n    std::string\
    \ paren_string20 = paren_string;\n    std::string paren_string21 = paren_string;\n\
    \    std::string paren_string22 = paren_string;\n    std::string paren_string23\
    \ = paren_string;\n    std::string paren_string24 = paren_string;\n    std::string\
    \ paren_string25 = paren_string;\n    std::string paren_string26 = paren_string;\n\
    \    std::string paren_string27 = paren_string;\n    std::string paren_string28\
    \ = paren_string;\n    std::string paren_string29 = paren_string;\n    std::string\
    \ paren_string30 = paren_string;\n    std::string paren_string31 = paren_string;\n\
    \    std::string paren_string32 = paren_string;\n    std::string paren_string33\
    \ = paren_string;\n    std::string paren_string34 = paren_string;\n    std::string\
    \ paren_string35 = paren_string;\n    std::string paren_string36 = paren_string;\n\
    \    std::string paren_string37 = paren_string;\n    std::string paren_string38\
    \ = paren_string;\n    std::string paren_string39 = paren_string;\n    std::string\
    \ paren_string40 = paren_string;\n    std::string paren_string41 = paren_string;\n\
    \    std::string paren_string42 = paren_string;\n    std::string paren_string43\
    \ = paren_string;\n    std::string paren_string44 = paren_string;\n    std::string\
    \ paren_string45 = paren_string;\n    std::string paren_string46 = paren_string;\n\
    \    std::string paren_string47 = paren_string;\n    std::string paren_string48\
    \ = paren_string;\n    std::string paren_string49 = paren_string;\n    std::string\
    \ paren_string50 = paren_string;\n    std::string paren_string51 = paren_string;\n\
    \    std::string paren_string52 = paren\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphbaq4nay.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    bool is_open = false;\n    for (size_t i = 0;\
    \ i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n   \
    \         is_open = true;\n            current_level++;\n        } else if (paren_string[i]\
    \ == ')') {\n            is_open = false;\n            current_level--;\n    \
    \    } else if (is_open) {\n            current_level++;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpju9pib_t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    for (auto &c : paren_string) {\n        if (c == '(') {\n            paren_level\
    \ = c;\n        } else if (c == ')') {\n            levels[levels.size() - 1]++;\n\
    \            paren_level = c;\n        } else {\n            levels[levels.size()\
    \ - 1]++;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzehc_qoi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_level--;\n\
    \        } else if (is_open) {\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsw6kyp5i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            paren_level = paren_string.substr(0, i);\n          \
    \  levels.push_back(std::stoi(paren_level));\n        } else if (paren_string[i]\
    \ == ')') {\n            long level_of_nesting = std::stoi(paren_level);\n   \
    \         if (level_of_nesting > levels.size()) {\n                levels.resize(level_of_nesting\
    \ + 1);\n            }\n            levels[level_of_nesting]++;\n            paren_level\
    \ = paren_string.substr(i + 1, paren_string.size() - i - 1);\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvc7hu8xv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  std::string paren_level;\n  long paren_level_count = 0;\n  for (char c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_level = paren_level + c;\n      paren_level_count++;\n\
    \    } else if (c == ')') {\n      paren_level = paren_level.substr(0, paren_level.size()\
    \ - 1);\n      paren_level_count--;\n      if (paren_level_count == 0) {\n   \
    \     paren_levels.push_back(std::stoi(paren_level));\n      }\n    }\n  }\n \
    \ return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv74ta78_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_level_string;\n    std::string paren_level_char;\n    long\
    \ paren_level = 0;\n    long paren_level_counter = 0;\n    bool paren_level_found\
    \ = false;\n    for (auto c : paren_string) {\n        paren_level_string = paren_level_char;\n\
    \        paren_level_char = c; // Store the character for later use\n        if\
    \ (c == '(') {\n            paren_level++;\n            paren_level_string = paren_level_char;\n\
    \            paren_level_found = true;\n        }\n        else if (c == ')')\
    \ {\n            paren_level--;\n            paren_level_string = paren_level_char;\n\
    \            paren_level_found = true;\n        }\n        else if (paren_level_found)\
    \ {\n            paren_level_string = paren_level_char;\n            paren_level_found\
    \ = false;\n        }\n        paren_level_string = std::to_string(paren_level);\n\
    \        paren_level_string = paren_level_string + paren_level_string;\n     \
    \   paren_level_string = paren_level_string + paren_level_string;\n        paren_level_string\
    \ = paren_level_string + paren_level_string;\n        paren_level_string = paren_level_string\
    \ + paren_level_string;\n        paren_level_string = paren_level_string + paren_level_string;\n\
    \        paren_level_string = paren_level_string + paren_level_string;\n     \
    \   paren_level_string = paren_level_string + paren_level_string;\n        paren_level_string\
    \ = paren_level_string + paren_level_string;\n        paren_level_string = paren_level_string\
    \ + paren_level_string;\n        paren_level_string = paren_level_string + paren_level_string;\n\
    \        paren_level_string = paren_level_string + paren_level_string;\n     \
    \   paren_level_string = paren_level_string + paren_level_string;\n        paren_level_string\
    \ = paren_level_string + paren_level_string;\n        paren_level_string = paren_level_string\
    \ + paren_level_string;\n        paren_level_string = paren_level_string + paren_level_string;\n\
    \        paren_level_string = paren_level_string + paren_level_string;\n     \
    \   paren_level_string = paren_level_string + paren_level_string;\n        paren_level_string\
    \ = paren_level_string + paren_level_string;\n        paren_level_string = paren_level_string\
    \ \n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4wchouvo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        if (paren_levels[i]\
    \ == \"(\") {\n            paren_levels_temp.push_back(i);\n        } else if\
    \ (paren_levels[i] == \")\") {\n            long paren_levels_size = paren_levels_temp.size();\n\
    \            if (paren_levels_size == 0) {\n                paren_levels_temp.push_back(i);\n\
    \            } else {\n                long paren_levels_max_size = paren_levels_temp[paren_levels_size\
    \ - 1];\n                long paren_levels_max_index = paren_levels_temp[paren_levels_size\
    \ - 2];\n                if (paren_levels_max_index > i) {\n                 \
    \   paren_levels_temp.push_back(i);\n                }\n            }\n      \
    \  }\n    }\n    return paren_levels_temp;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmposrn3mlr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy = paren_levels.begin();\n\
    \    long paren_level = 0;\n    long paren_level_copy = 0;\n    long paren_level_copy2\
    \ = 0;\n    long paren_level_copy3 = 0;\n    long paren_level_copy4 = 0;\n   \
    \ long paren_level_copy5 = 0;\n    long paren_level_copy6 = 0;\n    long paren_level_copy7\
    \ = 0;\n    long paren_level_copy8 = 0;\n    long paren_level_copy9 = 0;\n   \
    \ long paren_level_copy10 = 0;\n    long paren_level_copy11 = 0;\n    long paren_level_copy12\
    \ = 0;\n    long paren_level_copy13 = 0;\n    long paren_level_copy14 = 0;\n \
    \   long paren_level_copy15 = 0;\n    long paren_level_copy16 = 0;\n    long paren_level_copy17\
    \ = 0;\n    long paren_level_copy18 = 0;\n    long paren_level_copy19 = 0;\n \
    \   long paren_level_copy20 = 0;\n    long paren_level_copy21 = 0;\n    long paren_level_copy22\
    \ = 0;\n    long paren_level_copy23 = 0;\n    long paren_level_copy24 = 0;\n \
    \   long paren_level_copy25 = 0;\n    long paren_level_copy26 = 0;\n    long paren_level_copy27\
    \ = 0;\n    long paren_level_copy28 = 0;\n    long paren_level_copy29 = 0;\n \
    \   long paren_level_copy30 = 0;\n    long paren_level_copy31 = 0;\n    long paren_level_copy32\
    \ = 0;\n    long paren_level_copy33 = 0;\n    long paren_level_copy34 = 0;\n \
    \   long paren_level_copy35 = 0;\n    long paren_level_copy36 = 0;\n    long paren_level_copy37\
    \ = 0;\n    long paren_level_copy38 = 0;\n    long paren_level_copy39 = 0;\n \
    \   long paren_level_copy40 = 0;\n    long paren_level_copy41 = 0;\n    long paren_level_copy42\
    \ = 0;\n    long paren_level_copy43 = 0;\n    long paren_level_copy44 = 0;\n \
    \   long paren_level_copy45 = 0;\n    long paren_level_copy46 = 0;\n    long paren_level_copy47\
    \ = 0;\n    long paren_level_copy48 = 0;\n    long paren_level_copy49 = 0;\n \
    \   long paren_level_copy50 = 0;\n    long paren_level_copy51 = 0;\n    long paren_level_copy52\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6j81luvt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level_string = paren_level_string.empty() ? \"\" :\
    \ paren_level_string + \" \";\n            paren_level_string = paren_level_string\
    \ + std::to_string(paren_level);\n            paren_level++;\n        } else if\
    \ (c == ')') {\n            paren_level_string = paren_level_string + std::to_string(paren_level);\n\
    \            paren_level--;\n            paren_level_string = paren_level_string\
    \ + std::to_string(paren_level);\n            paren_level_string = paren_level_string\
    \ + \" \";\n            paren_level_string = paren_level_string + std::to_string(paren_level);\n\
    \            paren_level_string = paren_level_string + \" \";\n            paren_level_string\
    \ = paren_level_string + std::to_string(paren_level);\n            paren_level_string\
    \ = paren_level_string + \" \";\n            paren_level_string = paren_level_string\
    \ + std::to_string(paren_level);\n            paren_level_string = paren_level_string\
    \ + \" \";\n            paren_level_string = paren_level_string + std::to_string(paren_level);\n\
    \            paren_level_string = paren_level_string + \" \";\n            paren_level_string\
    \ = paren_level_string + std::to_string(paren_level);\n            paren_level_string\
    \ = paren_level_string + \" \";\n            paren_level_string = paren_level_string\
    \ + std::to_string(paren_level);\n            paren_level_string = paren_level_string\
    \ + \" \";\n            paren_level_string = paren_level_string + std::to_string(paren_level);\n\
    \            paren_level_string = paren_level_string + \" \";\n            paren_level_string\
    \ = paren_level_string + std::to_string(paren_level);\n            paren_level_string\
    \ = paren_level_string + \" \";\n            paren_level_string = paren_level_string\
    \ + std::to_string(paren_level);\n            paren_level_string = paren_level_string\
    \ + \" \";\n            paren_level_string = paren_level_string + std::to_string(paren_level);\n\
    \            paren_level_string = paren_level_string + \" \";\n            paren_level_string\
    \ = paren_level_string + std::to_string(paren_level);\n            paren_level_string\
    \ = paren_level_string + \" \";\n            paren_level_string = paren_level_string\
    \ + std::\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkjhn3oml.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpag6bor0r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821954
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    for (auto &c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level = paren_level + c;\n        } else if\
    \ (c == ')') {\n            paren_level = paren_level.substr(0, paren_level.size()\
    \ - 1);\n            paren_levels.push_back(std::stoi(paren_level));\n       \
    \     paren_level = c;\n        } else {\n            paren_level = paren_level\
    \ + c;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu_5s4ihz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_level = std::to_string(level);\n            level++;\n\
    \        } else if (c == ')') {\n            level--;\n            levels[level]\
    \ = std::stoi(paren_level);\n        }\n    }\n    return levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphy1iakym.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n            assert(paren_level\
    \ >= 0);\n            paren_levels.push_back(paren_level);\n        } else {\n\
    \            assert(paren_level == 0);\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9o90wupf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    size_t paren_level_count = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            paren_level_count++;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (paren_string[i] == ')') {\n            paren_level_count--;\n\
    \            assert(paren_level_count >= 0);\n            paren_levels.push_back(paren_level);\n\
    \            assert(paren_level_count);\n        } else {\n            assert(paren_string[i]\
    \ == ' ');\n        }\n        if (paren_level_count == 0) {\n            paren_level++;\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnfzx1esq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool in_paren = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            in_paren\
    \ = true;\n        } else if (c == ')') {\n            paren_level--;\n      \
    \      in_paren = false;\n        } else if (c == ' ') {\n            if (in_paren)\
    \ {\n                paren_levels.push_back(paren_level);\n            }\n   \
    \     }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx6vi28ah.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(')')).split(\")\");\n  for (int i = 0; i < paren_levels.size();\
    \ i++) {\n    paren_levels[i] = std::stoll(paren_levels[i]);\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqjrc6ssp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (char c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level_string = paren_level_string.empty() ? \"(\"\
    \ : paren_level_string;\n        } else if (c == ')') {\n            is_closed\
    \ = true;\n            paren_level_string = paren_level_string.empty() ? \")\"\
    \ : paren_level_string;\n        } else if (is_open && is_closed) {\n        \
    \    paren_level_string = paren_level_string.empty() ? \"\" : paren_level_string;\n\
    \            paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzk320gxw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string curr_level;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            curr_level = curr_level + c;\n        } else if (c == ')') {\n\
    \            curr_level = curr_level.substr(0, curr_level.size() - 1);\n     \
    \       levels[level++] = std::stoi(curr_level);\n            curr_level.clear();\n\
    \        } else {\n            curr_level = curr_level + c;\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcfcurma7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    for (auto &c : paren_string) {\n        if (c == '(') {\n            current_level\
    \ = current_level + \"(\";\n        } else if (c == ')') {\n            current_level\
    \ = current_level.substr(0, current_level.size() - 1) + \")\";\n        } else\
    \ {\n            current_level = current_level + c;\n        }\n    }\n    long\
    \ current_level_length = current_level.size();\n    for (auto &c : current_level)\
    \ {\n        if (c == '(') {\n            levels.push_back(current_level_length);\n\
    \        } else if (c == ')') {\n            levels.push_back(levels[levels.size()\
    \ - 1]);\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvcv42zt0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long level = 0;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_level--;\n\
    \        } else if (is_open) {\n            paren_level++;\n        } else {\n\
    \            paren_level--;\n        }\n        if (paren_level == level) {\n\
    \            paren_levels[paren_level - 1]++;\n        } else {\n            paren_levels.push_back(level);\n\
    \            paren_level = 1;\n            level = paren_level;\n        }\n \
    \   }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqh9hgf9b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            paren_levels.push_back(paren_level);\n        } else\
    \ if (c == ')') {\n            paren_levels.pop_back();\n        }\n        paren_level++;\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi4ugk_ex.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    for (size_t i = 0; i < paren_string.size(); i++)\
    \ {\n        char c = paren_string[i];\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level++;\n        }\n        else if (c == ')') {\n\
    \            is_close = true;\n            paren_level--;\n        }\n       \
    \ else if (is_open) {\n            paren_level++;\n        }\n        else if\
    \ (is_close) {\n            paren_level--;\n        }\n        if (paren_level\
    \ == current_level) {\n            paren_levels.push_back(paren_level);\n    \
    \    }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbu881oa2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_level = \"\";\n    for (auto c : paren_string) {\n\
    \        if (c == '(') {\n            curr_paren_level += c;\n        } else if\
    \ (c == ')') {\n            curr_paren_level += c;\n            paren_levels.push_back(std::stoll(curr_paren_level));\n\
    \            curr_paren_level = \"\";\n        } else {\n            curr_paren_level\
    \ += c;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq10oclc8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::vector<long> paren_levels_temp;\n    std::string paren_levels_temp_str;\n\
    \    std::string paren_levels_temp_str_temp;\n    std::string paren_levels_temp_str_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp;\n    std::string paren_levels_temp_str_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp;\n    std::string\
    \ paren_levels_temp_str_temp_temp_temp_temp_temp_temp;\n    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    std::string paren_levels_temp_str_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp37742w5g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto it = paren_string.begin(); it != paren_string.end();\
    \ ++it) {\n        if (*it == '(') {\n            ++level;\n        } else if\
    \ (*it == ')') {\n            --level;\n        }\n        paren_levels.push_back(level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb6v_2va8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821953
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string current_paren_level;\n    for (auto c : paren_string) {\n   \
    \     if (c == '(') {\n            current_paren_level = \"(\";\n        } else\
    \ if (c == ')') {\n            current_paren_level = \")\";\n        } else if\
    \ (c == ' ') {\n            current_paren_level = \" \";\n        } else {\n \
    \           paren_levels.push_back(std::stoi(current_paren_level));\n        \
    \    current_paren_level = c;\n        }\n    }\n    paren_levels.push_back(std::stoi(current_paren_level));\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcic79lqf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.split(\"\
    \ \");\n  std::vector<long> paren_levels_temp;\n  paren_levels_temp.push_back(1);\n\
    \  for (int i = 0; i < paren_levels.size(); i++) {\n    if (paren_levels[i] ==\
    \ \"(\") {\n      paren_levels_temp.push_back(paren_levels_temp.back() + 1);\n\
    \    } else if (paren_levels[i] == \")\") {\n      paren_levels_temp.push_back(paren_levels_temp.back()\
    \ - 1);\n    }\n  }\n  std::vector<long> paren_levels_temp_reverse;\n  paren_levels_temp_reverse\
    \ = paren_levels_temp;\n  std::reverse(paren_levels_temp_reverse.begin(), paren_levels_temp_reverse.end());\n\
    \  std::vector<long> paren_levels_temp_reverse_temp;\n  paren_levels_temp_reverse_temp.push_back(1);\n\
    \  for (int i = 0; i < paren_levels_temp_reverse.size(); i++) {\n    if (paren_levels_temp_reverse[i]\
    \ == paren_levels_temp_reverse.back()) {\n      paren_levels_temp_reverse_temp.push_back(paren_levels_temp_reverse_temp.back()\
    \ + 1);\n    } else {\n      paren_levels_temp_reverse_temp.push_back(paren_levels_temp_reverse_temp.back()\
    \ - 1);\n    }\n  }\n  std::vector<long> paren_levels_temp_reverse_temp_reverse;\n\
    \  paren_levels_temp_reverse_temp_reverse = paren_levels_temp_reverse_temp;\n\
    \  std::reverse(paren_levels_temp_reverse_temp_reverse.begin(), paren_levels_temp_reverse_temp_reverse.end());\n\
    \  std::vector<long> paren_levels_temp_reverse_temp_reverse_temp;\n  paren_levels_temp_reverse_temp_reverse_temp.push_back(1);\n\
    \  for (int i = 0; i < paren_levels_temp_reverse_temp_reverse.size(); i++) {\n\
    \    if (paren_levels_temp_reverse_temp_reverse[i] == paren_levels_temp_reverse_temp_reverse.back())\
    \ {\n      paren_levels_temp_reverse_temp_reverse_temp.push_back(paren_levels_temp_reverse_temp_reverse_temp.back()\
    \ + 1);\n    } else {\n      paren_levels_temp_reverse_temp_reverse_temp.push_back(paren_levels_temp_reverse_temp_reverse_temp.back()\
    \ - 1);\n    }\n  }\n  std::vector<long> paren_levels_temp_reverse_temp_reverse_temp_reverse;\n\
    \  paren_levels_temp_reverse_temp_reverse_temp_reverse = paren_levels_temp_reverse_temp_reverse_temp;\n\
    \  std::reverse(\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvsh1f3x0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::vector<long> paren_levels_temp;\n    std::string paren_string_temp;\n\
    \    long paren_levels_temp_index = 0;\n    long paren_levels_temp_size = 0;\n\
    \    long paren_levels_temp_index2 = 0;\n    long paren_levels_temp_size2 = 0;\n\
    \    long paren_levels_temp_index3 = 0;\n    long paren_levels_temp_size3 = 0;\n\
    \    long paren_levels_temp_index4 = 0;\n    long paren_levels_temp_size4 = 0;\n\
    \    long paren_levels_temp_index5 = 0;\n    long paren_levels_temp_size5 = 0;\n\
    \    long paren_levels_temp_index6 = 0;\n    long paren_levels_temp_size6 = 0;\n\
    \    long paren_levels_temp_index7 = 0;\n    long paren_levels_temp_size7 = 0;\n\
    \    long paren_levels_temp_index8 = 0;\n    long paren_levels_temp_size8 = 0;\n\
    \    long paren_levels_temp_index9 = 0;\n    long paren_levels_temp_size9 = 0;\n\
    \    long paren_levels_temp_index10 = 0;\n    long paren_levels_temp_size10 =\
    \ 0;\n    long paren_levels_temp_index11 = 0;\n    long paren_levels_temp_size11\
    \ = 0;\n    long paren_levels_temp_index12 = 0;\n    long paren_levels_temp_size12\
    \ = 0;\n    long paren_levels_temp_index13 = 0;\n    long paren_levels_temp_size13\
    \ = 0;\n    long paren_levels_temp_index14 = 0;\n    long paren_levels_temp_size14\
    \ = 0;\n    long paren_levels_temp_index15 = 0;\n    long paren_levels_temp_size15\
    \ = 0;\n    long paren_levels_temp_index16 = 0;\n    long paren_levels_temp_size16\
    \ = 0;\n    long paren_levels_temp_index17 = 0;\n    long paren_levels_temp_size17\
    \ = 0;\n    long paren_levels_temp_index18 = 0;\n    long paren_levels_temp_size18\
    \ = 0;\n    long paren_levels_temp_index19 = 0;\n    long paren_levels_temp_size19\
    \ = 0;\n    long paren_levels_temp_index20 = 0;\n    long paren_levels_temp_size20\
    \ = 0;\n    long paren_levels_temp_index21 = 0;\n    long paren_levels_temp_size21\
    \ = 0;\n    long paren_levels_temp_index22 = 0;\n    long paren_levels_temp_size22\
    \ = 0;\n    long paren_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_qmt7ivg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          paren_level--;\n        }\n    }\n    paren_levels.push_back(paren_level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj_ohi_1n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0uiuyppp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n            paren_level_string = std::to_string(paren_level);\n\
    \        } else if (c == ')') {\n            paren_level--;\n            paren_level_string\
    \ = std::to_string(paren_level);\n        } else {\n            paren_level_string\
    \ = std::to_string(paren_level);\n            paren_level_string.push_back(c);\n\
    \        }\n        paren_levels.push_back(std::stoi(paren_level_string));\n \
    \   }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpec0rqq75.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyihc842w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821956
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n            paren_level_string = std::to_string(paren_level);\n\
    \        } else if (c == ')') {\n            paren_level--;\n            paren_level_string\
    \ = std::to_string(paren_level);\n        } else {\n            paren_level_string\
    \ = std::to_string(paren_level);\n        }\n        paren_levels.push_back(paren_level_string);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl8ifv1xl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    std::string paren_level = \"\";\n    size_t paren_level_count = 0;\n    for\
    \ (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            paren_level_count++;\n            paren_level += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            paren_level_count--;\n\
    \            paren_level += paren_string[i];\n            if (paren_level_count\
    \ == 0) {\n                paren_levels.push_back(std::stoi(paren_level));\n \
    \               paren_level = \"\";\n            }\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzi9s76f0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level\
    \ = \"\";\n    std::string paren_level_token = \"\";\n    long paren_level_count\
    \ = 0;\n    for (auto &c : paren_string) {\n        if (c == '(') {\n        \
    \    paren_level_token += c;\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level += paren_level_token;\n           \
    \ paren_level_token = \"\";\n            paren_level_count--;\n            if\
    \ (paren_level_count == 0) {\n                paren_level_count = 0;\n       \
    \         paren_level += c;\n                paren_level_count++;\n          \
    \  }\n        } else if (c == ' ') {\n            paren_level += c;\n        }\n\
    \    }\n    paren_level += paren_level_token;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n    paren_level_count--;\n\
    \    paren_level_count--;\n    paren_level_count--;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsipxnwdd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_string_reversed = paren_string;\n    std::reverse(paren_string_reversed.begin(),\
    \ paren_string_reversed.end());\n    size_t paren_string_reversed_size = paren_string_reversed.size();\n\
    \    size_t paren_string_reversed_index = 0;\n    size_t paren_string_reversed_index_end\
    \ = 0;\n    size_t paren_string_reversed_index_start = 0;\n    size_t paren_string_reversed_index_count\
    \ = 0;\n    bool paren_string_reversed_index_is_open = false;\n    bool paren_string_reversed_index_is_closed\
    \ = false;\n    bool paren_string_reversed_index_is_opening_paren = false;\n \
    \   bool paren_string_reversed_index_is_closing_paren = false;\n    bool paren_string_reversed_index_is_opening_paren_or_closing\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening =\
    \ false;\n    bool paren_string_reversed_index_is_opening_paren_or_closing_paren\
    \ = false;\n    bool paren_string_reversed_index_is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool paren_string_reversed_index_is_closing_paren_or_opening_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmper904oke.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ');\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(1);\n    long max_level = 1;\n    for (long i\
    \ = 0; i < paren_levels.size(); i++) {\n        long current_level = paren_levels[i];\n\
    \        long current_level_temp = paren_levels_temp[i];\n        while (current_level\
    \ > max_level) {\n            max_level = current_level;\n            paren_levels_temp.push_back(current_level_temp);\n\
    \            current_level++;\n        }\n    }\n    return paren_levels_temp;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr1w8x06c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_string = paren_string;\n    size_t paren_level = 0;\n \
    \   size_t paren_level_count = 0;\n    size_t paren_level_count_max = 0;\n   \
    \ size_t paren_level_count_min = 0;\n    size_t paren_level_count_sum = 0;\n \
    \   size_t paren_level_count_sum_max = 0;\n    size_t paren_level_count_sum_min\
    \ = 0;\n    size_t paren_level_count_sum_sum = 0;\n    size_t paren_level_count_sum_sum_max\
    \ = 0;\n    size_t paren_level_count_sum_sum_min = 0;\n    size_t paren_level_count_sum_sum_sum\
    \ = 0;\n    size_t paren_level_count_sum_sum_max = 0;\n    size_t paren_level_count_sum_sum_min\
    \ = 0;\n    size_t paren_level_count_sum_sum_sum = 0;\n    size_t paren_level_count_sum_sum_max\
    \ = 0;\n    size_t paren_level_count_sum_sum_min = 0;\n    size_t paren_level_count_sum_sum_sum\
    \ = 0;\n    size_t paren_level_count_sum_sum_max = 0;\n    size_t paren_level_count_sum_sum_min\
    \ = 0;\n    size_t paren_level_count_sum_sum_sum = 0;\n    size_t paren_level_count_sum_sum_max\
    \ = 0;\n    size_t paren_level_count_sum_sum_min = 0;\n    size_t paren_level_count_sum_sum_sum\
    \ = 0;\n    size_t paren_level_count_sum_sum_max = 0;\n    size_t paren_level_count_sum_sum_min\
    \ = 0;\n    size_t paren_level_count_sum_sum_sum = 0;\n    size_t paren_level_count_sum_sum_max\
    \ = 0;\n    size_t paren_level_count_sum_sum_min = 0;\n    size_t paren_level_count_sum_sum_sum\
    \ = 0;\n    size_t paren_level_count_sum_sum_max = 0;\n    size_t paren_level_count_sum_sum_min\
    \ = 0;\n    size_t paren_level_count_sum_sum_sum = 0;\n    size_t paren_level_count_sum_sum_max\
    \ = 0;\n    size_t paren_level_count_sum_sum_min = 0;\n    size_t paren_level_count_sum_sum_sum\
    \ = 0;\n    size_t paren_level_count_sum_sum_max = 0;\n    size_t paren_level_count_sum_sum_min\
    \ = 0;\n    size_t paren_level_count_sum_sum_sum = 0;\n    size_t paren_level_count_sum_sum_max\
    \ = 0;\n    size_t paren_level_count_sum_sum_min = 0;\n    size_t paren_level_count_sum_sum_sum\
    \ = 0;\n    size_t paren_level_count_sum_sum_max = 0;\n    size_t paren_level_count_sum_sum_min\
    \ = 0;\n    size_t paren_level_count_sum_sum_sum = 0;\n    size_t paren_level_count_sum_sum_max\
    \ = 0;\n    size_t paren_level_count_sum_sum_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9e33o5_j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels_t paren_levels_t;\n\
    \    paren_levels_t.size = 0;\n    paren_levels_t.max_level = 0;\n    paren_levels_t.max_level_size\
    \ = 0;\n    paren_levels_t.max_level_num = 0;\n    paren_levels_t.max_level_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num = 0;\n    paren_levels_t.max_level_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num = 0;\n    paren_levels_t.max_level_num_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num = 0;\n    paren_levels_t.max_level_num_num_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num = 0;\n    paren_levels_t.max_level_num_num_num_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num = 0;\n    paren_levels_t.max_level_num_num_num_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num = 0;\n  \
    \  paren_levels_t.max_level_num_num_num_num_num_num_num_num_size = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num =\
    \ 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num_size\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num_num\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num_num\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num_num\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num_num\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num_num_num\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_num_num_num_num_num\
    \ = 0;\n    paren_levels_t.max_level_num_num_num_num_num_num_num_\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4dvhnf3_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n      assert(level >= 0);\n      paren_levels.push_back(level);\n\
    \    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6gb0o2ld.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  std::string curr_paren_level = \"\";\n  for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n    if (paren_string[i] == '(') {\n      curr_paren_level += paren_string[i];\n\
    \    } else if (paren_string[i] == ')') {\n      paren_levels.push_back(std::stoi(curr_paren_level));\n\
    \      curr_paren_level = \"\";\n    } else {\n      curr_paren_level += paren_string[i];\n\
    \    }\n  }\n  paren_levels.push_back(std::stoi(curr_paren_level));\n  return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9j2x18da.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level++;\n        } else if (c == ')') {\n      \
    \      is_closed = true;\n            paren_level--;\n        } else if (c ==\
    \ ' ') {\n            if (is_open && is_closed) {\n                paren_levels.push_back(paren_level);\n\
    \            }\n            is_open = false;\n            is_closed = false;\n\
    \        }\n    }\n    if (is_open && is_closed) {\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxqwqbd3u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long level = 0;\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_closed = true;\n        } else if (is_open && is_closed)\
    \ {\n            paren_levels.push_back(level);\n            is_open = false;\n\
    \            is_closed = false;\n        } else if (is_open) {\n            level++;\n\
    \        } else if (is_closed) {\n            level--;\n        }\n    }\n   \
    \ return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4v7apuuo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string current_paren_string\
    \ = \"\";\n    long current_paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            current_paren_level++;\n           \
    \ current_paren_string += c;\n        } else if (c == ')') {\n            current_paren_level--;\n\
    \            current_paren_string += c;\n        } else {\n            current_paren_string\
    \ += c;\n        }\n        if (current_paren_level > 0) {\n            paren_levels.push_back(current_paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3mf0hull.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    long paren_level_count = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            paren_level = paren_levels[paren_level_count];\n            paren_level_count++;\n\
    \        } else if (paren_string[i] == ')') {\n            paren_level_count--;\n\
    \            paren_level = paren_levels[paren_level_count];\n        } else if\
    \ (paren_string[i] == ' ') {\n            paren_level_count = 0;\n        } else\
    \ {\n            paren_level_count = 0;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbi35c2sw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long paren_level =\
    \ 0;\n    bool is_open = false;\n    bool is_closed = false;\n    for (auto c\
    \ : paren_string) {\n        if (c == '(') {\n            is_open = true;\n  \
    \          paren_level++;\n        } else if (c == ')') {\n            is_closed\
    \ = true;\n            paren_level--;\n        } else if (is_open && is_closed)\
    \ {\n            paren_levels[paren_level - 1]++;\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv2xkvi_r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(paren_levels.back() == 0);\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph0iz9pal.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.reserve(paren_levels.size());\n    for (long i = 0; i <\
    \ paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    long max_level = 0;\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            max_level\
    \ = paren_levels_temp[i];\n        }\n    }\n    std::vector<long> paren_levels_temp2;\n\
    \    paren_levels_temp2.reserve(paren_levels_temp.size());\n    for (long i =\
    \ 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i] ==\
    \ max_level) {\n            paren_levels_temp2.push_back(max_level);\n       \
    \ } else {\n            paren_levels_temp2.push_back(paren_levels_temp[i]);\n\
    \        }\n    }\n    return paren_levels_temp2;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzowibt1a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (char c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_levels.push_back(paren_level);\n        } else if\
    \ (c == ')') {\n            is_closed = true;\n            paren_level = paren_levels.back();\n\
    \        } else if (c == ' ') {\n            if (is_open && is_closed) {\n   \
    \             paren_level = paren_levels.back();\n            }\n        } else\
    \ {\n            is_open = false;\n            is_closed = false;\n        }\n\
    \    }\n    if (paren_levels.size() == 0) {\n        paren_levels.push_back(1);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprarjbn5h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n            paren_level_string = std::to_string(paren_level);\n\
    \        } else if (c == ')') {\n            paren_level--;\n            paren_level_string\
    \ = std::to_string(paren_level);\n        } else {\n            paren_level_string\
    \ = std::to_string(paren_level);\n            paren_level_string.push_back(c);\n\
    \        }\n        paren_levels.push_back(std::stoi(paren_level_string));\n \
    \   }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpec0rqq75.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822031
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_level_string;\n    std::string paren_level_char;\n    long\
    \ paren_level = 0;\n    long paren_level_counter = 0;\n    bool paren_level_found\
    \ = false;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        paren_level_found\
    \ = false;\n        paren_level_counter = 0;\n        paren_level_string = \"\"\
    ;\n        paren_level_char = \"\";\n        paren_level = 0;\n        while (i\
    \ < paren_string.size() && !paren_level_found) {\n            paren_level_char\
    \ = paren_string[i];\n            if (paren_level_char == '(') {\n           \
    \     paren_level_found = true;\n                paren_level++;\n            \
    \    paren_level_string += paren_level_char;\n            } else if (paren_level_char\
    \ == ')') {\n                paren_level_found = true;\n                paren_level--;\n\
    \                paren_level_string += paren_level_char;\n            } else if\
    \ (paren_level_char == ' ') {\n                paren_level_string += paren_level_char;\n\
    \            }\n            i++;\n        }\n        if (paren_level_found) {\n\
    \            paren_levels[paren_level_counter] = paren_level;\n        }\n   \
    \ }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0h0p0a5n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    long paren_level = 1;\n    long paren_level_temp = 1;\n    long paren_level_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp = 1;\n    long paren_level_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp = 1;\n    long\
    \ paren_level_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7njq3av3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long current_level\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   current_level++;\n        } else if (c == ')') {\n            current_level--;\n\
    \        }\n        paren_levels.push_back(current_level);\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp400s7b6o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string curr_level;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            curr_level = curr_level + c;\n            level++;\n        }\
    \ else if (c == ')') {\n            level--;\n            curr_level = curr_level.substr(0,\
    \ curr_level.size() - 1);\n            levels[level - 1]++;\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcb6pjfab.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level_string = paren_level_string.empty() ? c : paren_level_string;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_string\
    \ = paren_level_string.empty() ? c : paren_level_string;\n            paren_level--;\n\
    \            if (paren_level == 0) {\n                paren_level_string = paren_level_string.empty()\
    \ ? c : paren_level_string;\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n                paren_level_string = paren\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz6ei1ti4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_temp.push_back(level);\n\
    \    }\n    long max_level = 0;\n    for (auto &level : paren_levels_temp) {\n\
    \        if (level > max_level) {\n            max_level = level;\n        }\n\
    \    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.reserve(paren_levels_temp.size());\n\
    \    for (auto &level : paren_levels_temp) {\n        paren_levels_temp2.push_back(level);\n\
    \    }\n    long max_level2 = 0;\n    for (auto &level : paren_levels_temp2) {\n\
    \        if (level > max_level2) {\n            max_level2 = level;\n        }\n\
    \    }\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.reserve(paren_levels_temp2.size());\n\
    \    for (auto &level : paren_levels_temp2) {\n        paren_levels_temp3.push_back(level);\n\
    \    }\n    long max_level3 = 0;\n    for (auto &level : paren_levels_temp3) {\n\
    \        if (level > max_level3) {\n            max_level3 = level;\n        }\n\
    \    }\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.reserve(paren_levels_temp3.size());\n\
    \    for (auto &level : paren_levels_temp3) {\n        paren_levels_temp4.push_back(level);\n\
    \    }\n    long max_level4 = 0;\n    for (auto &level : paren_levels_temp4) {\n\
    \        if (level > max_level4) {\n            max_level4 = level;\n        }\n\
    \    }\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.reserve(paren_levels_temp4.size());\n\
    \    for (auto &level : paren_levels_temp4) {\n        paren_levels_temp5.push_back(level);\n\
    \    }\n    long max_level5 = 0;\n    for (auto &level : paren_levels_temp5) {\n\
    \        if (level > max_level5) {\n            max_level5 = level;\n        }\n\
    \    }\n    std::vector<long> paren_levels_temp6;\n    paren_levels_temp6.reserve(paren_levels_temp5.size());\n\
    \    for (auto &level : paren_levels_temp5) {\n        paren_level\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5_cwq5w3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long max_level = 0;\n\
    \    long current_level = 0;\n    long level = 0;\n    bool is_open = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            current_level++;\n        } else if (c == ')') {\n    \
    \        is_open = false;\n            current_level--;\n        } else if (is_open)\
    \ {\n            level++;\n            if (level > max_level) {\n            \
    \    max_level = level;\n            }\n        }\n    }\n    paren_levels.push_back(max_level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplu_wxrb_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    long paren_level = 1;\n    long paren_level_temp = 1;\n    long paren_level_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp = 1;\n    long paren_level_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp = 1;\n    long\
    \ paren_level_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 1;\n    long paren_level_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpokh6psih.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            current_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            current_level--;\n\
    \        } else if (is_open) {\n            current_level++;\n        } else {\n\
    \            paren_levels.push_back(current_level);\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpasp37w9v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821954
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    long paren_level_count = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count++;\n        } else if (c == ')') {\n          \
    \  paren_level_count--;\n            paren_level = std::to_string(paren_level_count);\n\
    \        } else if (c == ' ') {\n            paren_level_count = 0;\n        }\
    \ else {\n            assert(false);\n        }\n        paren_levels.push_back(std::stoi(paren_level));\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3wj2888j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    long paren_level_count = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            paren_level_count++;\n            paren_level = paren_levels[paren_level_count];\n\
    \            paren_levels[paren_level_count] = i;\n        } else if (paren_string[i]\
    \ == ')') {\n            paren_level_count--;\n            paren_level = paren_levels[paren_level_count];\n\
    \            paren_levels[paren_level_count] = i;\n        } else {\n        \
    \    paren_level = paren_levels[paren_level_count];\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5x0sxwng.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_temp.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp2 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp3 = paren_levels_temp2;\n    std::vector<long> paren_levels_temp4\
    \ = paren_levels_temp3;\n    std::vector<long> paren_levels_temp5 = paren_levels_temp4;\n\
    \    std::vector<long> paren_levels_temp6 = paren_levels_temp5;\n    std::vector<long>\
    \ paren_levels_temp7 = paren_levels_temp6;\n    std::vector<long> paren_levels_temp8\
    \ = paren_levels_temp7;\n    std::vector<long> paren_levels_temp9 = paren_levels_temp8;\n\
    \    std::vector<long> paren_levels_temp10 = paren_levels_temp9;\n    std::vector<long>\
    \ paren_levels_temp11 = paren_levels_temp10;\n    std::vector<long> paren_levels_temp12\
    \ = paren_levels_temp11;\n    std::vector<long> paren_levels_temp13 = paren_levels_temp12;\n\
    \    std::vector<long> paren_levels_temp14 = paren_levels_temp13;\n    std::vector<long>\
    \ paren_levels_temp15 = paren_levels_temp14;\n    std::vector<long> paren_levels_temp16\
    \ = paren_levels_temp15;\n    std::vector<long> paren_levels_temp17 = paren_levels_temp16;\n\
    \    std::vector<long> paren_levels_temp18 = paren_levels_temp17;\n    std::vector<long>\
    \ paren_levels_temp19 = paren_levels_temp18;\n    std::vector<long> paren_levels_temp20\
    \ = paren_levels_temp19;\n    std::vector<long> paren_levels_temp21 = paren_levels_temp20;\n\
    \    std::vector<long> paren_levels_temp22 = paren_levels_temp21;\n    std::vector<long>\
    \ paren_levels_temp23 = paren_levels_temp22;\n    std::vector<long> paren_levels_temp24\
    \ = paren_levels_temp23;\n    std::vector<long> paren_levels_temp25 = paren_levels_temp24;\n\
    \    std::vector<long> paren_levels_temp26 = paren_levels_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8764wvzt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            if (current_level.empty())\
    \ {\n                levels.push_back(0);\n                current_level = c;\n\
    \            } else {\n                levels.push_back(levels.size());\n    \
    \            current_level = c;\n            }\n        } else if (c == ')') {\n\
    \            if (current_level.empty()) {\n                throw std::runtime_error(\"\
    Invalid parenthesis string\");\n            }\n            levels.push_back(levels.size());\n\
    \            current_level = c;\n        } else {\n            current_level +=\
    \ c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu0fx0lmo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(')')).split(\")\");\n    long max_level = 0;\n  \
    \  for (long level : paren_levels) {\n        max_level = std::max(max_level,\
    \ level);\n    }\n    std::vector<long> max_level_paren_levels;\n    for (long\
    \ level : paren_levels) {\n        max_level_paren_levels.push_back(max_level);\n\
    \    }\n    return max_level_paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0j9zqcpe.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(0);\n    paren_levels.push_back(0);\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcse5j92c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool in_paren = false;\n\
    \    for (char c : paren_string) {\n        if (c == '(') {\n            paren_level++;\n\
    \            in_paren = true;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            in_paren = false;\n        } else if (c == ' ' && in_paren) {\n \
    \           paren_levels[paren_level - 1]++;\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6ucqmi7g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long current_level = 0;\n  for (char c : paren_string) {\n    if (c == '(')\
    \ {\n      current_level++;\n    } else if (c == ')') {\n      current_level--;\n\
    \    }\n    paren_levels.push_back(current_level);\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprvj1y_49.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_char;\n\
    \    long level = 0;\n    for (auto &c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n            paren_char = \"(\";\n        } else if\
    \ (c == ')') {\n            level--;\n            paren_char = \")\";\n      \
    \  } else if (c == ' ') {\n            level = 0;\n        } else {\n        \
    \    paren_char = c; // Keep the original char\n        }\n        levels.push_back(level);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl3k9t_e_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    for (auto &c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level = paren_level + c;\n        } else if\
    \ (c == ')') {\n            paren_level = paren_level.substr(0, paren_level.size()\
    \ - 1);\n            paren_levels.push_back(std::stoi(paren_level));\n       \
    \     paren_level = c;\n        } else {\n            paren_level = paren_level\
    \ + c;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu_5s4ihz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n            paren_level_string = std::to_string(paren_level);\n\
    \        } else if (c == ')') {\n            paren_level--;\n            paren_level_string\
    \ = std::to_string(paren_level);\n        } else {\n            paren_level_string\
    \ = std::to_string(paren_level);\n        }\n        paren_levels.push_back(std::stoi(paren_level_string));\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7mr_ila1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long level = 0;\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    long opening_paren_level\
    \ = 0;\n    long closing_paren_level = 0;\n    for (auto c : paren_string) {\n\
    \        if (c == '(') {\n            is_open = true;\n            opening_paren_level\
    \ = level;\n            level++;\n        } else if (c == ')') {\n           \
    \ is_closed = true;\n            closing_paren_level = level;\n            level--;\n\
    \        } else if (is_open) {\n            level++;\n        } else if (is_closed)\
    \ {\n            level--;\n        }\n        if (level == opening_paren_level\
    \ && level == closing_paren_level) {\n            paren_levels.push_back(level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8z2tqcbe.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            current_level\
    \ = current_level + \"(\";\n        } else if (c == ')') {\n            current_level\
    \ = current_level.substr(0, current_level.size() - 1) + \")\";\n        } else\
    \ {\n            current_level = current_level + c;\n        }\n        if (current_level.find(\"\
    (\") == std::string::npos) {\n            levels.push_back(std::stoi(current_level));\n\
    \            current_level.clear();\n        }\n    }\n    return levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi9oa7dzo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.assign(paren_levels_temp.begin(),\
    \ paren_levels_temp.end());\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.assign(paren_levels_temp2.begin(),\
    \ paren_levels_temp2.end());\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.assign(paren_levels_temp3.begin(),\
    \ paren_levels_temp3.end());\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.assign(paren_levels_temp4.begin(),\
    \ paren_levels_temp4.end());\n    std::vector<long> paren_levels_temp6;\n    paren_levels_temp6.assign(paren_levels_temp5.begin(),\
    \ paren_levels_temp5.end());\n    std::vector<long> paren_levels_temp7;\n    paren_levels_temp7.assign(paren_levels_temp6.begin(),\
    \ paren_levels_temp6.end());\n    std::vector<long> paren_levels_temp8;\n    paren_levels_temp8.assign(paren_levels_temp7.begin(),\
    \ paren_levels_temp7.end());\n    std::vector<long> paren_levels_temp9;\n    paren_levels_temp9.assign(paren_levels_temp8.begin(),\
    \ paren_levels_temp8.end());\n    std::vector<long> paren_levels_temp10;\n   \
    \ paren_levels_temp10.assign(paren_levels_temp9.begin(), paren_levels_temp9.end());\n\
    \    std::vector<long> paren_levels_temp11;\n    paren_levels_temp11.assign(paren_levels_temp10.begin(),\
    \ paren_levels_temp10.end());\n    std::vector<long> paren_levels_temp12;\n  \
    \  paren_levels_temp12.assign(paren_levels_temp11.begin(), paren_levels_temp11.end());\n\
    \    std::vector<long> paren_levels_temp13;\n    paren_levels_temp13.assign(paren_levels_temp12.begin(),\
    \ paren_levels_temp12.end());\n    std::vector<long> paren_levels_temp14;\n  \
    \  paren_levels_temp14.assign(paren_levels_temp13.begin(), paren_levels_temp\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp18wcme5n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels.size());\n\
    \    long max_level = 0;\n    for (long i = 0; i < paren_levels.size(); i++) {\n\
    \        long current_level = paren_levels_temp[i];\n        long current_paren_level\
    \ = 0;\n        for (long j = 0; j < paren_levels[i].size(); j++) {\n        \
    \    if (paren_levels[i][j] == '(') {\n                current_paren_level++;\n\
    \            } else if (paren_levels[i][j] == ')') {\n                current_paren_level--;\n\
    \            }\n            if (current_paren_level > max_level) {\n         \
    \       max_level = current_paren_level;\n            }\n        }\n        paren_levels_temp.push_back(max_level);\n\
    \    }\n    return paren_levels_temp;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpplot2vs6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3otylwz1.cpp: In function 'int main()':\n/tmp/tmp3otylwz1.cpp:84:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3otylwz1.cpp:2:\n/tmp/tmp3otylwz1.cpp:85:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp3otylwz1.cpp:85:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp3otylwz1.cpp:85:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3otylwz1.cpp:85:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp3otylwz1.cpp:85:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp3otylwz1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long max_level = 0;\n  \
    \  long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n \
    \   bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_or_closing\
    \ = false;\n    bool is_opening_or_closed = false;\n    bool is_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_closing = false;\n    bool is_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening = false;\n    bool is_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_closed = false;\n   \
    \ bool is_opening_or_opening_or_opening_or_opening = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_closed = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening = false;\n  \
    \  bool is_opening_or_opening_or_opening_or_opening_or_opening_or_closing = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_closed = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening =\
    \ false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_open\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphfkia29z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n        } else if (c == ')') {\n            is_open = false;\n\
    \        } else if (is_open) {\n            paren_levels.push_back(level);\n \
    \           level++;\n        }\n    }\n    paren_levels.push_back(level);\n \
    \   return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpepr_4yoj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (is_open) {\n            paren_level += c;\n            if (paren_level\
    \ == \"(\") {\n                is_open = false;\n                level++;\n  \
    \          } else if (paren_level == \")\") {\n                is_open = false;\n\
    \                level--;\n            }\n        } else {\n            if (c\
    \ == '(') {\n                is_open = true;\n                level++;\n     \
    \       } else if (c == ')') {\n                is_open = true;\n            \
    \    level--;\n            }\n        }\n    }\n    levels.push_back(level);\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3j4r8qn4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n\
    \      paren_levels.push_back(paren_level);\n      paren_level++;\n    } else\
    \ if (c == ')') {\n      paren_level--;\n      assert(paren_level >= 0);\n   \
    \   paren_levels.push_back(paren_level);\n    }\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp18_pfj9a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long level = 0;\n\
    \    bool is_open = false;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            is_open = true;\n        } else if (c == ')') {\n      \
    \      is_open = false;\n        } else if (is_open) {\n            paren_levels.push_back(level);\n\
    \            level++;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpt1zi3frw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (char c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpidlv32sm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_levels.pop_back();\n\
    \        } else if (is_open) {\n            paren_level++;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuxvywwl7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(')')).split(\")\");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(paren_levels.size());\n    long max_level = 0;\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        if (paren_levels[i]\
    \ > max_level) {\n            max_level = paren_levels[i];\n        }\n    }\n\
    \    long max_level_temp = max_level;\n    for (long i = 0; i < paren_levels.size();\
    \ i++) {\n        if (paren_levels[i] > max_level) {\n            paren_levels_temp.push_back(paren_levels[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp2;\n    for (long i\
    \ = 0; i < paren_levels_temp.size(); i++) {\n        paren_levels_temp2.push_back(paren_levels_temp[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp3;\n    for (long i = 0; i < paren_levels_temp2.size();\
    \ i++) {\n        paren_levels_temp3.push_back(paren_levels_temp2[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp4;\n    for (long i = 0; i < paren_levels_temp3.size();\
    \ i++) {\n        paren_levels_temp4.push_back(paren_levels_temp3[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp5;\n    for (long i = 0; i < paren_levels_temp4.size();\
    \ i++) {\n        paren_levels_temp5.push_back(paren_levels_temp4[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp6;\n    for (long i = 0; i < paren_levels_temp5.size();\
    \ i++) {\n        paren_levels_temp6.push_back(paren_levels_temp5[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp7;\n    for (long i = 0; i < paren_levels_temp6.size();\
    \ i++) {\n        paren_levels_temp7.push_back(paren_levels_temp6[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp8;\n    for (long i = 0; i < paren_levels_temp7.size();\
    \ i++) {\n        paren_levels_temp8.push_back(paren_levels_temp7[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp9;\n    for (long i = 0; i < paren_levels_temp8.size();\
    \ i++) {\n        paren_levels_temp9.push_back(paren_levels_temp8[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp10;\n    for (long i = 0; i < paren_levels_temp9.size();\
    \ i++) {\n        paren_levels_temp10.push_back(paren_levels_temp9[i]);\n    }\n\
    \    std::vector<long> paren_levels_temp\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplk9_vjv7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_level_string;\n    std::string paren_level_char;\n    long\
    \ paren_level_counter = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3\
    \ = 0;\n    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n\
    \    long paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long\
    \ paren_level_counter8 = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10\
    \ = 0;\n    long paren_level_counter11 = 0;\n    long paren_level_counter12 =\
    \ 0;\n    long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n\
    \    long paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n  \
    \  long paren_level_counter17 = 0;\n    long paren_level_counter18 = 0;\n    long\
    \ paren_level_counter19 = 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21\
    \ = 0;\n    long paren_level_counter22 = 0;\n    long paren_level_counter23 =\
    \ 0;\n    long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n\
    \    long paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n  \
    \  long paren_level_counter28 = 0;\n    long paren_level_counter29 = 0;\n    long\
    \ paren_level_counter30 = 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32\
    \ = 0;\n    long paren_level_counter33 = 0;\n    long paren_level_counter34 =\
    \ 0;\n    long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n\
    \    long paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n  \
    \  long paren_level_counter39 = 0;\n    long paren_level_counter40 = 0;\n    long\
    \ paren_level_counter41 = 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43\
    \ = 0;\n    long paren_level_counter44 = 0;\n    long paren_level_counter45 =\
    \ 0;\n    long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n\
    \    long paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n  \
    \  long paren_level_counter50 = 0;\n    long paren_level_counter51 = 0;\n    long\
    \ paren_level_counter52 = 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54\
    \ = 0;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsjh9_588.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long max_level = 0;\n  \
    \  long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            level++;\n        }\n        else if (c == ')') {\n   \
    \         is_closed = true;\n            level--;\n        }\n        else if\
    \ (is_open && is_closed) {\n            if (level > max_level) {\n           \
    \     max_level = level;\n            }\n        }\n        else if (is_open)\
    \ {\n            is_open = false;\n        }\n        else if (is_closed) {\n\
    \            is_closed = false;\n        }\n    }\n    if (max_level > 0) {\n\
    \        result.push_back(max_level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpice_dj3z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long max_level = 0;\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    long\
    \ paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_index = 0;\n    long paren_level_count_max_index2\
    \ = 0;\n    long paren_level_count_max_index3 = 0;\n    long paren_level_count_max_index4\
    \ = 0;\n    long paren_level_count_max_index5 = 0;\n    long paren_level_count_max_index6\
    \ = 0;\n    long paren_level_count_max_index7 = 0;\n    long paren_level_count_max_index8\
    \ = 0;\n    long paren_level_count_max_index9 = 0;\n    long paren_level_count_max_index10\
    \ = 0;\n    long paren_level_count_max_index11 = 0;\n    long paren_level_count_max_index12\
    \ = 0;\n    long paren_level_count_max_index13 = 0;\n    long paren_level_count_max_index14\
    \ = 0;\n    long paren_level_count_max_index15 = 0;\n    long paren_level_count_max_index16\
    \ = 0;\n    long paren_level_count_max_index17 = 0;\n    long paren_level_count_max_index18\
    \ = 0;\n    long paren_level_count_max_index19 = 0;\n    long paren_level_count_max_index20\
    \ = 0;\n    long paren_level_count_max_index21 = 0;\n    long paren_level_count_max_index22\
    \ = 0;\n    long paren_level_count_max_index23 = 0;\n    long paren_level_count_max_index24\
    \ = 0;\n    long paren_level_count_max_index25 = 0;\n    long paren_level_count_max_index26\
    \ = 0;\n    long paren_level_count_max_index27 = 0;\n    long paren_level_count_max_index28\
    \ = 0;\n    long paren_level_count_max_index29 = 0;\n    long paren_level_count_max_index30\
    \ = 0;\n    long paren_level_count_max_index31 = 0;\n    long paren_level_count_max_index32\
    \ = 0;\n    long paren_level_count_max_index33 = 0;\n    long paren_level_count_max_index34\
    \ = 0;\n    long paren_level_count_max_index35 = 0;\n    long paren_level_count_max_index36\
    \ = 0;\n    long paren_level_count_max_index37 = 0;\n    long paren_level_count_max_index38\
    \ = 0;\n    long paren_level_count_max_index39 = 0;\n    long paren_level_count_max_index40\
    \ = 0;\n    long paren_level_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj_6_n5mz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            paren_level++;\n        } else if (c == ')') {\n    \
    \        paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnz_uzjxl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long paren_level =\
    \ 0;\n    long paren_level_count = 0;\n    std::string paren_string_reversed =\
    \ paren_string;\n    paren_string_reversed.rbegin();\n    paren_string_reversed.rend();\n\
    \    for (char c : paren_string_reversed) {\n        if (c == '(') {\n       \
    \     paren_level++;\n            paren_level_count++;\n        } else if (c ==\
    \ ')') {\n            paren_level--;\n            paren_level_count--;\n     \
    \   }\n        if (paren_level == 0 && paren_level_count == 0) {\n           \
    \ paren_levels.push_back(paren_level);\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5hnv178n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    std::vector<long> paren_levels_temp_temp;\n    std::vector<long>\
    \ paren_levels_temp_temp_temp;\n    std::vector<long> paren_levels_temp_temp_temp_temp;\n\
    \    long paren_levels_temp_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp = 0;\n    long paren_levels_temp_temp\
    \ = 0;\n    long paren_levels_temp = 0;\n    long paren_levels = 0;\n    long\
    \ paren_levels_temp_temp = 0;\n    long paren_levels_temp_temp_temp = 0;\n   \
    \ long paren_levels_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n \
    \   long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long\
    \ paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbt_lfwwx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    long paren_level_count = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level = paren_levels[paren_levels.size() - 1];\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n            paren_level =\
    \ paren_levels[paren_levels.size() - 1];\n        } else if (c == ' ') {\n   \
    \         paren_levels[paren_levels.size() - 1] += paren_level_count;\n      \
    \  }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxbvw7m0h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            level++;\n        } else if (c == ')') {\n            is_closed\
    \ = true;\n            level--;\n        } else if (c == ' ') {\n            if\
    \ (is_open && is_closed) {\n                paren_levels.push_back(level);\n \
    \           }\n            is_open = false;\n            is_closed = false;\n\
    \        } else {\n            is_open = false;\n            is_closed = false;\n\
    \        }\n    }\n    if (is_open && is_closed) {\n        paren_levels.push_back(level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx_t5a15p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    for (auto it = paren_string.begin(); it !=\
    \ paren_string.end(); ++it) {\n        if (*it == '(') {\n            paren_level\
    \ = *it;\n        } else if (*it == ')') {\n            paren_level += *it;\n\
    \            paren_levels.push_back(std::stoll(paren_level));\n            paren_level.clear();\n\
    \        } else {\n            paren_level += *it;\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgq8zqvrq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcxs577sx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long max_level = 0;\n  \
    \  long level = 0;\n    long pos = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space = false;\n    bool is_closing_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space_or_space = false;\n    bool is_closing_paren_or_space_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space_or_space = false;\n\
    \    bool is_closing_curly_bracket_or_paren_or_space_or_space = false;\n    bool\
    \ is_opening_square_bracket_or_paren_or_space_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space_or_space\
    \ = false;\n    bool is_opening_paren_or_space_or_space_or_space = false;\n  \
    \  bool is_closing_paren_or_space_or_space_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_opening_square_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_opening_paren_or_space_or_space_or_space_or_space = false;\n\
    \    bool is_closing_paren_or_space_or_space_or_space_or_space = false;\n    bool\
    \ is_opening_curly_bracket_or_paren_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpldth7ya5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp948rrb2y.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp948rrb2y.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp948rrb2y.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp948rrb2y.cpp: In function 'int main()':\n/tmp/tmp948rrb2y.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp948rrb2y.cpp:2:\n/tmp/tmp948rrb2y.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp948rrb2y.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp948rrb2y.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp948rrb2y.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp948rrb2y.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::string paren_char;\n\
    \    long level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        paren_char = paren_string[i];\n        if (paren_char == '(') {\n   \
    \         level++;\n        } else if (paren_char == ')') {\n            level--;\n\
    \        }\n        result.push_back(level);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8vhg13w_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_8ydi84b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            current_level++;\n\
    \        } else if (paren_string[i] == ')') {\n            current_level--;\n\
    \        }\n        paren_levels.push_back(current_level);\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptdldfyco.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long level = 0;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_level--;\n\
    \        } else if (is_open) {\n            paren_level++;\n        } else {\n\
    \            paren_level--;\n        }\n        if (paren_level == level) {\n\
    \            paren_levels[paren_levels.size() - 1]++;\n        } else {\n    \
    \        paren_levels.push_back(1);\n        }\n        level++;\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpm0i3uc_2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(paren_level);\n            paren_level++;\n \
    \       }\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7v2g78nr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long paren_level_count = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n            paren_level_count++;\n        } else if (c\
    \ == ')') {\n            is_closed = true;\n            paren_level_count--;\n\
    \        } else if (c == ' ' && is_open && !is_closed) {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level = 0;\n        } else if (c == ' ' && is_open && is_closed)\
    \ {\n            paren_level_count--;\n        } else if (c == ' ' && is_open\
    \ && !is_closed) {\n            paren_level_count++;\n        } else if (c ==\
    \ ' ' && is_open && is_closed) {\n            paren_level_count++;\n        }\
    \ else if (c == ' ') {\n            paren_level_count++;\n        } else if (c\
    \ == ')') {\n            paren_level_count--;\n        }\n        paren_level\
    \ += 1;\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2d88uty_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  paren_level = std::to_string(paren_level_count);\n        } else {\n      \
    \      paren_level += c;\n        }\n        if (paren_level_count == 0) {\n \
    \           paren_level_count = std::stoi(paren_level);\n            paren_levels.push_back(paren_level_count);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8mg0_7du.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    long paren_level_count = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            paren_level = paren_string.substr(0, i);\n            paren_level_count++;\n\
    \        } else if (paren_string[i] == ')') {\n            paren_level_count--;\n\
    \            if (paren_level_count == 0) {\n                paren_levels.push_back(paren_level);\n\
    \            }\n        }\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi_cwafb0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_levels.pop_back();\n\
    \        } else if (is_open) {\n            paren_level++;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuxvywwl7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &i : paren_levels) {\n        long paren_level = 0;\n        for\
    \ (auto &j : i) {\n            if (j == '(') {\n                paren_level++;\n\
    \            } else if (j == ')') {\n                paren_level--;\n        \
    \    }\n        }\n        paren_levels_temp.push_back(paren_level);\n    }\n\
    \    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.reserve(paren_levels_temp.size());\n\
    \    for (auto &i : paren_levels_temp) {\n        if (i == 0) {\n            paren_levels_temp2.push_back(0);\n\
    \        } else {\n            paren_levels_temp2.push_back(i);\n        }\n \
    \   }\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.reserve(paren_levels_temp2.size());\n\
    \    for (auto &i : paren_levels_temp2) {\n        paren_levels_temp3.push_back(i);\n\
    \    }\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.reserve(paren_levels_temp3.size());\n\
    \    for (auto &i : paren_levels_temp3) {\n        paren_levels_temp4.push_back(i);\n\
    \    }\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.reserve(paren_levels_temp4.size());\n\
    \    for (auto &i : paren_levels_temp4) {\n        paren_levels_temp5.push_back(i);\n\
    \    }\n    std::vector<long> paren_levels_temp6;\n    paren_levels_temp6.reserve(paren_levels_temp5.size());\n\
    \    for (auto &i : paren_levels_temp5) {\n        paren_levels_temp6.push_back(i);\n\
    \    }\n    std::vector<long> paren_levels_temp7;\n    paren_levels_temp7.reserve(paren_levels_temp6.size());\n\
    \    for (auto &i : paren_levels_temp6) {\n        paren_levels_temp7.push_back(i);\n\
    \    }\n    std::vector<long> paren_levels_temp8;\n    paren_levels_temp8.reserve(paren_levels_temp7.size());\n\
    \    for (auto &i : paren_levels_temp7) {\n        paren_levels_temp8.push_back(i);\n\
    \    }\n    std::vector<\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfn39uiif.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    size_t paren_start = 0;\n    size_t paren_end\
    \ = 0;\n    size_t paren_end_paren = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_start = i;\n\
    \        } else if (paren_string[i] == ')') {\n            paren_end = i;\n  \
    \          paren_end_paren = i;\n        } else if (paren_string[i] == ' ') {\n\
    \            paren_level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          paren_level--;\n        }\n        if (paren_level == 0) {\n      \
    \      paren_levels.push_back(paren_end - paren_start);\n        }\n    }\n  \
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplz633htp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(paren_levels.size());\n    long paren_level = 0;\n\
    \    long paren_level_counter = 0;\n    long paren_level_counter2 = 0;\n    long\
    \ paren_level_counter3 = 0;\n    long paren_level_counter4 = 0;\n    long paren_level_counter5\
    \ = 0;\n    long paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n\
    \    long paren_level_counter8 = 0;\n    long paren_level_counter9 = 0;\n    long\
    \ paren_level_counter10 = 0;\n    long paren_level_counter11 = 0;\n    long paren_level_counter12\
    \ = 0;\n    long paren_level_counter13 = 0;\n    long paren_level_counter14 =\
    \ 0;\n    long paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n\
    \    long paren_level_counter17 = 0;\n    long paren_level_counter18 = 0;\n  \
    \  long paren_level_counter19 = 0;\n    long paren_level_counter20 = 0;\n    long\
    \ paren_level_counter21 = 0;\n    long paren_level_counter22 = 0;\n    long paren_level_counter23\
    \ = 0;\n    long paren_level_counter24 = 0;\n    long paren_level_counter25 =\
    \ 0;\n    long paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n\
    \    long paren_level_counter28 = 0;\n    long paren_level_counter29 = 0;\n  \
    \  long paren_level_counter30 = 0;\n    long paren_level_counter31 = 0;\n    long\
    \ paren_level_counter32 = 0;\n    long paren_level_counter33 = 0;\n    long paren_level_counter34\
    \ = 0;\n    long paren_level_counter35 = 0;\n    long paren_level_counter36 =\
    \ 0;\n    long paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n\
    \    long paren_level_counter39 = 0;\n    long paren_level_counter40 = 0;\n  \
    \  long paren_level_counter41 = 0;\n    long paren_level_counter42 = 0;\n    long\
    \ paren_level_counter43 = 0;\n    long paren_level_counter44 = 0;\n    long paren_level_counter45\
    \ = 0;\n    long paren_level_counter46 = 0;\n    long paren_level_counter47 =\
    \ 0;\n    long paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n\
    \    long paren_level_counter50 = 0;\n    long paren_level_counter51 = 0;\n  \
    \  long paren_level_counter52 = 0;\n    long paren_level_counter53 = 0;\n    long\
    \ paren_level_counter\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjxeafcuo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_string = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n    std::string paren_level_string = paren_string;\n    std::string paren_level_char;\n\
    \    long paren_level = 0;\n    long paren_level_counter = 0;\n    long paren_level_counter2\
    \ = 0;\n    long paren_level_counter3 = 0;\n    long paren_level_counter4 = 0;\n\
    \    long paren_level_counter5 = 0;\n    long paren_level_counter6 = 0;\n    long\
    \ paren_level_counter7 = 0;\n    long paren_level_counter8 = 0;\n    long paren_level_counter9\
    \ = 0;\n    long paren_level_counter10 = 0;\n    long paren_level_counter11 =\
    \ 0;\n    long paren_level_counter12 = 0;\n    long paren_level_counter13 = 0;\n\
    \    long paren_level_counter14 = 0;\n    long paren_level_counter15 = 0;\n  \
    \  long paren_level_counter16 = 0;\n    long paren_level_counter17 = 0;\n    long\
    \ paren_level_counter18 = 0;\n    long paren_level_counter19 = 0;\n    long paren_level_counter20\
    \ = 0;\n    long paren_level_counter21 = 0;\n    long paren_level_counter22 =\
    \ 0;\n    long paren_level_counter23 = 0;\n    long paren_level_counter24 = 0;\n\
    \    long paren_level_counter25 = 0;\n    long paren_level_counter26 = 0;\n  \
    \  long paren_level_counter27 = 0;\n    long paren_level_counter28 = 0;\n    long\
    \ paren_level_counter29 = 0;\n    long paren_level_counter30 = 0;\n    long paren_level_counter31\
    \ = 0;\n    long paren_level_counter32 = 0;\n    long paren_level_counter33 =\
    \ 0;\n    long paren_level_counter34 = 0;\n    long paren_level_counter35 = 0;\n\
    \    long paren_level_counter36 = 0;\n    long paren_level_counter37 = 0;\n  \
    \  long paren_level_counter38 = 0;\n    long paren_level_counter39 = 0;\n    long\
    \ paren_level_counter40 = 0;\n    long paren_level_counter41 = 0;\n    long paren_level_counter42\
    \ = 0;\n    long paren_level_counter43 = 0;\n    long paren_level_counter44 =\
    \ 0;\n    long paren_level_counter45 = 0;\n    long paren_level_counter46 = 0;\n\
    \    long paren_level_counter47 = 0;\n    long paren_level_counter48 = 0;\n  \
    \  long paren_level_counter49 = 0;\n    long paren_level_counter50 = 0;\n    long\
    \ paren_level_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz6d7z9is.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels_t paren_levels_temp;\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_level\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1dpo75w8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcxs577sx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  std::string current_paren_string = paren_string;\n  long current_paren_level\
    \ = 0;\n  while (current_paren_string.size() > 0) {\n    long current_paren_level\
    \ = std::count(current_paren_string.begin(), current_paren_string.end(), ')');\n\
    \    current_paren_string = current_paren_string.substr(0, current_paren_string.size()\
    \ - current_paren_level);\n    paren_levels.push_back(current_paren_level);\n\
    \  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4yvsll3i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    std::string current_paren_string = \"\";\n   \
    \ std::string current_paren_group = \"\";\n    for (auto c : paren_string) {\n\
    \        if (c == '(') {\n            paren_level++;\n            current_paren_group\
    \ += c;\n        } else if (c == ')') {\n            paren_level--;\n        \
    \    current_paren_group += c;\n            current_paren_string = current_paren_group;\n\
    \            paren_levels.push_back(paren_level);\n            current_paren_group.clear();\n\
    \        } else {\n            current_paren_string += c;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8hbo4n2d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpechfbjd6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821954
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level_count++;\n            paren_level = paren_level\
    \ + c;\n        } else if (c == ')') {\n            paren_level_count--;\n   \
    \         paren_level = paren_level.substr(0, paren_level.size() - 1);\n     \
    \       paren_level_count = paren_level_count < 0 ? 0 : paren_level_count;\n \
    \           paren_levels.push_back(paren_level_count);\n            paren_level\
    \ = c;\n        } else {\n            paren_level = paren_level + c;\n       \
    \ }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5ycos4mp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\" \");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(paren_levels.size());\n    long paren_level =\
    \ 1;\n    for (auto &paren_levels_itr : paren_levels_temp) {\n        paren_levels_itr\
    \ = paren_level;\n        paren_level++;\n    }\n    std::vector<long> paren_levels_itr;\n\
    \    for (auto &paren_levels_itr : paren_levels_temp) {\n        paren_levels_itr.push_back(paren_levels_itr);\n\
    \    }\n    std::vector<long> paren_levels_itr_temp;\n    paren_levels_itr_temp.push_back(paren_levels_itr);\n\
    \    for (long paren_levels_itr_temp_index = 0; paren_levels_itr_temp_index <\
    \ paren_levels_temp.size(); paren_levels_itr_temp_index++) {\n        std::vector<long>\
    \ paren_levels_itr_temp;\n        paren_levels_itr_temp.push_back(paren_levels_itr_temp_index);\n\
    \        for (long paren_levels_itr_temp_index_2 = 0; paren_levels_itr_temp_index_2\
    \ < paren_levels_itr_temp[paren_levels_itr_temp_index].size(); paren_levels_itr_temp_index_2++)\
    \ {\n            paren_levels_itr_temp.push_back(paren_levels_itr_temp[paren_levels_itr_temp_index][paren_levels_itr_temp_index_2]);\n\
    \        }\n        paren_levels_itr_temp.push_back(paren_levels_itr_temp[paren_levels_itr_temp_index].size());\n\
    \        paren_levels_itr_temp_temp.push_back(paren_levels_itr_temp);\n    }\n\
    \    std::vector<long> paren_levels_itr_temp_temp;\n    paren_levels_itr_temp_temp.push_back(paren_levels_itr_temp);\n\
    \    for (long paren_levels_itr_temp_temp_index = 0; paren_levels_itr_temp_temp_index\
    \ < paren_levels_temp.size() - 1; paren_levels_itr_temp_temp_index++) {\n    \
    \    std::vector<long> paren_levels_itr_temp_temp;\n        paren_levels_itr_temp_temp.push_back(paren_levels_itr_temp_temp_index);\n\
    \        for (long paren_levels_itr_temp_temp_index_2 = 0; paren_levels_itr_temp_temp_index_2\
    \ < paren_levels_itr_temp_temp[paren_levels_itr_temp_temp_index].size() - 1; paren_levels_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzga_oqlu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_level = \"\";\n    for (auto c : paren_string) {\n\
    \        if (c == '(') {\n            curr_paren_level += c;\n        } else if\
    \ (c == ')') {\n            curr_paren_level += c;\n            paren_levels.push_back(std::stoi(curr_paren_level));\n\
    \            curr_paren_level = \"\";\n        } else {\n            curr_paren_level\
    \ += c;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp49mco04l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821953
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long current_level = 0;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            level++;\n\
    \        }\n        else if (c == ')') {\n            is_open = false;\n     \
    \       level--;\n        }\n        else if (is_open) {\n            level++;\n\
    \        }\n        else {\n            result.push_back(level);\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfmzodj_x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level++;\n        } else if (c == ')') {\n      \
    \      is_open = false;\n            paren_level--;\n        } else if (is_open)\
    \ {\n            paren_levels.push_back(paren_level);\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpewvg70mb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  if (paren_level_count == 0) {\n                paren_levels.push_back(paren_level);\n\
    \                paren_level_count = 0;\n            }\n        }\n        paren_level++;\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpekg6w06f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            paren_level++;\n        } else if (c == ')') {\n    \
    \        paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnz_uzjxl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyhyj8c7_.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyhyj8c7_.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpyhyj8c7_.cpp:20:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpyhyj8c7_.cpp:20:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpyhyj8c7_.cpp:21:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpyhyj8c7_.cpp:21:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpyhyj8c7_.cpp: In function 'int\
    \ main()':\n/tmp/tmpyhyj8c7_.cpp:24:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyhyj8c7_.cpp:2:\n/tmp/tmpyhyj8c7_.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpyhyj8c7_.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpyhyj8c7_.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            level--;\n\
    \        } else if (is_open) {\n            level++;\n        } else {\n     \
    \       level--;\n        }\n        paren_levels.push_back(level);\n    }\n \
    \   return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3qqrd_f7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels_t paren_levels_t;\n\
    \    paren_levels_t.clear();\n    paren_levels_t.push_back(paren_levels);\n  \
    \  paren_levels_t paren_levels_t1;\n    paren_levels_t1.clear();\n    paren_levels_t1.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t2;\n    paren_levels_t2.clear();\n    paren_levels_t2.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t3;\n    paren_levels_t3.clear();\n    paren_levels_t3.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t4;\n    paren_levels_t4.clear();\n    paren_levels_t4.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t5;\n    paren_levels_t5.clear();\n    paren_levels_t5.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t6;\n    paren_levels_t6.clear();\n    paren_levels_t6.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t7;\n    paren_levels_t7.clear();\n    paren_levels_t7.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t8;\n    paren_levels_t8.clear();\n    paren_levels_t8.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t9;\n    paren_levels_t9.clear();\n    paren_levels_t9.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t10;\n    paren_levels_t10.clear();\n    paren_levels_t10.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t11;\n    paren_levels_t11.clear();\n    paren_levels_t11.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t12;\n    paren_levels_t12.clear();\n    paren_levels_t12.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t13;\n    paren_levels_t13.clear();\n    paren_levels_t13.push_back(paren_levels);\n\
    \    paren_levels_t paren_levels_t14;\n    paren_levels_t14.\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp02wmfeml.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n      assert(level >= 0);\n      paren_levels.push_back(level);\n\
    \    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjsdufv4w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (char c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpidlv32sm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822032
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string current_paren_string = paren_string;\n    long current_paren_level\
    \ = 0;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_opening_paren\
    \ = true;\n            current_paren_level++;\n        }\n        else if (c ==\
    \ ')') {\n            is_closing_paren = true;\n            current_paren_level--;\n\
    \        }\n        else if (c == ' ') {\n            if (is_opening_paren &&\
    \ is_closing_paren) {\n                paren_levels.push_back(current_paren_level);\n\
    \            }\n            current_paren_string = \"\";\n        }\n        else\
    \ if (c == '(' || c == '[' || c == '{') {\n            current_paren_string +=\
    \ c;\n        }\n        else if (c == ']' || c == '}') {\n            current_paren_string\
    \ += c;\n        }\n    }\n    if (current_paren_string.empty()) {\n        paren_levels.push_back(current_paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkqyytc2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long current_level\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   current_level++;\n        } else if (c == ')') {\n            current_level--;\n\
    \        }\n        if (current_level > 0) {\n            paren_levels.push_back(current_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd6casxnc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    for (long i = 1; i < paren_levels.size(); i++) {\n        long paren_level\
    \ = paren_levels[i];\n        long paren_levels_temp_size = paren_levels_temp.size();\n\
    \        long paren_levels_temp_size = paren_levels_temp_size + 1;\n        if\
    \ (paren_levels_temp_size >= paren_level) {\n            paren_levels_temp[paren_levels_temp_size]\
    \ = paren_levels_temp[paren_levels_temp_size] + 1;\n        } else {\n       \
    \     paren_levels_temp.push_back(1);\n        }\n    }\n    return paren_levels_temp;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoccsd85x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n   \
    \   level++;\n    } else if (c == ')') {\n      level--;\n    }\n    paren_levels.push_back(level);\n\
    \  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5_g1umbn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    long current_level_size = 1;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    for (auto c : paren_string) {\n        if (c == '(') {\n     \
    \       is_open = true;\n            current_level = c;\n            current_level_size\
    \ = 1;\n        } else if (c == ')') {\n            is_closed = true;\n      \
    \      current_level = c;\n            current_level_size = 1;\n        } else\
    \ if (c == ' ') {\n            if (is_open) {\n                current_level +=\
    \ c;\n                current_level_size += 1;\n            } else if (is_closed)\
    \ {\n                levels.push_back(current_level_size);\n                current_level_size\
    \ = 1;\n            }\n        } else {\n            current_level += c;\n   \
    \         current_level_size += 1;\n        }\n    }\n    levels.push_back(current_level_size);\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5y0inlpp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    long paren_levels_sum = 0;\n    for (long i = 0; i\
    \ < paren_levels_temp.size(); i++) {\n        paren_levels_sum += paren_levels_temp[i];\n\
    \    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    long paren_levels_sum2 = 0;\n    for (long i = 0;\
    \ i < paren_levels_temp2.size(); i++) {\n        paren_levels_sum2 += paren_levels_temp2[i];\n\
    \    }\n    long paren_levels_sum3 = paren_levels_sum - paren_levels_sum2;\n \
    \   long paren_levels_sum4 = paren_levels_sum2 - paren_levels_sum3;\n    long\
    \ paren_levels_sum5 = paren_levels_sum3 - paren_levels_sum4;\n    long paren_levels_sum6\
    \ = paren_levels_sum4 - paren_levels_sum5;\n    long paren_levels_sum7 = paren_levels_sum5\
    \ - paren_levels_sum6;\n    long paren_levels_sum8 = paren_levels_sum6 - paren_levels_sum7;\n\
    \    long paren_levels_sum9 = paren_levels_sum7 - paren_levels_sum8;\n    long\
    \ paren_levels_sum10 = paren_levels_sum8 - paren_levels_sum9;\n    long paren_levels_sum11\
    \ = paren_levels_sum9 - paren_levels_sum10;\n    long paren_levels_sum12 = paren_levels_sum10\
    \ - paren_levels_sum11;\n    long paren_levels_sum13 = paren_levels_sum11 - paren_levels_sum12;\n\
    \    long paren_levels_sum14 = paren_levels_sum12 - paren_levels_sum13;\n    long\
    \ paren_levels_sum15 = paren_levels_sum13 - paren_levels_sum14;\n    long paren_levels_sum16\
    \ = paren_levels_sum14 - paren_levels_sum15;\n    long paren_levels_sum17 = paren_levels_sum15\
    \ - paren_levels_sum16;\n    long paren_levels_sum18 = paren_levels_sum16 - paren_levels_sum17;\n\
    \    long paren_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_l6npp5o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    size_t paren_level_count = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            paren_level_count++;\n        } else if (paren_string[i] == ')')\
    \ {\n            paren_level_count--;\n        }\n        if (paren_level_count\
    \ == 0) {\n            paren_levels.push_back(paren_level);\n            paren_level_count\
    \ = 0;\n            paren_level++;\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4f7vzewk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    std::vector<long> paren_levels_temp_temp;\n    long\
    \ paren_levels_temp_temp_temp;\n    long paren_levels_temp_temp2;\n    long paren_levels_temp_temp3;\n\
    \    long paren_levels_temp_temp4;\n    long paren_levels_temp_temp5;\n    long\
    \ paren_levels_temp_temp6;\n    long paren_levels_temp_temp7;\n    long paren_levels_temp_temp8;\n\
    \    long paren_levels_temp_temp9;\n    long paren_levels_temp_temp10;\n    long\
    \ paren_levels_temp_temp11;\n    long paren_levels_temp_temp12;\n    long paren_levels_temp_temp13;\n\
    \    long paren_levels_temp_temp14;\n    long paren_levels_temp_temp15;\n    long\
    \ paren_levels_temp_temp16;\n    long paren_levels_temp_temp17;\n    long paren_levels_temp_temp18;\n\
    \    long paren_levels_temp_temp19;\n    long paren_levels_temp_temp20;\n    long\
    \ paren_levels_temp_temp21;\n    long paren_levels_temp_temp22;\n    long paren_levels_temp_temp23;\n\
    \    long paren_levels_temp_temp24;\n    long paren_levels_temp_temp25;\n    long\
    \ paren_levels_temp_temp26;\n    long paren_levels_temp_temp27;\n    long paren_levels_temp_temp28;\n\
    \    long paren_levels_temp_temp29;\n    long paren_levels_temp_temp30;\n    long\
    \ paren_levels_temp_temp31;\n    long paren_levels_temp_temp32;\n    long paren_levels_temp_temp33;\n\
    \    long paren_levels_temp_temp34;\n    long paren_levels_temp_temp35;\n    long\
    \ paren_levels_temp_temp36;\n    long paren_levels_temp_temp37;\n    long paren_levels_temp_temp38;\n\
    \    long paren_levels_temp_temp39;\n    long paren_levels_temp_temp40;\n    long\
    \ paren_levels_temp_temp41;\n    long paren_levels_temp_temp42;\n    long paren_levels_temp_temp43;\n\
    \    long paren_levels_temp_temp44;\n    long paren_levels_temp_temp45;\n    long\
    \ paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp155u71zh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            current_level\
    \ = current_level + \"(\";\n        } else if (c == ')') {\n            current_level\
    \ = current_level.substr(0, current_level.length() - 1) + \")\";\n        } else\
    \ {\n            current_level = current_level + c;\n        }\n        if (current_level.length()\
    \ == 0) {\n            levels.push_back(std::stoi(current_level));\n         \
    \   current_level.clear();\n        }\n    }\n    return levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoafzb2so.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_temp.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse;\n    paren_levels_temp_reverse.reserve(paren_levels_temp.size());\n\
    \    for (auto &level : paren_levels_temp) {\n        paren_levels_temp_reverse.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp;\n    paren_levels_temp_reverse_temp.reserve(paren_levels_temp_reverse.size());\n\
    \    for (auto &level : paren_levels_temp_reverse) {\n        paren_levels_temp_reverse_temp.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp_reverse;\n    paren_levels_temp_reverse_temp_reverse.reserve(paren_levels_temp_reverse_temp.size());\n\
    \    for (auto &level : paren_levels_temp_reverse_temp) {\n        paren_levels_temp_reverse_temp_reverse.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp_reverse_temp;\n \
    \   paren_levels_temp_reverse_temp_reverse_temp.reserve(paren_levels_temp_reverse_temp_reverse.size());\n\
    \    for (auto &level : paren_levels_temp_reverse_temp_reverse) {\n        paren_levels_temp_reverse_temp_reverse_temp.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp_reverse_temp_reverse;\n\
    \    paren_levels_temp_reverse_temp_reverse_temp_reverse.reserve(paren_levels_temp_reverse_temp_reverse_temp.size());\n\
    \    for (auto &level : paren_levels_temp_reverse_temp_reverse_temp) {\n     \
    \   paren_levels_temp_reverse_temp_reverse_temp_reverse.push_back(level);\n  \
    \  }\n    std::vector<long> paren_levels_temp_reverse_temp_reverse_temp_reverse_temp;\n\
    \    paren_levels_temp_reverse_temp_reverse_temp_reverse_temp.reserve(paren_levels_temp_reverse_temp_reverse_temp_reverse.size());\n\
    \    for (auto &level : paren_levels_temp_reverse_temp_reverse_temp_reverse) {\n\
    \        paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkxl395o5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(')')).split(\")\");\n  for (auto &level : paren_levels)\
    \ {\n    level = level.substr(0, level.find_first_of('('));\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmo778azi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n            paren_level_string = std::to_string(paren_level);\n\
    \        } else if (c == ')') {\n            paren_level--;\n            paren_level_string\
    \ = std::to_string(paren_level);\n            paren_levels.push_back(std::stoi(paren_level_string));\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmper2dco4a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string curr_paren_string\
    \ = paren_string;\n    long curr_paren_level = 0;\n    bool is_first_paren = true;\n\
    \    while (curr_paren_string != \"\") {\n        if (curr_paren_string[0] ==\
    \ '(') {\n            curr_paren_level++;\n        } else if (curr_paren_string[0]\
    \ == ')') {\n            curr_paren_level--;\n        }\n        curr_paren_string\
    \ = curr_paren_string.substr(1);\n        if (curr_paren_level == 0) {\n     \
    \       paren_levels.push_back(curr_paren_level);\n        }\n        is_first_paren\
    \ = true;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph_5hr4ue.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  long paren_level_counter = 1;\n  long paren_level_counter_reset\
    \ = 1;\n  long paren_level_counter_reset_reset = 1;\n  for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n      paren_levels.push_back(paren_level);\n\
    \      paren_level++;\n      paren_level_counter++;\n      paren_level_counter_reset++;\n\
    \      paren_level_counter_reset_reset++;\n    } else if (paren_string[i] == ')')\
    \ {\n      paren_level--;\n      paren_level_counter--;\n      paren_level_counter_reset--;\n\
    \      paren_level_counter_reset_reset--;\n      if (paren_level == 0) {\n   \
    \     paren_levels.push_back(paren_level);\n      }\n    }\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa_leszzp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5lm4hx94.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\")\")).split(\")\");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.reserve(paren_levels.size());\n    for (auto &level : paren_levels)\
    \ {\n        paren_levels_temp.push_back(level.length());\n    }\n    std::vector<long>\
    \ paren_levels_temp2 = paren_levels_temp;\n    paren_levels_temp2.push_back(paren_levels_temp2.back());\n\
    \    long max_level = 0;\n    for (auto &level : paren_levels_temp2) {\n     \
    \   if (level > max_level) {\n            max_level = level;\n        }\n    }\n\
    \    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.reserve(max_level\
    \ + 1);\n    for (auto &level : paren_levels_temp2) {\n        if (level == max_level)\
    \ {\n            paren_levels_temp3.push_back(level);\n        } else {\n    \
    \        paren_levels_temp3.push_back(level + 1);\n        }\n    }\n    return\
    \ paren_levels_temp3;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9th7tq0x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_level;\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == '(') {\n            curr_paren_level\
    \ = paren_levels.size();\n            paren_levels.push_back(curr_paren_level);\n\
    \        } else if (paren_string[i] == ')') {\n            long curr_level = curr_paren_level;\n\
    \            while (curr_level > 0) {\n                --curr_level;\n       \
    \         paren_levels.push_back(curr_level);\n            }\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplt6vlamg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (size_t i = 0;\
    \ i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n   \
    \         is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (paren_string[i] == ')') {\n            is_open = false;\n\
    \            paren_level--;\n        } else if (is_open) {\n            paren_level++;\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg5nnjas7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    bool paren_level_found = false;\n    for\
    \ (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level = std::to_string(paren_level_count);\n            paren_level_count\
    \ = 0;\n            paren_level_found = true;\n        } else if (c == ')') {\n\
    \            paren_level_count--;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n            paren_level_found = true;\n \
    \       } else if (c == ' ') {\n            if (paren_level_found) {\n       \
    \         paren_level += c;\n            }\n        } else {\n            assert(false);\n\
    \        }\n    }\n    if (paren_level_found) {\n        paren_level_count--;\n\
    \        paren_level = std::to_string(paren_level_count);\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == ' ') {\n         \
    \   if (paren_level_found) {\n                paren_level += c;\n            }\n\
    \        } else {\n            assert(false);\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == ')') {\n         \
    \   if (paren_level_found) {\n                paren_level += c;\n            }\n\
    \        } else {\n            assert(false);\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   if (paren_level_found) {\n                paren_level += c;\n            }\n\
    \        } else {\n            assert(false);\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == ' ') {\n         \
    \   if (paren_level_found) {\n                paren_level += c;\n            }\n\
    \        } else {\n            assert(false);\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == ')') {\n         \
    \   if (paren_level_found) {\n                paren_level += c;\n            }\n\
    \        } else {\n            assert(false);\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   if (paren_level_found) {\n                paren_level += c;\n            }\n\
    \        } else {\n            assert(false);\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == ' ') {\n         \
    \   if (paren_level_found) {\n                paren_level += c;\n            }\n\
    \        } else {\n            assert(false);\n        }\n    }\n    paren_level\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7qnklvyl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnbik9p63.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpnbik9p63.cpp:12:16: error: ISO C++ forbids declaration of 'c' with no\
    \ type [-fpermissive]\n     for (auto &c : paren_string) {\n                ^\n\
    /tmp/tmpnbik9p63.cpp:12:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &c : paren_string) {\n                    ^\n/tmp/tmpnbik9p63.cpp:\
    \ In function 'int main()':\n/tmp/tmpnbik9p63.cpp:24:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpnbik9p63.cpp:2:\n/tmp/tmpnbik9p63.cpp:25:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpnbik9p63.cpp:25:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpnbik9p63.cpp:25:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpnbik9p63.cpp:25:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnbik9p63.cpp:25:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnbik9p63.cpp:25:113: note: candidates are:\nIn file included from /usr/includ"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string curr_paren_string\
    \ = paren_string;\n    long curr_level = 0;\n    bool is_first_paren = true;\n\
    \    bool is_last_paren = true;\n    bool is_last_level_of_parens = false;\n \
    \   long last_paren_level = 0;\n    long last_paren_level_of_parens = 0;\n   \
    \ long last_paren_level_of_parens_count = 0;\n    long last_paren_level_of_parens_count_of_parens\
    \ = 0;\n    long last_paren_level_of_parens_count_of_parens_count = 0;\n    long\
    \ paren_level_of_parens_count_of_parens = 0;\n    long paren_level_of_parens_count_of_parens_count\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens = 0;\n\
    \    long paren_level_of_parens_count_of_parens_count_of_parens_count = 0;\n \
    \   long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens\
    \ = 0;\n    long paren_level_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_of_parens_count_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcgew3w3f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcxs577sx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821955
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy = paren_levels;\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        long paren_level\
    \ = paren_levels[i];\n        long paren_level_count = 0;\n        long paren_level_count_copy\
    \ = 0;\n        for (long j = 0; j < paren_levels_copy.size(); j++) {\n      \
    \      if (paren_levels_copy[j] == paren_level) {\n                paren_level_count++;\n\
    \                paren_level_count_copy++;\n            }\n        }\n       \
    \ if (paren_level_count_copy == 0) {\n            paren_levels_copy.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels_copy;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp77hg8ra1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ');\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.reserve(paren_levels.size());\n    for (long i = 0; i <\
    \ paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    long paren_levels_size = paren_levels_temp.size();\n    long paren_levels_max_size\
    \ = paren_levels_temp[paren_levels_size - 1];\n    long paren_levels_max_size_index\
    \ = 0;\n    for (long i = 0; i < paren_levels_size; i++) {\n        if (paren_levels_temp[i]\
    \ > paren_levels_max_size) {\n            paren_levels_max_size = paren_levels_temp[i];\n\
    \            paren_levels_max_size_index = i;\n        }\n    }\n    long paren_levels_max_size_index_temp\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp2 =\
    \ paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp3 = paren_levels_max_size_index;\n\
    \    long paren_levels_max_size_index_temp4 = paren_levels_max_size_index;\n \
    \   long paren_levels_max_size_index_temp5 = paren_levels_max_size_index;\n  \
    \  long paren_levels_max_size_index_temp6 = paren_levels_max_size_index;\n   \
    \ long paren_levels_max_size_index_temp7 = paren_levels_max_size_index;\n    long\
    \ paren_levels_max_size_index_temp8 = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp9\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp10\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp11\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp12\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp13\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp14\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp15\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp16\
    \ = paren_levels_max_size_index;\n    long paren_levels_max_size_index_temp17\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyeckal7p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659822033
