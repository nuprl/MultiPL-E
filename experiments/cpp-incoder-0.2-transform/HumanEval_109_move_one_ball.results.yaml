language: cpp
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    long temp;\n    for (int i = 0; i < n; i++) {\n        temp = arr[i];\n\
    \        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        count++;\n\
    \    }\n    if (count == 0) {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4qnwu704.cpp: In function 'int main()':\n/tmp/tmp4qnwu704.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4qnwu704.cpp:2:\n/tmp/tmp4qnwu704.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp4qnwu704.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp4qnwu704.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp4qnwu704.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp4qnwu704.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp4qnwu704.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4qnwu704.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != 0) {\n      \
    \      count++;\n            int temp = arr[i];\n            arr[i] = 0;\n   \
    \         arr[n-1] = temp;\n        }\n    }\n    if (count == 0) {\n        return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9ozbuxqv.cpp: In function 'int main()':\n/tmp/tmp9ozbuxqv.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ozbuxqv.cpp:2:\n/tmp/tmp9ozbuxqv.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp9ozbuxqv.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp9ozbuxqv.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp9ozbuxqv.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp9ozbuxqv.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp9ozbuxqv.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ozbuxqv.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i) {\n      \
    \      count++;\n        }\n    }\n    if (count == 0) {\n        return true;\n\
    \    }\n    int m = n / 2;\n    for (int i = 0; i < m; i++) {\n        int temp\
    \ = arr[i];\n        arr[i] = arr[n - 1 - i];\n        arr[n - 1 - i] = temp;\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i) {\n      \
    \      return false;\n        }\n    }\n    return true;\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb6tbpkv7.cpp: In function 'int main()':\n/tmp/tmpb6tbpkv7.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb6tbpkv7.cpp:2:\n/tmp/tmpb6tbpkv7.cpp:50:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpb6tbpkv7.cpp:50:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpb6tbpkv7.cpp:50:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpb6tbpkv7.cpp:50:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpb6tbpkv7.cpp:50:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpb6tbpkv7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb6tbpkv7.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i) {\n      \
    \      count++;\n        }\n    }\n    if (count == 0) {\n        return true;\n\
    \    }\n    int m = n / 2;\n    for (int i = 0; i < m; i++) {\n        long temp\
    \ = arr[i];\n        arr[i] = arr[m];\n        arr[m] = temp;\n    }\n    for\
    \ (int i = m + 1; i < n; i++) {\n        long temp = arr[i];\n        arr[i] =\
    \ arr[0];\n        arr[0] = temp;\n    }\n    for (int i = 0; i < n; i++) {\n\
    \        if (arr[i] != i) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmo_rbsz5.cpp: In function 'int main()':\n/tmp/tmpmo_rbsz5.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmo_rbsz5.cpp:2:\n/tmp/tmpmo_rbsz5.cpp:55:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpmo_rbsz5.cpp:55:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpmo_rbsz5.cpp:55:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmo_rbsz5.cpp:55:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmo_rbsz5.cpp:55:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpmo_rbsz5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmo_rbsz5.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i) {\n      \
    \      count++;\n        }\n    }\n    if (count == 0) {\n        return true;\n\
    \    }\n    int m = n / 2;\n    for (int i = 0; i < m; i++) {\n        long temp\
    \ = arr[i];\n        arr[i] = arr[n - 1];\n        arr[n - 1] = temp;\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpum5co88d.cpp: In function 'int main()':\n/tmp/tmpum5co88d.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpum5co88d.cpp:2:\n/tmp/tmpum5co88d.cpp:45:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpum5co88d.cpp:45:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpum5co88d.cpp:45:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpum5co88d.cpp:45:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpum5co88d.cpp:45:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpum5co88d.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpum5co88d.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    long long\
    \ int n = arr.size();\n    long long int m = n/2;\n    long long int temp;\n \
    \   long long int count = 0;\n    for(int i=0;i<m;i++)\n    {\n        temp =\
    \ arr[i];\n        arr[i] = arr[m];\n        arr[m] = temp;\n        count++;\n\
    \    }\n    if(count>0)\n    {\n        return true;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpinr7psca.cpp: In function 'int main()':\n/tmp/tmpinr7psca.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpinr7psca.cpp:2:\n/tmp/tmpinr7psca.cpp:45:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpinr7psca.cpp:45:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpinr7psca.cpp:45:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpinr7psca.cpp:45:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpinr7psca.cpp:45:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpinr7psca.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpinr7psca.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int m =\
    \ n/2;\n    int count = 0;\n    for(int i = 0; i<m; i++) {\n        for(int j\
    \ = i+1; j<n; j++) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n\
    \            arr[j] = temp;\n            count++;\n        }\n    }\n    if(count\
    \ == n) return true;\n    else return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx1ok3rlp.cpp: In function 'int main()':\n/tmp/tmpx1ok3rlp.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx1ok3rlp.cpp:2:\n/tmp/tmpx1ok3rlp.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpx1ok3rlp.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpx1ok3rlp.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpx1ok3rlp.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpx1ok3rlp.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpx1ok3rlp.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx1ok3rlp.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int m =\
    \ n;\n    long temp;\n    long ans = 0;\n    long temp1;\n    long temp2;\n  \
    \  long temp3;\n    long temp4;\n    long temp5;\n    long temp6;\n    long temp7;\n\
    \    long temp8;\n    long temp9;\n    long temp10;\n    long temp11;\n    long\
    \ temp12;\n    long temp13;\n    long temp14;\n    long temp15;\n    long temp16;\n\
    \    long temp17;\n    long temp18;\n    long temp19;\n    long temp20;\n    long\
    \ temp21;\n    long temp22;\n    long temp23;\n    long temp24;\n    long temp25;\n\
    \    long temp26;\n    long temp27;\n    long temp28;\n    long temp29;\n    long\
    \ temp30;\n    long temp31;\n    long temp32;\n    long temp33;\n    long temp34;\n\
    \    long temp35;\n    long temp36;\n    long temp37;\n    long temp38;\n    long\
    \ temp39;\n    long temp40;\n    long temp41;\n    long temp42;\n    long temp43;\n\
    \    long temp44;\n    long temp45;\n    long temp46;\n    long temp47;\n    long\
    \ temp48;\n    long temp49;\n    long temp50;\n    long temp51;\n    long temp52;\n\
    \    long temp53;\n    long temp54;\n    long temp55;\n    long temp56;\n    long\
    \ temp57;\n    long temp58;\n    long temp59;\n    long temp60;\n    long temp61;\n\
    \    long temp62;\n    long temp63;\n    long temp64;\n    long temp65;\n    long\
    \ temp66;\n    long temp67;\n    long temp68;\n    long temp69;\n    long temp70;\n\
    \    long temp71;\n    long temp72;\n    long temp73;\n    long temp74;\n    long\
    \ temp75;\n    long temp76;\n    long temp77;\n    long temp78;\n    long temp79;\n\
    \    long temp80;\n    long temp81;\n    long temp82;\n    long temp83;\n    long\
    \ temp84;\n    long temp85;\n    long \n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7frzbric.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmp7frzbric.cpp:115:1: error: expected unqualified-id before '}'\
    \ token\n }\n ^\n/tmp/tmp7frzbric.cpp: In function 'int main()':\n/tmp/tmp7frzbric.cpp:117:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7frzbric.cpp:2:\n/tmp/tmp7frzbric.cpp:118:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp7frzbric.cpp:118:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp7frzbric.cpp:118:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp7frzbric.cpp:118:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp7frzbric.cpp:118:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp7frzbric.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included fr"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    long long\
    \ int sum = 0;\n    for(int i = 0; i < n; i++) {\n        sum += arr[i];\n   \
    \ }\n    long long int sum1 = sum;\n    long long int sum2 = 0;\n    for(int i\
    \ = 0; i < n; i++) {\n        sum1 += arr[i];\n        sum2 += arr[i];\n    }\n\
    \    if(sum1 == sum2) {\n        return true;\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi42i_lxa.cpp: In function 'int main()':\n/tmp/tmpi42i_lxa.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi42i_lxa.cpp:2:\n/tmp/tmpi42i_lxa.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpi42i_lxa.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpi42i_lxa.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpi42i_lxa.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpi42i_lxa.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpi42i_lxa.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi42i_lxa.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    int n = arr.size();\n\
    \    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[n\
    \ - 1]) {\n            count++;\n        }\n    }\n    if (count == 0) {\n   \
    \     return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpidvyck0f.cpp: In function 'int main()':\n/tmp/tmpidvyck0f.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpidvyck0f.cpp:2:\n/tmp/tmpidvyck0f.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpidvyck0f.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpidvyck0f.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpidvyck0f.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpidvyck0f.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpidvyck0f.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpidvyck0f.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    long long\
    \ int n = arr.size();\n    long long int m = n/2;\n    long long int temp;\n \
    \   long long int arr1[m];\n    long long int arr2[m];\n    long long int arr3[m];\n\
    \    long long int arr4[m];\n    long long int arr5[m];\n    long long int arr6[m];\n\
    \    long long int arr7[m];\n    long long int arr8[m];\n    long long int arr9[m];\n\
    \    long long int arr10[m];\n    long long int arr11[m];\n    long long int arr12[m];\n\
    \    long long int arr13[m];\n    long long int arr14[m];\n    long long int arr15[m];\n\
    \    long long int arr16[m];\n    long long int arr17[m];\n    long long int arr18[m];\n\
    \    long long int arr19[m];\n    long long int arr20[m];\n    long long int arr21[m];\n\
    \    long long int arr22[m];\n    long long int arr23[m];\n    long long int arr24[m];\n\
    \    long long int arr25[m];\n    long long int arr26[m];\n    long long int arr27[m];\n\
    \    long long int arr28[m];\n    long long int arr29[m];\n    long long int arr30[m];\n\
    \    long long int arr31[m];\n    long long int arr32[m];\n    long long int arr33[m];\n\
    \    long long int arr34[m];\n    long long int arr35[m];\n    long long int arr36[m];\n\
    \    long long int arr37[m];\n    long long int arr38[m];\n    long long int arr39[m];\n\
    \    long long int arr40[m];\n    long long int arr41[m];\n    long long int arr42[m];\n\
    \    long long int arr43[m];\n    long long int arr44[m];\n    long long int arr45[m];\n\
    \    long long int arr46[m];\n    long long int arr47[m];\n    long long int arr48[m];\n\
    \    long long int arr49[m];\n    long long int arr50[m];\n    long long int arr51[m];\n\
    \    long long int arr52[m];\n    long long int arr53[m];\n    long long int arr54\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8qtufip1.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmp8qtufip1.cpp:83:1: error: expected initializer before '}' token\n\
    \ }\n ^\n/tmp/tmp8qtufip1.cpp: In function 'int main()':\n/tmp/tmp8qtufip1.cpp:85:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8qtufip1.cpp:2:\n/tmp/tmp8qtufip1.cpp:86:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp8qtufip1.cpp:86:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp8qtufip1.cpp:86:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8qtufip1.cpp:86:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp8qtufip1.cpp:86:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8qtufip1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/in"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    long long\
    \ int n = arr.size();\n    long long int m = n/2;\n    long long int temp;\n \
    \   long long int count = 0;\n    long long int flag = 0;\n    for(int i = 0;\
    \ i < n; i++) {\n        temp = arr[i];\n        arr[i] = arr[m - 1];\n      \
    \  arr[m - 1] = temp;\n        flag = 1;\n        for(int j = 0; j < n; j++) {\n\
    \            if(arr[j] > arr[j+1]) {\n                flag = 0;\n            }\n\
    \        }\n        if(flag == 1) {\n            count++;\n        }\n    }\n\
    \    if(count == n) {\n        return true;\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp24a11hz6.cpp: In function 'int main()':\n/tmp/tmp24a11hz6.cpp:51:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp24a11hz6.cpp:2:\n/tmp/tmp24a11hz6.cpp:52:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp24a11hz6.cpp:52:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp24a11hz6.cpp:52:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp24a11hz6.cpp:52:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp24a11hz6.cpp:52:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp24a11hz6.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp24a11hz6.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    int n = arr.size();\n\
    \    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i\
    \ + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                swap(arr[i],\
    \ arr[j]);\n                count++;\n            }\n        }\n    }\n    if\
    \ (count == 0) {\n        return true;\n    } else {\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnifdexwi.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmpnifdexwi.cpp:31:36: error: 'swap' was not declared in this\
    \ scope\n                 swap(arr[i], arr[j]);\n                            \
    \        ^\n/tmp/tmpnifdexwi.cpp:31:36: note: suggested alternative:\nIn file\
    \ included from /usr/include/c++/4.8.2/set:62:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpnifdexwi.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_multiset.h:791:5:\
    \ note:   'std::swap'\n     swap(multiset<_Key, _Compare, _Alloc>& __x,\n    \
    \ ^\n/tmp/tmpnifdexwi.cpp: In function 'int main()':\n/tmp/tmpnifdexwi.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnifdexwi.cpp:2:\n/tmp/tmpnifdexwi.cpp:44:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpnifdexwi.cpp:44:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpnifdexwi.cpp:44:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnifdexwi.cpp:44:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnifdexwi.cpp:44:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    long long\
    \ int n = arr.size();\n    long long int sum = 0;\n    long long int temp = 0;\n\
    \    long long int count = 0;\n    long long int sum1 = 0;\n    long long int\
    \ sum2 = 0;\n    long long int sum3 = 0;\n    long long int sum4 = 0;\n    long\
    \ long int sum5 = 0;\n    long long int sum6 = 0;\n    long long int sum7 = 0;\n\
    \    long long int sum8 = 0;\n    long long int sum9 = 0;\n    long long int sum10\
    \ = 0;\n    long long int sum11 = 0;\n    long long int sum12 = 0;\n    long long\
    \ int sum13 = 0;\n    long long int sum14 = 0;\n    long long int sum15 = 0;\n\
    \    long long int sum16 = 0;\n    long long int sum17 = 0;\n    long long int\
    \ sum18 = 0;\n    long long int sum19 = 0;\n    long long int sum20 = 0;\n   \
    \ long long int sum21 = 0;\n    long long int sum22 = 0;\n    long long int sum23\
    \ = 0;\n    long long int sum24 = 0;\n    long long int sum25 = 0;\n    long long\
    \ int sum26 = 0;\n    long long int sum27 = 0;\n    long long int sum28 = 0;\n\
    \    long long int sum29 = 0;\n    long long int sum30 = 0;\n    long long int\
    \ sum31 = 0;\n    long long int sum32 = 0;\n    long long int sum33 = 0;\n   \
    \ long long int sum34 = 0;\n    long long int sum35 = 0;\n    long long int sum36\
    \ = 0;\n    long long int sum37 = 0;\n    long long int sum38 = 0;\n    long long\
    \ int sum39 = 0;\n    long long int sum40 = 0;\n    long long int sum41 = 0;\n\
    \    long long int sum42 = 0;\n    long long int sum43 = 0;\n    long long int\
    \ sum44 = 0;\n    long long int sum45 = 0;\n    long long int sum46 = 0;\n   \
    \ long long int sum47 = 0;\n    long long int sum48 = 0;\n    long long int sum49\
    \ = 0;\n    long long int sum50 = 0;\n    long long int sum51 = 0;\n    long long\
    \ int sum52 = 0;\n    long long int sum53 = 0;\n    long long int sum54 = 0;\n\
    \    long long int sum55 = 0;\n    long long int sum56 = 0;\n    long long int\
    \ sum57 = 0;\n    long long int sum58 = 0;\n    long long int sum59 = 0;\n   \
    \ long long int sum60 = 0;\n    long long \n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_oevwhq5.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmp_oevwhq5.cpp:91:1: error: expected unqualified-id before '}'\
    \ token\n }\n ^\n/tmp/tmp_oevwhq5.cpp: In function 'int main()':\n/tmp/tmp_oevwhq5.cpp:93:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_oevwhq5.cpp:2:\n/tmp/tmp_oevwhq5.cpp:94:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp_oevwhq5.cpp:94:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp_oevwhq5.cpp:94:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp_oevwhq5.cpp:94:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp_oevwhq5.cpp:94:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp_oevwhq5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    long\
    \ n = arr.size();\n    long sum = 0;\n    long temp = 0;\n    long temp2 = 0;\n\
    \    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6\
    \ = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long\
    \ temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n\
    \    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17\
    \ = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n   \
    \ long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24\
    \ = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n   \
    \ long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31\
    \ = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n   \
    \ long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38\
    \ = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n   \
    \ long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45\
    \ = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n   \
    \ long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52\
    \ = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n   \
    \ long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59\
    \ = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n   \
    \ long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n    long temp66\
    \ = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n   \
    \ long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n    long temp73\
    \ = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n   \
    \ long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n    long temp80\
    \ = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83 = 0;\n   \
    \ long \n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphyf4tvm5.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmphyf4tvm5.cpp:112:1: error: expected unqualified-id before '}'\
    \ token\n }\n ^\n/tmp/tmphyf4tvm5.cpp: In function 'int main()':\n/tmp/tmphyf4tvm5.cpp:114:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphyf4tvm5.cpp:2:\n/tmp/tmphyf4tvm5.cpp:115:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmphyf4tvm5.cpp:115:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmphyf4tvm5.cpp:115:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmphyf4tvm5.cpp:115:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmphyf4tvm5.cpp:115:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmphyf4tvm5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included fr"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    long temp = 0;\n    long temp2 = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1]\
    \ = temp;\n        count++;\n    }\n    if (count == 0) {\n        return true;\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        temp2 = arr[i];\n        arr[i]\
    \ = arr[0];\n        arr[0] = temp2;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvwrm2dy4.cpp: In function 'int main()':\n/tmp/tmpvwrm2dy4.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvwrm2dy4.cpp:2:\n/tmp/tmpvwrm2dy4.cpp:47:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpvwrm2dy4.cpp:47:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpvwrm2dy4.cpp:47:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpvwrm2dy4.cpp:47:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpvwrm2dy4.cpp:47:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpvwrm2dy4.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvwrm2dy4.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n ==\
    \ 0)\n        return true;\n    int m = n / 2;\n    for (int i = 0; i < m; i++)\
    \ {\n        int temp = arr[i];\n        arr[i] = arr[n - 1 - i];\n        arr[n\
    \ - 1 - i] = temp;\n    }\n    for (int i = 0; i < m; i++) {\n        int temp\
    \ = arr[i];\n        arr[i] = arr[n - 1 - i];\n        arr[n - 1 - i] = temp;\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        int temp = arr[i];\n      \
    \  arr[i] = arr[0];\n        arr[0] = temp;\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        int temp = arr[i];\n        arr[i] = arr[0];\n        arr[0]\
    \ = temp;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9zsgw8da.cpp: In function 'int main()':\n/tmp/tmp9zsgw8da.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9zsgw8da.cpp:2:\n/tmp/tmp9zsgw8da.cpp:53:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp9zsgw8da.cpp:53:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp9zsgw8da.cpp:53:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp9zsgw8da.cpp:53:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp9zsgw8da.cpp:53:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp9zsgw8da.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9zsgw8da.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i) {\n      \
    \      count++;\n        }\n    }\n    if (count == 0) {\n        return true;\n\
    \    }\n    int mid = n / 2;\n    for (int i = 0; i < mid; i++) {\n        if\
    \ (arr[i] != i) {\n            arr[i] = arr[i + 1];\n        }\n    }\n    for\
    \ (int i = mid; i < n; i++) {\n        if (arr[i] != i) {\n            arr[i]\
    \ = arr[i - 1];\n        }\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp44hqcgav.cpp: In function 'int main()':\n/tmp/tmp44hqcgav.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp44hqcgav.cpp:2:\n/tmp/tmp44hqcgav.cpp:50:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp44hqcgav.cpp:50:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp44hqcgav.cpp:50:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp44hqcgav.cpp:50:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp44hqcgav.cpp:50:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp44hqcgav.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp44hqcgav.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Your code here\n    long long\
    \ int n = arr.size();\n    long long int arr_size = n;\n    long long int arr[n];\n\
    \    long long int temp;\n    long long int i;\n    long long int j;\n    long\
    \ long int k;\n    long long int temp1;\n    long long int temp2;\n    long long\
    \ int temp3;\n    long long int temp4;\n    long long int temp5;\n    long long\
    \ int temp6;\n    long long int temp7;\n    long long int temp8;\n    long long\
    \ int temp9;\n    long long int temp10;\n    long long int temp11;\n    long long\
    \ int temp12;\n    long long int temp13;\n    long long int temp14;\n    long\
    \ long int temp15;\n    long long int temp16;\n    long long int temp17;\n   \
    \ long long int temp18;\n    long long int temp19;\n    long long int temp20;\n\
    \    long long int temp21;\n    long long int temp22;\n    long long int temp23;\n\
    \    long long int temp24;\n    long long int temp25;\n    long long int temp26;\n\
    \    long long int temp27;\n    long long int temp28;\n    long long int temp29;\n\
    \    long long int temp30;\n    long long int temp31;\n    long long int temp32;\n\
    \    long long int temp33;\n    long long int temp34;\n    long long int temp35;\n\
    \    long long int temp36;\n    long long int temp37;\n    long long int temp38;\n\
    \    long long int temp39;\n    long long int temp40;\n    long long int temp41;\n\
    \    long long int temp42;\n    long long int temp43;\n    long long int temp44;\n\
    \    long long int temp45;\n    long long int temp46;\n    long long int temp47;\n\
    \    long long int temp48;\n    long long int temp49;\n    long long int temp50;\n\
    \    long long int temp51;\n    long long int temp52;\n    long long int temp53;\n\
    \    long long int temp54;\n    long long int temp55;\n    long long int temp56;\n\
    \    long long int temp57;\n    long long int temp58;\n    long long int temp59;\n\
    \    long long \n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp47jfpz36.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmp47jfpz36.cpp:28:24: error: declaration of 'long long int arr\
    \ [(((sizetype)(((ssizetype)n) + -1)) + 1)]' shadows a parameter\n     long long\
    \ int arr[n];\n                        ^\n/tmp/tmp47jfpz36.cpp:93:1: error: expected\
    \ unqualified-id before '}' token\n }\n ^\n/tmp/tmp47jfpz36.cpp: In function 'int\
    \ main()':\n/tmp/tmp47jfpz36.cpp:95:10: error: 'candidate' does not name a type\n\
    \     auto candidate = move_one_ball;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp47jfpz36.cpp:2:\n/tmp/tmp47jfpz36.cpp:96:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp47jfpz36.cpp:96:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp47jfpz36.cpp:96:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp47jfpz36.cpp:96:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp47jfpz36.cpp:96:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp47jfpz36.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_Inp"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ an array sorted in non-decreasing order by performing \n// the following operation\
    \ on the given array:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the array by one\n// position in the right direction. The last element of the\
    \ array will be moved to\n// the starting position in the array i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted array by performing the above operation\n\
    // then return True else return False.\n// If the given array is empty then return\
    \ True.\n// Note: The given list is guaranteed to have unique elements.\n// For\
    \ Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given array.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// array by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    int count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i) {\n      \
    \      count++;\n        }\n    }\n    if (count == 0) {\n        return true;\n\
    \    }\n    int m = n / 2;\n    for (int i = 0; i < m; i++) {\n        int temp\
    \ = arr[i];\n        arr[i] = arr[n - 1 - i];\n        arr[n - 1 - i] = temp;\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i) {\n      \
    \      return false;\n        }\n    }\n    return true;\n}\nint main() {\n  \
    \  auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb6tbpkv7.cpp: In function 'int main()':\n/tmp/tmpb6tbpkv7.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb6tbpkv7.cpp:2:\n/tmp/tmpb6tbpkv7.cpp:50:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpb6tbpkv7.cpp:50:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpb6tbpkv7.cpp:50:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpb6tbpkv7.cpp:50:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpb6tbpkv7.cpp:50:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpb6tbpkv7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb6tbpkv7.cpp:2"
  stdout: ''
