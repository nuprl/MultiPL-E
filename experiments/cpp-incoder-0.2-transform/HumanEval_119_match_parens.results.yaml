language: cpp
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            ans = \"Yes\";\n            break;\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0uiz4_8d.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp0uiz4_8d.cpp:18:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmp0uiz4_8d.cpp:24:5: error: expected\
    \ ';' before 'return'\n     return ans;\n     ^\n/tmp/tmp0uiz4_8d.cpp:24:5: error:\
    \ expected primary-expression before 'return'\n/tmp/tmp0uiz4_8d.cpp:24:5: error:\
    \ expected ';' before 'return'\n/tmp/tmp0uiz4_8d.cpp:24:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmp0uiz4_8d.cpp:24:5: error: expected ')' before 'return'\n\
    /tmp/tmp0uiz4_8d.cpp: In function 'int main()':\n/tmp/tmp0uiz4_8d.cpp:27:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = match_parens;\n    \
    \      ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0uiz4_8d.cpp:2:\n/tmp/tmp0uiz4_8d.cpp:28:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp0uiz4_8d.cpp:28:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp0uiz4_8d.cpp:28:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp0uiz4_8d.cpp:28:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmp0uiz4_8d.cpp:29:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [e"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &i : lst) {\n        if\
    \ (i.size() == 1) {\n            ans = \"Yes\";\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfw3a5c1g.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpfw3a5c1g.cpp:18:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmpfw3a5c1g.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmpfw3a5c1g.cpp:19:15:\
    \ error: request for member 'size' in 'i', which is of non-class type 'int'\n\
    \         if (i.size() == 1) {\n               ^\n/tmp/tmpfw3a5c1g.cpp: In function\
    \ 'int main()':\n/tmp/tmpfw3a5c1g.cpp:26:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = match_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfw3a5c1g.cpp:2:\n/tmp/tmpfw3a5c1g.cpp:27:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpfw3a5c1g.cpp:27:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpfw3a5c1g.cpp:27:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpfw3a5c1g.cpp:27:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpfw3a5c1g.cpp:28:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate(("
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    bool flag = false;\n    for (auto\
    \ i : lst) {\n        if (i == \"(\") {\n            flag = true;\n        } else\
    \ if (i == \")\") {\n            flag = false;\n        } else {\n           \
    \ ans = \"No\";\n            break;\n        }\n    }\n    if (flag) {\n     \
    \   ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvkgha2h6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpvkgha2h6.cpp:19:15: error: 'i' does not name a type\n     for\
    \ (auto i : lst) {\n               ^\n/tmp/tmpvkgha2h6.cpp:29:5: error: expected\
    \ ';' before 'if'\n     if (flag) {\n     ^\n/tmp/tmpvkgha2h6.cpp:29:5: error:\
    \ expected primary-expression before 'if'\n/tmp/tmpvkgha2h6.cpp:29:5: error: expected\
    \ ';' before 'if'\n/tmp/tmpvkgha2h6.cpp:29:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpvkgha2h6.cpp:29:5: error: expected ')' before 'if'\n/tmp/tmpvkgha2h6.cpp:\
    \ In function 'int main()':\n/tmp/tmpvkgha2h6.cpp:35:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvkgha2h6.cpp:2:\n/tmp/tmpvkgha2h6.cpp:36:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpvkgha2h6.cpp:36:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpvkgha2h6.cpp:36:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpvkgha2h6.cpp:36:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpvkgha2h6.cpp:37:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    std::string temp;\n    for (auto\
    \ &it : lst) {\n        if (it == \"(\") {\n            temp.push_back('(');\n\
    \        } else if (it == \")\") {\n            temp.push_back(')');\n       \
    \ } else {\n            temp.push_back(it);\n        }\n    }\n    if (temp ==\
    \ \"()()\") {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb5qfohor.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpb5qfohor.cpp:19:16: error: ISO C++ forbids declaration of 'it'\
    \ with no type [-fpermissive]\n     for (auto &it : lst) {\n                ^\n\
    /tmp/tmpb5qfohor.cpp:19:21: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &it : lst) {\n                     ^\n/tmp/tmpb5qfohor.cpp:20:19:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         if (it == \"(\") {\n                   ^\n/tmp/tmpb5qfohor.cpp:22:26:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         } else if (it == \")\") {\n                          ^\n/tmp/tmpb5qfohor.cpp:\
    \ In function 'int main()':\n/tmp/tmpb5qfohor.cpp:34:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb5qfohor.cpp:2:\n/tmp/tmpb5qfohor.cpp:35:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpb5qfohor.cpp:35:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpb5qfohor.cpp:35:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpb5qfohor.cpp:35:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string res;\n    bool flag = false;\n    for (auto &i : lst)\
    \ {\n        if (i.size() == 1) {\n            if (i[0] == '(') {\n          \
    \      flag = true;\n            }\n            if (i[0] == ')') {\n         \
    \       flag = false;\n            }\n        }\n        if (flag) {\n       \
    \     res += i[0];\n        }\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_ou5s8gn.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp_ou5s8gn.cpp:19:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmp_ou5s8gn.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmp_ou5s8gn.cpp:20:15:\
    \ error: request for member 'size' in 'i', which is of non-class type 'int'\n\
    \         if (i.size() == 1) {\n               ^\n/tmp/tmp_ou5s8gn.cpp:21:20:\
    \ error: invalid types 'int[int]' for array subscript\n             if (i[0] ==\
    \ '(') {\n                    ^\n/tmp/tmp_ou5s8gn.cpp:24:20: error: invalid types\
    \ 'int[int]' for array subscript\n             if (i[0] == ')') {\n          \
    \          ^\n/tmp/tmp_ou5s8gn.cpp:29:23: error: invalid types 'int[int]' for\
    \ array subscript\n             res += i[0];\n                       ^\n/tmp/tmp_ou5s8gn.cpp:\
    \ In function 'int main()':\n/tmp/tmp_ou5s8gn.cpp:35:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_ou5s8gn.cpp:2:\n/tmp/tmp_ou5s8gn.cpp:36:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp_ou5s8gn.cpp:36:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp_ou5s8gn.cpp:36:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp_ou5s8gn.cpp:36:88:"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n  // Your code here\n  std::string ans = \"No\";\n  for (int i = 0;\
    \ i < lst.size(); i++) {\n    if (lst[i][0] == '(' && lst[i][1] == '(') {\n  \
    \    ans = \"Yes\";\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpez2fv_pd.cpp: In function 'int main()':\n/tmp/tmpez2fv_pd.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = match_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpez2fv_pd.cpp:2:\n/tmp/tmpez2fv_pd.cpp:28:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpez2fv_pd.cpp:28:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpez2fv_pd.cpp:28:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpez2fv_pd.cpp:28:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpez2fv_pd.cpp:29:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \             ^\n/tmp/tmpez2fv_pd.cpp:29:84: warning: extended initializer lists\
    \ only available with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n                                  \
    \                                                  ^\n/tmp/tmpez2fv_pd.cpp:29:84:\
    \ warning: extended initializer lists only available with -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s = \"No\";\n    for (auto &x : lst) {\n        if (x.size()\
    \ == 1) {\n            s += x[0];\n        } else if (x.size() == 2) {\n     \
    \       s += x[0] + x[1];\n        } else {\n            s += x[0] + x[1] + x[2];\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwbbgat3b.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpwbbgat3b.cpp:18:16: error: ISO C++ forbids declaration of 'x'\
    \ with no type [-fpermissive]\n     for (auto &x : lst) {\n                ^\n\
    /tmp/tmpwbbgat3b.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &x : lst) {\n                    ^\n/tmp/tmpwbbgat3b.cpp:19:15:\
    \ error: request for member 'size' in 'x', which is of non-class type 'int'\n\
    \         if (x.size() == 1) {\n               ^\n/tmp/tmpwbbgat3b.cpp:20:21:\
    \ error: invalid types 'int[int]' for array subscript\n             s += x[0];\n\
    \                     ^\n/tmp/tmpwbbgat3b.cpp:21:22: error: request for member\
    \ 'size' in 'x', which is of non-class type 'int'\n         } else if (x.size()\
    \ == 2) {\n                      ^\n/tmp/tmpwbbgat3b.cpp:22:21: error: invalid\
    \ types 'int[int]' for array subscript\n             s += x[0] + x[1];\n     \
    \                ^\n/tmp/tmpwbbgat3b.cpp:22:28: error: invalid types 'int[int]'\
    \ for array subscript\n             s += x[0] + x[1];\n                      \
    \      ^\n/tmp/tmpwbbgat3b.cpp:24:21: error: invalid types 'int[int]' for array\
    \ subscript\n             s += x[0] + x[1] + x[2];\n                     ^\n/tmp/tmpwbbgat3b.cpp:24:28:\
    \ error: invalid types 'int[int]' for array subscript\n             s += x[0]\
    \ + x[1] + x[2];\n                            ^\n/tmp/tmpwbbgat3b.cpp:24:35: error:\
    \ invalid types 'int[int]' for array subscript\n             s += x[0] + x[1]\
    \ + x[2];\n                                   ^\n/tmp/tmpwbbgat3b.cpp: In function\
    \ 'int main()':\n/tmp/tmpwbbgat3b.cpp:30:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = match_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwbbgat3b.cpp:2:\n/tmp/tmpwbbgat3b.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((s"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    // Your code here\n    std::string ans = \"No\";\n    for (auto\
    \ &i : lst) {\n        if (i == \"(\") {\n            ans = \"Yes\";\n       \
    \     break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb854v__6.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpb854v__6.cpp:19:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmpb854v__6.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmpb854v__6.cpp:20:18:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         if (i == \"(\") {\n                  ^\n/tmp/tmpb854v__6.cpp: In function\
    \ 'int main()':\n/tmp/tmpb854v__6.cpp:28:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = match_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb854v__6.cpp:2:\n/tmp/tmpb854v__6.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpb854v__6.cpp:29:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpb854v__6.cpp:29:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpb854v__6.cpp:29:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpb854v__6.cpp:30:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate("
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        if\
    \ (s.find(\"(\") == std::string::npos) {\n            ans = \"Yes\";\n       \
    \     break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe4il27eu.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpe4il27eu.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpe4il27eu.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpe4il27eu.cpp:19:15:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \         if (s.find(\"(\") == std::string::npos) {\n               ^\n/tmp/tmpe4il27eu.cpp:\
    \ In function 'int main()':\n/tmp/tmpe4il27eu.cpp:27:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe4il27eu.cpp:2:\n/tmp/tmpe4il27eu.cpp:28:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpe4il27eu.cpp:28:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpe4il27eu.cpp:28:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpe4il27eu.cpp:28:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpe4il27eu.cpp:29:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string s = \"No\";\n    for (auto it = lst.begin(); it != lst.end();\
    \ ++it) {\n        if (*it == \"(\") {\n            s += \"Yes\";\n        } else\
    \ if (*it == \")\") {\n            s += \"No\";\n        }\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn0osncj0.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpn0osncj0.cpp:18:15: error: 'it' does not name a type\n     for\
    \ (auto it = lst.begin(); it != lst.end(); ++it) {\n               ^\n/tmp/tmpn0osncj0.cpp:18:33:\
    \ error: expected ';' before 'it'\n     for (auto it = lst.begin(); it != lst.end();\
    \ ++it) {\n                                 ^\n/tmp/tmpn0osncj0.cpp:18:33: error:\
    \ 'it' was not declared in this scope\n/tmp/tmpn0osncj0.cpp: In function 'int\
    \ main()':\n/tmp/tmpn0osncj0.cpp:28:10: error: 'candidate' does not name a type\n\
    \     auto candidate = match_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn0osncj0.cpp:2:\n/tmp/tmpn0osncj0.cpp:29:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpn0osncj0.cpp:29:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpn0osncj0.cpp:29:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpn0osncj0.cpp:29:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpn0osncj0.cpp:30:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\""
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    std::string temp;\n    for (auto\
    \ &i : lst) {\n        if (i.size() == 1) {\n            ans = \"Yes\";\n    \
    \        break;\n        }\n        temp = i;\n        ans = match_parens(temp);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdc0u2wzo.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpdc0u2wzo.cpp:19:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmpdc0u2wzo.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmpdc0u2wzo.cpp:20:15:\
    \ error: request for member 'size' in 'i', which is of non-class type 'int'\n\
    \         if (i.size() == 1) {\n               ^\n/tmp/tmpdc0u2wzo.cpp:25:32:\
    \ error: could not convert 'temp' from 'std::string {aka std::basic_string<char>}'\
    \ to 'std::vector<std::basic_string<char> >'\n         ans = match_parens(temp);\n\
    \                                ^\n/tmp/tmpdc0u2wzo.cpp: In function 'int main()':\n\
    /tmp/tmpdc0u2wzo.cpp:30:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = match_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdc0u2wzo.cpp:2:\n/tmp/tmpdc0u2wzo.cpp:31:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpdc0u2wzo.cpp:31:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpdc0u2wzo.cpp:31:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdc0u2wzo.cpp:31:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                        "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        if\
    \ (s.size() > 0 && s.front() == '(' && s.back() == ')') {\n            ans = \"\
    Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw6yyj_gz.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpw6yyj_gz.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpw6yyj_gz.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpw6yyj_gz.cpp:19:15:\
    \ error: request for member 'size' in 's', which is of non-class type 'int'\n\
    \         if (s.size() > 0 && s.front() == '(' && s.back() == ')') {\n       \
    \        ^\n/tmp/tmpw6yyj_gz.cpp:19:31: error: request for member 'front' in 's',\
    \ which is of non-class type 'int'\n         if (s.size() > 0 && s.front() ==\
    \ '(' && s.back() == ')') {\n                               ^\n/tmp/tmpw6yyj_gz.cpp:19:51:\
    \ error: request for member 'back' in 's', which is of non-class type 'int'\n\
    \         if (s.size() > 0 && s.front() == '(' && s.back() == ')') {\n       \
    \                                            ^\n/tmp/tmpw6yyj_gz.cpp: In function\
    \ 'int main()':\n/tmp/tmpw6yyj_gz.cpp:27:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = match_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw6yyj_gz.cpp:2:\n/tmp/tmpw6yyj_gz.cpp:28:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpw6yyj_gz.cpp:28:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpw6yyj_gz.cpp:28:86: warning: extended\
    \ initializer lists only available with -std=c++1"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    bool flag = false;\n    for (auto\
    \ &i : lst) {\n        if (i.size() == 1) {\n            if (i[0] == '(' || i[0]\
    \ == ')') {\n                flag = true;\n            }\n        }\n    }\n \
    \   if (flag) {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3864v3ry.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp3864v3ry.cpp:19:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmp3864v3ry.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmp3864v3ry.cpp:20:15:\
    \ error: request for member 'size' in 'i', which is of non-class type 'int'\n\
    \         if (i.size() == 1) {\n               ^\n/tmp/tmp3864v3ry.cpp:21:20:\
    \ error: invalid types 'int[int]' for array subscript\n             if (i[0] ==\
    \ '(' || i[0] == ')') {\n                    ^\n/tmp/tmp3864v3ry.cpp:21:35: error:\
    \ invalid types 'int[int]' for array subscript\n             if (i[0] == '(' ||\
    \ i[0] == ')') {\n                                   ^\n/tmp/tmp3864v3ry.cpp:\
    \ In function 'int main()':\n/tmp/tmp3864v3ry.cpp:32:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3864v3ry.cpp:2:\n/tmp/tmp3864v3ry.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp3864v3ry.cpp:33:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp3864v3ry.cpp:33:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3864v3ry.cpp:33:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    bool flag = false;\n    for (auto\
    \ &it : lst) {\n        if (it == \"(\") {\n            flag = true;\n       \
    \ } else if (it == \")\") {\n            flag = false;\n        } else if (flag)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3wltn9bb.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp3wltn9bb.cpp:19:16: error: ISO C++ forbids declaration of 'it'\
    \ with no type [-fpermissive]\n     for (auto &it : lst) {\n                ^\n\
    /tmp/tmp3wltn9bb.cpp:19:21: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &it : lst) {\n                     ^\n/tmp/tmp3wltn9bb.cpp:20:19:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         if (it == \"(\") {\n                   ^\n/tmp/tmp3wltn9bb.cpp:22:26:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         } else if (it == \")\") {\n                          ^\n/tmp/tmp3wltn9bb.cpp:\
    \ In function 'int main()':\n/tmp/tmp3wltn9bb.cpp:32:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3wltn9bb.cpp:2:\n/tmp/tmp3wltn9bb.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp3wltn9bb.cpp:33:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp3wltn9bb.cpp:33:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp3wltn9bb.cpp:33:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        if\
    \ (s.find(\"(\") == std::string::npos) {\n            ans = \"Yes\";\n       \
    \     break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe4il27eu.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpe4il27eu.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpe4il27eu.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpe4il27eu.cpp:19:15:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \         if (s.find(\"(\") == std::string::npos) {\n               ^\n/tmp/tmpe4il27eu.cpp:\
    \ In function 'int main()':\n/tmp/tmpe4il27eu.cpp:27:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe4il27eu.cpp:2:\n/tmp/tmpe4il27eu.cpp:28:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpe4il27eu.cpp:28:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpe4il27eu.cpp:28:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpe4il27eu.cpp:28:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpe4il27eu.cpp:29:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        ans\
    \ = std::string(ans.begin(), s.begin()) + \"Yes\" + std::string(ans.begin(), s.end());\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6et3t1ib.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp6et3t1ib.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmp6et3t1ib.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmp6et3t1ib.cpp:19:42:\
    \ error: request for member 'begin' in 's', which is of non-class type 'int'\n\
    \         ans = std::string(ans.begin(), s.begin()) + \"Yes\" + std::string(ans.begin(),\
    \ s.end());\n                                          ^\n/tmp/tmp6et3t1ib.cpp:19:88:\
    \ error: request for member 'end' in 's', which is of non-class type 'int'\n \
    \        ans = std::string(ans.begin(), s.begin()) + \"Yes\" + std::string(ans.begin(),\
    \ s.end());\n                                                                \
    \                        ^\n/tmp/tmp6et3t1ib.cpp: In function 'int main()':\n\
    /tmp/tmp6et3t1ib.cpp:24:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = match_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6et3t1ib.cpp:2:\n/tmp/tmp6et3t1ib.cpp:25:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp6et3t1ib.cpp:25:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp6et3t1ib.cpp:25:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp6et3t1ib.cpp:25:88: error: 'candidate"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    bool flag = false;\n    for (auto\
    \ &i : lst) {\n        if (i == \"(\") {\n            flag = true;\n        }\
    \ else if (i == \")\") {\n            flag = false;\n        } else if (flag)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqanaap8h.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpqanaap8h.cpp:19:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmpqanaap8h.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmpqanaap8h.cpp:20:18:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         if (i == \"(\") {\n                  ^\n/tmp/tmpqanaap8h.cpp:22:25:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \         } else if (i == \")\") {\n                         ^\n/tmp/tmpqanaap8h.cpp:\
    \ In function 'int main()':\n/tmp/tmpqanaap8h.cpp:32:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqanaap8h.cpp:2:\n/tmp/tmpqanaap8h.cpp:33:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpqanaap8h.cpp:33:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpqanaap8h.cpp:33:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpqanaap8h.cpp:33:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                 "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string res;\n    bool flag = false;\n    for (auto &x : lst)\
    \ {\n        if (x.find(\"(\") != std::string::npos) {\n            flag = true;\n\
    \        }\n        if (flag) {\n            res += x;\n        }\n        if\
    \ (x.find(\")\") != std::string::npos) {\n            flag = false;\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdcv4jnb4.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpdcv4jnb4.cpp:19:16: error: ISO C++ forbids declaration of 'x'\
    \ with no type [-fpermissive]\n     for (auto &x : lst) {\n                ^\n\
    /tmp/tmpdcv4jnb4.cpp:19:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &x : lst) {\n                    ^\n/tmp/tmpdcv4jnb4.cpp:20:15:\
    \ error: request for member 'find' in 'x', which is of non-class type 'int'\n\
    \         if (x.find(\"(\") != std::string::npos) {\n               ^\n/tmp/tmpdcv4jnb4.cpp:26:15:\
    \ error: request for member 'find' in 'x', which is of non-class type 'int'\n\
    \         if (x.find(\")\") != std::string::npos) {\n               ^\n/tmp/tmpdcv4jnb4.cpp:\
    \ In function 'int main()':\n/tmp/tmpdcv4jnb4.cpp:33:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdcv4jnb4.cpp:2:\n/tmp/tmpdcv4jnb4.cpp:34:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpdcv4jnb4.cpp:34:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpdcv4jnb4.cpp:34:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdcv4jnb4.cpp:34:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                           "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &i : lst) {\n        if\
    \ (i.size() == 1) {\n            ans = \"Yes\";\n            break;\n        }\n\
    \        ans = \"No\";\n        for (auto &j : i) {\n            if (j == '(')\
    \ {\n                ans = \"Yes\";\n                break;\n            }\n \
    \           if (j == ')') {\n                ans = \"No\";\n                break;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2280y9y7.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmp2280y9y7.cpp:18:16: error: ISO C++ forbids declaration of 'i'\
    \ with no type [-fpermissive]\n     for (auto &i : lst) {\n                ^\n\
    /tmp/tmp2280y9y7.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &i : lst) {\n                    ^\n/tmp/tmp2280y9y7.cpp:19:15:\
    \ error: request for member 'size' in 'i', which is of non-class type 'int'\n\
    \         if (i.size() == 1) {\n               ^\n/tmp/tmp2280y9y7.cpp:24:20:\
    \ error: ISO C++ forbids declaration of 'j' with no type [-fpermissive]\n    \
    \     for (auto &j : i) {\n                    ^\n/tmp/tmp2280y9y7.cpp:24:24:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (auto\
    \ &j : i) {\n                        ^\n/tmp/tmp2280y9y7.cpp: In function 'int\
    \ main()':\n/tmp/tmp2280y9y7.cpp:38:10: error: 'candidate' does not name a type\n\
    \     auto candidate = match_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2280y9y7.cpp:2:\n/tmp/tmp2280y9y7.cpp:39:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmp2280y9y7.cpp:39:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmp2280y9y7.cpp:39:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp2280y9y7.cpp:39:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\"\
    , (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string>\
    \ lst) {\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n        if\
    \ (s.find(\"(\") != std::string::npos) {\n            ans = \"Yes\";\n       \
    \     break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    ((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    (\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"\
    )\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpevckuhrw.cpp: In function 'std::string match_parens(std::vector<std::basic_string<char>\
    \ >)':\n/tmp/tmpevckuhrw.cpp:18:16: error: ISO C++ forbids declaration of 's'\
    \ with no type [-fpermissive]\n     for (auto &s : lst) {\n                ^\n\
    /tmp/tmpevckuhrw.cpp:18:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &s : lst) {\n                    ^\n/tmp/tmpevckuhrw.cpp:19:15:\
    \ error: request for member 'find' in 's', which is of non-class type 'int'\n\
    \         if (s.find(\"(\") != std::string::npos) {\n               ^\n/tmp/tmpevckuhrw.cpp:\
    \ In function 'int main()':\n/tmp/tmpevckuhrw.cpp:27:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = match_parens;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpevckuhrw.cpp:2:\n/tmp/tmpevckuhrw.cpp:28:47: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                ^\n/tmp/tmpevckuhrw.cpp:28:86: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    \     assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\"\
    )\"}))) == (\"Yes\"));\n                                                     \
    \                                 ^\n/tmp/tmpevckuhrw.cpp:28:86: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpevckuhrw.cpp:28:88: error: 'candidate' was not declared in\
    \ this scope\n     assert(candidate((std::vector<std::string>({(std::string)\"\
    ()(\", (std::string)\")\"}))) == (\"Yes\"));\n                               \
    \                                                         ^\n/tmp/tmpevckuhrw.cpp:29:47:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n    "
  stdout: ''
