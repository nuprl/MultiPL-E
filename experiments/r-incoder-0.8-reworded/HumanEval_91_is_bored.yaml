name: HumanEval_91_is_bored
language: r
prompt: "# You'll be given a string of words, and your task is to count the number\n\
  # of boredoms. A boredom is a sentence that starts with the word \"I\".\n# Sentences\
  \ are delimited by '.', '?' or '!'.\n# For example:\n# >>> is_bored('Hello world')\n\
  # 0\n# >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n\
  # 1\nis_bored <- function(S) {"
tests: "test_humaneval <- function() {\ncandidate <- is_bored\n    if(!identical(candidate('Hello\
  \ world'), 0)){quit('no', 1)}\n    if(!identical(candidate('Is the sky blue?'),\
  \ 0)){quit('no', 1)}\n    if(!identical(candidate('I love It !'), 1)){quit('no',\
  \ 1)}\n    if(!identical(candidate('bIt'), 0)){quit('no', 1)}\n    if(!identical(candidate('I\
  \ feel good today. I will be productive. will kill It'), 2)){quit('no', 1)}\n  \
  \  if(!identical(candidate('You and I are going for a walk'), 0)){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n    i <- grep('I',S)\n    i <- i+1\n    i <- length(grep('\\\\.',S))\n\
    \    i <- length(grep('\\\\?',S))\n    i <- length(grep('!',S))\n    i <- length(grep('\\\
    .',S,i))\n    i <- length(grep('\\\\?',S,i))\n    i <- length(grep('!',S,i))\n\
    \    i <- length(grep('\\\\.',S,i,fixed = TRUE))\n    return(i)\n}\n", "\n   \
    \ S <- unlist(strsplit(S,\".|[?!]\"))\n    sum(grepl(\"^I\",S))\n}\n</code>\n\
    <|/ a tags=r,regex |>\n<| c |>\nThis seems to be working with the sample data,\
    \ but the output is still incorrect for the actual data.  The issue seems to be\
    \ that the `grepl` is returning `integer(0)`\n<|/ c |>\n<| c |>\nCould you give\
    \ us a sample data set where the grepl is returning `integer(0)`? I've tested\
    \ my code with the data you provided, and the result should be `0`, not `integer(0)`.\n\
    <|/ c |>\n<| c |>\nThe actual data set has over 600,000 records.  I was able to\
    \ fix the issue.  Thanks so much for the help.\n<|/ c |>\n<| c |>\n, glad to help.\
    \ Good luck with your project.\n<|/ c |>\n<| c |>\nThe issue is fixed now. Thanks\
    \ for the help.\n<|/ c |>\n<| a dscore=1 |>\nI haven't tested this with your actual\
    \ data, but the following should work:\n<code>\nlibrary(dplyr)\n\ndf %>% mutate(bored\
    \ = as.integer(grepl(\"^I\", paste(sentence, collapse = \"\"))))\n\n</code>\n\
    <|/ a tags=r,regex |>\n<| c |>\nUnfortunately this seems to return the same as\
    \ the other solutions posted here\n<|/ c |>\n<| a dscore=1 tags=r,regex |>\n<code>\n\
    library(stringr)\nlibrary(tidyverse)\n\ndf <- data_frame(sentence = c(\"I love\
    \ this weather\", \"The sky is blue.\", \"This is not bored\"))\ndf$bored <- str_count(df$sentence,\
    \ \"^I\") # returns count of \"I\"\ndf\n</code>\n<|/ a |>\n<| c |>\nThis also\
    \ seems to be returning 0 for the actual data set\n<|/ c |>\n<| c |>\nThe actual\
    \ data set has over 600,000 records.  I was able to fix the issue.  Thanks so\
    \ much for the help.\n<|/ c |>\n<| a tags=r,regex |>\nWe can use stringr::str_count\
    \ after creating a 'bored' column\n<code>\nlibrary(stringr)\ndf$bored <- str_count(df$sentence,\
    \ pattern = \"^I\")\ndf$bored", "\n    length(grep('I', S, value=T))\n}\n", "\n\
    \  S <- unlist(strsplit(S, split = \" \"))\n  if(all(S %in% c(\"I\"))){\n    sum(S==\"\
    I\")\n  } else {\n    NA\n  }\n}\n", "\n    boreds <- gregexpr(\"\\\\bI\\\\b\"\
    , S)\n    return(sum(lengths(boreds)) == 0)\n}\n", "\n  M <- strsplit(S, split=\"\
    [.?!]\\\\s*\", perl=TRUE)[[1]]\n  sum(M == \"I\")\n}\n</cell>\n<text>\nTesting\n\
    We can test your solution on several test cases. Let's start with a simple one:\n\
    \n\n</text>\n<cell>", "\n  S <- gsub(\"[.!?]\", \". |? \", S)\n  strsplit(S, \"\
    \ \\\\.\")[[1]][-1] == \"I\"\n}\n</cell>\n<cell>\nis_bored(\"Hello world\")\n\
    </cell>\n<cell>\nis_bored(\"The sky is blue. The sun is shining. I love this weather\"\
    )\n</cell>\n<text>\nNow use your is_bored function to count how many words of\
    \ bored text you have.\n\n\n</text>\n<cell>", "\n  S <- gsub(\"[.?!]\", \"\",\
    \ S)\n  S <- unlist(strsplit(S, \" \"))\n  nchar(grep(\"^I\", S, value = TRUE))\n\
    }\n", "\n    S <- tolower(S)\n    S <- strsplit(S, \" \")[[1]]\n    S <- S[S !=\
    \ \".\"]\n    S <- S[S != \"?\"]\n    S <- S[S != \"!\"]\n    S <- unlist(S)\n\
    \    if (length(S) == 0) return(0)\n    S <- grepl(\"^[I]\", S)\n    sum(S)\n\
    }\n", "\n    boredoms <- 0L\n    S <- tolower(S)\n    S <- gsub('[.?!]', '', S)\n\
    \    for (i in 1:length(S)) {\n        if (substr(S[i], 1, 1) == 'i') { boredoms\
    \ <- boredoms + 1L }\n    }\n    return(boredoms)\n}\n", "\n    w <- strsplit(S,\
    \ \"[.!?]\") # Split into words\n    bored <- which(w == 'I')     # Get the indices\
    \ of boredom words\n    sum(bored)                # How many are there boredoms\n\
    }\nis_bored(\"The sky is blue. The sun is shining. I love this weather.\")", "\n\
    \  n <- length(gregexpr('I', S))\n  ifelse(n < 1, T, F)\n}\n</cell>\n<text>\n\
    Problem 2: Part of Speech Tagging\nPart of speech tagging is the process of determining\
    \ the grammatical role of a word within a sentence. Tagging is widely used in\
    \ information retrieval, and is often performed by hand prior to forming the corpus.\
    \ One approach is to tag parts of speech using universal tags from the NLTK library.\
    \ For this homework assignment, you will be using the Penn Treebank tagset. Part\
    \ of speech tagging allows you to determine the most common grammatical role that\
    \ a word plays in a sentence, even if the word itself does not appear in the sentence.\
    \ For example,\n\n'play' = 'play'\n'stole' = 'stole'\n'write' = 'write'\n'write'\
    \ = 'have write'\n'play' = 'have play'\n'stole' = 'have stole'\n'write' = 'have\
    \ write'\nGiven a sentence, you can use the following code to determine the tag\
    \ for each word in the sentence.\n\n\n</text>\n<cell>", "\n    library(stringr)\n\
    \    S <- gsub(\"\\\\.|\\\\?|!\", \"\", S)\n    str_count(S, \"\\\\bI\\\\b\")\n\
    }\n", "\n    S <- unlist(strsplit(S, \" \"))\n    # your solution here\n    #\
    \ ...\n    return(0)\n}\n</cell>\n<cell>", "\n    boredom_count <- 0\n    \n \
    \   str_split(S, \"[.?!]\") %>% \n      unlist %>% \n      grep(\"^I\", ., value\
    \ = T) %>% \n      nrow \n}\n", "\n  # Your code here\n  boredoms <- unlist(strsplit(S,\
    \ split=\"[.?!]\"))\n  sum(grepl(\"^I\", boredoms))\n}\n</cell>\n<cell>\nis_bored('Hello\
    \ world')\n</cell>\n<cell>\nis_bored('The sky is blue. The sun is shining. I love\
    \ this weather')\n</cell>\n<text>\nIf you do all the coding correctly, you should\
    \ get the following results (i.e. your function returns the value \"2\" for this\
    \ sentence):\n>>> is_bored('Hello world')\n2\n>>> is_bored('The sky is blue. The\
    \ sun is shining. I love this weather')\n2\nWhy don't you try some other test\
    \ cases?\nWrite your code below to test your function.\nDo you get the same result\
    \ for all the sentences?\n\n\n</text>\n<cell>", "\n  S <- strsplit(S, \"\\\\.\"\
    )\n  sapply(S, \"[\", function(x) grepl(\"^I\", x))\n}\n", "\n  S <- unlist(strsplit(S,\
    \ \" \"))\n  s <- strsplit(S, \".\")\n  w <- strsplit(S, pattern = \"[?!]\")\n\
    \  bored <- sapply(s, function(x) {\n    if (x[1] == \"I\") {\n      return(1)\n\
    \    } else if (x[2] == \"I\") {\n      return(1)\n    } else {\n      return(0)\n\
    \    }\n  })\n  return(sum(bored))\n}\n</code>\n<|/ a tags=r,string,regex |>\n\
    <| c |>\nYes, I agree with you on why we should not count words with non-bored\
    \ characters. I did my own implementation. Just thought it would be helpful to\
    \ let the OP know about my work.\n<|/ c |>\n<| c |>\nThank you for the answer.\
    \ I did actually use a similar logic to my work. My main challenge was to find\
    \ the most efficient way to perform this task with minimal coding, just to satisfy\
    \ my curiosity. It seems there is not much room to improve on this problem because\
    \ it is pretty specific to the problem at hand. \n\nI have upvoted your answer\
    \ but have marked one as the accepted one because it was a more efficient way\
    \ of doing what I did. Thanks again.\n<|/ c |>\n<| a tags=r,string,regex |>\n\
    The approach below should do it. I would advise against using strsplit, because\
    \ this splits your string by spaces, punctuation and other characters. In this\
    \ case I would use sub instead.\n<code>\nis_bored <- function(S) {\n    S <- unlist(strsplit(S,\
    \ \" \"))\n    w <- sapply(S, function(x) sub(\"\\\\w+\\\\b\", \"\", x))\n   \
    \ bored <- sapply(w, function(x) sum(x == \"I\"))\n    return(sum(bored))\n}\n\
    \nis_bored(\"Hello world\")\n[1] 0\nis_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n[1] 1\nis_bored(\"The sky is blue. Blip blip\")\n[1]\
    \ 0\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis also works, I did end up using\
    \ a similar logic to yours. Thanks!\n<|/ c |>\n<| c |>\n, you are welcome. If\
    \ you think your question has been answered, feel free to accept an answer that\
    \ helped you the most.\n<|/ c |>\n<| a tags=r,string,regex |>\nThis would work:\n\
    <code>\nis_bored <- function(S) {\n  S <- unlist(strsplit(S, \" \"))\n  ", "\n\
    \    n <- gregexpr(\"^[I].*\", S)  # gregexpr returns a list of the indices that\
    \ match\n    sum(n != 0)  # the n != 0 part is to only count the boredoms that\
    \ start with the letter 'I'\n}\n</cell>\n<text>\nRun the code cell below to test\
    \ your solution.\n\n\n</text>\n<cell>", "\n  count <- 0\n  \n  for (i in seq_along(S))\
    \ {\n    \n    if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n      count <-\
    \ count + 1\n    }\n    \n  }\n  \n  return(count)\n}\n", "\n  S <- unlist(strsplit(S,\
    \ split = \"\\\\.\")[[1]])\n  length(regexpr(\"I\", S)) > 0\n}\n", "\n  boredoms\
    \ <- which(grepl('^[i.!?]$', S, perl=TRUE))\n  length(boredoms)\n}", "\n    boredoms\
    \ <- gregexpr(\"(?<=^|[.?!])I\", S)\n    sum(sapply(boredoms, `[`, 1) == 1)\n\
    }\n</code>\nSome examples of what happens when you run this function on your test\
    \ data.\n<code>\n> is_bored(S = \"The sky is blue. The sun is shining. I love\
    \ this weather.\")\n[1] 1\n> is_bored(S = \"Hello world.\")\n[1] 0\n> is_bored(S\
    \ = \"Hello world.\")\n[1] 0\n> is_bored(S = \"A blue sky? Is that what you mean?\"\
    )\n[1] 0\n> is_bored(S = \"The sky is blue.\")\n[1] 1\n> is_bored(S = \"The sky\
    \ is blue. The sun is shining. I love this weather.\")\n[1] 1\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nI should also mention that this solution uses regular\
    \ expressions. Regex is one of the most powerful features in R. Check out the\
    \ docs for `?regex` for more info. :)\n<|/ c |>\n<| c |>\nThat's true; I tend\
    \ to think of regex as \"the solution\" when it comes to parsing text files. It's\
    \ just that I'm always suspicious about using regex for my own projects, so I\
    \ tend to avoid it as much as I can. One of the reasons is that I tend to think\
    \ of regex in the context of regex, so I try to avoid it as much as possible.\
    \ :)\n<|/ c |>\n<| c |>\nI wonder if there is a way to modify it so that it can\
    \ also find the number of \"i\"s without punctuation such as \"i\"s?\n<|/ c |>\n\
    <| a tags=r,regex,string |>\nHere is an easy way to do this with the stringr package.\n\
    <code>\nlibrary(stringr)\n\nstr_replace_all(S, \"(?<=^|[,.])i\", \"I\")\n\n[1]\
    \ \"HelloI world\"\n[2] \"The skyI is blue. The sunI is shining. I love thisI\
    \ weather.\"\n[3] \"HelloIworld\"\n[4] \"HelloI world\"\n</code>\nThis looks for\
    \ an i at the beginning of a string that either begins before a comma, period\
    \ or question mark. Then replaces it with I.\n<|/ a dscore=3 |>\n<| c |>\nThe\
    \ output has some extra spaces (e.g., `\" I \"`) at the start and end of the string.\n\
    <|/ c |>\n<| c |>\nThis is pretty clever, and probably the most efficient answer.\
    \ The ", "\n  require(stringr)\n  S <- unlist(str_split(S, \"[.?!]\"))\n  sum(S\
    \ == \"I\")\n}\nis_bored(str)\n", "\n    S <- strsplit(S, '\\\\.|\\\\?|\\\\!')\n\
    \    sum(S != I(list(I(\"I\"))))\n}\n", "\n    require(stringr)\n    S <- unlist(strsplit(S,\
    \ '[.?!]'))\n    sum(str_detect(S, '^I')[[1]])\n}\n</cell>\n<text>\nPart 2: Pruning\n\
    Let's create a function to prune the wordcloud before calling make_wordcloud.\
    \ We'll remove words that are not in the bowel_wordlist.\n\n\n</text>\n<cell>",
  "\n  sum(grepl(\"^I\", S))\n}\n", "\n  S <- gsub(\".|!|?|\\\\s|$\", \"\", S, perl=TRUE)\n\
    \  return(sum(grepl(\"^I\", S, ignore.case = TRUE)))\n}\n", "\n  boredoms <- grep(\"\
    ^I\", S)\n  sum(boredoms)\n}\n", "\n  # BEGIN Question 2\n  # Replace this line\
    \ with the code you need.\n  # END Question 2\n  boredom_count <- 0\n  # BEGIN\
    \ Question 1\n  # Replace this line with the code you need.\n  # END Question\
    \ 1\n}\n", "\n  S <- tolower(S)\n  inds <- which(grepl(\"^[ioe][.!?]+$\", S))\n\
    \  sum(inds != 0)\n}\n</code>\nThis does have one small flaw: it only works if\
    \ \"I\" is at the beginning of the sentence. If you want it to work even for sentences\
    \ that start with other words, you'll need to change the regular expression in\
    \ grepl. You could try this with grepl but it's going to be slow:\n<code>\nis.bored\
    \ <- function(S) {\n  S <- tolower(S)\n  inds <- which(grepl(\"\\\\bi[.!?]+\\\\\
    b\", S))\n  sum(inds != 0)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nOh, I forgot\
    \ to add that \"I\" is not at the start of a sentence or in the middle. Sorry.\n\
    <|/ c |>\n<| c |>\nOK, I just edited my answer. Unfortunately there's no easy\
    \ solution for this, at least not with the current version of R.\n<|/ c |>\n<|\
    \ c |>\nHi David, I updated the post to make it more clear. Thanks for your time.\n\
    <|/ c |>\n<| c |>\nThis is very much the best answer, but doesn't quite do the\
    \ trick when it's only finding boredoms. For example: `is_bored(\"the quick brown\
    \ fox\")` should return `3`, but returns `0`.\n<|/ c |>\n<| a |>\nHere's a possibility\
    \ using dplyr & tidyverse.  First I create a variable that tells me if the sentence\
    \ starts with I, then I separate the sentence into words, and finally I count\
    \ the sentences that start with I:\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\n\
    \nsentence <- \"I, the sky is blue. The sun is shining. I love this weather.\"\
    \n\nseparate_sentence <- sentence %>% \n  strsplit(\" \", simplify = T) %>% \n\
    \  unlist() %>% \n  as.data.frame(stringsAsFactors = F) %>% \n  mutate(sentence\
    \ = 1) %>% \n  mutate(word = 1) %>% \n  mutate(sentence = if_else(str_detect(sentence,\
    \ \"^I\"), 1, 0)) %>% \n  group_by(sentence) %>% \n  summarize(word = sum(word))\
    \ %>% \n  mutate(word = if_else(word == 0, 0, word)) %>% \n  select(sentence,\
    \ word) %>% \n  summarize(boredoms = sum(word)) %>% \n  ", "\n  boredoms <- gregexpr(\"\
    ^I\", S)\n  sum(boredoms > 0)\n}\n</code>\nSo far, we've been using gregexpr to\
    \ find the positions of word boundaries. Since we're only interested in counting\
    \ matches, we can simplify this by replacing it with gregexpr(\"^I\", S) - the\
    \ position of the start of word boundary. (The -th element in a vector, counting\
    \ from the right, is simply the element preceding the one we care about.)\nNext,\
    \ we need to find each boredom. grep looks for subsequences matching a pattern.\
    \ gregexpr returns a vector of positions that match. So, if we call grep with\
    \ no arguments (\"look for the whole line\"), grep returns positions in the string\
    \ that match. Since we want to match on just the start of a word (the ^I part\
    \ of the regular expression), we need to change how that part is matched. Since\
    \ we're only interested in counting matches, we can do that by telling grep to\
    \ return the positions of the matches in the input string.\nNext, we need to check\
    \ each of these positions to see if the position is greater than zero, indicating\
    \ that there is at least one match there.\nFinally, we can count these boredoms\
    \ by taking the sum over all of the positions - in other words, how many positions\
    \ in the input string were a boredom.\n<|/ a dscore=3 tags=r |>\n<| a dscore=2\
    \ |>\nA way without using loops is by using gregexpr on the character string and\
    \ subsetting based on this.\n<code>\nx <- \"I love this weather.\"\nlength(gregexpr(\"\
    ^I\", x)[[1]])", "\n    bored = grepl('^I', S)\n    length(which(bored))\n}\n\
    </cell>\n<text>\nRun the following cell to test your code:\n\n\n</text>\n<cell>",
  "\n  n <- 0\n  i <- 1\n  while(i <= length(S)) {\n    word <- unlist(strsplit(S[i],'[.?!]'))[1]\n\
    \    if(word == 'I') n <- n + 1\n    i <- i + 1\n  }\n  return(n)\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=regex,r dscore=4 |>\nAnother method would be to use\
    \ rm_between:\n<code>\nlibrary(stringr)\nlibrary(dplyr)\n\ndf <- data.frame(text\
    \ = c('Hello world', 'The sky is blue. The sun is shining. I love this weather'),\n\
    \                 stringsAsFactors = FALSE)\n\ndf %>% \n  mutate(bored = ifelse(rm_between(text,\
    \ 'I', '.', fixed = TRUE), 1,0))\n</code>\nOutput\n<code>\n                  \
    \              text  bored\n1        Hello world                     0\n2 The\
    \ sky is blue. The sun is shining       1\n3                 I love this weather\
    \       0\n</code>\n<|/ a |>\n<| a tags=regex,r |>\nA more elegant solution is\
    \ to use stringr:\n<code>\nlibrary(stringr)\nbored <- str_detect(df$text, '^I|^\\\
    .|^!')\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYou need the `fixed = TRUE` argument\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\nbored <- grepl(\"^I|^\\\\.|^!\", df$text)\n\
    </code>\n<|/ a tags=regex,r |>\n<| a dscore=3 tags=regex,r |>\nOne more method\
    \ using stringr package:\n<code>\nlibrary(stringr)\nbored <- str_count(df$text,\"\
    ^I\")+str_count(df$text,\"\\\\.\")+str_count(df$text,\"!\")\n</code>\n<|/ a |>\n\
    <| a tags=regex,r |>\nThe most efficient way is to use str_detect from stringr\
    \ package:\n<code>\nlibrary(stringr)\nbored <- str_detect(df$text, \"^I\")+str_detect(df$text,\
    \ \"\\\\.\")+str_detect(df$text, \"!\")\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    I think using `stringr` for this type of task is the most efficient way in this\
    \ case\n<|/ c |>\n<| c |>\nThis answer is not useful, since it uses the function\
    \ `grepl` which is not needed.\n<|/ c |>\n<| a ", "\n    boredoms <- grep(\"^I\"\
    , S, value = TRUE)\n    sum(boredoms)\n}\n", "\n  boreds <- grep('^I', S, value\
    \ = TRUE)\n  return(length(boreds))\n}\n</cell>\n<cell>", "\n  x <- grepl(\"^I\"\
    , S)\n  sum(x)\n}\n", "\n    x <- unlist(strsplit(S, split='(?<=\\\\.|\\\\?| |\\\
    \\!)'))\n    if (all(x %in% c(\"I\", \"are\", \"you\", \"is\", \"am\", \"I\",\
    \ \"am\"))) {\n        x <- 1\n    } else {\n        x <- 0\n    }\n    x\n}\n",
  "\n  is_bored <- function(S) {\n    boredoms <- gregexpr(\"\\\\bI\\\\b\", S)\n \
    \   sum(attr(boredoms, \"match.length\") >= 2)\n  }\n  return(apply(S, 1, is_bored))\n\
    }\n", "\n  S <- unlist(strsplit(S, split='\\\\.')) # split sentences by '.'\n\
    \  bored <- sapply(S, function(x) {\n    grepl('^(I)', x)\n  }) # find sentences\
    \ with 'I' in them\n  length(bored)\n}\n", "\n  S <- tolower(S)\n  N <- 0\n  M\
    \ <- grepl(\"^I\", S)\n  for(i in M)\n    N <- N + 1\n  return(N)\n}\n", "\n \
    \ boreds <- strsplit(S,\".*\\\\.\")[[1]]\n  boreds <- boreds[!grepl(\"^I\",boreds)]\n\
    \  boreds <- which(grepl(\"^I\",boreds))\n  return(length(boreds))\n}\nis_bored(mybored)\n\
    </cell>\n<cell>\nis_bored('The sky is blue. The sun is shining. I love this weather')\n\
    </cell>\n<text>\nTask 3: Count words with specific length\nWrite a function which\
    \ takes a string of words as input and returns a vector of lengths\ncorresponding\
    \ to the number of letters in each word.\n\nFor example:\n>>> myvec <- c(\"Hello\"\
    , \"world\")\n>>> wordlength(myvec)\n[1] 5 4\n</text>\n<cell>\nmyvec <- c(\"Hello\"\
    , \"world\")\n</cell>\n<cell>\nwordlength <- function(myvec) {\n  lengths <- strsplit(myvec,\
    \ ' ')[[1]]\n  lengths <- lengths[!grepl(\"^[a-z]\",lengths)]\n  return(lengths)\n\
    }\nwordlength(myvec)\n</cell>\n<text>\nTask 4: Count words with specific lengths\n\
    Write a function which takes a vector of words as input and returns a vector of\
    \ lengths\ncorresponding to the number of letters in each word. Same as wordlength()\
    \ but this function\nalso takes strings as input.\n\nFor example:\n>>> myvec <-\
    \ c(\"Hello\", \"world\")\n>>> wordlengths(myvec)\n[1] 5 4\n>>> myvec <- c(\"\
    Hello\", \"world\", \"!\", \"!\")\n>>> wordlengths(myvec)\n[1] 5 4\n>>> myvec\
    \ <- c(\"Hello\", \"world\")\n>>> wordlengths(myvec)\n[1] 5 4\n>>> myvec <- c(\"\
    Hello\", \"world\", \"!\", \"!\")\n>>> wordlengths(myvec)\n[1] 5 4\n>>> myvec\
    \ <- c(\"Hello\", \"world\", \"!\", \"!\", \"!\")\n>>> wordlengths(myvec)\n[1]\
    \ 5 4\n>>> myvec <- c(\"Hello\", \"world\", \"!\", \"!\", \"!\", \"!\")\n>>> wordlengths(myvec)\n\
    [1] 5 4\n>>> myvec <- c(\"Hello\", \"world\", \"!\", \"!\", \"!\", \"!\", \"!\"\
    )\n>>> wordlengths(myvec)\n[1] 5 4\n>>> myvec <- c(\"Hello\", \"world\")\n>>>\
    \ wordlengths(myvec)\n[1] 5 4\n\n</text>\n<cell>\nmyve", "\n  S <- unlist(strsplit(S,\
    \ pattern=\"\\\\.|\\\\?|\\\\!\"))\n  sum(S %in% \"I\")\n}\n</cell>\n<text>\nAnd\
    \ now let's test your function\n\n\n</text>\n<cell>\nis_bored(\"Hello world\"\
    )\n</cell>\n<cell>\nis_bored(\"The sky is blue. The sun is shining. I love this\
    \ weather\")\n</cell>\n<text>\nGreat! You should now have a basic idea of how\
    \ to handle input data in R using R's built-in data structures and apply functions\
    \ to them.\n\n\n</text>\n<text>\n\nPart 2: Putting it all together (Bonus)\nLet's\
    \ try to use what we've learned so far to create a full sentiment analyzer capable\
    \ of determining whether a movie review is positive or negative.\n\nWe'll start\
    \ by getting the movie review data using movie reviews from\n earlier. Then, we'll\
    \ use R to build a sentiment analyzer.\n\nTo start, we'll use the same function\
    \ we used in a previous notebook to create a list of words for each review. Next\
    \ we'll count the number of positive and negative words in the list, and add this\
    \ number to our sentiment analyzer.\n\n\n</text>\n<text>\nReview data\nThe dataset\
    \ is stored as a list of reviews.\n\n\n</text>\n<cell>\nmovie_review_df <- read.csv('https://raw.githubusercontent.com/datasciencedojo/Data-Analysis-with-R-Companion/master/datasets/movie-reviews.csv')\n\
    </cell>\n<cell>\nmovie_review_df\n</cell>\n<text>\nLet's take a look at the data\
    \ types of each column to see the types of information that we'll be working with:\n\
    \n\n</text>\n<cell>\nsapply(movie_review_df, class)\n</cell>\n<text>\nThe reviews\
    \ are in character format, so we'll want to convert them to words before we do\
    \ anything else.\n\nLet's create a new column with the word count for each review.\n\
    \n\n</text>\n<cell>\nmovie_review_df$words = unlist(strsplit(movie_review_df$review,\
    \ split=\" \"))\n</cell>\n<cell>\nmovie_review_df\n</cell>\n<text>\nWe can also\
    \ look at the first few rows of the reviews to get a sense of what the sentiment\
    \ analyzer is working with.\n\n\n</text>\n<cell>\nhead(movie_review_df)\n</cell>\n\
    <text>\nNow let's create a column that contains the sentiment score for each review.\
    \ We'll use an if/else statement here since this function is used to create our\
    \ sentiment analyzer.\n\n\n</text>\n<cell>\nmovie_review_df$sentiment", "\n  \n\
    \  # Remove commas and dots from the sentence to make a vector of words.\n  #\
    \ Keep the original string if there is no period.\n  S2 <- gsub(\"[.,?!]\", \"\
    \", S) \n  \n  # Make a list of sentences.\n  S3 <- strsplit(S2, \" \")\n  \n\
    \  # Find the word that starts with \"I\".\n  bored <- FALSE\n  for (i in 1:length(S3))\
    \ {\n    if (S3[[i]][1] == \"I\") {\n      bored <- TRUE\n    }\n  }\n  \n  #\
    \ Return the number of boredoms.\n  return(bored)\n}\n</cell>\n<cell>", "\n  N\
    \ <- 0\n  S <- gsub(\"[.?!]\", \" \", S)\n  for (i in 1:(length(S)-1)){\n    if\
    \ (substring(S[i], 1, 1) != \"I\") {\n      next\n    }\n    \n    next\n  }\n\
    \  \n  return(N)\n}\n", "\n  # Split sentence into words\n  S <- strsplit(S, \"\
    [,?!.]\")[[1]]\n  \n  # Count boredoms by counting the occurrence of the first\
    \ word \"I\"\n  # in the sentence\n  sum( grepl(\"^I\", S) )\n}\n", "\n  M <-\
    \ gregexpr(\"[I]\", S)\n  M <- sapply(M, `[`, 1)\n  sum(M == \"I\")\n}\n</cell>\n\
    <cell>", "\n    len <- nchar(S)\n    bored <- 0\n    for (word in strsplit(S,\
    \ \" \")[[1]]) {\n        bored <- bored + ((grepl(\"^I\", word) & word != \"\
    I\") |\n                          (grepl(\"^!\", word) & word != \"!\") |\n  \
    \                        (grepl(\"^\\.\", word) & word != \".\") |\n         \
    \                 (grepl(\"^,\", word) & word != \",\") |\n                  \
    \        (grepl(\"\\?\", word) & word != \"?\") |\n                          (grepl(\"\
    \\.\", word) & word != \".\"))\n    }\n    return(bored)\n}\n", "\n  S <- gsub(\"\
    \\\\.|!|\\\\?\", \"\", S);\n  S1 <- strsplit(S, \" \");\n  sapply(S1, function(x)\
    \ sum(grepl(\"^I\", x)));\n}\n\nis_bored(\"Hello world\")", "\n  sum(grepl(\"\
    ^I\", S))\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=r,string,string-matching,regex\
    \ |>\nJust to give another approach\n<code>\ngrepl(\"^I\",mystr)\n</code>\n<|/\
    \ a |>\n<| c |>\n`grepl` can find matches on its own, so you don't need to include\
    \ it with `grep` afterwards. Also note that this approach does not find matches\
    \ that are in between words which is what OP asked for\n<|/ c |>\n<| a dscore=0\
    \ |>\nI would use the stringr package:\n<code>\nlibrary(stringr)", "\n    \n \
    \   S <- tolower(S)\n    bored <- grepl(\"^(i|ii)\", S)\n    bored <- length(which(bored\
    \ == TRUE))\n    return(bored)\n}\n</cell>\n<cell>", "\n    S <- unlist(strsplit(S,\
    \ split='[?!.]+'))\n    sum(startsWith(S,c(\"I\")))\n}\n</cell>\n<text>\nQuiz\
    \ Question: Using a TextCorpus, find the total number of boredoms in the corpus\
    \ of documents included in the TextCorpus.\n\n\n</text>\n<cell>\nbored_corpus\
    \ <- TextCorpus(VectorSource(bored_doc_ids))\n</cell>\n<cell>", "\n  S <- gsub(\"\
    [.?!]\", \"\", S) # remove special characters\n  sum((grepl(\"^I\", S) & grepl(\"\
    .\", S))) # count sentences starting with I and ending with a full stop\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nNice answer, but you should probably consider using\
    \ \\b instead of ^I. \\b matches on word boundaries, so it's more precise and\
    \ will still work for strings like \"the\", \"of\", etc.\n<|/ c |>\n<| c |>\n\
    I like your answer, but you should really consider using \\b instead of ^I, as\
    \ that will also match \"The\" and \"That\", which is probably not what you want.\n\
    <|/ c |>\n<| a tags=r,regex dscore=1 |>\nYou can try this, \n<code>\nstrsplit(test1,\
    \ split=\"[?.!]\")[[1]][!grepl(\"^I\",strsplit(test1, split=\"[?.!]\")[[1]])]\n\
    </code>\n<|/ a |>\n<| a |>\nThis worked for me:\n<code>", "\n  S <- strsplit(S,\
    \ \"[.?!]\")[[1]]\n  sum(grepl(\"^I\", S)) == 1L\n}\n</cell>\n<text>\nRun the\
    \ cell below to test your code.\n\n\n</text>\n<cell>\nis_bored('Hello world')\n\
    </cell>\n<cell>\nis_bored('The sky is blue. The sun is shining. I love this weather')\n\
    </cell>\n<text>\nThe cell below will turn in your written answers. Run the cell\
    \ before submitting your assignment.\n\n\n</text>\n<cell>\ngrader[4] = is_bored\n\
    </cell>\n<text>\nQuestion 5\nThe boredom count program you wrote is pretty good,\
    \ but we can do better. Instead of only counting boredoms in the very beginning\
    \ of the string, we can also detect boredoms as soon as they are about to happen.\n\
    \nHow would you edit the program to make it count boredoms wherever they occur?\n\
    \n\n</text>\n<cell>", "\n  str_count <- str_count(S, '(?i)^(?i)(?!I).*[.?!]$')\n\
    \  str_count / length(S)\n}\n</code>\n<|/ a tags=r,string,regex,count |>\n<| a\
    \ |>\nThis works on R 3.5.1\n<code>\nrequire(stringr)\nstr_count(\"The sky is\
    \ blue. The sun is shining. I love this weather.\", regex = \"(?i)^(?!I).*[.?!]$\"\
    )\n</code>\n<|/ a tags=r,string,regex,count dscore=2 |>\n<| a tags=r,string,regex,count\
    \ dscore=1 |>\nJust in case the question is about how to count words in a sentence,\
    \ without using a regex or counting all the punctuation, here is a way that does\
    \ not use a regex or counting all the punctuation:\n<code>\nsentence <- \"Hello\
    \ world! It's been a long time. Today is my favorite day.\"\nsentence %>% strsplit()\
    \ %>% unlist() %>% length()", "\n  boredoms <- unlist(lapply(strsplit(S, '[.?!]'),\
    \ function(x) grepl('^I', x)))\n  length(boredoms)\n}\n</code>\n<|/ a tags=r,regex\
    \ dscore=1 |>\n<| a dscore=0 |>\nAnother option using stringr library and str_count:\n\
    <code>", "\n  boredoms <- 0\n  boredoms <- grepl('^I',S)\n  return(boredoms)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your approach. It would be a lot\
    \ more efficient to test '^I' rather than 'I' as the string starts with 'I'. Also,\
    \ your function will return 0 in other cases (e.g. 'Hello world')\n<|/ c |>\n\
    <| c |>\nThanks. I knew I should have used grepl() instead of grep(). I've modified\
    \ my answer.\n<|/ c |>\n<| c |>\nYeah, I should have explained my thinking a bit\
    \ better. The reason I didn't do that is that I was thinking 'grep' would return\
    \ all the occurrences of the pattern whereas I only want the first one. Hence\
    \ 'grep' would only return a vector of length 1.\n<|/ c |>\n<| c |>\nYeah, your\
    \ `grepl` solution is perfect. I was thinking more of the opposite. Thanks for\
    \ your help!\n<|/ c |>\n<| a tags=r,function |>\nYou could try the stringr package:\n\
    <code>\nlibrary(stringr)\nstr_detect(sentence, pattern = \"^I\")\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=r,function |>\nA dplyr solution:\n<code>\nlibrary(dplyr)\n\
    \nsentence <- \"The sky is blue. The sun is shining. I love this weather\"\n\n\
    sentence %>% \n  dplyr::count(pattern = \"^I\", .names = \"is_bored\") %>% \n\
    \  ungroup()\n</code>\nOutput:\n<code>", "\n  x <- gregexpr(\"I\", S)\n  sum(grepl(\"\
    ^I\", S))\n}\n", "\n  m <- gregexpr(\"[?!.]\", S)\n  count <- 0\n  for(m in m[[1]])\
    \ {\n    if(S[m] == S[1]) count <- count + 1\n  }\n  return(count)\n}\n", "\n\
    \  sum(grepl(\"^I\", S)) > 0\n}\n</cell>\n<cell>", "\n    require(plyr)\n    require(stringr)\n\
    \    require(stringi)\n    str_count <- function(x, y) {\n        length(grep(x,\
    \ y))\n    }\n    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n\
    \    }\n    str_count <- function(x, y) {\n        length(grep(x, y))\n    }\n\
    \    str_count <- function(x, y) {\n        length(grep(x, y))\n    }\n    str_count\
    \ <- function(x, y) {\n        length(grep(x, y))\n    }\n    str_count <- function(x,\
    \ y) {\n        length(grep(x, y))\n    }\n    str_detect <- function(x, y) {\n\
    \        sum(str_detect(x, y))\n    }\n    str_count <- function(x, y) {\n   \
    \     length(grep(x, y))\n    }\n    str_detect <- function(x, y) {\n        sum(str_detect(x,\
    \ y))\n    }\n    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n\
    \    }\n    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n  \
    \  }\n    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n    }\n\
    \    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n    }\n  \
    \  str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n    }\n    str_detect\
    \ <- function(x, y) {\n        sum(str_detect(x, y))\n    }\n    str_count <-\
    \ function(x, y) {\n        length(grep(x, y))\n    }\n    str_detect <- function(x,\
    \ y) {\n        sum(str_detect(x, y))\n    }\n    str_detect <- function(x, y)\
    \ {\n        sum(str_detect(x, y))\n    }\n    str_detect <- function(x, y) {\n\
    \        sum(str_detect(x, y))\n    }\n    str_detect <- function(x, y) {\n  \
    \      sum(str_detect(x, y))\n    }\n    str_detect <- function(x, y) {\n    \
    \    sum(str_detect(x, y))\n    }\n    str_detect <- function(x, y) {\n      \
    \  sum(str_detect(x, y))\n    }\n    str_detect <- function(x, y) {\n        sum(str_detect(x,\
    \ y))\n    }\n    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n\
    \    }\n    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n  \
    \  }\n    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n    }\n\
    \    str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n    }\n  \
    \  str_detect <- function(x, y) {\n        sum(str_detect(x, y))\n", "\n    count_boredoms\
    \ <- 0\n    count <- 0\n    \n    for (i in 1:(length(S)-1)) {\n        if (grepl(\"\
    ^I\", S[i])) {\n            count_boredoms <- count_boredoms + 1\n           \
    \ count <- count + 1\n        }\n    }\n    \n    count_boredoms\n}\n", "\n  S\
    \ <- strsplit(S, ' ')\n  bored <- 0\n  for (i in 1:length(S)) {\n    if (grepl('^I',\
    \ S[i])) {\n      bored <- bored + 1\n    }\n  }\n  return(bored)\n}\n", "\n \
    \ L <- strsplit(S, split = \"[.?!]\", fixed = TRUE)\n  sum(grepl(\"^I\", L)) +\
    \ 1\n}\n", "\n  bored_S <- grep(\"^I\",S,perl=TRUE)\n  if(length(bored_S) > 0)\
    \ {\n    bored_S <- unlist(strsplit(as.character(bored_S),\" \"))\n    bored_S\
    \ <- grep(\"^.\",bored_S,perl=TRUE)\n    bored_S <- grep(\"^.?\",bored_S,perl=TRUE)\n\
    \    bored_S <- grep(\"^!\",bored_S,perl=TRUE)\n    bored_S <- length(bored_S)\n\
    \  } else {\n    bored_S <- 0\n  }\n  return(bored_S)\n}", "\n  S <- as.character(S)\n\
    \  bored = 0\n  for (i in seq_along(gregexpr(\"\\\\bI\\\\b\", S))) {\n    if (substring(S[i],\
    \ 2, 5) == \"bore\") {\n      bored <- bored + 1\n    }\n  }\n  return(bored)\n\
    }\n</code>\nNow we have a function that takes a string and checks the number of\
    \ boredoms (returning a numeric value). I suggest that you take these steps one\
    \ at a time, and try to code each step before proceeding. You will learn more\
    \ if you try to debug each step.\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your\
    \ answer, but can you explain to me how this works? I'm new to R and I don't understand\
    \ why it works this way. For example, why is \"\\\\bI\\\\b\" needed? Why does\
    \ substring take three arguments, not two? Why do I need the for loop? Why does\
    \ the last line return bored and not bored + 1? Also, please let me know if I've\
    \ made any mistakes in my coding skills.\n<|/ c |>\n<| c |>\nThe `\\\\b` parts\
    \ are regular expressions meaning \"word boundary\", which means \"word character\
    \ but not word character\", and the `\\\\bI\\\\b` means \"the word 'I' not followed\
    \ by a word character\".  `substring()` and `gregexpr()` are used to extract substrings\
    \ from a string, and `gregexpr()` returns \"a vector of `matches` where the `matches`\
    \ are of the form start, end and `match`.\"  So the for loop is checking each\
    \ sentence for a substring that begins and ends with the substring \"I\".  `bored`\
    \ starts off as `0`, counts each time `substring()` returns a substring that begins\
    \ with \"I\".  When it returns `NA`, it counts the next time it returns something\
    \ other than `NA`.  When it returns anything else, it counts the next time.\n\
    <|/ c |>\n<| c |>\nIf you run into problems, you can ask specific questions on\
    \ Stack Overflow and we'll help you fix them.  Please ask one question per post.\
    \  When you have a specific question, please post that question and we'll help\
    \ you fix it.\n<|/ c |>\n<| c |>\nOkay I will do that, thanks for your explanation.\
    \ I was having trouble finding the right search terms to find documentation on\
    \ how to search for this particular problem or type of problem.\n<|/ c |>\n<|\
    \ c |>\nJust remember, we only want to help you fix _your_ code, not someone else's.\
    \  We don't really mind if you ", "\n  S <- gsub(\"[?.!]\", \"\", S)\n  x <- strsplit(S,\
    \ \".\")[[1]]\n  sum(x %in% c(\"I\"))\n}\n</cell>\n<cell>", "\n  bored <- grep(\"\
    ^[I]+|^[.!?]*$\", S)\n  return(length(bored))\n}", "\n  gregexpr(\"^I.+\", S)\
    \ + 1\n}\n\nis_bored(\"Hello world\")\nis_bored(\"The sky is blue. The sun is\
    \ shining. I love this weather\")\n", "\n  return(grepl('^I', S) | grepl('^!',\
    \ S) | grepl('.', S) | grepl('!', S) | grepl('?', S))\n}\n", "\n  boredoms <-\
    \ unlist(str_split(S, \"[.?!]\"))\n  sum(boredoms == \"I\")\n}\n", "\n    boredom\
    \ <- grep(\"^I\", S, ignore.case = TRUE, perl=TRUE)\n    return(length(boredom))\n\
    }\n", "\n  S <- tolower(S);\n  str <- unlist(strsplit(S, split = '[.?!]'));\n\
    \  return(sum(str == 'i'));\n};\n</cell>\n<cell>", "\n  L <- unlist(strsplit(S,\
    \ split = \" \"))\n  bored <- which(L %in% c(\"I\", \"I.\")) # or grep('I|I\\\
    .', L)\n  if (length(bored) > 0) return(1) else return(0)\n}\n", "\n  S <- gsub(\"\
    [?!.]\", \"\", S)\n  sum( grepl(\"^I\", S) )\n}\n</cell>\n<cell>", "\n  # Add\
    \ your code here\n  S %>% strsplit(pattern=\"[.?!]\") %>% length == length(which(grepl(\"\
    ^I\",S)))\n}\n</cell>\n<cell>", "\n  grep('^I', S, value = TRUE)\n}\n</cell>\n\
    <cell>", "\n    S <- strsplit(S, split = \" \")[[1]]\n    sum(str_detect(S, \"\
    ^I.*\"))\n}\n", "\n\treturn(sum(grepl(\"^I\",S)))\n}\n</cell>\n<cell>", "\n  #\
    \ Remove whitespace\n  S <- gsub(\"[[:space:]]+\", \"\", S) \n  # Split on periods,\
    \ questions, or exclamation marks\n  S <- strsplit(S, split = \"[\\\\.\\\\?!]+\"\
    )[[1]]\n  # Return number of sentences that start with a capital letter\n  length(grep(\"\
    ^[A-Z]\", S))\n}\n", "\n  n <- length(S)\n  if(n > 0) {\n    boredom <- nchar(\"\
    I\", S)\n    if(boredom > 0) {\n      return(1)\n    } else {\n      return(0)\n\
    \    }\n  }\n  return(0)\n}\n</cell>\n<cell>", "\n  V <- unlist(strsplit(S, split='\\\
    \\.|\\\\?|!'))\n  return(sum(V == 'I'))\n}\n", "\n  return(sum(grepl(\"^I\",S))\
    \ - sum(grepl(\"^!\",S)))\n}\n</cell>\n<cell>", "\n  bored <- S\n  for(i in 2:length(S))\
    \ {\n    if(S[i] == '.' || S[i] == '?' || S[i] == '!') {\n      bored <- paste(bored,\
    \ collapse = \" \")\n    } else {\n      bored <- paste(bored, S[i], sep = \"\
    \ \")\n    }\n  }\n  return(nchar(grep(\"^I\", bored, ignore.case = TRUE, value\
    \ = TRUE))/(nchar(S)-1))\n}\n", "\n  # Remove all punctuation and split the sentence\
    \ on '.', '?' and '!'.\n  S <- tolower(gsub('[[:punct:]]', '', S))\n  S <- strsplit(S,\
    \ split = \"[.?!]\", fixed = TRUE)\n  S <- unlist(S)\n\n  # Find the number of\
    \ sentences that start with \"I\".\n  sum(grepl(\"^i\", S))\n}\n", "\n  S <- tolower(S)\n\
    \  M <- gregexpr(\"^i\", S)\n  N <- attr(M, \"match.length\")\n  sum(grepl(\"\
    ^i\", S, fixed=TRUE))\n}\n</cell>\n<text>\n1.2. Write a function max_boredoms\
    \ to get the maximum number of boredoms any word in the dictionary can have.\n\
    \n\n</text>\n<cell>", "\n  boredoms <- 0\n  for (i in 1:length(S)) {\n    if (substr(S[i],\
    \ 1, 1) == \"I\") {\n      boredoms = boredoms + 1\n    }\n  }\n  return(boredoms)\n\
    }\n", "\n  is_bored <- function(words) {\n    require(plyr)\n    is_bored <- function(words)\
    \ {\n      words <- unlist(strsplit(words, split = \" \"))\n      is_bored <-\
    \ function(words) {\n        require(plyr)\n        is_bored <- function(words)\
    \ {\n          is_bored <- function(words) {\n            require(plyr)\n    \
    \        is_bored <- function(words) {\n              is_bored <- function(words)\
    \ {\n                is_bored <- function(words) {\n                  is_bored\
    \ <- function(words) {\n                    is_bored <- function(words) {\n  \
    \                    is_bored <- function(words) {\n                        is_bored\
    \ <- function(words) {\n                          is_bored <- function(words)\
    \ {\n                            is_bored <- function(words) {\n             \
    \                 is_bored <- function(words) {\n                            \
    \    is_bored <- function(words) {\n                                  is_bored\
    \ <- function(words) {\n                                    is_bored <- function(words)\
    \ {\n                                      is_bored <- function(words) {\n   \
    \                                     is_bored <- function(words) {\n        \
    \                                  is_bored <- function(words) {\n           \
    \                                 is_bored <- function(words) {\n            \
    \                                  is_bored <- function(words) {\n           \
    \                                     is_bored <- function(words) {\n        \
    \                                          is_bored <- function(words) {\n   \
    \                                                 is_bored <- function(words)\
    \ {\n                                                      is_bored <- function(words)\
    \ {\n                                                        is_bored <- function(words)\
    \ {\n                                                          is_bored <- function(words)\
    \ {\n                                                            is_bored <- function(words)\
    \ {\n                                                              is_bored <-\
    \ function(words) {\n                                                        \
    \        is_bored <- function(words) {\n                                     \
    \                             is_bored <- function(words) {\n                \
    \                                                    is_bored <- function(words)\
    \ {\n                                                                      is_bored\
    \ <- function(words) {\n                                                     \
    \                   is_bored <- function(words) {\n                          \
    \                                                                is_bored <- function(words)\
    \ {\n                                                                        \
    \                    is_bored <- function(words) {\n                         \
    \                                                                     is_bored\
    \ <- function(words) {\n                                                     \
    \                                           is_bored <- function(words) {\n  \
    \                                                                            \
    \                    is_bored <- function(words) {\n                         \
    \                                                                           is_bored\
    \ <- function(words) {\n                                                     \
    \                                                 is_bored <- function(words)\
    \ {\n                                                                        \
    \                                is_bored <- function(words) {\n             \
    \                                                                            \
    \                 is_bored <- function(words) {\n                            \
    \                                                                            \
    \    is_bored <- function(words) {\n                                         \
    \                                                                     is_bored\
    \ <- function(words) {\n                                                     \
    \                                                           is_bored <- function(words)\
    \ {\n                                                                        \
    \                                          is_bored <- function(words) {\n   \
    \                                                                            \
    \                                     is_bored <- function(words) {\n        \
    \                                                                            \
    \                                  is_bored <- function(words) {\n           \
    \                                                                            \
    \                                 is_bored <- function(", "\n  boredom_regex <-\
    \ regexpr(\"(?<!^)(?<!\\\\.)(?!I).\", S)\n  stopifnot(boredom_regex > 0)\n  sum(str_detect(S,\
    \ \"^I\"))\n}\n", "\n  stopifnot(S == gsub(\".|!|?\", \" \", S))\n  boredom <-\
    \ grepl(\"^[I]\", S)\n  return(sum(boredom))\n}\n</cell>\n<cell>", "\n  s <- strsplit(S,\
    \ split = \" [?!.]\")[[1]]\n  sum(s == \"I\")\n}\n</cell>\n<cell>", "\n  S <-\
    \ gsub(\"[.!?]\", \" \", S)\n  return(grepl(\"^I\", S))\n}\n</cell>\n<text>\n\
    Task 2: Basic text classification\nWe will now create a classifier for the Iris\
    \ dataset and test it on the Iris data. We'll use cross-validation to split the\
    \ data into training and test sets. Note that this will be a little different\
    \ than the one we used in Task 1. We will use stratified cross-validation here,\
    \ but we will not use this here.\n\nNote that you will be given some functions\
    \ that you will need to implement in order to complete the code for this task!\n\
    \n\n</text>\n<cell>", "\n  num_bored <- sum(grepl('^I', S))\n  return(num_bored)\n\
    }\n", "\n  M <- sapply(strsplit(S, '[.!?]'), function(x) length(x) > 1)\n  sum(M)\n\
    }\n</cell>\n<text>\nRun the following cells to check that your implementation\
    \ matches a few simple test cases.\n\n\n</text>\n<cell>\nis_bored(\"Hello world\"\
    )\n</cell>\n<cell>\nis_bored(\"Hello, world!\")\n</cell>\n<cell>\nis_bored(\"\
    Hello, world?\")\n</cell>\n<cell>\nis_bored(\"I love this weather.\")\n</cell>\n\
    <cell>\nis_bored(\"I love this weather. I am happy.\")\n</cell>\n<cell>", "\n\
    \  S <- tolower(S)\n  grepl('\\\\b(i|i\\\\?|u|u)\\\\b', S)\n}\n</cell>\n<cell>",
  "\n  x <- strsplit(S, split = \"[.?!]\")\n  sum(x %in% c(\"I\", \"I'M\", \"I'm\"\
    , \"i'm\"))\n}\n</cell>\n<text>\nRun the cell below to test your solution.\n\n\
    \n</text>\n<cell>\ntest_is_bored <- function(S) {\n  cat(is_bored(S))\n}\n</cell>\n\
    <cell>\nis_bored('Hello world')\n</cell>\n<cell>\ntest_is_bored('The sky is blue.\
    \ The sun is shining. I love this weather')\n</cell>\n<text>\nSolution\nClick\
    \ below for a solution.\n\n\n</text>\n<cell>\nis_bored <- function(S) {\n  x <-\
    \ strsplit(S, split = \"[.?!]\")\n  sum(x %in% c(\"I\", \"I'M\", \"I'm\", \"i'm\"\
    ))\n}\n</cell>\n<text>\nNow that we have defined is_bored, let's test it to see\
    \ that it works as expected.\n\n\n</text>\n<cell>\nis_bored('Hello world')\n</cell>\n\
    <cell>\nis_bored('The sky is blue. The sun is shining. I love this weather')\n\
    </cell>\n<text>\nFinally, let us create a vector containing the complete text\
    \ of all the books we have access to.\n\n\n</text>\n<cell>\nbooks <- c('The Fellowship\
    \ of the Ring', 'God\\'s Favourite',\n           'The Two Towers', 'Pride and\
    \ Prejudice',\n           'Gone with the Wind and the Weather Saviour', 'Return\
    \ of the King', \n           'The Mummy\\'s Favourite', 'The Shining', 'Who is\
    \ Shakin', \n           'His Admiral', 'The Great Pyramids', 'The Fellowship of\
    \ the Ring', \n           'The Two Towers', 'Pride and Prejudice', 'Gone with\
    \ the Wind and the Weather Saviour', \n           'Return of the King', 'The Mummy\\\
    's Favourite', 'The Shining', \n           'Who is Shakin', 'His Admiral', 'The\
    \ Great Pyramids')\n</cell>\n<text>\nWe can use mapply to count the number of\
    \ times a word appears in each of our books. We also need to supply a function\
    \ that will check whether a word appears in a particular book. The function check_bored\
    \ checks whether the book is a bored one, and returns 0 if it is not, or 1 if\
    \ it is.\n\n\n</text>\n<cell>\n", "\n  boredom <- 0\n  for (i in 1:length(S))\
    \ {\n    if(S[i] == \"I\" & S[i+1] == \"a\" & S[i+2] == \"b\" & S[i+3] == \"e\"\
    \ & \n        S[i+4] == \"n\" & S[i+5] == \"t\" & S[i+6] == \"y\" & S[i+7] ==\
    \ \"!\")\n      boredom <- boredom + 1\n  }\n  return(boredom)\n}\n</code>\nThe\
    \ solution above is very inefficient, and we really only need to check the first\
    \ 3 characters.\nWe can use a recursive function, using substring and grepl:\n\
    <code>\nis_bored <- function(S) {\n  boredom <- 0\n  for (i in 1:length(S)) {\n\
    \    if(S[i] == \"I\" && S[i+1] == \"a\" && S[i+2] == \"b\") {\n      boredom\
    \ <- boredom + 1\n      boredom <- boredom + grepl(\"[.?!]\", substring(x = S,\
    \ from = i, to = 3))\n    }\n  }\n  return(boredom)\n}\n</code>\nHowever, this\
    \ solution also requires a lot of repetition, which we do not want. So, the next\
    \ solution uses a regular expression, using grep and regmatches:\n<code>\nis_bored\
    \ <- function(S) {\n  boredom <- 0\n  for (i in 1:length(S)) {\n    if(S[i] ==\
    \ \"I\" && S[i+1] == \"a\" && S[i+2] == \"b\") {\n      boredom <- boredom + 1\n\
    \      boredom <- boredom + lengths(regmatches(x = S, gregexpr(pattern = \"[.?!]\"\
    , \n                                                        x = S)))\n    }\n\
    \  }\n  return(boredom)\n}\n</code>\nWe can even use a for loop to simplify the\
    \ logic:\n<code>\nis_bored <- function(S) {\n  boredom <- 0\n  for (i in 1:length(S))\
    \ {\n    if(S[i] == \"I\" && S[i+1] == \"a\" && S[i+2] == \"b\") {\n      boredom\
    \ <- boredom + 1\n      boredom <- boredom + length(gregexpr(pattern = \"[.?!]\"\
    , \n                                        x = S[i:i+3]))\n    }\n  }\n  return(boredom)\n\
    }\n</code>\nThe for loop above is probably the simplest and fastest. However,\
    \ it uses regex and grep which can take a long time to run on a very large dataset.\
    \ We can take advantage of vectorization to speed up the process by using sapply\
    \ instead:\n<code>\nis_bored <- function(S) {\n  boredom <- 0", "\n    boredoms\
    \ <- length(grep(\"^I\",S))\n    return(boredoms)\n}\n</code>\n<|/ a tags=r dscore=0\
    \ |>\n<| c |>\nHi, thank you for your reply! I am very new to R and am trying\
    \ to learn it for a project I am working on. I am not sure what I am doing wrong,\
    \ but your solution isn't working for me. I am still getting \"Error: object 'boredoms'\
    \ not found\"\n<|/ c |>\n<| c |>\nHmm, looks like you might have changed the variable\
    \ name in the `grep` command. The variable names in the function should be the\
    \ same as those in the function.\n<|/ c |>\n<| c |>\nHi, I changed it to \"boredoms\
    \ <- length(grep(\"^I\",S))\" but the error is still \"Error: object 'boredoms'\
    \ not found\"\n<|/ c |>\n<| c |>\nHi again! I fixed it now. The problem was that\
    \ I was trying to use boredoms outside of the function. Thank you for your help!!\n\
    <|/ c |>\n<| c |>\nThat's good. If this answers your question, please [accept\
    \ it](https://stackoverflow.com/help/someone-answers) as the answer.\n<|/ c |>\n\
    <| a tags=r dscore=0 |>\nYou have to first define boredoms outside the function.\
    \ Otherwise, R will just create a new variable boredoms for the function.\n<code>\n\
    boredoms <- 0\nis_bored <- function(S) {\n  boredoms <- length(grep(\"^I\",S))\n\
    \  return(boredoms)\n}\n", "\n  s <- strsplit(S, split='\\\\.')\n  sum(sapply(s,\
    \ function(x) sum(x %in% c('I', '!'))))\n}\n", "\n  S <- tolower(S)\n  bored <-\
    \ 0\n  s <- strsplit(S, \" \")\n  for(i in 1:length(s)) {\n    if(s[i] != \"\"\
    )\n    {\n      if(grepl(\"^[iI]\", s[i]))\n      {\n        bored <- bored +\
    \ 1\n      }\n    }\n  }\n  return(bored)\n}\n</cell>\n<cell>", "\n  # The regular\
    \ expression to match\n  pattern <- '^([\\\\.?!])I[\\\\.?!]*'\n  # The regular\
    \ expression counts the number of matches\n  return(gregexpr(pattern, S) %>% lengths)\n\
    }\n</cell>\n<cell>", "\n  S <- gsub(\"[^A-Za-z]+\", \"\", S) # remove non-letters\n\
    \  S <- grep(\"^[I]+$\", S, ignore.case=T) # only boredom sentences\n  return(length(S))\n\
    }\n</cell>\n<cell>", "\n    str_count(S, '^I')\n}\n", "\n    bored_inds <- gregexpr('\\\
    \\bI\\\\b|\\\\b\\\\bI\\\\b|\\\\b\\\\bI\\\\b|\\\\bI\\\\b|\\\\b.*\\\\bI\\\\b', S)\n\
    \    sum(bored_inds)\n}\n</cell>\n<cell>", "\n    S = tolower(S); # Make sure\
    \ we don't have any capital letters\n    words = strsplit(S, \" \"); \n    boredoms\
    \ = sapply(words, function(word) { \n        word = tolower(word); # Make sure\
    \ we don't have any capital letters\n        ifelse(word == \"i\", 1, 0) \n  \
    \  })\n    sum(boredoms > 0) \n}\n", "\n  boredoms <- grep(\"^I\",S,ignore.case=TRUE)\n\
    \  return(length(boredoms))\n}\n", "\n  boreds <- gregexpr(\"^I+\", S)\n  sum(length(boredsapply(S,\
    \ boreds)) > 0)\n}\n</cell>\n<text>\nExercise: Write a function to check whether\
    \ a string has vowels.\nWe can use the %in% operator to do this.\n\n\n</text>\n\
    <cell>", "\n  M <- sapply(str_split(S, ' '), function(x) ifelse(grepl('^I', x),\
    \ 1, 0))\n  M <- rowSums(M)\n  return(M <= 2)\n}", "\n  S <- strsplit(S, \"[.!?]\"\
    , perl=TRUE)[[1]][2]\n  sum(grepl(\"^I\", S))\n}\n</code>\nYou still need to run\
    \ tests on your data:\n<code>", "\n  x <- unlist(strsplit(S, '\\\\.|\\\\?|\\\\\
    !'))\n  xx <- grep(\"^I\", x)\n  as.numeric(length(xx) > 0)\n}\n", "\n  S <- tolower(S)\n\
    \  stopifnot(grepl('^[ie]\\\\s.*', S))\n  count_bored <- 0L\n  S <- strsplit(S,\
    \ ' ')\n  for (i in seq_along(S)) {\n    if (!is.na(S[[i]]) && grepl('^i', S[[i]]))\n\
    \      count_bored <- count_bored + 1L\n  }\n  count_bored\n}\n</cell>\n<text>\n\
    Task 2. Write a function is_rude that accepts a vector of strings (one per person)\
    \ and returns a vector with the same length. Every element of the returned vector\
    \ is a boolean indicating whether each string was rude or not.\n\n\n</text>\n\
    <cell>", "\n  bored = 0\n  i = 2\n  while (i <= length(S)) {\n    if (S[i] ==\
    \ '?') {\n      if (S[i - 1] == '!') {\n        bored = bored + 1\n      }\n \
    \     i = i + 1\n    } else if (S[i] == '.') {\n      if (S[i - 1] == '!') {\n\
    \        bored = bored + 1\n      }\n      i = i + 1\n    } else if (S[i] == '!')\
    \ {\n      bored = bored + 1\n      i = i + 1\n    } else {\n      i = i + 1\n\
    \    }\n  }\n  return(bored)\n}\n", "\n    bored <- grepl(\"^I\", S)\n    sum(bored)\n\
    }\n", "\n  grepl(\"^I\", S)\n}\n", "\n  l <- strsplit(S, pattern = \"[?!.]\")\n\
    \  l1 <- lapply(l, length)\n  sum(c(l1[[1]] > 0, l1[[2]] > 0))\n}\n", "\n    boredoms\
    \ <- sapply(str_split(S, '\\\\.|\\\\?|!'), function(x)\n        ifelse(x == \"\
    I\", 1, 0))\n    sum(boredoms)\n}\n", "\n  S <- tolower(S); # make all letters\
    \ lower case\n  str_c(\"\\\\bI\\\\b\", strsplit(S, \" \\\\.\")[[1]], collapse\
    \ = \"|\")\n}\n</cell>\n<cell>", "\n  # Write your code here.\n  count <- 0\n\
    \  for (i in 1:length(S)) {\n    word = S[i]\n    if(word == '.' || word == '?'\
    \ || word == '!'){\n      count += 1\n    }\n  }\n  return(count)\n}\n</cell>\n\
    <cell>", "\n  m <- gregexpr(\"^I\", S)\n  sum(regmatches(S, m)[[1]] != \"I\")\n\
    }\n</cell>\n<cell>", "\n    S <- unlist(strsplit(S, split = '\\\\.|\\\\?|\\\\\
    !'))\n    sum(grepl(\"^I\", S))\n}\n", "\n  # split into words\n  S <- strsplit(S,\
    \ \" \")[[1]]\n\n  # count boredom words\n  sum(sapply(S, function(x) {\n    if\
    \ (x == \"I\") 1\n    else if (! grepl(\"[\\\\.\\\\?!]\", x)) 0\n    else NA\n\
    \  }, na.rm = TRUE))\n}\n</cell>\n<cell>", "\n  S <- unlist(strsplit(S, split\
    \ = \" \"))\n  sum(grepl(\"^I\", S))\n}\n</cell>\n<cell>", "\n  S <- strsplit(S,\
    \ \" .\")[[1]]\n  sum(grepl(\"^I\", S))\n}\n", "\n  m <- regexpr(\"\\\\b[Ii]\\\
    \\S+\\\\b\", S, perl=T)\n  sum(m > 0)\n}\n</code>\nThe regexpr() call finds the\
    \ first occurrence of the word \"I\" in your string S, then it searches backwards\
    \ for non-whitespace characters (\\S) until the next word boundary (\\b). \nYou\
    \ can see it return 2 for the string \"I love this weather\".\n<|/ a dscore=0\
    \ |>\n<| c |>\nAwesome! Thanks so much for the detailed explanation and the code\
    \ examples!\n<|/ c |>\n<| a dscore=0 tags=count,string,r |>\nHere's a very simple\
    \ and straightforward solution that would work well for your question. The benefit\
    \ of this approach is that it only uses a single regex. Also, it does not require\
    \ a package to run:\n<code>\nis_bored <- function(string){\n  string[grepl(\"\
    I\", string)] == 1\n}\n\nis_bored(\"I love this weather\")\n</code>\n<|/ a |>\n\
    <| a |>\n<code>\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(data.table)\n", "\n\
    \  # Return 0 if no boredoms found\n  boredoms <- gregexpr(\"\\\\bi\\\\b\", S)\n\
    \  return(length(boredoms))\n}\n", "\n  bored <- grepl(\"^I\",S)\n  sum(bored)\n\
    }", "\n  # Write your code here.\n  return(grepl('^I',S)) #regexp '^I' means \"\
    begins with 'I' character\"\n}\n</cell>\n<cell>", "\n    boredom <- which(grepl(\"\
    ^I\", S) == TRUE)\n    boredom <- length(boredom)\n    return(boredom)\n}\n",
  "\n  sapply(strsplit(S, '\\\\.')[[1]], function(x) {\n    grepl('\\\\bI\\\\b', x)\n\
    \  }) %>% \n    sum\n}\n", "\n  boredom_count <- 0\n  \n  for(i in 1:length(S))\
    \ {\n    if(S[i] == '.' || S[i] == '?' || S[i] == '!') {\n      boredom_count\
    \ <- boredom_count + 1\n    }\n  }\n  return(boredom_count)\n}", "\n  l <- strsplit(S,\
    \ \"[.?!]\")[[1]]\n  sum(startsWith(l, \"I\"))\n}\n", "\n  S <- gsub(\"[\\.\\\
    ?!]\",\"\",S)\n  nchar(gsub(\"^I\",\"\",S)) == 1\n}\n", "\n  # Implement this\
    \ function using count_words\n  return(count_words(S, boredom) > 0)\n}\n", "\n\
    \  require(stringr)\n  is_bored <- str_count(S, \"^I\")\n  return(is_bored)\n\
    }\n", "\n  S <- unlist(strsplit(S, split=\"[.!?]\"))\n  return(sum(grepl(\"^I\"\
    , S)))\n}\n</cell>\n<cell>", "\n  boredom_count <- nchar(gsub(\"[\\.\\?\\!]\"\
    , \"\", S, ignore.case = TRUE))\n  return(boredom_count)\n}\n", "\n  l <- str_count(S,\
    \ \"[\\\\.?!]\")\n  sum(l == 1)\n}\n", "\n  boredom_count <- 0\n  for (i in 1:(length(S)-2))\
    \ {\n    x <- grepl(\"^I\", S[i:(i+2)], ignore.case = TRUE)\n    if (length(x)\
    \ == 0) {\n      boredom_count <- boredom_count + 1\n    }\n  }\n  return(boredom_count)\n\
    }\n", "\n  S <- strsplit(S, \"[?.!]\")[[1]]\n  tab <- table(strsplit(S, \"\\\\\
    .\"))\n  tab[tab > 1] <- FALSE\n  sum(tab)\n}\n\nis_bored('Hello world') # 0\n\
    is_bored('The sky is blue. The sun is shining. I love this weather') # 1\nis_bored('The\
    \ sky is blue. The sun is shining. I love this weather.') # 1\nis_bored('The sky\
    \ is blue. The sun is shining. I love this weather.?') # 1\nis_bored('The sky\
    \ is blue. The sun is shining. I love this weather.!') # 1\nis_bored('The sky\
    \ is blue. The sun is shining. I love this weather.!?') # 1\nis_bored('The sky\
    \ is blue. The sun is shining. I love this weather.?!') # 1\nis_bored('The sky\
    \ is blue. The sun is shining. I love this weather.!?!') # 1\nis_bored('The sky\
    \ is blue. The sun is shining.?!?!') # 1\nis_bored('The sky is blue. There is\
    \ nothing shining.') # 1\nis_bored('The sky is blue.The sun is shining.?!?!?!?!?!?')\
    \ # 1\nis_bored('The sky is blue. The sun is shining.!') # 1\nis_bored('The sky\
    \ is blue. The sun is shining.!?!') # 1\nis_bored('The sky is blue. The sun is\
    \ shining.?!?!?!?!?!?!?') # 1\nis_bored('The sky is blue. The sun is shining.!?!?!?!?!?!?!?!?!?!?!?!?!?')\
    \ # 1\nis_bored('The sky is blue.The sun is shining.!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!')\
    \ # 1\nis_bored('The sky is blue.The sun is shining.!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?",
  "\n  s <- unlist(strsplit(S, '[.?!]'))\n  sum(grepl('^I', s))\n}\n</cell>\n<text>\n\
    Finally, define the function that returns true if the sentence is grammatically\
    \ correct, false otherwise.\n\n\n</text>\n<code language=conda-env-data-py>",
  "\n  boredoms <- 0\n  S <- unlist(strsplit(S, \"[.?!]\"))\n  for(i in seq_along(S))\
    \ {\n    if(S[i] == 'I') {\n      boredoms += 1\n    }\n  }\n  return(boredoms)\n\
    }\n</code>\nAnd we test it by making sure it gives us the same answer:\n<code>\n\
    > is_bored(\"I love this weather\")\n[1] 1\n</code>\nYour code will now work:\n\
    <code>\n> is_bored(string)\n[1] 1\n</code>\n<|/ a dscore=1 tags=r,loops |>\n<|\
    \ c |>\nWow thank you so much. This makes it so much easier.\n<|/ c |>\n<| c |>\n\
    No worries, hope it helps.  And welcome to SO.\n<|/ c |>\n<| a |>\nA vectorized\
    \ approach could be this:\n<code>", "\n  # Split S into words, remove '.', '?'\
    \ and '!' from S, and return the count\n  bored <- unlist(strsplit(gsub(\"[.!?]\"\
    ,\"\",S),split=' '))\n  return(length(grep(\"^I\",bored)))\n}\n", "\n  length(grep(\"\
    ^I\", S, value = TRUE))\n}\n</code>\nFor this function to work you will have to\
    \ download the data or to run it locally on your computer, which is not the case\
    \ for your homework question. \nIf your question is about how to get to the data,\
    \ there are many sources to look for it. I suggest looking for a dataset in the\
    \ NLTK website, and to look for any course materials about NLP (Natural Language\
    \ Processing).\n<|/ a tags=text-processing,r,python |>\n<| c |>\nI believe that\
    \ the OP is asking how to do this in R or Python, not how to do this in R. Also,\
    \ your answer does not give the answer to the question.\n<|/ c |>\n<| c |>\nWhat\
    \ do you mean by \"how to do this in R\"? He asked how to do this in R. R can\
    \ run Python functions. R is just an environment.\n<|/ c |>\n<| c |>\nI believe\
    \ what he is asking is to solve a particular type of problem (given a corpus,\
    \ find the number of boredoms occurring in each sentence). He is not asking how\
    \ to do this in R or Python. He is asking how to use the corpus to solve the problem.\
    \ I have given an R solution and pointed him to the NLTK library for how to do\
    \ it. I don't think my answer was bad, but the answer was wrong.\n<|/ c |>\n<|\
    \ c |>\nWhat you do know is how to perform functions on data, so I think the OP\
    \ is asking how to apply those functions on data. He is also asking how to get\
    \ to the data in a way that works for his homework. I am not an expert in NLP,\
    \ but if someone asks how to solve a homework problem, they will likely not be\
    \ able to answer unless they have the exact data necessary to run this algorithm.\n\
    <|/ c |>\n<| c |>\nI don't think my answer was wrong. It was only meant as an\
    \ additional information to clarify the OP's confusion.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI am not familiar with R, but the following Python code should give the\
    \ result you want:\n<code>\nimport re\ndef is_bored(s):\n    matches = re.findall(r'I',\
    \ s)\n    return len(matches) > 0\n\nif __name__ == '__main__':\n    print is_bored('Hello\
    \ world')\n    print is_bored('The sky is blue. The sun is shining. I love this\
    \ weather')\n</code>\n<|/ a tags=text-processing,r,python |>\n<| a |>\nI dont\
    \ have much idea about R but I hope this will help you to do it in python\n<code>\n\
    import nltk", "\n  count <- 0\n  for(i in 1:length(S)) {\n    if(grepl('\\\\bI\\\
    \\b',S[i])==TRUE | grepl('\\\\bi\\\\b',S[i])==TRUE | grepl('\\\\bI\\\\b',S[i])==TRUE\
    \ | grepl('\\\\bi\\\\b',S[i])==TRUE) {\n      count <- count + 1\n    }\n  }\n\
    \  return(count)\n}", "\n  # TODO: Read sentence S into a character vector.\n\
    \  # Hint: Use readLines or readChar.\n  \n  # If the string is empty return 0\n\
    \  if(S == \"\"){\n    return(0)\n  }\n\n  # Split the string into the vector\
    \ words\n  wordVector = strsplit(S, \".\")\n  \n  # Return 1 if the first word\
    \ starts with I, 0 otherwise\n  return(as.integer(grepl(\"I\",wordVector[[1]]))\
    \ + 0)\n}\n", "\n    boredoms <- str_count(S, '[I|!|.][^.!?]*[!?][.!?]*')\n  \
    \  return(sum(boredoms != 0))\n}\n</cell>\n<cell>", "\n  a <- gregexpr(\"(?<=^|[.?!])I\"\
    , S)\n  sum(a > 0)\n}\n", "\n  length(grep(\"^I.*\", S, ignore.case = TRUE))\n\
    }\n\nis_bored('Hello world') # 0\nis_bored('The sky is blue. The sun is shining')\
    \ # 1\nis_bored('The sun is shining. I love this weather.') # 1\nis_bored(\"The\
    \ sky is blue. Hello world. Hello world!\") # 2\nis_bored(\"The sun is shining!\
    \ Hello world!\") # 0\nis_bored(\"The sun is shining. Hello world.\") # 0\nis_bored(\"\
    The sun is shining. Hello world. Hello.\") # 0\nis_bored(\"The sun is shining?\
    \ Hello world!\") # 0\nis_bored(\"The sun is shining. Hello world.\") # 0\nis_bored(\"\
    The sun is shining. Hello world. Hello.\") # 0\nis_bored(\"The sun is shining!\
    \ Hello world.\") # 0\nis_bored(\"The sun is shining! Hello world. Hello.\") #\
    \ 0\nis_bored(\"The sun is shining. Hello world. Hello!\") # 0\nis_bored(\"The\
    \ sun is shining? Hello world.\") # 0\nis_bored(\"The sun is shining? Hello world.\
    \ Hello.\") # 0\nis_bored(\"The sun is shining! Hello world. Hello!\") # 0\nis_bored(\"\
    The sun is shining? Hello world. Hello.\") # 0\nis_bored(\"The sun is shining?\
    \ Hello world. Hello!\") # 0\nis_bored(\"The sun is shining! Hello world. Hello!\"\
    ) # 0\nis_bored(\"The sun is shining? Hello world. Hello!\") # 0\nis_bored(\"\
    The sun is shining! Hello world. Hello!\") # 0\nis_bored(\"The sun is shining?\
    \ Hello world. Hello!\") # 0\nis_bored(\"The sun is shining! Hello world. Hello!\"\
    ) # 0\nis_bored(\"The sun is shining? Hello world. Hello!\") # 0\nis_bored(\"\
    The sun is shining! Hello world. Hello!\") # 0\nis_bored(\"The sun is shining?\
    \ Hello world. Hello!\") # 0\nis_bored(\"The sun is shining! Hello world. Hello!\"\
    ) # 0\nis_bored(\"The sun is shining? Hello world. Hello", "\n  S <- strsplit(S,\
    \ split=\"(?<=.)[?!]+\")[[1]]\n  sum(grepl(\"^I\", S))\n}\n</cell>\n<cell>", "\n\
    \  S <- gsub(\" \\\\.[\\\\?!] *\", \"\", S, perl = TRUE)\n  M <- strsplit(S, \"\
    \ \")[[1]]\n  boredom <- grepl(\"^I\", M, perl = TRUE)\n  sum(boredom)\n}\n\n\
    </cell>\n<cell>", "\n  boredoms <- strsplit(S, \"[.?!]\")\n  sum(grepl(\"^I\"\
    , boredoms[[1]]))\n}\n\nis_bored(\"Hello world\")", "\n  S <- unlist(strsplit(S,\
    \ split = \" \"))\n  is_bored <- 0\n  for (i in 1:length(S)) {\n    if (grepl(\"\
    ^I\", S[i])) {\n      is_bored <- is_bored + 1\n    }\n  }\n  return(is_bored)\n\
    }\n</cell>\n<text>\nNow try it on all the sentence pairs:\n\n\n</text>\n<cell>\n\
    sentence_pairs <- c(\"Hello world\", \"The sky is blue. The sun is shining. I\
    \ love this weather.\")\n</cell>\n<cell>\nsentence_pairs\n</cell>\n<cell>\nis_bored(sentence_pairs)\n\
    </cell>\n<text>\nFinally, let's print a table of what we've learned.\n\n\n</text>\n\
    <cell>\ncbind(sentence_pairs, is_bored(sentence_pairs))\n</cell>\n<text>\nTask\n\
    The task consists of two parts: (1) creating new variable names, and (2) writing\
    \ a function. The variable names must be capitalized and delimited with underscores,\
    \ and must be of the form bore_x. Each of these words must be in quotation marks,\
    \ like \"boredom\". You must name the new variable names after the original sentence\
    \ pairs, but with a different suffix. For example, in the sentence pairs above,\
    \ if we name the new variables bore_1 and bore_2, then we would get:\n\nsentence_pairs\
    \   is_bore_1  is_bore_2\n\"Hello world\"    0          0\n\"The sky is blue.\"\
    \    1          0\n\"The sun is shining.\" 1          1\n\"I love this weather.\"\
    \ 0          1\n\n\n</text>\n<cell>", "\n  # Split S in to sentences.\n  S <-\
    \ strsplit(S, pattern = \"[.?!]\")\n  # Count the number of sentences that start\
    \ with the word \"I\".\n  sum(grepl(\"^I\", S) & grepl(\"^I\", S[[1]]))\n}\n\n\
    is_bored(hello_world_bored)\nis_bored(hello_world_bored_test)\nis_bored(hello_world_bored_test)\n\
    is_bored(hello_world_bored_test_test)\nis_bored(hello_world_bored_test_test_test)\n\
    is_bored(hello_world_bored_test_test_test_test)\nis_bored(hello_world_bored_test_test_test_test_test)\n\
    is_bored(hello_world_bored_test_test_test_test_test_test)\n</cell>\n<cell>", "\n\
    \  S <- strsplit(S, \"[.?!]\")\n  n <- 0\n  for(i in seq_along(S))\n    if(S[i][1]\
    \ == \"I\") n <- n+1\n  return(n)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks,\
    \ I wasn't aware of such possibility!\n<|/ c |>\n<| a tags=r,string |>\nYou can\
    \ use the gregexpr() function to count the number of times each pattern appears\
    \ in a string. For example:\n<code>\ngregexpr(\"I\",stringr::str_split(\"Hello\
    \ world\", sep = \".\", simplify = T))$lengths\n</code>\nwill return the number\
    \ of occurrences of \"I\" in the string \"Hello World\". The result is 1 since\
    \ \"Hello World\" starts with \"I\".\n<|/ a dscore=1 |>\n<| a |>\nYou could use\
    \ stringr and str_count from base R:\n<code>\nrequire(stringr)\n\nstr_count(string\
    \ = \"Hello world\",pattern = \"I\")", "\n  S <- tolower(S)\n  bored <- grepl('^[ie!]*$',\
    \ S)\n  sum(bored)\n}\n\nis_bored(\"The sky is blue. The sun is shining. I love\
    \ this weather.\")\n</cell>\n<text>\n6. Extract tweets using tweepy (Python)\n\
    (adapted from )\n\n\n</text>\n<cell>", "\n  boredoms <- sum(grepl(\"^I\",S))\n\
    \  return(boredoms)\n}\n", "\n  S <- tolower(S)\n  sapply( gregexpr(\"^i\", S),\
    \ function(x) sum(x != 1) )\n}\n", "\n    S <- unlist(strsplit(S, \" \"))\n  \
    \  sum(grepl(\"^[I].*\", S) & grepl(\"\\\\.|!|?|\\\\?\", S))\n}\n</code>\nThen\
    \ we can use it like this:\n<code>\ndf <- data.frame(\n    sentences = c(\n  \
    \      \"The sky is blue.\",\n        \"The sun is shining.\",\n        \"I love\
    \ this weather.\"\n    ),\n    bored = c(0, 2, 1)\n)\n</code>\nThen,\n<code>\n\
    df$bored <- is_bored(df$sentences)\n</code>\n<|/ a |>\n<| a dscore=1 tags=r,string\
    \ |>\nYou could try something like this with a combination of str_detect and str_split:\n\
    <code>\ndf <- data.frame(x = c(\"The sky is blue.\", \"The sun is shining.\",\
    \ \"I love this weather.\"))\n\ndf$x <- as.character(df$x)\n\ndf$bored <- sapply(df$x,\
    \ function(x) {\n  x <- unlist(strsplit(x, \" \"))\n  sum(str_detect(x, \"^[I].*\"\
    ))\n})\n</code>\n<|/ a |>\n<| a dscore=1 tags=r,string |>\nYou can get away with\
    \ using a loop and a regular expression here:\n<code>", "\n  x <- grepl(\"^I\"\
    ,S,perl=TRUE)\n  sum(x)\n}\n", "\n  a <- gregexpr(\"[[:<:]]I[[:>:]]\", S)\n  sum(c(TRUE,\
    \ length(S)-a[1]>0) >= 2)\n}\nis_bored(\"Hello world\")\nis_bored(\"The sky is\
    \ blue. The sun is shining. I love this weather\")\nis_bored(\"I love this weather.\"\
    )\nis_bored(\"The sun is shining. I love this weather\")\nis_bored(\"The sun is\
    \ shining.\")\nis_bored(\"The sun is shining? I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this weather\")\nis_bored(\"The sun is shining! I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this weather\")\nis_bored(\"The sun is shining! I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this weather\")\nis_bored(\"The sun is shining! I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this weather\")\nis_bored(\"The sun is shining! I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this weather\")\nis_bored(\"The sun is shining! I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this weather\")\nis_bored(\"The sun is shining! I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this weather\")\nis_bored(\"The sun is shining! I love this weather\")\nis_bored(\"\
    The sun is shining! I love this weather\")\nis_bored(\"The sun is shining! I love\
    \ this ", "\n  n <- nchar(gsub(\"[?.!]\", \"\", S)) # Count the number of periods\
    \ (.)\n  return(sum(substr(S, 1, n) == \"I\"))\n}\n", "\n    S <- strsplit(S,'\
    \ ')[[1]]\n    sum(grepl(\"^I\",S,fixed = TRUE))\n}\nis_bored(\"Hello world\")",
  "\n  boredoms <- gregexpr(\"[[:<:]]I[[:>:]]\", S)\n  sum(unlist(lapply(boredoms,\
    \ `[`, -1)))\n}\n", "\n  S <- unlist(strsplit(S,split='.|\\\\?|!'))\n  sum(S[1]=='I')\n\
    }\n</code>\nThen you can test it out like so:\n<code>\n> is_bored('Hello world')\n\
    [1] 0\n> is_bored('The sky is blue. The sun is shining. I love this weather')\n\
    [1] 1\n</code>\n<|/ a tags=r,string |>\n<| c |>\nI think that is wrong. Should\
    \ not it be `sum(S[1]=='I')` instead of `sum(S[1]=='i')`?\n<|/ c |>\n<| c |>\n\
    : good catch, thanks. I've corrected my answer and added some explanation to my\
    \ answer as well.\n<|/ c |>\n<| a tags=r,string |>\n<code>\nlibrary(stringr)\n\
    myvector <- c(\"hello world\", \"world hello \", \"hello world\") \nstr_count(myvector,\
    \ \"hello\")\n[1] 3 2 1\n</code>\n<|/ a dscore=5 |>\n<| a tags=r,string |>\nYou\
    \ can also do this with gsubfn\n<code>\nlibrary(gsubfn)\ngrep(\"hello\", strsplit(\"\
    hello world\", \"\\\\W+\"))\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 tags=r,string\
    \ |>\nIf you have a vector of strings, and you want to count all occurrences of\
    \ a specific string, you can use str_count() from the stringr package (for strings).\n\
    <code>\nvec <- c(\"hello world\", \"world hello \", \"hello world\")\nstr_count(vec,\
    \ \"hello\")\n[1] 3 2 1\n</code>\n<|/ a |>\n<| a |>\nHere is an approach with\
    \ base R using gregexpr:\n<code>\n> x <- 'the quick brown fox jumps over the lazy\
    \ dog'\n> gregexpr(\"[[:alpha:]]+\",x)[[1]][[1]]\n[1] \"the\"     \"quick\"  \
    \ \"brown\"   \"fox\"     \"jumps\"   \"over\"    \"lazy\"   \"dog\"    \n> gregexpr(\"\
    [[:alpha:]]+\",x)[[1]][[2]]\n[1] \"quick\"  \"brown\"  \"fox\"    \"jumps\"  \"\
    over\"   \"lazy\"   \"dog\" \n> gregexpr(\"[[:alpha:]]+\",x)[[1]][[3]]\n[1] \"\
    brown\"  \"fox\"    \"jumps\"  \"over\"   \"lazy\"   \"dog\" \n> gregexpr(\"[[:alpha:]]+\"\
    ,x)[[1]][[4]]\n[1] \"fox", "\n  S <- tolower(S)\n  \n  boredoms <- sapply(lapply(strsplit(S,\
    \ \"[.?!]\"), grep(\"^i\", )), length)\n  \n  # If boredoms == 0 then we didn't\
    \ find a boredom, so return\n  # FALSE. If boredoms == 1 then we found a boredom,\
    \ so return\n  # TRUE.\n  return(boredoms == 0)\n}\n", "\n  S <- unlist(strsplit(S,'\
    \ '))\n  count <- 0\n  for(i in 1:length(S)) {\n    if(S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!') {\n      count <- count + 1\n    }\n  }\n  return(count)\n\
    }\n", "\n  L <- strsplit(S, \"[.?!]\")\n  sum(startsWith(L, \"I\"))\n}", "\n \
    \ n <- 0\n  for (i in 1:(length(S)-1)) {\n    if (grepl(\"^I\", S[i]) & grepl(\"\
    ^[.!?]\", S[i+1])==FALSE) {\n      n <- n + 1\n    }\n  }\n  return(n)\n}\n",
  "\n  # Split the sentence into an array based on the delimiters.\n  split_S <- strsplit(S,\
    \ c('.', '?', '!'))\n\n  # Initialize a variable for the number of boredoms.\n\
    \  boredoms <- 0\n  \n  # For each array in the split sentence...\n  for(i in\
    \ seq_along(split_S)) {\n    # Count the number of boredoms.\n    if(split_S[[i]][1]\
    \ == 'I') {\n      boredoms <- boredoms + 1\n    }\n  }\n  \n  # Return the number\
    \ of boredoms.\n  return(boredoms)\n}\n</cell>\n<text>\nRun the next cell to test\
    \ your implementation.\n\n\n</text>\n<cell>\nis_bored('The sky is blue. The sun\
    \ is shining. I love this weather.')\n</cell>\n<text>\nQuestion 3\nUsing your\
    \ is_bored function, use it to count the length of a sentence (S below).\n\n\n\
    </text>\n<cell>", "\n  boredom = grep(\"^I\", S)\n  bored = length(boredom)\n\
    \  return(bored)\n}\n", "\n    S <- tolower(S)\n    sum(grepl(\"^i\", S) & !grepl(\"\
    ^[!?.]\", S))\n}\n</cell>\n<cell>\nis_bored(sentence)\n</cell>\n<text>\nBONUS:\
    \ Write a function\n\n</text>\n<cell>", "\n  S <- tolower(S)\n  L <- gregexpr(\"\
    \\\\b[iy]?\\\\b\",S)\n  bore <- length(L[[1]])\n  return(bore)\n}\n</cell>\n<cell>",
  "\n  boredoms <- which(grepl(\"^I\", S))\n  return(length(boredoms))\n}\n", "\n\
    \    bored <- gregexpr(\"^I\", S)[[1]]\n    nchar(S)-sum(bored)\n}\n</cell>\n\
    <cell>\nis_bored('Hello world')\n</cell>\n<cell>\nis_bored('The sky is blue. The\
    \ sun is shining. I love this weather')\n</cell>\n<cell>\nis_bored('The sky is\
    \ blue. The sun is shining?')\n</cell>\n<text>\nThe is_bored function works. Try\
    \ it for yourself on some test cases.\n\n\n</text>\n<text>\n(Optional) Task: Gender\
    \ ratio check\n\n</text>\n<text>\nWrite a function that returns a list of all\
    \ words in a given string, except for the first and last.\n\nThe string will consist\
    \ of lowercase English letters.\nThe function will take in one argument - the\
    \ string itself. \nThe function should return a vector of strings containing the\
    \ first and last words of the string.\nThe first and last words will only appear\
    \ once, and there will always be at least 2 words.\nThe function should not include\
    \ duplicate words.\nIf there are more than two words, you should return \"Too\
    \ many words\".\n\nTest your function on several examples of strings:\n\n- Test\
    \ case 1: input string 'Hello world'\n- Expected output: 'Hello', 'world'\n\n\
    - Test case 2: input string 'Hi my name is Kelly'\n- Expected output: 'Hi', 'my',\
    \ 'name', 'is', 'Kelly'\n\n- Test case 3: input string 'My name is Kelly'\n- Expected\
    \ output: 'My', 'name', 'is', 'Kelly'\n\n- Test case 4: input string 'Hi my name\
    \ is Kelly. My name is Kelly'\n- Expected output: 'Hi', 'my', 'name', 'is', 'Kelly'\n\
    \n- Test case 5: input string 'My name is Kelly. Hi my name is Kelly. Hi my name\
    \ is Kelly'\n- Expected output: 'My', 'name', 'is', 'Kelly'\n\n- Test case 6:\
    \ input string 'My name is Kelly. My name is Kelly. My name is Kelly'\n- Expected\
    \ output: 'My', 'name', 'is', 'Kelly'\n\n- Test case 7: input string 'My name\
    \ is Kelly. My name is Kelly. My name is Kelly. My name is Kelly. My name is Kelly'\n\
    - Expected output: 'Too many words'\n\n- Test case 8: input string 'My name is\
    \ Kelly. My name is Kelly. My name is K", "\n  boredoms <- grepl('^I.*', S)\n\
    \  sum(boredoms)\n}\n</cell>\n<cell>", "\n    boredom_count <- 0\n    boredom_list\
    \ <- gregexpr('\\\\bI\\\\b|\\\\byou\\\\b|\\\\bare\\\\b|\\\\bwere\\\\b|\\\\bare\\\
    \\b|\\\\b', S, perl = TRUE)\n    for (i in 1:length(boredom_list)) {\n       \
    \ boredom_count <- boredom_count + (boredom_list[i]-boredom_list[i-1]+1)\n   \
    \ }\n    return(boredom_count)\n}\n", "\n  return(length(grep(\"^I\", S)) > 0)\n\
    }\n", "\n  n <- gregexpr(\"[\\.?!](I)\", S)\n  sum(regmatches(S, n)[[1]] == 'I')\n\
    }\n", "\n  # print ('is_bored', S) # debug\n  n <- str_count(S, '.')\n  n <- n\
    \ + str_count(S, '?')\n  n <- n + str_count(S, '!')\n  return(n)\n}\n", "\n  boredoms\
    \ <- nchar(gsub(\"[\\\\.\\\\?!]\", \"\", S)) > 1\n  return(sum(boredoms))\n}\n\
    </cell>\n<cell>", "\n    S <- tolower(S)\n    L <- strsplit(S, \".|\\\\?|!\")[[1]]\n\
    \    boredom <- sum(grepl(\"^i\", L))\n    return(boredom)\n}\n</cell>\n<text>\n\
    Let's try it out:\n\n\n</text>\n<cell>\nis_bored('Hello world')\n</cell>\n<cell>\n\
    is_bored('The sky is blue. The sun is shining. I love this weather.')\n</cell>\n\
    <text>\nHow would you re-implement this function in R?\n\n\n</text>\n<cell>\n\
    is_bored <- function(S) {\n    S <- tolower(S)\n    L <- strsplit(S, \".|\\\\\
    ?|!\")[[1]]\n    boredom <- sum(grepl(\"^i\", L))\n    return(boredom)\n}\n</cell>\n\
    <cell>\nis_bored('Hello world')\n</cell>\n<cell>\nis_bored('The sky is blue. The\
    \ sun is shining. I love this weather.')\n</cell>\n<text>\nNow let's apply it\
    \ to some example sentences.\n\n\n</text>\n<cell>\nbored_sentences <- c('Is that\
    \ a bored world?','I love this weather.','Is my body bored?')\n</cell>\n<cell>\n\
    sapply(bored_sentences,is_bored)\n</cell>\n<text>\nUsing a loop\nNow let's use\
    \ for loops to implement is_bored. We'll need two indices, one for L, the list\
    \ created in strsplit, and the other for boredom.\n\n\n</text>\n<cell>\nis_bored\
    \ <- function(S) {\n    S <- tolower(S)\n    L <- strsplit(S, \".|\\\\?|!\")[[1]]\n\
    \    boredom <- 0\n    for (i in 1:length(L)) {\n        boredom <- boredom +\
    \ (grepl(\"^i\", L[i]))\n    }\n    return(boredom)\n}\n</cell>\n<cell>\nis_bored('Hello\
    \ world')\n</cell>\n<cell>\nis_bored('The sky is blue. The sun is shining. I love\
    \ this weather.')\n</cell>\n<text>\nNow let's apply this to some example sentences.\n\
    \n\n</text>\n<cell>\nbored_sentences <- c('Is that a bored world?','I love this\
    \ weather.','Is my body bored?')\n</cell>\n<cell>\n", "\n  S <- tolower(S)\n \
    \ M <- gregexpr(\"[[:<:]](bore)?[[:>:]]\", S)\n  length(attr(M, \"match.length\"\
    )[[1]])\n}\n", "\n  # Implement a function that takes a string as its argument\
    \ and returns the number\n  # of boredoms (\"I\") in the string.\n  \n  # BEGIN\
    \ YOUR CODE HERE\n  \n  # END YOUR CODE\n}\n", "\n  bored <- 0\n  i <- 1\n  while(i\
    \ <= length(S)) {\n    if(S[i] == \"I\" ||\n       (S[i] == '.' && S[i - 1] ==\
    \ '.') ||\n       (S[i] == '.' && S[i - 1] == '?') ||\n       (S[i] == '?' &&\
    \ S[i - 1] == '!')) {\n      bored <- bored + 1\n    }\n    i <- i + 1\n  }\n\
    \  bored\n}\n", "\n  boredoms <- regexpr('(?<=^|[.?!])[I]', S, perl=TRUE)\n  return(length(boredoms))\n\
    }\n", "\n    words <- strsplit(S, \" \", fixed = TRUE)\n    boredom_count <- sum(grepl(\"\
    ^I\", words[[1]]), na.rm = TRUE)\n    return(boredom_count)\n}\nis_bored(\"Hello\
    \ world\")\nis_bored(\"The sky is blue. The sun is shining. I love this weather\"\
    )", "\n    M <- gregexpr(\"^I\", S)\n    M[[1]][1] != 0\n}\n", "\n  n <- 0\n \
    \ for (i in 1:(length(S)-4)) {\n    if (S[i] == 'I' & S[i+3] == '.' & S[i+6] ==\
    \ '!') {\n      n <- n + 1\n    }\n  }\n  return(n)\n}\n</code>\nFinally, let's\
    \ test your code:\n<code>\nis_bored <- function(S) {\n  n <- 0\n  for (i in 1:(length(S)-4))\
    \ {\n    if (S[i] == 'I' & S[i+3] == '.' & S[i+6] == '!') {\n      n <- n + 1\n\
    \    }\n  }\n  return(n)\n}\n\nis_bored(\"I love this weather.\")", "\n  S <-\
    \ gsub(\"[?!]\", \".\", S)\n  S <- strsplit(S, split = \"[.!?]\")[[1]]\n  sum(startsWith(S,\
    \ \"I\"))\n}\n", "\n    x <- unlist(strsplit(S, split = \" \"))\n    sum(x ==\
    \ \"I\")\n}\n", "\n  N <- length(s)\n  M <- gregexpr('.', S)\n  M <- M[[1]] +\
    \ M[[2]] - 1\n  L <- gregexpr('.?', S)\n  L <- L[[1]] + L[[2]] - 1\n  MN <- gregexpr('!',\
    \ S)\n  MN <- MN[[1]] + MN[[2]] - 1\n  return(sum(S %in% c(\"I\", \"i\", \"I\"\
    , \n            \"i\", \"!\", \"!\", \n            \".\", \"?\", \".\")[M : M\
    \ + MN - 1]))\n}\n</code>\nThe second part of your question involves the use of\
    \ tm and text2corpus. You want to tokenize your text and transform it into documents,\
    \ where each document is a vector of terms, where each term is a term from your\
    \ original corpus. There are many ways to do this, but I used the tm package and\
    \ the text2corpus function. The first two lines of code do this:\n<code>\ntt <-\
    \ text2corpus(txt)\ntt <- tm::removeSparseTerms(tt, sparse = 0.99)\ntt <- tm::removeSparseTerms(tt,\
    \ sparse = 0.05)\n</code>\nThe third line removes sparse terms (see ?removeSparseTerms),\
    \ and finally it gets rid of the empty document at the end (but we didn't want\
    \ to use it anyways). \nNow that you have a corpus with terms, you can run it\
    \ through the boredom function:\n<code>\nboredoms <- textstats::boredom(tt)\n\
    </code>\nAnd a quick look at the first few results:\n<code>\nhead(boredoms)",
  "\n    sum(grepl('^I', S))\n}\n", "\n  n <- nchar(S)\n  boredom <- rep(0, n)\n \
    \ boredom[substr(S, 1, 1) == \"I\"] <- 1\n  boredom\n}\n\nis_bored(str1) # 1\n",
  "\n    sum(grepl(\"^I\",S)) \n}\n", "\n  bored <- unlist(strsplit(S, split='\\\\\
    .|\\\\?|!'))\n  sum(startsWith(bored, \"I\"))\n}\n</cell>\n<text>\nRun the cell\
    \ below to test your solution. Make sure it returns the expected value.\n\n\n\
    </text>\n<cell>\nis_bored(\"Hello world\")\n</cell>\n<cell>\nis_bored(\"The sky\
    \ is blue. The sun is shining. I love this weather.\")\n</cell>\n<cell>\nis_bored(\"\
    The sun is shining. I love this weather.\")\n</cell>\n<text>\nFinally, create\
    \ a vector 'bored' containing all the is_bored answers.\n\n\n</text>\n<cell>\n\
    bored <- c(is_bored(\"Hello world\"), is_bored(\"The sun is shining\"), is_bored(\"\
    The sun is shining\"), is_bored(\"I love this weather\"))\n</cell>\n<cell>\nbored\n\
    </cell>\n<text>\nAnd then calculate the ratio between the bored and the happy\
    \ customers.\n\n\n</text>\n<cell>\nratio <- bored / sum(bored) * 100\n</cell>\n\
    <cell>\nratio\n</cell>\n<text>\nThat looks way more reasonable than the other\
    \ statistics I've seen so far! Feel free to check out your solutions on the course\
    \ website.\n\n\n</text>\n<text>\nQuiz Question: Proportion between happy and bored\
    \ is what you'd expect based on the ratio calculated earlier. Why do you think\
    \ that is?\n\n\n</text>\n<text>\nExploring HTML character entities\nIf you read\
    \ recent essays like this essay, you'll find that some of them use HTML character\
    \ entity references such as &nbsp;, &amp;, or &gt;. You might be able to adapt\
    \ what you learned in the previous chapters to clean up the corpus of documents.\
    \ In the cell below, write a function to convert the corpus of documents to a\
    \ corpus where all entities (e.g. &amp;) are replaced with their corresponding\
    \ characters.\n\n\n</text>\n<cell>", "\n  sum(grepl(\"^I\", S))\n}\n", "\n  boredoms\
    \ <- strsplit(S, \" \")[[1]]\n  sum(grepl(\"^I\", boredoms)) > 1\n}\n", "\n  boredoms\
    \ <- c()\n  sentence <- unlist(strsplit(as.character(S), \" \"))\n  for(i in 1:length(sentence))\
    \ {\n    if(grepl(\"^I\", sentence[i])) {\n      boredoms <- c(boredoms, i)\n\
    \    }\n  }\n  length(boredoms)\n}\n", "\n  require(stringr)\n  is_bored <- str_detect(S,\
    \ \"^[I].*[.?!]\")\n  sum(is_bored)\n}\n", "\n    S <- strsplit(S, ' ')[[1]]\n\
    \    S <- strsplit(S, ' ')[[1]][1]\n    count <- 1\n    for (i in seq(along=S))\
    \ {\n        if (substr(S[i], 1, 1) == 'I') {\n            count <- count + 1\n\
    \        }\n    }\n    return(count)\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
