name: HumanEval_58_common
language: r
prompt: "# Return sorted unique common elements for two lists.\n# >>> common(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n# c(1, 5, 653)\n# >>> common(c(5,\
  \ 3, 2, 8), c(3, 2))\n# c(2, 3)\ncommon <- function(l1, l2) {"
tests: "test_humaneval <- function() {\ncandidate <- common\n    if(!identical(candidate(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c()), c())){quit('no', 1)}\n}\n\
  test_humaneval()"
completions: ["\n  common <- unique(c(l1, l2))\n  idx <- order(common)\n  c(common[idx[-length(idx)-1]],\
    \ common[idx[-1L]])\n}\n", "\n  # Store common elements in an atomic vector\n\
    \  l1 <- sort(l1)\n  l2 <- sort(l2)\n  out <- c(l1, l2)\n  out <- unique(out)\n\
    \  return(out)\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  common1 <-\
    \ intersect(u1, u2)\n  common2 <- intersect(u2, u1)\n  common\n}\n</code>\n<|/\
    \ a dscore=1 tags=r,dataframe |>\n<| a dscore=1 |>\nI did it with data.table as\
    \ follows.\n<code>\nlibrary(data.table)", "\n  l <- sort(union(l1, l2))\n  l[!duplicated(l)]\n\
    }\n</code>\n<|/ a tags=dataframe,r,sorting |>\n<| a |>\n<code>", "\n  u1 <- unique(l1)\n\
    \  u2 <- unique(l2)\n  u1 <- intersect(u1, u2)\n  return(u1)\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\nThis solution uses the data.table package and\
    \ should scale well to larger data.\n<code>\nlibrary(data.table)\ndat <- data.table(x\
    \ = c(1:10000, 9999:1), y = sample(1:10000, 10000, replace = TRUE))\ndat$xy <-\
    \ paste(dat$x, dat$y)\nsetkey(dat, xy)\nans <- dat[, list(x.y = x[y == min(y)],\
    \ 'x.y.count' = length(y)), by = xy][, xy.count := x.y.count][, x.y.count := NULL]\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nJust a quick question: why do you set `dat$xy\
    \ <- paste(dat$x, dat$y)` before setting key `setkey(dat, xy)`? Is that necessary?\n\
    <|/ c |>\n<| c |>\n- it's just to create a unique identifier for each pair. The\
    \ `data.table` package doesn't require it but I like to do it anyway. See the\
    \ `setkey` help page for more details: https://cran.r-project.org/web/packages/data.table/data.table.pdf\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a base R version using aggregate and ave.\n\
    <code>\ndat = data.frame(x = c(1:3, 1:3, 1:3), y = c(1:3, 1:3, 1:3))\ndat$z =\
    \ ave(dat$x, dat$y, FUN = function(x) paste0(unique(x), collapse = \",\"))\naggregate(z\
    \ ~ x, dat, FUN = function(x) paste0(unique(x), collapse = \",\"))\n</code>\n\
    <|/ a tags=r |>\n<| a dscore=0 |>\nHere is my solution using Rcpp, data.table,\
    \ and dplyr. I found it to be quite fast for my needs and I wanted to share it\
    \ with you all. \n<code>", "\n  if (length(l1) == 0) {\n    return(NULL)\n  }\n\
    \  if (length(l2) == 0) {\n    return(c(l1))\n  }\n  common1 <- sort(l1)\n  common2\
    \ <- sort(l2)\n  common1 <- common1[-which(common2 %in% common1)[1], ]\n  common2\
    \ <- common2[-which(common1 %in% common2)[1], ]\n  return(c(common1, common2))\n\
    }\n", "\n    l1 <- as.vector(l1)\n    l2 <- as.vector(l2)\n    c(sort(unique(l1))[which(match(sort(unique(l1)),\
    \ sort(unique(l2))) == 1)],\n      sort(unique(l2))[which(match(sort(unique(l2)),\
    \ sort(unique(l1)) == 1)])\n}\n</cell>\n<cell>\ncommon(c(1, 4, 3, 34, 653, 2,\
    \ 5), c(5, 7, 1, 5, 9, 653, 121))\ncommon(c(5, 3, 2, 8), c(3, 2))\n</cell>\n<text>\n\
    We also have \"uncommon\" functions uncommon and uncommon.\nUncommon is pretty\
    \ much the same as common, with the exception that it only outputs the unique\
    \ elements.\n\nFor example, uncommon(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5,\
    \ 9, 653, 121)) is just c(1, 5, 653).\n\n\n</text>\n<cell>\nuncommon <- function(l1,\
    \ l2) {\n    l1 <- as.vector(l1)\n    l2 <- as.vector(l2)\n    c(sort(unique(l1))[which(match(sort(unique(l1)),\
    \ sort(unique(l2))) == 1)],\n      sort(unique(l2))[which(match(sort(unique(l2)),\
    \ sort(unique(l1)) == 1)])\n}\n</cell>\n<cell>\nuncommon(c(1, 4, 3, 34, 653, 2,\
    \ 5), c(5, 7, 1, 5, 9, 653, 121))\nuncommon(c(5, 3, 2, 8), c(3, 2))\n</cell>\n\
    <text>\nThe function is_member is used to determine if a value in one vector is\
    \ also a value in a second vector.\n\nFor example, we can use is_member to determine\
    \ if c(1, 4, 3, 34, 653, 2, 5) is in c(5, 7, 1, 5, 9, 653, 121).\n\n\n</text>\n\
    <cell>\nis_member <- function(l1, l2) {\n    l1 <- as.vector(l1)\n    l2 <- as.vector(l2)\n\
    \    match(l1, sort(unique(l2)))\n}\n</cell>\n<cell>\nis_member(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\nis_member(c(5, 3, 2, 8), c(3, 2))\n\
    </cell>\n<text>\nWe can use is_member to determine if c(1, 4, 3, 34, 653, 2, 5)\
    \ is in c(5, 7, 1, 5, 9, 653, 121) is also in c(5, 7, 1, 5, 9, 653, 121).\n\n\n\
    </text>\n<cell>\nis_member(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n\
    is_member(c(5, 3, 2, 8), c(3, 2))\n</cell>\n<text>\nis_", "\n  res <- sort(intersect(sort(l1),\
    \ sort(l2)))\n  return(res)\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  comb <- intersect(u1, u2)\n  if(length(comb) == 0){\n    return(NA)\n\
    \  } else {\n    return(comb)\n  }\n}\n", "\n  common_index <- intersect(which(seq_along(l1)\
    \ > which(seq_along(l2) & l1 == l2)), which(seq_along(l1) < which(seq_along(l2)\
    \ & l1 == l2)))\n  return(unlist(lapply(common_index, function(i) { l1[i] })))\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks very much for your answer, but my real data\
    \ set is ~3M rows, and this function is taking forever! It was running for about\
    \ 15 minutes before I killed the process.\n<|/ c |>\n<| c |>\nWell, there is not\
    \ much I can do. If you have other ideas how to speed it up, please let me know\
    \ :)\n<|/ c |>\n<| c |>\nActually, I may have found a solution. Just give me a\
    \ minute!\n<|/ c |>\n<| c |>\nAh, I see your solution now. It is a lot faster\
    \ than my original. Thanks!\n<|/ c |>\n<| c |>\nI added a solution which uses\
    \ some built-in functions in R. Should be much faster\n<|/ c |>\n<| a |>\nJust\
    \ for fun, here is a solution using data.table and a custom function which finds\
    \ the minimum of two values.\n<code>\nlibrary(data.table)\ndt <- data.table(a=c(1,5,3,34,653,2,5),\n\
    \                 b=c(5,7,1,5,9,653,121))\n\nfind_min <- function(x, y) {\n  x[which.min(x\
    \ == y)]\n}\n\ndt[, min(values(.SD)), by=.(a,b)]\n", "\n  result <- list()\n \
    \ i <- 0\n  while(i < length(l1) && i < length(l2)) {\n    if(l1[[i]] < l2[[i]])\n\
    \      result[[i]] <- l1[i]\n    else result[[i]] <- l2[i]\n    i <- i + 1\n \
    \ }\n  if(i < length(l1) && i < length(l2))\n    result[[i]] <- l1[i]\n  else\
    \ if(i < length(l1))\n    result[[i]] <- l2[i]\n  else if(i < length(l2))\n  \
    \  result[[i]] <- l1[i]\n  else result[[i]] <- l2[i]\n  result\n}\n", "\n  u1\
    \ <- union(l1, l2)\n  u2 <- union(l2, l1)\n  setdiff(union(u1, u2), l1)\n}\n",
  "\n  # Get sorted unique elements.\n  l1 <- sort(unique(l1))\n  l2 <- sort(unique(l2))\n\
    \  # Get common elements.\n  common <- l1[intersect(l1, l2)]\n  # Return sorted\
    \ unique common elements.\n  sort(unique(common))\n}\n</code>\nNote that this\
    \ approach will perform badly if the lists get very large. For example for l1\
    \ = c(1500000, 1500001, 1500002) and l2 = c(1500002, 1500003) the common elements\
    \ would be 1500001 and 1500003 rather than 1500002 and 1500003. \nIf this occurs,\
    \ we can use the much faster RcppAlgos library:\n<code>\nlibrary(RcppAlgos)\n",
  "\n  un.l1 <- sort(unique(c(l1, names(l1))))\n  un.l2 <- sort(unique(c(l2, names(l2))))\n\
    \  un.l1[un.l1 == un.l2] <- NA\n  un.l1[is.na(un.l1)] <- un.l2[is.na(un.l1)]\n\
    \  un.l1[!is.na(un.l1)] <- un.l1[!is.na(un.l1)] - 1\n  un.l1\n}\n", "\n  u1 <-\
    \ sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l1, l2)),\
    \ decreasing = TRUE)\n  commons <- u1[seq_along(u1) %in% u2]\n  return(commons)\n\
    }\n</code>\n<|/ a dscore=2 tags=r,list,comparison |>\n<| c |>\nThis is very interesting\
    \ and works very well and I learned a lot from it. Thanks very much. I like the\
    \ use of lapply here, but I am not sure I understand the use of the return function.\
    \ The documentation is very vague about it. What does it do exactly? Thanks!\n\
    <|/ c |>\n<| c |>\nThe `return()` function is used to return a value from a function\
    \ call. The `lapply()` function returns a list (in this case a list of vectors)\
    \ from applying a function to all the elements of a list supplied as the first\
    \ argument. `return()` then returns the list to the caller.\n<|/ c |>\n<| c |>\n\
    Got it! Thanks so much for all your help!\n<|/ c |>\n<| c |>\nFor those who find\
    \ this answer's useful - I added some additional notes to my answer that might\
    \ help you understand how `lapply` works better.\n<|/ c |>\n<| a dscore=1 |>\n\
    You can use intersect.  \n<code>\nintersect(list1, list2)\n</code>\n<|/ a tags=r,list,comparison\
    \ |>\n<| c |>\nThanks for the response. This is great, but I need to compare each\
    \ element in the list with all the other elements in the list and return the common\
    \ elements. Thanks again!\n<|/ c |>\n<| c |>\nIf list1 and list2 have same length,\
    \ intersect will return the common elements. If you have different length, please\
    \ post a reproducible example for us to test\n<|/ c |>\n<| a dscore=1 |>\nYou\
    \ can use %in% on both vectors:\n<code>\ncommons <- c(list1, list2) %in% c(list1,\
    \ list2)\n</code>\n<|/ a tags=r,list,comparison |>\n<| c |>\nThank you for the\
    \ response. This works great, but I need to compare each element in the list with\
    \ all the other elements in the list and return the common elements. Thanks again!\n\
    <|/ c |>\n<| c |>\nI got it now. Thank you so much for your help!\n<|/ c |>\n\
    <| a dscore=0 |>\nTry this solution:\n<code>\n    list1 <- c(1, 4, 3, 34, 653,\
    \ 2, 5)\n    ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  l1 <- unique(l1)\n  l2\
    \ <- unique(l2)\n  unique(c(l1, l2))\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nYou could also use an association list:\n<code>\nf1 <- function(x,y) {\n\
    \    x <- sort(x)\n    y <- sort(y)\n    y <- unique(y)\n    x <- unique(x)\n\
    \    n <- length(x)\n    k <- length(y)\n    tab <- rep(0, n+k)\n    tab[seq_len(n)]\
    \ <- 1\n    tab[k:n] <- -1\n    x <- x[1:n]\n    y <- y[1:k]\n    tab[x+y]\n}\n\
    \n> f1(letters[1:5], letters[1:5])\n[1]  1  0  0 -1  0\n\n> f1(letters[1:5], letters[1:3])\n\
    [1] -1 -1  0  1  0\n</code>\n<|/ a tags=algorithm,sorting,r |>\n<| a tags=algorithm,sorting,r\
    \ |>\nHere's an alternative solution which avoids sorting and sorts both the lists\
    \ first. \nThe idea is to find which elements are common between the two lists\
    \ and then sort both lists based on that subset. For example, for a = c(1, 2,\
    \ 3, 4, 5) and b = c(1, 2, 1, 4, 5), we find which elements are common by comparing\
    \ them with a[1:5] == b[1:5] and then sort them using order:\n<code>\n> order\
    \ (a[1:5] == b[1:5])\n[1]  1  4  2  3  5\n\n> a <- a[order(a[1:5] == b[1:5])]\n\
    > b <- b[order(a[1:5] == b[1:5])]\n\n> a\n[1]  1  2  3  4  5\n\n> b\n[1]  1  4\
    \  2  3  5\n</code>\nThe algorithm works because we are sorting both lists first\
    \ based on the common elements found above. We then use the result of the sorting\
    \ of both lists to subset both lists based on the result of the above comparison.\
    \ The result is that the sorted lists are ordered by common elements.\nHere's\
    \ a benchmark comparing the different solutions:\n<code>\nlibrary(microbenchmark)\n\
    library(data.table)\n\na <- rnorm(1e6)\nb <- rnorm(1e6)\nc <- rnorm(1e6)\nd <-\
    \ rnorm(1e6)\n\nmicrobenchmark(\n  David = f1(list(a), list(b)),\n  Nick = f2(list(a),\
    \ list(b)),\n  akrun = c(", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  c(setdiff(u1,\
    \ u2), setdiff(u2, u1))\n}\n</code>\n<|/ a |>\n<| c |>\nThat is so great. I am\
    \ still trying to understand the logic of the code. It returns common values from\
    \ two vectors. But the last line of code should also return common elements for\
    \ two vectors.\n<|/ c |>\n<| c |>\n- That is correct. The last line returns common\
    \ elements for two vectors. Do you understand how `setdiff` works?\n<|/ c |>\n\
    <| a dscore=1 |>\nHere's an alternate implementation, that doesn't require you\
    \ to convert your data into factors and also doesn't require the use of set.seed\
    \ (which you may not know about yet).\n<code>", "\n    l <- sort(unique(c(l1,\
    \ l2)))\n    which(l == c(l1, l2))\n}\n</code>\nThe second approach will require\
    \ a call to sort on each iteration of the loop in common. Sorting is O(n log n).\
    \ Using R's sort can make for a significant speed improvement in common but only\
    \ if the lists are very long.\n<|/ a tags=r dscore=1 |>\n<| a dscore=1 tags=r\
    \ |>\nUsing sapply to loop through each element of list1, and returning the common\
    \ elements:\n<code>\nlist1 <- list(2, 3, 5, 7)\n\nlist2 <- list(5,7,9,3,65,123)\n\
    list2 <- list2[!duplicated(list2)]\n\nlist3 <- list2[list1 %in% list2]\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't seem to work if the elements are not necessarily\
    \ in order.\n<|/ c |>\n<| c |>\nTrue, but I assume OP's data has elements which\
    \ are not necessarily ordered.\n<|/ c |>\n<| a dscore=1 tags=r |>\nJust to give\
    \ another option that might work for you, here is one possibility.\n<code>\nlist1\
    \ <- list(2, 3, 5, 7)\nlist2 <- list(5,7,9,3,65,123)\n", "\n  out <- NULL\n  len\
    \ <- 0\n  for(k in seq_along(l1)) {\n    len <- len + 1\n    out <- c(out, l1[k])\n\
    \    if(k %in% seq_along(l2)) {\n      out <- c(out, l2[k])\n    }\n  }\n  if(len\
    \ > 0) {\n    out <- out[order(-out)]\n  }\n  return(out)\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThat is almost identical to my answer. One just keeps the order (which\
    \ may be desirable or not). +1 for the effort though.\n<|/ c |>\n<| c |>\nYes,\
    \ that's true. I've only posted mine to see if there are any faster ways. I do\
    \ like the `unlist` idea though. I'll leave the post up here in case others find\
    \ it useful.\n<|/ c |>\n<| c |>\nHi Joshua, I used your `unlist` idea but my function\
    \ doesn't always return the correct results. I've posted my code as an update\
    \ to my original question.\n<|/ c |>\n<| c |>\nI see you posted a new question\
    \ for your `common` function. Can you elaborate on \"doesn't always return the\
    \ correct results\"? What is the input you are providing to that function?\n<|/\
    \ c |>\n<| c |>\nThanks for your help, Joshua! I've posted the new question here:\
    \ http://stackoverflow.com/questions/19296682/inconsistency-in-function-returning-common-elements-in-lists\n\
    <|/ c |>\n<| a |>\nHere's another way using Reduce (which may be faster than using\
    \ merge in some cases):\n<code>\nx<-c(3,5,2,3,5,5,2)\ny<-c(1,2,5,1,2,5,2)\n",
  "\n  u1 <- sort(unique(c(l1)))\n  u2 <- sort(unique(c(l2)))\n  intersect(u1, u2)\n\
    }\n", "\n  common = l1[duplicated(l1)] #find duplicate items\n  common = c(common,\
    \ apply(l2, 1, function(x) length(which(l1==x))) #add duplicated values to common\
    \ list\n  return(common)\n}\n</code>\n<|/ a |>\n<| a |>\nThis answer will use\
    \ an approach that first calculates the frequency of each item in the given vectors,\
    \ and then uses the information from this vector to perform a final sort of the\
    \ items.\nI tested this on the following input vectors:\n<code>\nx <- c(1,2,4,5,7,8,9,2,5,4,1,5,5,2)\n\
    y <- c(6,5,1,7,9,6,9,8,2,5,4,1,5,5)\n</code>\nThe first step is to calculate the\
    \ frequency of each item in the vectors:\n<code>\nxFreq <- table(x)\nyFreq <-\
    \ table(y)\n\nxFreq\nyFreq\n</code>\nThe output will be a table with each item\
    \ in the vector, along with a frequency of it's occurrence:\n<code>\n> xFreq\n\
    x \n1 2 3 4 5 7 8 9 2 5 4 1 5 5 2 \n8 \n> yFreq\ny\n1 2 3 4 5 7 8 9 2 5 4 1 5\
    \ 5 2 \n8 \n</code>\nUsing the information from this table, we can now sort the\
    \ items in each vector:\n<code>\nxOrder <- order(xFreq)\nyOrder <- order(yFreq)\n\
    \nx[xOrder]\ny[yOrder]\n</code>\nThe result will be the following:\n<code>\n>\
    \ x[xOrder]\n [1] 1 2 3 4 5 7 8 9 2 5 4 1 5 5 2 \n> y[yOrder]\n [1] 1 2 3 4 5\
    \ 7 8 9 2 5 4 1 5 5 2 \n</code>\nThe final step is to calculate the intersection\
    \ between the two sorted vectors:\n<code>\nz <- x[xOrder] %in% y[yOrder]\n</code>\n\
    The result of this operation will be TRUE for all items that are in the intersected\
    \ vector:\n<code>\n> z\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n</code>\n\
    Lastly, we sort the resulting vectors so that the items that are in the intersected\
    \ vector are first:\n<code>\nz[xOrder]\nz[yOrder]\n</code>\nThe result of this\
    \ operation will be the following:\n<code>\n> z[xOrder]\n [1] 1 2 3 4 5 7 8 ",
  "\n    common <- list()\n    i <- 0\n    while(i < length(l1) & i < length(l2))\
    \ {\n        if(l1[i] == l2[i]) {\n            common[[i]] <- l1[i]\n        \
    \    i <- i + 1\n        } else if(l1[i] < l2[i]) {\n            i <- i + 1\n\
    \        } else {\n            i <- i + 1\n        }\n    }\n    while(i < length(l1))\
    \ {\n        common[[i]] <- l1[i]\n        i <- i + 1\n    }\n    while(i < length(l2))\
    \ {\n        common[[i]] <- l2[i]\n        i <- i + 1\n    }\n    common\n}\n\
    </code>\n<|/ a tags=subset,r |>\n<| c |>\nFor a solution like this, where `common`\
    \ returns a vector rather than a list of vectors, I'd consider using `Reduce(union,\
    \ ...)` instead of `common(...)`. `Reduce(union, ...)` is more idiomatic than\
    \ `common(...)`, while `common(...)` is clearer IMO. Also, `c` is redundant in\
    \ `c(1, 4, 3, 34, 653, 2, 5)` since `c(...)` already returns the vector.\n<|/\
    \ c |>\n<| c |>\n, Thanks, will add these in to my answer.\n<|/ c |>\n<| c |>\n\
    Thanks! And for those who are looking for a `common` function that returns a vector\
    \ rather than a `list`, here you go: `common <- function(l1, l2) { common <- c(l1);\
    \ i <- 0; while(i < length(l1) & i < length(l2)) { if(l1[i] == l2[i]) { common[[i]]\
    \ <- l1[i]; i <- i + 1; } else if(l1[i] < l2[i]) { i <- i + 1; } else { i <- i\
    \ + 1 } } while(i < length(l1)) { common[[i]] <- l1[i]; i <- i + 1 } while(i <\
    \ length(l2)) { common[[i]] <- l2[i]; i <- i + 1 } common; }`\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if the lists are of different lengths. `common(c(1,2,3,4),c(1,4,3,2))`\
    \ returns `c(1, 2, 3, 4)` instead of `c(1)`.\n<|/ c |>\n<| c |>\n, Yes, it would\
    \ not work if `common` is returning a `list` instead of `vector`. I have updated\
    \ the answer to return `vector` instead and also refactored the code to use `Reduce`\
    \ instead of `while` loop in `common`.\n<|/ c |>\n<| a tags=subset,r |>\n<code>\n\
    \ common=function(x, y) {\n    ind1=", "\n  unique(c(sort(l1), sort(l2)))\n}\n",
  "\n\tv1 <- sort(unique(c(l1)))\n\tv2 <- sort(unique(c(l2)))\n\tv3 <- intersect(v1,\
    \ v2)\n\treturn(sort(unique(v3)))\n}\n", "\n  l1[seq_along(l1)] %in% l2[seq_along(l2)]\n\
    }\n</code>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  common(u1, u2)\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere's a solution I\
    \ came up with using data.table.\n<code>\nlibrary(data.table)\ndt1 <- data.table(a\
    \ = c(1, 4, 3, 34, 653, 2, 5), b = c(5, 7, 1, 5, 9, 653, 121))\ndt2 <- data.table(a\
    \ = c(5, 3, 2, 8), b = c(3, 2))\n</code>\ndt1 and dt2 are two data.table objects.\
    \ Column a is present in both. Column b only exists in dt1, but not in dt2.\n\
    Using data.table's non-equi join functionality, we can create a table that only\
    \ contains observations from dt1 and dt2, and therefore has the desired outcome\
    \ of returning the column 'a' from each table. The code below will return a data.table\
    \ with one column 'a' which only contains values that are present in dt1 AND dt2.\n\
    <code>\nsetkey(dt1, a)\nsetkey(dt2, b)\n\ndt1[dt2, .(colA = a), on = .(a = b)]\n\
    \n   colA\n1:    1\n2:    5\n3: 653\n</code>\nFrom here, we can remove the column\
    \ using dt1[,colA := NULL]\n<|/ a tags=merge,r |>\n<| a dscore=0 tags=merge,r\
    \ |>\nTry this (although it's rather inefficient):\n<code>\na <- c(1, 4, 3, 34,\
    \ 653, 2, 5)\nb <- c(5, 7, 1, 5, 9, 653, 121)\n\ncommon_b <- intersect(a, b)\n\
    common_a <- intersect(b, a)\nintersect(common_b, common_a)\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=merge,r |>\nI came up with a simpler solution that is using\
    \ only base R.\nThe function intersect2 will merge two data.frames by columns\
    \ and retain only the unique values of each column. The function is then used\
    \ with two arguments each data.frame. This results in three data.frames. I then\
    \ extract the unique values of each column to create a final data.frame with the\
    \ common values. The function intersect3 will then merge the unique values into\
    \ a single column by taking the union of the unique values of each column. I then\
    \ remove the duplicated values.\n<code>\nintersect2 <- function(x, y) {\n  temp\
    \ <- merge(x, y, by = NULL, all.x = TRUE, all.y = FALSE)\n  temp <- temp[!duplicated(temp[,\
    \ 1]), ]\n  return(temp)\n}\n\nintersect3 <- function(x) {\n  un", "\n  common1\
    \ <- combn(x=l1, n=length(setdiff(1:length(l1), l2)),\n                   simplify=FALSE)\n\
    \  common2 <- combn(x=l2, n=length(setdiff(1:length(l2), l1)),\n             \
    \      simplify=FALSE)\n  c(rbind(common1[[1]], common2[[1]]))\n}\n</code>\n<code>",
  "\n  common = unique(c(l1, l2))\n  inds <- which(common %in% c(l1, l2))\n  unique(c(common[inds],\
    \ common[inds+ 1]))\n}\n</cell>\n<cell>", "\n  setNames(sort(unique(c(l1, l2))),\
    \ sort(unique(c(l1, l2))))\n}\n", "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <-\
    \ sort(unique(c(l2, l1)))\n  c((v <- u1[u2 %in% u1]), rep(NA_integer_, nchar(v)\
    \ - length(v)))\n}\n</cell>\n<text>\nThe common function above uses three different\
    \ sorting methods:\n\nsort the two lists first\nsort one list first\nsort the\
    \ two lists again\n\nand returns the common elements between them.\n\nThe first\
    \ two methods work best when the lists are already sorted. The third method works\
    \ best if the lists are in random order (this is usually the case when you are\
    \ working with data scraped from the web). However, the third method is much less\
    \ efficient because it sorts all the list twice, once for each of the two lists\
    \ you are comparing.\n\nThe function also adds NAs to pad shorter vectors to the\
    \ length of the longer one.\n\nLet's apply the function to a small example, to\
    \ see how it works.\n\n\n</text>\n<cell>\ncommon(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))\n</cell>\n<text>\nYou can see that common() returns c(2,\
    \ 3) (common), since the two numbers 3 and 5 appear in both of the vectors.\n\n\
    Let's check how it works on a more complicated example with multiple matches.\n\
    \n\n</text>\n<cell>\ncommon(c(1, 4, 3, 34, 653, 2, 5, 7, 1, 5, 9, 653, 121), c(5,\
    \ 7, 1, 5, 9, 653, 121))\n</cell>\n<text>\nLet's check how it works on a more\
    \ complicated example where the first vector is longer.\n\n\n</text>\n<cell>\n\
    common(c(1, 4, 3, 34, 653, 2, 5, 7, 1, 5, 9, 653, 121, 34), c(5, 7, 1, 5, 9, 653,\
    \ 121))\n</cell>\n<text>\nThe common function has also added NAs to the shorter\
    \ vector, so we can compare it directly to the longer one.\n\n\n</text>\n<cell>\n\
    common(c(1, 4, 3, 34, 653, 2, 5, 7, 1, 5, 9, 653, 121, 34), c(5, 7, 1, 5, 9, 653,\
    \ 121, 3))\n</cell>\n<text>\nThe common function can also use another variable\
    \ as the ordering variable. Let's create a data frame with multiple columns, where\
    \ each column is sorted by the corresponding value in a separate column.\n\n\n\
    </text>\n<cell>\ndf <- data.frame(x = c(1, 4, 3, 34, 653, 2, 5, 7, 1, 5, 9, 653,\
    \ 121, 34), y = c(5, 7, 1, 5, 9, 653, 121, 34))\nhead(df)\n</cell>\n<text>\nThe\
    \ common function can then be used on this data ", "\n  sort(unique(l1)[intersect(sort(unique(l1)),\
    \ sort(unique(l2)))])\n}\n", "\n  common  <- sort(sort(intersect(c(l1, l2)), use.names=F))\n\
    \  len1   <- length(l1)\n  len2   <- length(l2)\n  if (len1 == 0) return(common)\n\
    \  else if (len2 == 0) return(common)\n  else if (len1 == len2) return(common)\n\
    \  else return(common)\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthis would be\
    \ a great answer, however it would be helpful if you explained to OP why your\
    \ code is better than the other answers (including mine).\n<|/ c |>\n<| c |>\n\
    I think it's better because it's easier to read and doesn't require an extra package\
    \ (and is shorter than mine). For small cases, it doesn't matter, but for larger\
    \ lists, it does. And it's an interesting exercise to play around with, even if\
    \ it requires you to write your own function.\n<|/ c |>\n<| a dscore=0 tags=r,subset,list\
    \ |>\n<code>", "\n  n <- length(l1)\n  commons <- rep(FALSE, n)\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 %in% l1] & !commons[u2]\n}\n</code>\n\
    This should work for vectors or lists of the same length. \nThe return value is\
    \ a vector of length n where TRUE is element of l1 and FALSE otherwise. \nAs we\
    \ see that all combinations of elements from u1 and u2 that are also elements\
    \ in l1 and l2 are of length n, we can use the fact that \n<code>\nu2[u1 %in%\
    \ l1] & !commons[u2]\n</code>\nholds for all elements that are in u1 and also\
    \ elements of l2. \nThis does not work when the lists are of different length,\
    \ but this can be fixed by making the list of common elements one element longer.\n\
    <|/ a |>\n<| a dscore=3 |>\nHere is a little bit shorter solution using RcppAlgos:\n\
    <code>", "\n  set1 <- union(l1, l2)\n  set2 <- union(l2, l1)\n  set1[!set1 %in%\
    \ set2]\n}\n", "\n    sort(unique(c(l1, l2)), decreasing = TRUE)\n}\n</code>\n\
    <|/ a |>\n<| a tags=r,vector,sorting,unique |>\nA solution using merge and sort\
    \ to get unique and sorted values.\n<code>", "\n    # return sorted unique common\
    \ elements\n    set1 <- sort(l1)\n    set2 <- sort(l2)\n    n1 <- length(set1)\n\
    \    n2 <- length(set2)\n    i <- 1\n    result <- vector(\"character\", n2)\n\
    \    while(i<=n2) {\n        if(set1[i] == set2[i]) {\n            result[i] <-\
    \ set1[i]\n            i <- i+1\n        } else {\n            i <- i+1\n    \
    \    }\n    }\n    return(result)\n}\n</code>\n<|/ a tags=vector,string,r dscore=2\
    \ |>\n<| c |>\nThis does not give the correct result for repeated values.\n<|/\
    \ c |>\n<| c |>\nNo, it does not give the correct result for repeated values.\n\
    <|/ c |>\n<| a dscore=0 |>\nI like the answer by Ben Bolker, but I just want to\
    \ add a little extra to his answer which is much faster than Ben's for large numbers.\
    \ We can use RcppAlgos:\n<code>", "\n  l1 <- as.vector(l1)\n  l2 <- as.vector(l2)\n\
    \  u1 <- unique(l1)\n  u2 <- unique(l2)\n  commons <- u1[match(l2, u1)]\n  if\
    \ (length(commons) == 0) commons <- rep(NA_character_, 1)\n  return(commons)\n\
    }\n</cell>\n<text>\nNow let's use the new common function together with the new\
    \ dplyr function select() to find all the names in the first data frame that appear\
    \ in the second data frame. Note that these names appear in both data frames.\n\
    \n\n</text>\n<cell>\ncommon_names <- select(names(df1), common(names(df1), names(df2)))\n\
    common_names\n</cell>\n<text>\nExercise: Compare names that appear in both data\
    \ frames and also include names that only appear in one data frame.\n\n</text>\n\
    <cell>", "\n  s1 <- sort(unique(c(l1, l2)))\n  s2 <- sort(unique(c(l2, l1)))\n\
    \  s1[s2[match(s1, s2)]]\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe function\
    \ `common()` is just returning a list of duplicates instead of returning the common\
    \ elements.\n<|/ c |>\n<| c |>\nNo, the common elements are the elements of the\
    \ list `s1` that are in both lists.\n<|/ c |>\n<| c |>\nYes, you are right, I\
    \ just didn't fully understand what the OP was asking for. Your answer is perfectly\
    \ fine I suppose, just a quick addition regarding performance.\n<|/ c |>\n<| c\
    \ |>\nThis is very similar to `common()` in my answer below. This one avoids using\
    \ the `match` function which could be slow for larger lists.\n<|/ c |>\n<| a |>\n\
    Using library(data.table) we can convert the lists to data.table and join them.\n\
    <code>\nlist1 <- list(a=1, b=2, c=3)\nlist2 <- list(a=1, b=2, c=3)\nlist3 <- list(a=1,\
    \ b=2, c=3)\nlist4 <- list(a=1, b=2, c=3)\nlist5 <- list(a=1, b=2, c=3)\nlist6\
    \ <- list(a=1, b=2, c=3)\nlist7 <- list(a=1, b=2, c=3)\nlist8 <- list(a=1, b=2,\
    \ c=3)\n\nlibrary(data.table)\n\nlst <- list(list1, list2, list3, list4, list5,\
    \ list6, list7, list8)\ndt <- setDT(lst)\nsetnames(dt, NULL)\ndt[dt[, intersect(names(lst),\
    \ names(.SD)), .SDcols = lst]]\n</code>\n<|/ a tags=list,r,duplicates,intersect,find\
    \ dscore=0 |>\n<| c |>\nThis would be better if you also add an explanation.\n\
    <|/ c |>\n<| a dscore=0 |>\nI propose a solution that combines the other answers.\
    \ First, I have created a helper function \"in\" to check if each element of a\
    \ vector is in another vector. Second, I have created a function \"common\" that\
    \ returns only those elements that are in both lists. The idea is to combine \"\
    in\" and \"common\" into one function.\n<code>", "\n  u1 <- sort(unique(c(l1,\
    \ l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  return(setdiff(u1, u2))\n}\n</code>\n\
    <|/ a tags=performance,r,vector |>\n<| c |>\nA good idea, but as noted above,\
    \ it only works when there are exactly the same number of elements in the vectors.\
    \  Also, it doesn't give the same answer as `common` in the example in the OP\
    \ post.  (Thanks for the idea though.)\n<|/ c |>\n<| c |>\nWell, I just tried\
    \ it and it works just as you said. `common(1:10, 5:1)` returns `5` and `common(1:10,\
    \ 1:10)` returns `integer(0)`.\n<|/ c |>\n<| c |>\nYes, you're right.  I guess\
    \ this solution was more appropriate to my needs than my example code.  Thanks\
    \ for your help, everybody.\n<|/ c |>\n<| c |>\nI guess I'm surprised that such\
    \ a simple operation takes so much time.  But I guess it's better to ask for forgiveness\
    \ than for permission and be more explicit than to ask for permission.\n<|/ c\
    \ |>\n<| a |>\nHere's another solution. \n<code>\nlibrary(data.table)\nsetDT(list(\n\
    \  a = c(1,2,3,4,5),\n  b = c(1,2,3,4,5)\n))\n\nsetkeyv(setDT(list(\n  a = c(1,2,3,4,5),\n\
    \  b = c(1,2,3,4,5)\n)), \"a\")\n\nsetDT(list(\n  a = c(1,2,3,4,5),\n  b = c(1,2,3,4,5)\n\
    ))[, setdiff(.SD, a), by = seq_len(.N)]\n", "\n  sort(union(l1, l2))\n}\n</code>\n\
    <|/ a tags=r,vector |>\n<| c |>\nI wouldn't call this \"the fastest algorithm\"\
    . It is a \"brute force\" approach and the complexity is O(n^2). In my benchmark\
    \ I tested the fastest method and the answer by is one of the fastest ones\n<|/\
    \ c |>\n<| c |>\nI agree that this is O(n^2) algorithm (I assumed that OP was\
    \ interested in the fastest algorithm). But it's also very easy to understand,\
    \ thus I believe that it's a correct and efficient approach to the problem.\n\
    <|/ c |>\n<| a |>\nA solution using data.table:\n<code>\nlibrary(data.table)\n\
    \ndt <- data.table(x = c(5, 7, 1, 5, 9, 653, 121), \n                 y = c(1,\
    \ 4, 3, 34, 653, 2, 5), \n                 z = c(5, 7, 1, 5, 9, 653, 121))\n\n\
    dt[, {\n  x = c(x[-.N], y[.N])\n  y = c(y[1], y[-1])\n  w = x %in% y\n  w = which(w)\n\
    \  w = cumsum(w)\n  w = w[w]\n  return(w)\n}, by=z]\n", "\n  unlist(sapply(l1,\
    \ function(x) \n    sapply(l2, function(y) if (x %in% y) x else NA )\n  ), use.names\
    \ = FALSE)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis was the fastest for me\
    \ by a long shot.  Thank you.\n<|/ c |>\n<| c |>\nI did some benchmarking with\
    \ a lot of different inputs on my machine (a Mac Pro 2014) and this solution was\
    \ about twice as fast as the `pmatch` solution from. I didn't test on larger inputs\
    \ as I don't have any large enough to test it on. Not sure why the `pmatch` approach\
    \ would be faster for larger inputs.\n<|/ c |>\n<| c |>\nI wonder why you think\
    \ this would be faster? I think you're comparing `pmatch` to `sapply` and that\
    \ would be a more difficult comparison because `pmatch` does not do the same looping\
    \ that is `sapply` does. It's also more difficult because `sapply` is doing more\
    \ looping and less function calls. I suspect it's slower than the other solution\
    \ because `pmatch` is doing a lot more looping because it has to look at every\
    \ element of `l1` rather than just looking at the first element.\n<|/ c |>\n<|\
    \ c |>\n`sapply` does the same looping and function calls as `pmatch` does. `sapply`\
    \ does just a single loop and a single function call because it can do the looping\
    \ that is `pmatch` does. `sapply` also has the advantage that it will return the\
    \ indices of `l1` rather than the elements themselves. `pmatch` is more difficult\
    \ because it has to look at every element of `l1` rather than just looking at\
    \ the first element.\n<|/ c |>\n<| c |>\n`pmatch` is definitely slower. This solution\
    \ takes about 6 times as long as `pmatch`.\n<|/ c |>\n<| a tags=r |>\nI took some\
    \ time to test some of the other solutions and benchmark them.\nI ran this on\
    \ two computers: one with 8 GB RAM and the other with 16GB RAM.\n<code>", "\n\
    \    indx <- which(outer(l1$values, l2$values, `==`))\n    l1[!duplicated(l1[c(\"\
    values\", indx)])]\n}\n</code>\nIf your data frame is large, then a dplyr solution\
    \ is likely to be faster:\n<code>\nlibrary(dplyr)\ndf1 %>% \n  mutate(common =\
    \ common(df1, .)) %>%\n  filter(!is.na(common))\n</code>\nThis assumes your common\
    \ function returns a data.frame with the same columns as df1.\n<|/ a tags=r,dplyr\
    \ |>\n<| a |>\n<code>\nsetdiff(df1$value, df1$value[duplicated(df1$value)])\n\
    [1] \"3\"  \"5\"  \"653\"\n</code>\n<|/ a tags=r,dplyr dscore=1 |>\n<| a tags=r,dplyr\
    \ dscore=1 |>\nFor your example data, this solution should work fine for your\
    \ example data:\n<code>\nlibrary(dplyr)\n\ndf1 %>%\n  mutate(\n    across(value,\
    \ ~sort(unique(.)))\n  ) %>%\n  select(-value)\n", "\n  tmp1 <- sort(unique(c(l1,\
    \ l2)))\n  tmp2 <- sort(unique(c(l2, l1)))\n  if (tmp1 == tmp2) tmp1 <- tmp1[1]\n\
    \  tmp1\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[!u1\
    \ %in% u2]\n}\n", "\n\tu1 <- unique(c(l1, l2))\n\tu2 <- unique(c(l2, l1))\n\t\
    sort(u1)[order(u2)]\n}\n", "\n  common1 <- intersect(l1, l2)\n  common2 <- intersect(common1,\
    \ l2)\n  common3 <- intersect(common1, common2)\n  common4 <- intersect(common2,\
    \ common3)\n  common5 <- intersect(common2, common3)\n  common6 <- intersect(common3,\
    \ common4)\n  common7 <- intersect(common3, common4)\n  common8 <- intersect(common4,\
    \ common5)\n  common9 <- intersect(common4, common5)\n  common10 <- intersect(common5,\
    \ common6)\n  common11 <- intersect(common5, common6)\n  common12 <- intersect(common5,\
    \ common7)\n  common13 <- intersect(common6, common7)\n  common14 <- intersect(common6,\
    \ common8)\n  common15 <- intersect(common7, common8)\n  common16 <- intersect(common8,\
    \ common9)\n  common17 <- intersect(common8, common9)\n  common18 <- intersect(common8,\
    \ common10)\n  common19 <- intersect(common9, common10)\n  common20 <- intersect(common10,\
    \ common11)\n  common21 <- intersect(common10, common11)\n  common22 <- intersect(common10,\
    \ common12)\n  common23 <- intersect(common11, common12)\n  common24 <- intersect(common11,\
    \ common13)\n  common25 <- intersect(common12, common13)\n  common26 <- intersect(common13,\
    \ common14)\n  common27 <- intersect(common14, common15)\n  common28 <- intersect(common15,\
    \ common16)\n  common29 <- intersect(common15, common16)\n  common30 <- intersect(common15,\
    \ common17)\n  common31 <- intersect(common16, common17)\n  common32 <- intersect(common16,\
    \ common18)\n  common33 <- intersect(common17, common18)\n  common34 <- intersect(common17,\
    \ common19)\n  common35 <- intersect(common18, common19)\n  common36 <- intersect(common18,\
    \ common20)\n  common37 <- intersect(common19, common20)\n  common38 <- intersect(common19,\
    \ common21)\n  common39 <- intersect(common20, common21)\n  common40 <- intersect(common21,\
    \ common22)\n  common", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  common_index <- intersect(u1, u2)\n  return(common_index[order(common_index)])\n\
    }\n</code>\n<|/ a dscore=2 tags=r,dataframe |>\n<| c |>\nYes, I did this too.\
    \ But I find my way easier to understand.\n<|/ c |>\n<| c |>\nWell, it's up to\
    \ you to decide :-)\n<|/ c |>\n<| a tags=r,dataframe dscore=1 |>\nHere's a solution\
    \ that uses dplyr group_by function with sum and then filter to return only common\
    \ values.\n<code>\nlibrary(dplyr)\n\ndf %>% \n    group_by(Group) %>% \n    summarise(common_values\
    \ = sum(Values)) %>% \n    filter(common_values == 1)\n</code>\nOutput\n<code>",
  "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  i <- u1 ==\
    \ u2\n  return(sort(unique(u1[i])))\n}\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n\
    \  common1 <- intersect(l1, l2)\n  common2 <- intersect(l2, l1)\n  common <- intersect(common1,\
    \ common2)\n  return(common)\n}\n", "\n  x <- sort(c(l1, l2))\n  i <- match(x,\
    \ sort(unique(x)))\n  y <- x[i]\n  return(y)\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis is great! Very cool. Now I understand why it works =) The only thing\
    \ I'd like to point out is that in my dataset I have many more levels than just\
    \ two so I renamed \"id\" to \"lev_0\" and \"lev_1\". With those levels I get\
    \ the following error: \"invalid factor: locs; elements should either be 1 (integers\
    \ 0-2) or NA NA NA NA NA NA NA NA NA NA NA\". Any idea how to fix this?\n<|/ c\
    \ |>\n<| c |>\nThe error tells you exactly what you need to do: you need to give\
    \ integers from 0 to NA for those levels that don't appear. For example, if your\
    \ variable is called \"lev_0\" and you only have \"lev_0\" and \"lev_1\", then\
    \ you need to replace c(NA, 1, NA) with c(0, 1, NA). The solution I posted assumes\
    \ that all levels appear exactly once.\n<|/ c |>\n<| c |>\nAh... I see. Yes, in\
    \ that case I do have all levels appear exactly once so this worked like a charm.\
    \ Thanks again for the great help. Just a note, since I noticed you edited your\
    \ answer I updated the original code with the solution you provided here and the\
    \ updated error message. Thanks again!\n<|/ c |>\n<| a |>\nI have found one more\
    \ way to do this using setdiff() function.\n<code>\nset.seed(123)\nn <- 1000\n\
    d1 <- data.frame(a = sample(LETTERS[1:3], size = n, replace = T),\n          \
    \       b = sample(letters[1:3], size = n, replace = T),\n                 c =\
    \ sample(letters[1:3], size = n, replace = T))\n\nd2 <- d1[sample(n),]\n\nsetdiff(d1$b,\
    \ d2$b)\n</code>\n<|/ a tags=r dscore=4 |>\n<| a dscore=3 |>\nTo build on answer,\
    \ you can also try the following, which seems to run a lot faster:\n<code>", "\n\
    \  s1 <- sort(unique(l1))\n  s2 <- sort(unique(l2))\n  intersect(c(s1, s2), c(s1,\
    \ s2))\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  i <-\
    \ intersect(u1, u2)\n  u1[!u1 %in% i]\n}\n</cell>\n<cell>", "\n  u <- unique(c(l1,\
    \ l2))\n  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you,\
    \ this is very helpful. One more question: do you know why my \"for loop\" doesn't\
    \ work? I thought this should work too...\n<|/ c |>\n<| c |>\nI used the same\
    \ exact code as you have, except that I had the vector `v1` in the global environment\
    \ and `l2` as a function parameter. Not sure why this would make a difference.\n\
    <|/ c |>\n<| c |>\nThank you so much! I knew the answer was probably something\
    \ stupid that I was doing.\n<|/ c |>\n<| c |>\nFor what it's worth, this answer\
    \ fails for vectors of different lengths. I think you'll also want to use [this\
    \ answer](https://stackoverflow.com/a/47491635/95735) for that case.\n<|/ c |>\n\
    <| c |>\nThank you for pointing that out. I edited my answer to add a check for\
    \ different vector lengths. That said, the \"for loop\" solution would also work\
    \ just fine.\n<|/ c |>\n<| a |>\n<code>", "\n  # Return sorted unique common elements\
    \ for two lists.\n  sort(unique(union(l1, l2))[order(union(l1, l2))])\n}\n</code>\n\
    <|/ a tags=r dscore=3 |>\n<| c |>\nNice code, but if you run it twice you get\
    \ the same result.  This is because the `union` function is recycled so the first\
    \ time you run it it returns 3 elements, then the next time you run it it returns\
    \ 6 elements.  You need something more robust to ensure that you get a unique\
    \ result.\n<|/ c |>\n<| c |>\nThanks for the comment. Yes, you are right. I've\
    \ updated the answer to correct this.\n<|/ c |>\n<| c |>\nIt might not be necessary\
    \ but since it's just for practice, here is a very simple way to guarantee a unique\
    \ result: simply use your function inside a `for` loop with a counter that resets\
    \ to zero each time `i` equals the length of one of the input lists.  `for (i\
    \ in 1:length(l1)) un.common <- common(c(l1[i], un.common), c(l2[i], un.common))`\
    \ and then `un.common`.  Now `un.common` will always be unique because of the\
    \ `for` loop.\n<|/ c |>\n<| c |>\nThis code also has the advantage of being straightforward\
    \ to extend if other parameters (such as column names, column positions, etc)\
    \ are needed.\n<|/ c |>\n<| c |>\nThis is actually what I have implemented in\
    \ my own code. However I was thinking that it could be done in a single line of\
    \ code. Anyways, +1 from me.\n<|/ c |>\n<| a |>\nJust to offer another option\
    \ that doesn't require creating any temporary objects and is pretty efficient:\n\
    <code>\ncommon.multiple <- function(l1, l2, ...){\n  u1 <- union(l1, ...)\n  u2\
    \ <- union(l2, ...)\n  u3 <- union(u1, u2)\n  u4 <- union(u3, u1)\n  u5 <- union(u4,\
    \ u2)\n  u6 <- union(u5, u3)\n  u7 <- union(u6, u4)\n  u8 <- union(u7, u5)\n \
    \ u9 <- union(u8, u6)\n  u10 <- union(u9, u7)\n  u11 <- union(u10, u8)\n  u12\
    \ <- union(u11, u9)\n  u13 <- union(u12, u10)\n  u14 <- union(u13, u11)\n  u15\
    \ <- union(u14, ", "\n  u <- union(l1, l2)\n  res <- sort(unique(u))\n  return(res)\n\
    }\n</code>\n<|/ a tags=r |>\n<| c |>\nThe `u <- union(l1, l2)` line is unnecessary\
    \ here and slows things down significantly. Just `union(l1, l2)` would suffice.\
    \ I also recommend using `outer(l1, l2, '+')` instead of `union` since `union`\
    \ sorts the two vectors before doing the union, which slows it down significantly.\n\
    <|/ c |>\n<| c |>\nI agree with you, `union` was not necessary here. I also agree\
    \ with `outer(l1, l2, '+')` since it is way faster. Thank you.\n<|/ c |>\n<| a\
    \ dscore=4 tags=r |>\nSince this has been the top result on google, I thought\
    \ I'd add an alternative answer that doesn't use any packages. I prefer this approach\
    \ because it avoids the overhead of calling unlist and cbind.\n<code>\nintersect\
    \ <- function(x, y) {\n  i1 <- seq(1, length(x), by=2)\n  i2 <- seq(2, length(y)+1,\
    \ by=2)\n  i3 <- setNames(i2, names(x))\n  i4 <- intersect(names(x), names(y))\n\
    \  i5 <- intersect(i3, i4)\n  x[which(names(x)[i5]==names(y)[i5])]\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`setNames(i2, names(x))` can be replaced with `setNames(i2,\
    \ intersect(names(x), names(y)))`\n<|/ c |>\n<| c |>\n`intersect()` can be replaced\
    \ with `unique(c(x, y))`. `i1 <- seq(1, length(x), by=2)` can be replaced with\
    \ `i1 <- seq(1, length(x), by=2)`. `i2 <- seq(2, length(y)+1, by=2)` can be replaced\
    \ with `i2 <- seq(1, length(y)+1, by=2)` - I took the liberty to update your answer.\n\
    <|/ c |>\n<| c |>\nThanks for your suggestions -- I've fixed my answer.\n<|/ c\
    \ |>\n<| a tags=r |>\nHere is a solution using data.table package.\n<code>\nlibrary(data.table)",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  intersect(u1, u2)\n}\n\
    </code>\n<|/ a tags=sorting,subset,r |>\n<| c |>\nI tried to implement your solution\
    \ on my own, but I could not get it to work. The example you provided in the comment\
    \ worked for me. Can you provide a bit more detail on why it didn't work for me\
    \ in your solution?\n<|/ c |>\n<| c |>\nThe function `common` I defined in the\
    \ answer is your function. Here I rewrote it to avoid confusion about `c` and\
    \ `unique`. Since you said you want the elements to appear in same order, this\
    \ function returns the elements in the same order as they are in `l1`. It uses\
    \ `union` on both lists and removes duplicates.\n<|/ c |>\n<| a dscore=1 tags=sorting,subset,r\
    \ |>\nWe can use union\n<code>\ncommon1 <- function(...){\n  u1 <- union(...);\
    \ \n  u2 <- union(...); \n  u1[!u1 %in% u2]\n}\n\ncommon1(list(c(1,4,3,34,653,2,5),\
    \ c(5,7,1,5,9,653,121), c(7,1,2,4,5,9,653)))", "\n  l1 <- c(unique(l1), NA)\n\
    \  l2 <- c(unique(l2), NA)\n  l1[which(sort(unique(c(l1, l2))) == sort(unique(c(l1,\
    \ l2))))]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI think you missed the crucial\
    \ point that the order of common items is important. I've added this point to\
    \ the question (just in case you are wondering)\n<|/ c |>\n<| a tags=dataframe,r,sorting\
    \ |>\nFor a larger dataset you can use data.table's setkey to sort and unique:\n\
    <code>", "\n    sort(unique(c(l1, l2))) # Sorting removes duplicates\n}\n", "\n\
    \    common1 <- l1\n    common2 <- l2\n    common1 <- l1[nzchar(common1)]\n  \
    \  common2 <- l2[nzchar(common2)]\n    common <- sort(union(nzchar(common1), nzchar(common2)))\n\
    \    common\n}\n</code>\n<|/ a |>\n<| a tags=dataframe,r,unique,string |>\nHere\
    \ is a simple base R method that avoids using a for loop:\n<code>", "\n  l1 <-\
    \ unique(l1)\n  l2 <- unique(l2)\n  l1[names(l1) %in% l2[names(l2)]] <- \"\"\n\
    \  return(l1)\n}\n", "\n  ans <- list()\n  n1 <- length(l1)\n  n2 <- length(l2)\n\
    \  for(i in 1:n1) {\n    for(j in 1:n2) {\n      if(l1[i] == l2[j]) {\n      \
    \  ans[[i]] <- l1[i]\n        break\n      }\n    }\n  }\n  ans <- sort(unique(unlist(ans)))\n\
    \  return(ans)\n}\n", "\n  s1 <- sort(l1)\n  s2 <- sort(l2)\n  n <- length(s1)\n\
    \  i <- 1\n  while (i <= n) {\n    if (s1[i] == s2[i]) {\n      return(s1[i])\n\
    \    }\n    i <- i + 1\n  }\n  return(NA)\n}\n", "\n  u1 <- unique(c(l1, l2))\n\
    \  u1[order(match(l1, u1), match(l2, u1)),]\n}\n</code>\n<|/ a dscore=4 tags=r,intersection,list\
    \ |>\n<| c |>\nIt was a very elegant solution, Thanks!\n<|/ c |>\n<| c |>\nThis\
    \ is the best solution when you want to find common elements in a list of lists\
    \ and you need to get a list of lists with the common elements in each of the\
    \ sublists.\n<|/ c |>\n<| a |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <-\
    \ unique(c(l2, l1))\n  common <- setdiff(unique(c(u1, u2)), c(u1, u2))\n  return(common)\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 tags=r |>\nI added a for loop solution here.\
    \ I had fun trying to figure it out. \n<code>\ncommon <- function(x, y){\n  lenx\
    \ <- length(x)\n  leny <- length(y)\n  i <- 0\n  for(j in 1:(leny-1)){\n    for(k\
    \ in (i+1):(leny)){\n      if(all(x[i] == y[j])){\n        i <- k\n        break\n\
    \      }\n    }\n    if(length(x[i:leny-1]) == leny){\n      return(c(x[i:leny-1]))\n\
    \    }\n  }\n  return(NA)\n}\n\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere is an\
    \ approach using merge and setdiff to get unique elements. \n<code>\nunique <-\
    \ function(x, y) {\n  out <- merge(x, y, by=NULL, all.x=TRUE)\n  return(setdiff(names(out),\
    \ names(y)))\n}\n\n> unique(c(1,4,3,34,653,2,5), c(5,7,1,5,9,653,121))\n[1] \"\
    1\" \n</code>\n<|/ a tags=r |>\n<| c |>\nThis returns \"1\" in your example.\n\
    <|/ c |>\n<| a tags=r dscore=1 |>\nI took answers above and modified them to return\
    \ the unique values. \n<code>", "\n  sort(unique(c(l1, l2)))\n}\n</code>\n<|/\
    \ a tags=list,sorting,r dscore=2 |>\n<| a |>\nAnother method using sapply:\n<code>\n\
    a <- c(1, 4, 3, 34, 653, 2, 5)\nb <- c(5, 7, 1, 5, 9, 653, 121)\nsapply(a, function(x)\
    \ sapply(b, function(y) x > y))", "\n  sort(unique(c(l1, l2)))\n}\n", "\n  u1\
    \ <- unique(l1)\n  u2 <- unique(l2)\n  s1 <- sort(u1)\n  s2 <- sort(u2)\n  \n\
    \  i <- match(c(s1, s2), u1)\n  \n  return(c(s1[i %% length(s1)], s2[i %/% length(s2)]))\n\
    }\n</cell>\n<text>\nExercise: Write a function is_perfect_square() that checks\
    \ whether a number is actually a perfect square. You may use modulo math to accomplish\
    \ this.\n\n\n</text>\n<cell>\nis_perfect_square <- function(x) {\n  # TODO: Implement\
    \ this function.\n  return(FALSE)\n}\n</cell>\n<text>\nExercise: Write a function\
    \ is_perfect_cube() that checks whether a number is actually a perfect cube. You\
    \ may use modulo math to accomplish this.\n\n\n</text>\n<cell>\nis_perfect_cube\
    \ <- function(x) {\n  # TODO: Implement this function.\n  return(FALSE)\n}\n</cell>\n\
    <text>\nExercise: Write a function is_prime() that checks whether a number is\
    \ prime. You may use the Sieve of Eratosthenes to accomplish this.\n\n\n</text>\n\
    <cell>\nis_prime <- function(x) {\n  # TODO: Implement this function.\n  return(FALSE)\n\
    }\n</cell>\n<text>\nExercise: Write a function prime_factors() that takes a number,\
    \ x, and returns the prime factors of x. You may use the Sieve of Eratosthenes\
    \ to accomplish this.\n\n\n</text>\n<cell>\nprime_factors <- function(x) {\n \
    \ # TODO: Implement this function.\n  return(list(1))\n}\n</cell>\n<text>\nExercise:\
    \ Write a function factorial() that takes a number, x, and returns the factorial\
    \ of x. You may use the Sieve of Eratosthenes to accomplish this.\n\n\n</text>\n\
    <cell>\nfactorial <- function(x) {\n  # TODO: Implement this function.\n  return(1)\n\
    }\n</cell>\n<text>\nExercise: Write a function fact(n) that takes a number n and\
    \ returns the factorial of n. You may use the Sieve of Eratosthenes to accomplish\
    \ this.\n\n\n</text>\n<cell>\nfact <- function(n) {\n  # TODO: Implement this\
    \ function.\n  return(1)\n}\n</cell>\n<text>\nExercise: Write a function fibonacci(n)\
    \ that takes a number n and returns the n-th fibonacci number. You may use the\
    \ Sieve of Eratosthenes to accomplish this.", "\n    # sort and remove duplicates\n\
    \    l1 <- sort(l1)\n    l2 <- sort(l2)\n    l1 <- unique(l1)\n    l2 <- unique(l2)\n\
    \n    # find the length of common elements\n    len <- length(intersect(l1, l2))\n\
    \n    # compare the common element with the rest of them\n    l1[l == l]\n}\n\
    </code>\n<|/ a tags=optimization,r dscore=0 |>\n<| a dscore=0 |>\nThe idea of\
    \ using for loop is good. Using apply family functions is also a good choice.\
    \ Here is a solution using base R:\n<code>\nn <- length(c(list1, list2))\nr <-\
    \ rep(seq_len(n), n)\nout <- c()\nfor (i in seq_along(list1)) {\n    temp <- which(r[!is.na(r)])\n\
    \    out <- c(out, list1[temp[which.min(abs(list1[temp] - list2))]])\n    r <-\
    \ r[-temp]\n}\nout\n</code>\nThe idea is to get the common elements after sorting\
    \ list1 and list2 first and then look for them in list1. We use a for loop to\
    \ first sort the vectors and then look for them in list1 and remove them from\
    \ list1 afterwards.\n<|/ a tags=optimization,r |>\n<| a tags=optimization,r dscore=0\
    \ |>\nThis approach does not use for loops or apply. For a vector x (of length\
    \ m) it uses two comparisons to find where in list1 the element x should be inserted,\
    \ and two assignments afterwards to insert the element at that position. The first\
    \ comparison searches for the closest position to x (using the search function)\
    \ to the first element of list1, and the second comparison searches for the closest\
    \ position to x (using the search function) to the second element of list1. \n\
    <code>\ninsert <- function(list1,list2,x){\n  ind1 <- search(x,list1)\n  ind2\
    \ <- search(x,list2)\n  if(ind1==ind2) stop(\"x is not in either list1 and list2\"\
    )\n  pos <- min(abs(ind1-list1),abs(ind2-list2))\n  ind1 <- min(ind1,ind2)\n \
    \ list1[ind1+pos] <- x\n  list2[ind2-pos] <- x\n}\n\nsearch <- function(x,list){\n\
    \  i <- which.min(abs(list[x] - x))\n  if(is.na(i)) NA else i\n}\n</code>\nThis\
    \ function is intended to be used to insert x into the sorted order of the elements\
    \ of list1 and list2, respectively. It makes no attempt to ", "\n  common = intersect(l1,\
    \ l2) # Return all unique elements that are in both lists\n  unique(sort(common))\
    \ # Sort to remove duplicates \n}\n</code>\nThe results of common will look like\
    \ this:\n<code>\n[1] 1 2 3 4 5 6 7 8 9 10 12 13 14 15 16 17 18 19 20\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis seems to be the best answer by far. I've just\
    \ found out that my solution doesn't actually work, but yours does. I'm going\
    \ to accept this one as the best answer.\n<|/ c |>\n<| c |>\nI agree that yours\
    \ is the best answer, but there are issues that I have come across with the other\
    \ solutions. The answer by Jake is much more concise, but there are a few issues\
    \ I have come across with it. If you read the original question, there are 3 examples\
    \ to clarify the issues I am talking about (namely the ones that include numbers\
    \ with leading zeros). Jake's answer is much more general, and I think you should\
    \ use it instead. Here's a link to the original question: http://stackoverflow.com/questions/17098478/how-to-find-common-elements-in-two-vectors-using-r\n\
    <|/ c |>\n<| a |>\nHere's another possible solution:\n<code>\ncommon<-function(vec1,\
    \ vec2){\n   vec1<-unique(vec1)\n   vec2<-unique(vec2)\n   return(vec1[which(vec1\
    \ %in% vec2)])\n}\n</code>\n<|/ a dscore=4 tags=function,vector,r |>\n<| a |>\n\
    Here is another approach using the data.table package:\n<code>\ndt1 <- data.table(vec1,\
    \ key = \"vec1\")\ndt2 <- data.table(vec2, key = \"vec2\")\ndt1[dt2, nomatch =\
    \ 0L, on = \"vec1\"]\n</code>\nThis returns a data.table object with the unique\
    \ values.\n<|/ a tags=function,vector,r dscore=4 |>\n<| a tags=function,vector,r\
    \ |>\nHere's a base solution (thanks to for pointing me in the right direction).\
    \ We get rid of the zero values by converting them to NA, and then use the %in%\
    \ operator:\n<code>\ncommon <- function(vec1, vec2) {\n    vec1 <- vec1[!vec1\
    \ == 0]\n    vec2 <- vec2[!vec2 == 0]\n    which(vec1 %in% vec2)\n}\n</code>\n\
    Some examples:\n<code>\n> common(c(1,4,3,34,653,2,5), c(5,7,1,5,9,", "\n  unique.sorted\
    \ <- function(l) sort(unique(l), decreasing = T)\n  u1 <- unique.sorted(l1)\n\
    \  u2 <- unique.sorted(l2)\n  u1[u1 == u2] <- NA\n  l1[ which(is.na(u1)) ]\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI'm curious how you came to this conclusion, and what\
    \ made you choose this data structure?\n<|/ c |>\n<| c |>\nI didn't come up with\
    \ this data structure, but it's pretty common in Haskell. I did it because it\
    \ was easy to come up with and was easy to understand. I don't know how you came\
    \ up with it though, other than as a way of doing what I did.\n<|/ c |>\n<| a\
    \ tags=algorithm,performance,hash,search,sorting |>\nHere's my attempt at an implementation\
    \ in C:\n<code>\nint common(int *list1, int *list2, int size) {\n    int result\
    \ = 0;\n    int *list3 = malloc(sizeof(int) * size);\n\n    for(int i = 0; i <\
    \ size; i++) {\n        list3[i] = list2[i];\n    }\n    for(int i = 0; i < size;\
    \ i++) {\n        if(list1[i] == list3[i]) {\n            result = 1;\n      \
    \  }\n    }\n\n    for(int i = 0; i < size; i++) {\n        free(list3[i]);\n\
    \    }\n    free(list3);\n\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nYou have an `i` index in the inner loop that doesn't correspond to the\
    \ `i` index in the outer loop. Maybe this should be a comment to my other answer?\n\
    <|/ c |>\n<| c |>\nThis is O(n^2). It doesn't look like the sorting is necessary\
    \ in any way.\n<|/ c |>\n<| c |>\nI haven't done C for a while, but this looks\
    \ like O(n^2) to me, isn't it O(n) ?\n<|/ c |>\n<| c |>\nYes, it's O(n^2) because\
    \ you need to loop over list1 twice, once to find the matching elements, and the\
    \ second time to find the matching elements.\n<|/ c |>\n<| a dscore=2 |>\nHere\
    \ is a solution that runs in O(n log n) time complexity and uses O(n) space:\n\
    <code>\ndef common(l1, l2):\n    l1.sort()\n    l2.sort()\n    l2_set = set(l2)\n\
    \    return [i for i, j in zip(l1, l2) if i in l2_set]\n</code>\n<|/ a tags=algorithm,performance,hash,search,sorting\
    \ |>\n<| a tags=algorithm,performance,hash,search,sorting |>\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  setdiff(u1, u2)\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThank you so much! This was extremely helpful! I only had to modify\
    \ it a bit because I needed to include a third vector to compare the two vectors\
    \ to, and this was the part I was stuck on. I just used a for loop to compare\
    \ the first element of one vector to every element of the second vector, and added\
    \ the elements to the new vector if it wasn't in the first vector.\n<|/ c |>\n\
    <| c |>\nIf you do that, you end up with only half the combinations - not even\
    \ one that appears in both lists, since `setdiff` will only return the intersection.\n\
    <|/ c |>\n<| a tags=r |>\nAnother way:\n<code>\n> u <- unique(c(l1,l2))\n> u\n\
    [1] 1 2 3 4 5 6 7 8 9\n> v <- unique(c(l2,l1))\n> v\n[1] 1 2 3 4 5 6 7 8 9\n>\
    \ u <- v[which(!v %in% u)]\n> u\n[1] 1 5 6 7 8 9\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis is essentially the same as my answer. I posted it before you had\
    \ added the second line.\n<|/ c |>\n<| c |>\nI posted it after you added it.\n\
    <|/ c |>\n<| c |>\nOops, I missed that when I first posted my answer. Thanks.\n\
    <|/ c |>\n<| c |>\nStrange, I thought that yours was wrong and mine was right.\
    \ I am curious where you saw that yours is wrong?\n<|/ c |>\n<| c |>\nI deleted\
    \ my answer and changed yours. Your code didn't work when the lists were of different\
    \ lengths. I corrected it. The `%in%` check is what I missed in my code.\n<|/\
    \ c |>\n<| a tags=r dscore=2 |>\nThis would be my approach (using purrr):\n<code>\n\
    library(purrr)\ncommon_elements <- function(l1, l2) {\n  list(l1, l2) %>%\n  \
    \  reduce(intersect) %>%\n    set_names(c(\"l1\", \"l2\")) %>%\n    map(as.character)\n\
    }\n\ncommon_elements(c(1, 4, 3, 34, 65", "\n  set1 <- sort(unique(c(l1, l2)),\
    \ decreasing = TRUE)\n  set2 <- set1[set1 != set1]\n  set1[set1 == set1]\n}\n",
  "\n  return(Reduce(intersect, Map(function(x, y) setNames(list(x), y), l1, l2)))\n\
    }\n</code>\n<|/ a tags=r |>\n<| c |>\nThank you this works great. Would it be\
    \ possible to return both sets in one list?\n<|/ c |>\n<| c |>\nYou can use the\
    \ `c()` function - `Reduce(intersect, Map(function(x, y) c(x,y), l1, l2))`.\n\
    <|/ c |>\n<| c |>\nGreat! This also solved the issue of returning two sets.\n\
    <|/ c |>\n<| a tags=r |>\nHere's a solution that works on multiple sets and returns\
    \ a single list with both the intersection and the union of the sets. It's a little\
    \ inefficient because it calls intersect/union repeatedly, but it should be fast\
    \ enough for what you're trying to do. If you want a function that works with\
    \ single sets, I'd suggest using the function above, but change the c() call in\
    \ the function to list().\n<code>", "\n  if (!length(l1) || !length(l2) || length(l1)\
    \ != length(l2)) stop(\"Must provide two vectors of equal length.\")\n  u <- sort(unique(c(l1,\
    \ l2)))\n  return(u[u != l1])  # exclude l1 from u\n}\n", "\n    sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n}\n", "\n  return(c(Reduce(intersect, c(sort(l1),\
    \ sort(l2))), l1[duplicated(l1)]))\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis\
    \ is an elegant solution and a good one! Thank you so much. I would only add that\
    \ your base R solution would need `unlist(sort(...))` at the end. Just in case\
    \ you ever need the unsorted version (maybe a larger number of elements).\n<|/\
    \ c |>\n<| c |>\n, you're very welcome. Thanks for the additional suggestion.\
    \ I'll add it to my answer.\n<|/ c |>\n<| c |>\n, I just added the `unlist` suggestion.\n\
    <|/ c |>\n<| a tags=r |>\nHere is a solution using only base R that works when\
    \ the input vectors are of equal length, i.e. common elements between all input\
    \ vectors:\n<code>", "\n  u <- unique(c(l1, l2))\n  return(unique(u)[ findInterval(length(u),\
    \ uniqueN(u)) ])\n}\n", "\n  return(Reduce(intersect, lapply(l1, `[`, \n    match(unlist(l2),\
    \ unique(unlist(l2))))), USE.NAMES = TRUE)\n}\n", "\n  intersect(sort(l1), sort(l2))\n\
    }\n</code>\n<|/ a |>\n<| a |>\nHere is an example of how to find the common elements\
    \ in two lists and return them in a data.frame:\n<code>\nlibrary(tidyverse)\n",
  "\n  res <- list()\n  for(i in seq_along(l1)) {\n    if(identical(l1[[i]], l2[[i]]))\
    \ {\n      res[[i]] <- l1[i]\n    } else {\n      break\n    }\n  }\n  res\n}\n",
  "\n  ans <- l1[[1]]\n  for(i in 2:length(l1)) {\n    ans <- setdiff(ans, l1[[i]])\n\
    \  }\n  ans\n}\n</code>\nThe common function returns all elements that are in\
    \ both of the lists.\n<|/ a |>\n<| c |>\nThanks so much! This works perfectly!\
    \ I'm just now working on understanding exactly how it works. Could you please\
    \ give me some advice on how to approach the logic behind `common()` please? Thanks\
    \ again!\n<|/ c |>\n<| c |>\nWhat exactly don't you understand about it? The `common`\
    \ function basically does what you would expect.\n<|/ c |>\n<| c |>\nI understand\
    \ that `common()` returns unique elements, but I do not understand why `common()`\
    \ is returning the unique elements. I understand that `common()` returns all elements\
    \ that are in both lists, but how are these unique elements being added?\n<|/\
    \ c |>\n<| c |>\n`common` returns all elements that are in both lists. `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `c(1, 5, 653)`, because\
    \ the first element of the first list is in both lists. The same is true for all\
    \ other elements. `common(c(5, 3, 2, 8), c(3, 2))` returns `c(2, 3)`, because\
    \ the first element of the second list is also in the second list.\n<|/ c |>\n\
    <| c |>\nThanks so much! This is very helpful! I'm now just trying to understand\
    \ how it is adding all unique elements. Could you please explain how `common()`\
    \ returns all elements that are in both lists?\n<|/ c |>\n<| a tags=r |>\nAnother\
    \ option:\n<code>\nlibrary(dplyr)\n\nlist1 <- list(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121))\nlist2 <- list(c(5, 3, 2, 8), c(3, 2))\n\nmap2(list1,\
    \ list2, ~unique(.x) %in% .y) %>%\n  reduce(`%in%`)\n</code>\nReturns:\n<code>\n\
    [1] TRUE FALSE\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is a base R option using\
    \ Reduce + intersect\n<code>\nReduce(intersect, list1) %in% Reduce(intersect,\
    \ list2)", "\n    common <- list()\n    for (i in 1:length(l1)) {\n        common[[i]]\
    \ <- l1[i] %in% l2\n    }\n    sort(unique(unlist(common)))\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=r dscore=0 |>\n<code>\ncommon = function(list1,list2){\n\
    \  \n  len1 = length(list1)\n  len2 = length(list2)\n  \n  if(len1==0 || len2==0)\
    \ return ()\n  \n  for(i in 1:len1){\n    if(list1[i]%in%list2){\n      list3\
    \ = c(list3,list1[i])\n    }\n  }\n  \n  return(list3)\n  \n}\n\ncommon(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n[1] \"1\" \"5\" \"653\"\n</code>\n\
    <|/ a |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding how and/or why it solves the problem would improve the answer's\
    \ long-term value.\n<|/ c |>\n<| a |>\n<code>\nlist1 <- c(1,4,3,34,653,2,5)\n\
    list2 <- c(5,7,1,5,9,653,121)\n\ncommon = intersect(list1,list2)\n</code>\n<|/\
    \ a tags=r dscore=0 |>\n<| a tags=r dscore=0 |>\nUsing tidyverse\n<code>\nlist1\
    \ <- c(1,4,3,34,653,2,5)\nlist2 <- c(5,7,1,5,9,653,121)\n\nlibrary(tidyverse)\n\
    </code>\nIf you want to find intersection of list 1 and list 2\n<code>\nintersect(list1,list2)\n\
    \n[1]  1  5 653\n</code>\nIf you want to find common elements of the list 1 and\
    \ list 2\n<code>\nlength(intersect(list1,list2))\n</code>\n<|/ a |>\n<| a tags=r\
    \ |>\nHere's a solution using dplyr:\n<code>\nlibrary(dplyr)\n\nlist1 <- c(1,4,3,34,653,2,5)\n\
    list2 <- c(5,7,1,5,9,653,121)\n\nlist1 = list(c(list1), list2)\nlist1 = list1[!duplicated(list1)]\n\
    list1 = list1[!duplicated(list1, fromLast = TRUE)]\n\nlist1\n</code>\nThis gives:\n\
    <code>\n[1] \"1\" \"5\" \"653\"\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=r\
    \ |>\n<code>\nlist", "\n  u <- union(l1, l2)\n  d <- setdiff(union(l1, l2), u)\n\
    \  c(u, d)\n}\n", "\n    if (length(l1) != length(l2)) {\n        stop(\"Inputs\
    \ must have the same length\")\n    }\n    out <- rep(NA_real_, length(l1))\n\
    \    for (i in seq_along(l1)) {\n        x <- l1[i]\n        x <- x[1]\n     \
    \   out[i] <- names(which(l2[x] == l2[[1]]))[1]\n    }\n    sort(out)\n}\n", "\n\
    \    sort(sort(unique(c(l1, l2))))\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nThe\
    \ first three lines are a one liner, and return a vector of common elements in\
    \ two lists:\n<code>\n> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))\n[1] 1 5 653\n</code>\n<|/ a tags=r,vector,list |>\n<| a |>\nThe two answers\
    \ above using intersect are great.  Just wanted to add this if you want more than\
    \ two lists to be tested for common elements, you can pass them all at once, for\
    \ example:\n<code>\ncommon_list <- intersect(list1, list2, list3, list4)\n</code>\n\
    And if you want a vector of common elements, you can just do:\n<code>\ncommon_elements\
    \ <- intersect(list1, list2, list3, list4, list5)\n</code>\n<|/ a dscore=3 tags=r,vector,list\
    \ |>\n<| a tags=r,vector,list dscore=3 |>\nSince I came here looking for the intersect\
    \ of a number of lists I thought I would add an answer to help others who may\
    \ come here.\nThis is how I did it.\n<code>\nList1 <- list(1,2,3)\nList2 <- list(4,5,6,7,8)\n\
    List3 <- list(1,2,3)\nList4 <- list(1,2,3,4,5,6,7,8)\n\nLists <- c(List1, List2,\
    \ List3, List4)\ncommon(Lists)\n</code>\n<|/ a |>\n<| a tags=r,vector,list |>\n\
    <code>", "\n  u <- unique(c(l1, l2))\n  i <- which(u == l1)\n  j <- which(u ==\
    \ l2)\n  c(c(i, j))\n}\n</code>\nNow we can simply do:\n<code>\ncommon(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n</code>\nAnd the result is:\n\
    <code>\n> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n[1] 1\
    \ 5 653\n</code>\n<|/ a tags=unique,sorting,intersect,r dscore=2 |>\n<| a dscore=2\
    \ |>\nIf there are many elements (many thousands), then the most efficient way\
    \ to do this would be to create a data frame and then use R's intersect function:\n\
    <code>\na = c(1, 4, 3, 34, 653, 2, 5)\nb = c(5, 7, 1, 5, 9, 653, 121)\ndf = data.frame(a\
    \ = a, b = b)\n</code>\nThen:\n<code>\n> intersect(df$a, df$b)\n[1] 1 5 653\n\
    </code>\nThis works in cases where the input vectors are all sorted, but you can\
    \ also use the data.table package's setintersect function:\n<code>\nlibrary(data.table)\n\
    setDT(df)[, a %in% b]\n</code>\n<|/ a tags=unique,sorting,intersect,r |>\n<| c\
    \ |>\nWhat if you don't want a data frame but a vector of integers?\n<|/ c |>\n\
    <| c |>\nA data frame is just a more convenient way of dealing with data frames.\
    \ If you want a vector of integers, just use something like `setDT(df)[, a %in%\
    \ b]$a`.\n<|/ c |>\n<| a dscore=1 tags=unique,sorting,intersect,r |>\nIn case\
    \ you just need a vector with unique numbers, you can use the following command\
    \ in the package \"dplyr\":\n<code>\ndf <- data.frame(a = c(1, 4, 3, 34, 653,\
    \ 2, 5))\ndf %>% distinct(a)\n</code>\nThe result will be:\n<code>\n  a\n1 1\n\
    2 5\n3 653\n</code>\n<|/ a |>\n<| a dscore=1 |>\nA base R solution (using intersect\
    \ and %in%) would be:\n<code>\nx <- c(1, 4, 3, 34, 653, 2, 5)\ny <- c(5, 7, 1,\
    \ 5, 9, 653, 121)\nintersect(x, y)\n\n[1] 1 5 653\n</code>\n<|/ a tags=unique,",
  "\n  n <- min(length(l1), length(l2))\n  if(length(l1) < length(l2)) \n    c(l1,\
    \ rep(NA, n-nlength(l2)))\n  else if(length(l1) > length(l2)) \n    c(rep(NA,\
    \ length(l1)-nlength(l2)), l2)\n  else \n    rep(c(l1[!is.na(l1)], l2[!is.na(l2)]),\
    \ n)\n}\n</code>\n<|/ a tags=dplyr,r,tidyverse,list,data.table |>\n<| a dscore=1\
    \ |>\nOne option is to use Reduce with intersect\n<code>\nReduce(intersect, list(list_1,\
    \ list_2))\n</code>\nThis returns\n\n[1] \"1\"   \"4\"   \"5\"   \"653\" \"12\"\
    \  \"34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\"  \"653\" \"32\"  \"51\"  \"\
    653\" \"12\"  \"34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\"  \"653\" \"32\" \
    \ \"51\"  \"653\" \"12\"  \"34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\"  \"653\"\
    \ \"32\"  \"51\"  \"653\" \"12\"  \"34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\"\
    \  \"653\" \"32\"  \"51\"  \"653\" \"12\"  \"34\"  \"7\"   \"9\"   \"653\" \"\
    32\"  \"51\"  \"653\" \"32\"  \"51\"  \"653\" \"12\"  \"34\"  \"7\"   \"9\"  \
    \ \"653\" \"32\"  \"51\"  \"653\" \"32\"  \"51\"  \"653\" \"12\"  \"34\"  \"7\"\
    \   \"9\"   \"653\" \"32\"  \"51\"  \"653\" \"32\"  \"51\"  \"653\" \"12\"  \"\
    34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\"  \"653\" \"32\"  \"51\"  \"653\"\
    \ \"12\"  \"34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\"  \"653\" \"32\"  \"51\"\
    \  \"653\" \"12\"  \"34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\"  \"653\" \"\
    32\"  \"51\"  \"653\" \"12\"  \"34\"  \"7\"   \"9\"   \"653\" \"32\"  \"51\" \
    \ \"653\" \"32\"  \"51\"  \"653\" \"12\"  \"34\"  \"7\"   \"", "\n  l1 <- sort(unique(l1))\n\
    \  l2 <- sort(unique(l2))\n  l1[match( l1, l2 )] # Return common elements.\n}\n\
    \ncommon(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))", "\n  l <- listUnique(l1,\
    \ l2)\n  i <- match(names(l), names(l))\n  names(l)[i] <- \"common\"\n  l\n}\n",
  "\n  n1 <- length(l1)\n  n2 <- length(l2)\n  common <- character(n1 + n2)\n  for(i\
    \ in 1:n1) {\n    common[i] <- l1[i]\n    for(j in 1:n2) {\n      if(l1[i] ==\
    \ l2[j]) {\n        common[i + j] <- l1[i]\n        break\n      }\n    }\n  }\n\
    \  common\n}\n</code>\nAnd it seems to work. As I said, I couldn't get it right\
    \ the first time, so I tested a bunch of different inputs and got some interesting\
    \ results. Some of them were just as fast as others, so I didn't bother trying\
    \ more. \n<code>\n> microbenchmark(\n+   common(a1, a2),\n+   common(b1, b2),\n\
    +   common(c1, c2),\n+   common(d1, d2),\n+   common(e1, e2),\n+   common(f1,\
    \ f2),\n+   common(g1, g2),\n+   common(h1, h2),\n+   common(i1, i2),\n+   common(j1,\
    \ j2),\n+   common(k1, k2),\n+   common(l1, l2)\n+ )\nUnit: milliseconds\n   \
    \       expr       min        lq    median        uq       max neval\n    common(a1,\
    \ a2)  22.50859  22.55503  23.17578  23.44642  26.67080   100\n    common(b1,\
    \ b2)  26.75425  26.84852  27.37805  27.78824  29.83953   100\n    common(c1,\
    \ c2)  17.81021  17.92052  18.12490  18.24881  20.16747   100\n    common(d1,\
    \ d2)  11.62714  11.73837  11.79770  11.89358  13.72565   100\n    common(e1,\
    \ e2)  14.04866  14.07352  14.15240  14.22779  15.27776   100\n    common(f1,\
    \ f2)  18.64441  18.71384  18.78719  18.95612  20.47413   100\n    common(g1,\
    \ g2)  22.72431  22.77341  22.89893  23.02064  24.30268   100\n    common(h1,\
    \ h2)  26.88476  26.97677  27.05705  27.07779  27.", "\n    common2 <- intersect(c(l1,\
    \ l2))\n    if (length(common2) == 0) return(NA)\n    common2 <- sort(common2)\n\
    \    common2 <- common2[!is.na(common2)]\n    return(common2)\n}\n", "\n    k\
    \ <- min(length(l1), length(l2))\n    i <- 0\n    l <- 0\n    for (j in 1:k) {\n\
    \        while (i < length(l1) && l1[[i]] == l1[[i + j]]) i <- i + 1\n       \
    \ while (i < length(l2) && l2[[i]] == l2[[i + j]]) i <- i + 1\n        l <- max(l,\
    \ i + j)\n    }\n    unique(c(setdiff(l1, l2[l - k]), setdiff(l2, l1[l - k])))\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is exactly the answer I was looking for. Thank\
    \ you for sharing this! However, I find it slightly confusing that there is a\
    \ `for` loop within `common` - is there a reason for this?\n<|/ c |>\n<| c |>\n\
    That's just a different way of writing it. `for` loops aren't used often in R\
    \ programming. It's just a different way of writing things and makes it easier\
    \ to read. :)\n<|/ c |>\n<| c |>\nActually, `common` should return an output that\
    \ is `ordered`, i.e. `c(2, 3)`, not `c(3, 2)`.\n<|/ c |>\n<| c |>\nYeah, I suppose\
    \ that would be an improvement. The original question didn't really say what order\
    \ should be used.\n<|/ c |>\n<| a tags=r,string,sorting,subset |>\nTry this function\
    \ \n<code>\ncommon2 <- function(x,y,n){\n   if(length(x) < n) \n      return(x)\n\
    \   if(length(y)<n) \n      return(y)\n   return(sort(c(x[[1]],y[[1]])) +\n  \
    \         common2(c(x[[1]],y[[1]]),c(y[[1]],x[[1]]),n-1)\n           )\n}\n</code>\n\
    Test function \n<code>\nx <- c(1:2,3:4)\ny <- c(1:5,2:4,3:5,4:6,5:7,6:8)\ncommon2(x,y)",
  "\n  u1 <- sort(unique(c(l1)))\n  u2 <- sort(unique(c(l2)))\n  u1[u2 %in% u1]\n\
    }\n", "\n  n1 <- length(l1)\n  n2 <- length(l2)\n  l <- numeric(n1 * n2)\n  i\
    \ <- 0\n  for (k in 1:n1) {\n    for(j in 1:n2) {\n      if (l1[k] == l2[j]) {\n\
    \        l[i] <- l1[k]\n        i <- i + 1\n      }\n    }\n  }\n  return(unique(c(l)))\n\
    }\n</code>\n<|/ a tags=r |>\n<| a |>\nHere is a one-liner:\n<code>\nsapply(c(1,\
    \ 4, 3, 34, 653, 2, 5), function(x){unique(c(sort(x),x))})\n[1]  1  5 653\n</code>\n\
    Or:\n<code>\n sapply(c(1, 4, 3, 34, 653, 2, 5), function(x){unique(c(sort(x),x))})[!duplicated(sapply(c(1,\
    \ 4, 3, 34, 653, 2, 5), function(x){unique(c(sort(x),x))}))]\n[1]  1  5 653\n\
    </code>\n<|/ a dscore=3 tags=r |>\n<| c |>\nThis is great. I was thinking of something\
    \ similar, except I was looking for something like `x[order(x)]` since I didn't\
    \ know if there was a way to get the order of the vector.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere is an option with base R function setdiff\n<code>\nunique(sort(c(sort(c(1,\
    \ 4, 3, 34, 653, 2, 5)), c(5, 7, 1, 5, 9, 653, 121))))\n[1]  1  5 653\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\nThis is a variant on the answer I propose here\
    \ that seems to give the same result:\n<code>\nunique(c(sort(c(1, 4, 3, 34, 653,\
    \ 2, 5)), c(5, 7, 1, 5, 9, 653, 121)))", "\n  n <- length(l1)\n  u1 <- sort(l1)\n\
    \  u2 <- sort(l2)\n  common_index <- which(u1 == u2)\n  common_index <- common_index[common_index\
    \ != n]\n  common_index\n}\n</cell>\n<cell>", "\n  unique(c(sort(l1), sort(l2)))\n\
    }\n</cell>\n<text>\nExercise: Recall that you can add two vectors together by\
    \ using the + operator. Can you write a function that can calculate the difference\
    \ between two vectors?\n\n\n</text>\n<cell>", "\n  stopifnot(length(l1) == length(l2))\n\
    \  u1 <- unique(l1)\n  u2 <- unique(l2)\n  setdiff(u1, u2)\n}\n", "\n  sort.list(setdiff(sort(unique(c(l1,\
    \ l2))), c(l1[1], l2[1])))\n}\n", "\n\tinter <- intersect(l1, l2)\n\tif(length(inter)\
    \ != 0) {\n\t\tl1[inter]\n\t}\n}\n</cell>\n<cell>", "\n    sort(unique(intersect(sort(l1),\
    \ sort(l2))))\n}\n", "\n  res <- NULL\n  for (i in seq_along(l1)) {\n    for (j\
    \ in seq_along(l2)) {\n      if (l1[[i]] == l2[[j]]) res <- c(res, i)\n    }\n\
    \  }\n  res\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list dscore=1 |>\nThis\
    \ can be done by checking the elements of the lists and removing them if they\
    \ match. \n<code>\nx <- list(c(1,2,3,4,5), c(1,2,3,4,5))\ny <- list(c(1,2,3,4,5),\
    \ c(1,2,3,4,5,6))\nx", "\n  sort <- function(l) sort(l, decreasing=TRUE)\n  l\
    \ <- sort(c(l1, l2), decreasing=TRUE)\n  i <- 1\n  l <- sort(c(l1, l2), decreasing=TRUE)\n\
    \  while (i < length(l)-1 & identical(l[[i]], l[[i+1]])) i <- i + 1\n  l[c(i,\
    \ i+1)]\n}\n</code>\n<|/ a |>\n<| a tags=r dscore=1 |>\nYou can use\n<code>\n\
    sort(unique(c(x, y), use.names = TRUE))\n[1] \"A\" \"B\" \"C\" \"D\"\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=r |>\nYou can use the function unique() and the argument\
    \ use.names = TRUE:\n<code>\nx <- c(\"A\", \"B\", \"C\", \"D\")\ny <- c(\"B\"\
    , \"A\", \"C\", \"D\")\n\nsort(unique(c(x,y), use.names = TRUE))\n[1] \"A\" \"\
    B\" \"C\" \"D\"\n</code>\n<|/ a |>\n<| c |>\n`unique(c(letters, LETTERS), use.names\
    \ = TRUE)` doesn't work\n<|/ c |>\n<| c |>\nYes, that's right. `sort(unique(c(letters,\
    \ LETTERS), use.names = TRUE))` works just fine.\n<|/ c |>\n<| c |>\n`sort(unique(c(letters,\
    \ LETTERS), use.names = TRUE))` doesn't work - it just gives me a vector of the\
    \ same length as `letters`.\n<|/ c |>\n<| c |>\nThat's strange. Do you have a\
    \ reproducible example?\n<|/ c |>\n<| c |>\nMy bad, `sort(unique(c(letters, LETTERS),\
    \ use.names = TRUE))` works fine. I had a mistake elsewhere in the code.\n<|/\
    \ c |>\n<| a tags=r |>\n<code>\nx <- c(\"A\", \"B\", \"C\", \"D\")\ny <- c(\"\
    B\", \"A\", \"C\", \"D\")\n</code>\nsort(unique(c(x,y))) does not work for me\
    \ in R 3.6.3 using R studio. The following is what I found to work:\n<code>\n\
    sort(unique(c(x,y), use.names = TRUE))\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    `sort(unique(c(letters, LETTERS), use.names = TRUE))` doesn't work\n<|/ c |>\n\
    <| a dscore=1 tags=r |>\n<code>\nxy ", "\n  unique(c(l1, l2))\n}\n", "\n    commons\
    \ <- sort(unique(c(l1, l2)), decreasing = TRUE)\n    names(commons) <- NULL\n\
    \    commons\n}\n", "\n  common <- common_set(c(l1, l2))\n  sort(unique(c(common,\
    \ intersect(l1, l2))))\n}\n", "\n    # Preprocessing.\n    l1 <- na.omit(l1)\n\
    \    l2 <- na.omit(l2)\n    \n    # Finding the common elements\n    commonInds\
    \ <- match(l1, l2, nomatch = 0)\n    commonInds\n}\n", "\n  indx <- which(!is.na(l1)\
    \ & !is.na(l2))\n  if (length(indx) < 2) {\n    return(NA)\n  }\n  l1[indx] <-\
    \ l2[indx]\n  l1[is.na(l1)] <- NA\n  return(l1)\n}\n", "\n  sort(unique(c(sort(l1),\
    \ sort(l2))))\n}\n</code>\nThen the function returns all those elements that are\
    \ common to both lists, ordered by length.\n<code>\n> common(c(1, 4, 3, 34, 653,\
    \ 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n[1]  1 653 5 7\n</code>\nThe order of the\
    \ common elements is guaranteed to be the same as the order of the original lists,\
    \ because of the call to sort. The sort call ensures that the final common elements\
    \ are in sorted order.\nThe call to sort is necessary to get the order of common\
    \ elements guaranteed to be in the same order as the original lists, because of\
    \ the call to unique. unique guarantees the ordering of common elements is the\
    \ same as of the original lists.\n<|/ a tags=function,r |>\n<| c |>\nthanks for\
    \ the help, unfortunately I cannot use %in%, because I need to return the values\
    \ in ascending order\n<|/ c |>\n<| c |>\nI don't understand. The example you provided\
    \ in the comment above shows that you don't want `653` to come before `1` in the\
    \ returned list. I don't know why you think you need that guarantee of ordering,\
    \ but it is easy to get that guarantee if you really need it.\n<|/ c |>\n<| c\
    \ |>\nSorry I misread your comment, I thought you were talking about another comment.\
    \ My mistake.\n<|/ c |>\n<| c |>\nNo problem. I'm glad you were able to figure\
    \ it out.\n<|/ c |>\n<| a |>\nAn alternative is to create a hash table where you\
    \ store your lists as key:value pairs.\n<code>\n> table(c(1, 4, 3, 34, 653, 2,\
    \ 5), c(5, 7, 1, 5, 9, 653, 121))\n1 2 3 4 5 7 8 9 10 11 12 13 14 15 16 17 18\
    \ 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44\
    \ 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70\
    \ 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96\
    \ 97 98 99 \n1 2 3 4 5 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ", "\n\
    \  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[is.na(u)] <-\
    \ 0\n  u <- sort(u)\n  return(u)\n}\n", "\n    len1 <- length(l1)\n    len2 <-\
    \ length(l2)\n    len1 == len2 || (len1 < len2 || is.na(intersect(l1, l2))) ||\
    \ is.na(intersect(l2, l1))\n}\n</code>\n<code>", "\n  u <- unique(c(l1, l2))\n\
    \  return(unname(setNames(which(names(u) %in% u), unname(which(names(u) %in% u)))))\n\
    }\n</cell>\n<cell>\nprint(common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121)))\n</cell>\n<cell>\nprint(common(c(5, 3, 2, 8), c(3, 2)))\n</cell>\n<text>\n\
    A list can contain another list as its elements:\n\n\n</text>\n<cell>\nx <- list(1,\
    \ 2, list(a = 1, b = 2, c = 3))\n</cell>\n<cell>\nx\n</cell>\n<text>\nList elements\
    \ are also accessed with double bracket notation:\n\n\n</text>\n<cell>\nx[1]\n\
    </cell>\n<cell>\nx[[1]]\n</cell>\n<text>\nIf no elements match the given condition,\
    \ the empty list will be returned:\n\n\n</text>\n<cell>\nx[x[[1]] == 3]\n</cell>\n\
    <cell>\nx[x[[1]] != 3]\n</cell>\n<text>\nSubsetting can also be done by position\
    \ with square brackets [ ]:\n\n\n</text>\n<cell>\nx[1:4]\n</cell>\n<text>\nThe\
    \ result is a list again:\n\n\n</text>\n<cell>\nx[1:4]\n</cell>\n<text>\nSlicing\
    \ with lists can also be done with negative numbers:\n\n\n</text>\n<cell>\nx[-3]\n\
    </cell>\n<cell>\nx[-c(3, 2)]\n</cell>\n<text>\nIf there are multiple items that\
    \ match to a subsetting, all the items will be removed:\n\n\n</text>\n<cell>\n\
    x[-c(3, 2), ]\n</cell>\n<text>\nThe lists can be combined with other vectors:\n\
    \n\n</text>\n<cell>\nx[1:4] * x[4:1]\n</cell>\n<cell>\nx[1:4] + x[4:1]\n</cell>\n\
    <text>\nCommon functions are also available:\n\n\n</text>\n<cell>\nx.mean <- function(x)\
    \ {\n  return(mean(x))\n}\n</cell>\n<cell>\nx.mean(list(1, 4, 3, 34, 653, 2, 5))\n\
    </cell>\n<cell>\nx.sum(list(1, 4, 3, 34, 653, 2, 5))\n</cell>\n<text>\nThe length\
    \ of the list can be returned with the length function:\n\n\n</text>\n<cell>\n\
    length(list(1, 4, 3, 34, 653, 2, 5))\n</cell>\n<cell>\nx.", "\n  # Get the unique\
    \ elements of each list, then unlist the unique elements \n  # into a vector,\
    \ sort it, then use that to filter out duplicates.\n  l1 <- unlist(l1)\n  l2 <-\
    \ unlist(l2)\n  unique(sort(c(l1, l2)))\n}\n\ncommon(list(1,4,3,34,653,5,7,1,5,9,653,121),\
    \ list(5,7,1,5,9,653,121))\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,sorting |>\n\
    Here is a possible implementation that I think works and is fast:\n<code>\ncomm_sorted\
    \ <- function(x, y) {\n  unique_x <- unique(unlist(x))\n  unique_y <- unique(unlist(y))\n\
    \  comm <- intersect(unique_x, unique_y)\n  comm <- sort(unique(comm))\n  comm\
    \ <- match(comm, unique(comm))\n  comm <- cbind(comm, rank(comm))\n  return(comm)\n\
    }\n\ncomm_sorted(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- sort(unique(c(l2, l1)))\n  intersect(u1, u2)\n\
    }\n</code>\nAnd here is the final solution\n<code>", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  match(unique(c(u1, u2)), unique(c(l1, l2)), nomatch\
    \ = 0)\n}\n", "\n  out <- NULL\n  i <- 0\n  while (i < length(l1)) {\n    if (l2[i]\
    \ < l1[i]) {\n      out <- c(out, l1[i])\n    }\n    i <- i + 1\n  }\n  while\
    \ (i < length(l2)) {\n    out <- c(out, l2[i])\n    i <- i + 1\n  }\n  return(out)\n\
    }\n</code>\n<|/ a |>\n<| a |>\nThis should work:\n<code>\ncommon <- function(x,\
    \ y) {\n    i <- 0\n    n <- length(x)\n    while (i < n) {\n        if (i %in%\
    \ names(y)[match(y, x[i])]) \n            x <- setdiff(x, x[i])\n        else\
    \ {\n            i <- i + 1\n        }\n    }\n    x\n}\n</code>\n<|/ a tags=match,r\
    \ dscore=1 |>\n<| a tags=match,r dscore=0 |>\nHere's a dplyr approach:\n<code>\n\
    a <- c(1, 2, 3, 4, 5)\nb <- c(3, 5)\nc <- c(1, 2)\ndf <- tibble(a, b, c)\n\ndf\
    \ %>%\n  mutate(abc = map2_int(a, c, ~.x %in% .y)) %>%\n  rowwise %>%\n  mutate(abc\
    \ = all(abc)) %>%\n  ungroup() %>%\n  select(-abc)\n", "\n    l1 <- sort(l1)\n\
    \    l2 <- sort(l2)\n    common1 <- l1\n    common2 <- l1\n    while (length(common1)\
    \ > 0 & length(common2) > 0) {\n        common1 <- c(common1[!is.na(match(common1,\
    \ l2))], common2)\n        common2 <- c(common1, common2[!is.na(match(common2,\
    \ l2))])\n    }\n    common1 <- common1[!is.na(match(common1, l2))]\n    common2\
    \ <- common2[!is.na(match(common2, l2))]\n    common\n}\n</code>\nAnd a couple\
    \ tests:\n<code>\n> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n\
    [1] 1 5 653\n> common(c(5, 3, 2, 8), c(3, 2))\n[1] 2 3\n</code>\n<|/ a tags=r,sorting,duplicates,arrays\
    \ |>\n<| a |>\nA variation on's answer. It doesn't use any external packages:\n\
    <code>\nx <- c(5, 5, 5, 6, 5, 4, 5, 7, 5, 8, 7, 8)\ny <- c(3, 3, 3, 3, 3, 3, 4,\
    \ 3, 3, 3, 3)\nx1 <- cumsum(x == y) + 1\nx2 <- cumsum(x > y) + 1\ny[x1[x2 == length(x2)]]\
    \ <- NA\ny", "\n  sort(unique(c(l1, l2)), decreasing = TRUE)\n}\n</cell>\n<text>\n\
    Common words frequency, for two lists of words.\n\n</text>\n<cell>", "\n    common1\
    \ <- intersect(l1, l2)\n    common2 <- intersect(l2, l1)\n    common1 <- unique(common1)\n\
    \    common2 <- unique(common2)\n    common1[length(common1)]\n}\n</code>\n<|/\
    \ a dscore=2 tags=r,sorting |>\n<| c |>\nThis is beautiful and simple. Could you\
    \ please elaborate on the logic of finding intersections and then filtering out\
    \ duplicates? It doesn't seem to be mentioned anywhere on Internet.\n<|/ c |>\n\
    <| c |>\nApologies for missing out the part where I needed to remove duplicates.\
    \ I fixed that now. Thanks for pointing that out!\n<|/ c |>\n<| a tags=r,sorting\
    \ dscore=1 |>\nI believe this can be solved without looping, by vectorizing the\
    \ inner loop. Vectorization is very important when working with R. \nThe inner\
    \ loop can be vectorized by adding another for loop. \n<code>", "\n  s1 <- sort(l1)\n\
    \  s2 <- sort(l2)\n  u1 <- unique(s1)\n  u2 <- unique(s2)\n  u1[u2 %in% c(rbind(u1,\
    \ u2))]\n}\n</code>\nEdit:\nHere is a more efficient implementation for finding\
    \ all common elements for two lists:\n<code>\ncommon <- function(l1, l2) {\n \
    \ s1 <- sort(unique(c(l1, l2)))\n  s2 <- sort(unique(c(l2, l1)))\n  u1 <- unique(s1)\n\
    \  u2 <- unique(s2)\n  u1[u2 %in% c(rbind(u1, u2))]\n}\n</code>\n<|/ a tags=r,merge,vector,sorting\
    \ |>\n<| c |>\nThis code works. However the sorting is not the most efficient\
    \ way. Since it sorts every vector twice, it could take longer than the vectorized\
    \ merge function.\n<|/ c |>\n<| c |>\nIt is probably not doing as many `unique`s\
    \ as it needs to do. I think it would be better to just combine lists and then\
    \ remove duplicates from that list.\n<|/ c |>\n<| c |>\nHmm, thanks for the suggestion.\
    \ I will try that and get back to you if I have any more issues.\n<|/ c |>\n<|\
    \ c |>\nThis code has some issues. For example, if there are a couple of elements\
    \ in the list that are in both lists, this function will output only one of them\
    \ (either one in l1 or one in l2). \n\nAlso, when I add some additional data that\
    \ looks like this: common(c(5, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121,\
    \ 100)) The output is c(5, 653), not c(5, 5).\n<|/ c |>\n<| c |>\nI added an implementation\
    \ that might work if you don't have much data to sort and unique.\n<|/ c |>\n\
    <| a tags=r,merge,vector,sorting |>\nA simple solution could be:\n<code>\nlibrary(stringr)\n\
    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\ny <- c(\"a\", \"b\", \"c\", \"d\",\
    \ \"e\", \"f\")\nstr_overlap(x, y)\n[1] \"a\" \"b\"\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=r,merge,vector,sorting dscore=0 |>\n<code>\ncommon <- function(x1, x2){\n\
    \  x1 <- sort(x1)\n  x2 <- sort(x2)\n  unique_x <- unique(x1)\n  unique_y <- unique(x2)",
  "\n  l1 <- as.vector(l1)\n  l2 <- as.vector(l2)\n  unq <- unlist(l1)\n  unq <- intersect(unq,\
    \ l2)\n  return(unq)\n}\n</cell>\n<text>\nLet's use the common function we defined\
    \ above to find some common elements for the first and second columns of our data:\n\
    \n\n</text>\n<cell>\ncommon(c(c(1, 4, 3, 34, 653, 2, 5, 7, 1), c(5, 7, 1, 5, 9,\
    \ 653, 121)), c(3, 2))\n</cell>\n<text>\nIn the last section, we saw that we could\
    \ combine multiple R functions together to perform various types of transformations\
    \ on our data.\n\n\n</text>\n<text>\n2.6 Summarizing Data\nWe often want to summarize\
    \ a dataset to get a better understanding of what kind of data is being represented.\
    \ There are two ways to do this: aggregate and summarize.\n\nAggregate calculates\
    \ summary statistics from the data, such as minimum, maximum, count, and mean.\n\
    Summarize finds summary statistics for one or several variables in a dataset based\
    \ on a characteristic or criteria.\n\nLet's see an example of each with our data\
    \ set from last time.\n\n\n</text>\n<cell>", "\n  s1 <- sort(l1)\n  s2 <- sort(l2)\n\
    \  i <- 0\n  s1[length(s1)]\n  while (i < length(s1)) {\n    if (s1[i] == s2[i])\
    \ break\n    else i <- i + 1\n  }\n  s1[-i]\n}\n</code>\n<|/ a tags=r,permutation,matrix\
    \ |>\n<| c |>\nWhile this answer seems to work, it takes ages to finish. Could\
    \ you think of any other way to speed up the process?\n<|/ c |>\n<| c |>\nSure.\
    \ Just try to parallelize it in parallel package and see how it goes. It should\
    \ be much faster especially on larger lists.\n<|/ c |>\n<| c |>\nSure, but I would\
    \ need a more detailed answer for that. Can you maybe elaborate a bit more about\
    \ parallelizing this? Thanks!\n<|/ c |>\n<| c |>\nI am not sure that this is going\
    \ to be faster than using combn() directly.\n<|/ c |>\n<| c |>\nThis is great,\
    \ but when applying this to a matrix it is only working for the first column.\
    \ When I apply it to a matrix of size 3x3 it returns only the permutations for\
    \ the first row and column. Any idea why?\n<|/ c |>\n<| a tags=r,permutation,matrix\
    \ dscore=4 |>\nYou can use combn like this:\n<code>\nres <- t(combn(m, m, function(x,\
    \ y) x[y]))\n</code>\nThat will give you all combinations.\n<|/ a |>\n<| c |>\n\
    This doesn't work for me.  I tried to find an answer for `m` dimension and it\
    \ keeps stopping at 3 dimension.  `m=3` works; `m=4` works; `m=10` does not work.\n\
    <|/ c |>\n<| a tags=r,permutation,matrix dscore=3 |>\nHere's another simple solution,\
    \ using combn to permute all the columns, and using R's matrix function to get\
    \ the elements into the right order.\n<code>\nres <- t(matrix(combn(m, m), ncol\
    \ = m))\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for me. I tried to find\
    \ an answer for `m` dimension and it keeps stopping at 3 dimension. `m=3` works;\
    \ `m=4` works; `m=10` does not work.\n<|/ c |>\n<| a dscore=2 |>\nHere is a very\
    \ fast algorithm that runs under 1 million operations a second:\n<code>\nmat <-\
    \ matrix(1:24, ncol=8)\nmat[order(t(apply(mat, 1, sort))),]", "\n    sort(unique(c(l1,\
    \ l2)))\n}\n", "\n    n1 <- length(l1)\n    n2 <- length(l2)\n    i <- 0\n   \
    \ while(i <= n1 && i <= n2) {\n        while(i <= n1 && (l1[[i]] <= l2[[i]]))\
    \ {\n            i <- i + 1\n        }\n        while(i <= n2 && (l2[[i]] <= l1[[i]]))\
    \ {\n            i <- i + 1\n        }\n        if(i > n1) {\n            break\n\
    \        }\n        else if(i > n2) {\n            break\n        }\n        else\
    \ if(l1[[i]] == l2[[i]]) {\n            i <- i + 1\n        }\n    }\n    if(i\
    \ > n1) {\n        l1\n    }\n    else if(i > n2) {\n        l2\n    }\n    else\
    \ if(l1[[i]] == l2[[i]]) {\n        c(l1[i], l2[i])\n    }\n    else {\n     \
    \   common(c(l1[1:i], l2[1:i]), c(l1[i:], l2[i:]))\n    }\n}\n", "\n  sorted <-\
    \ sort(c(l1, l2))\n  sorted <- sorted[!duplicated(sorted)]\n  return(sorted)\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nHow would you do this with matrices?\n\
    <|/ c |>\n<| a tags=r,sorting |>\nAs the OP mentioned, they want to compute the\
    \ unique elements in each row of a matrix. \nHere's a way to do it with data.table\
    \ package:\n<code>\nset.seed(123)\ndt1 <- data.table(matrix(rnorm(200*5), ncol\
    \ = 5))\ndt2 <- data.table(matrix(rnorm(200*5), ncol = 5))\n", "\n  u1 <- unique(l1)\n\
    \  u2 <- unique(l2)\n  intersect(u1, u2)\n}\n</code>\n<|/ a tags=list,r,unique\
    \ |>\n<| a |>\nHere is a data.table version which should be more efficient as\
    \ it uses binary join and doesn't require sorting of vectors.\n<code>\nlibrary(data.table)\n\
    library(magrittr)\nsetDT(mydf)[mydf, .SD[1], on=names(mydf)[-c(1:2)], allow.cartesian=TRUE][,\
    \ \n        .(list1=unique(c(list1, sort(list2)))), by=names(mydf)[-c(1:2)]][,\
    \ \n            list2 := NULL][]\n</code>\nOutput:\n<code>\n   name1 name2 list1\
    \ list2\n1:     A     B     A     A\n2:     A     B     B     A\n3:     A    \
    \ B     C     A\n4:     B     C     B     B\n5:     B     C     C     B\n6:  \
    \   B     C     D     B\n7:     C     D     C     C\n8:     C     D     D    \
    \ C\n</code>\n<|/ a tags=list,r,unique dscore=3 |>\n<| a dscore=3 tags=list,r,unique\
    \ |>\nThe function unique is unfortunately not optimized for lists containing\
    \ duplicated entries. As such, you should consider using some other data structure,\
    \ such as named vector, for storing your lists.\nHowever, if you really want to\
    \ use lists, you can use unlist with duplicates:\n<code>\nmydf[!duplicated(unlist(mydf[-1])),\
    \ ]\n", "\n  unique(c(sort(l1), sort(l2)))\n}\n</code>\n<|/ a dscore=2 tags=r,list\
    \ |>\n<| a dscore=2 |>\nI wrote a function that computes intersections for lists\
    \ and vectors by first sorting the lists and then applying a simple intersection\
    \ algorithm. The intersection function returns the union of their common elements,\
    \ if any.\n<code>\nintersect <- function(list1, list2) {\n  if(is.list(list1)\
    \ && is.list(list2)){\n    list1 <- sort(list1)\n    list2 <- sort(list2)\n  \
    \  len1 <- length(list1)\n    len2 <- length(list2)\n    len <- max(len1, len2)\n\
    \    index <- 1\n    result <- list()\n    for(i in 1:len){\n      if(list1[i]\
    \ == list2[(i+1):len]){\n        result[index] <- list1[i]\n        index <- index\
    \ + 1\n      } else if(list1[i] == list2[(i+1):(len+1)]){\n        result[index]\
    \ <- list1[(i+1):len]\n        index <- index + 1\n      }\n    }\n    result\n\
    \  } else if(is.list(list1) && !is.list(list2)){\n    list1 <- sort(list1)\n \
    \   result <- list()\n    for(i in 1:length(list1)){\n      if(list1[i] == list2[i]){\n\
    \        result[i] <- list1[i]\n      }\n    }\n    result\n  } else if(!is.list(list1)\
    \ && is.list(list2)){\n    list2 <- sort(list2)\n    result <- list()\n    for(i\
    \ in 1:length(list2)){\n      if(list2[i] == list1[i]){\n        result[i] <-\
    \ list2[i]\n      }\n    }\n    result\n  } else {\n    list2 <- sort(list2)\n\
    \    list1 <- sort(list1)\n    result <- list()\n    len1 <- length(list1)\n \
    \   len2 <- length(list2)\n    len <- max(len1, len2)\n    index <- 1\n    for(i\
    \ in 1:len){\n      if(list1[i] == list2[(i+1):len]){\n        result[index] <-\
    \ list1[i]\n        index <- index + 1\n      } else if(list1[i] == list2[(i+1):(len+1)]){\n\
    \        result[index] <- list1[(i+1):len]\n        index <- index + 1\n     \
    \ }\n    }\n    result\n  }\n}\n</code>\nAn example of usage:\n<code>\nintersect(c(1,\
    \ 5, 3), c(3, 7, 1))\n</code>\nGives\n<code>\n[1]  3 7\n</code>\n<|/ a ", "\n\
    \    n1 <- length(l1)\n    n2 <- length(l2)\n    if(n1 == 0) {\n        return(list())\n\
    \    }\n    if(n2 == 0) {\n        return(list())\n    }\n    idx <- c(1, length(l1))\n\
    \    i <- 0\n    while(i < n1) {\n        if(l1[i] == l2[i]) {\n            idx\
    \ <- c(idx, i)\n            i <- i+1\n        }\n        i <- i+1\n    }\n   \
    \ list(c(idx[1], idx[n1]), c(idx[n1+1], length(l2)))\n}\n", "\n    n1 <- length(l1)\n\
    \    n2 <- length(l2)\n    if (n1 == 0) return(l2)\n    if (n2 == 0) return(l1)\n\
    \    i <- 0\n    set <- c()\n    while (i < n1 && i < n2) {\n        x <- l1[i]\n\
    \        y <- l2[i]\n        if (x != y) \n            set <- c(set, x, y)\n \
    \       i <- i + 1\n    }\n    if (i < n1)\n        set <- c(set, l1[i])\n   \
    \ if (i < n2)\n        set <- c(set, l2[i])\n    return(set)\n}\n", "\n    if\
    \ (length(l1) > length(l2)) return(l1[seq_along(l2) %in% unlist(l2)])\n    if\
    \ (length(l1) < length(l2)) return(l2[seq_along(l1) %in% unlist(l1)])\n    if\
    \ (all(unlist(l1) %in% unlist(l2))) return(c(l1, l2))\n    if (all(unlist(l2)\
    \ %in% unlist(l1))) return(c(l2, l1))\n}\n</code>\n<|/ a |>\n<| a tags=r |>\n\
    Here's another approach without duplicating elements - it checks whether the two\
    \ vectors are equal length and if they are it uses the indices to get the common\
    \ elements.\n<code>\nintersect <- function(x,y){\n  stopifnot(length(x)==length(y))\n\
    \  ans <- y[which(x==y)]\n  return(ans)\n}\n\nxy <- c('blue','green','red','yellow','pink')\n\
    xx <- c('green','pink')\nintersect(yy,xx)\n\n[1] \"green\"\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI wouldn't have thought of this one.\n<|/ c |>\n<| a dscore=4 |>\n\
    This can also be done with purrr, using the %in% operator, which allows logical\
    \ vectors. \nThis solution has the advantage of not requiring any packages:\n\
    <code>\nintersect(c('blue','green','red','yellow','pink'), c('green','pink'))\n\
    [1] \"green\"\n</code>\n<|/ a tags=r |>\n<| a |>\nAs the other answers have shown,\
    \ there are several ways to do this, and there are subtle issues you can run into\
    \ in some cases. Here are a few:\n\nIf your two vectors are of different lengths,\
    \ then the output will also be of different length. If you want to get a vector\
    \ with the common elements, you should pad one of them with NA (or some other\
    \ value that's not in the other vector). You can do that with:\n<code>\ncommon\
    \ = c(\"blue\",\"green\",\"red\",\"yellow\",\"pink\")\ncommon2 = c(\"green\",\"\
    pink\")\ncommon = c(common, NA)\ncommon2 = c(common2, NA)\ncommon[which(common\
    \ %in% common2)]\n</code>\nwhich produces [1] \"green\"\nIf your two vectors are\
    \ of equal length, then you will get two output vectors, the first of which only\
    \ contains elements that occur in both, and then the second of which only contains\
    \ elements that occur in both but the first element was removed. This is because ",
  "\n  u <- union(l1, l2)\n  tmp <- unique(u)\n  tmp <- rbind(tmp, tmp[-1, ])\n  tmp\
    \ <- tmp[order(tmp[, 1]), ]\n  tmp <- tmp[which(apply(tmp, 1, function(x) {\n\
    \    all(l1[[1]] == x[[1]])\n  })), ]\n  tmp <- tmp[order(tmp[, 1]), ]\n  tmp\n\
    }\n</code>\n<|/ a tags=r,list dscore=3 |>\n<| a dscore=3 |>\n<code>\nL <- list(1,5,2,3,4)\n\
    U <- list(2,3,4)\n</code>\nIf order is important try this:\n<code>\nL <- list(1,5,2,3,4)\n\
    U <- list(2,4,3)\n\nL <- Reduce(intersect, lapply(seq_along(L), function(x) L[[x]]))\n\
    U <- Reduce(intersect, lapply(seq_along(U), function(x) U[[x]]))\n\nL <- L[order(L)]\
    \ \nU <- U[order(U)]\n\nL", "\n  indx <- intersect(seq_along(l1), seq_along(l2))\n\
    \  if(length(indx) > 0) {\n    out <- l1[indx]\n  } else {\n    out <- c(l1, l2)\n\
    \  }\n  return(out)\n}\n", "\n  sort(union(sort(l1), sort(l2)), decreasing = TRUE)\n\
    }\n", "\n  # Sort lists first.\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  # If lists\
    \ are identical, return empty list.\n  if (length(l1) == length(unique(l1))) {\n\
    \    return(list())\n  }\n  if (length(l2) == length(unique(l2))) {\n    return(list())\n\
    \  }\n  # Return all common elements.\n  return(unique(l1[intersect(l1, l2)]))\n\
    }\n</code>\nThis doesn't require any packages, works even if lists are of different\
    \ lengths, and is fairly short. Hope this helps!\n<|/ a |>\n<| a tags=r |>\nThis\
    \ solution relies on no packages and is quite concise. It only returns common\
    \ items until it reaches the length of the shorter list. \n<code>\nmyfunction\
    \ <- function(x, y) {\n  x <- sort(x)\n  y <- sort(y)\n  i <- c(TRUE, diff(which(x\
    \ %in% y)) < 0)\n  c(y[i + 1], x[i])\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This also relies on `diff` function which doesn't exist in R 3.0.1 version\n<|/\
    \ c |>\n<| a |>\nBuilding on top of Emily's solution, here's a solution that I\
    \ believe would be more memory efficient, since it doesn't use any packages.\n\
    <code>\nmyfunction <- function(x, y) {\n  x <- sort(x)\n  y <- sort(y)\n  xi <-\
    \ which(x == y)\n  yi <- which(y == x)\n  yii <- yi - yi + 1\n  yii[which.max(yii\
    \ == 0)] <- NA\n  yii <- yii[!is.na(yii)]\n  yii[which.max(xi < yii)]\n}\n</code>\n\
    <|/ a dscore=1 tags=r |>\n<| c |>\nThis is definitely more memory efficient than\
    \ mine. However, my system crashed when I tried `x <- c(rep(NA,10^9), rep(1,10^9))`\
    \ with `y <- c(rep(NA,10^9), rep(1,10^9), rep(2,10^9))`. With your solution, it\
    \ takes about 10s to complete.\n<|/ c |>\n<| c |>\nThanks for the feedback. I'm\
    \ running this on a Linux Mint machine, with 8GB of RAM. The issue probably comes\
    \ from the `which.max` line -- this might need some tuning. My code also ", "\n\
    \  i1 <- match(l1, sort(unique(l1)))\n  i2 <- match(l2, sort(unique(l2)))\n  setdiff(sort(unique(l1[i1])[!duplicated(l1[i1])]),\
    \ \n         sort(unique(l2[i2])[!duplicated(l2[i2])]))\n}\n", "\n  tmp <- c(sort(l1),\
    \ sort(l2))\n  tmp[!(tmp %in% l1)] <- NA\n  tmp[!(tmp %in% l2)] <- NA\n  tmp[!is.na(tmp)]\
    \ <- tmp[!is.na(tmp)]\n  tmp[is.na(tmp)] <- NA\n  tmp\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nI like Aaron's answer. Here's a version using data.table:\n<code>",
  "\n  stopifnot(length(l1) == length(l2))\n  set1 <- sort(unique(l1))\n  set2 <-\
    \ sort(unique(l2))\n  intersect(set1, set2)\n}\n", "\n  u1 <- unique(sort(l1))\n\
    \  u2 <- unique(sort(l2))\n  u1[u2 %in% u1]\n}\n", "\n  # Find common elements\
    \ first.\n  l1 <- as.vector(l1)\n  l2 <- as.vector(l2)\n  common_elements <- intersect(l1,\
    \ l2)\n  # Remove duplicated elements.\n  common_elements <- sort(unique(common_elements))\n\
    \  return(common_elements)\n}\n", "\n  if(length(l1) != length(l2)) {\n    stop(\"\
    Lists must have equal length\")\n  }\n  unique(c(l1, l2))\n}\n</code>\n<|/ a tags=function,r,for-loop\
    \ |>\n<| a |>\nWe can use Map\n<code>\nf1 <- function(a, b, ...) {\n   out1 <-\
    \ Map(function(x,y) setNames(as.list(c(x[!is.na(x)], y[!is.na(y)])), c(\"X\",\
    \ \"Y\")), a, b, ...)\n   out2 <- Map(setNames, out1, c(names(out1[[1]]), names(out2[[1]])))\n\
    \   rbind(out1[[1]], out2[[1]])\n }\n\nf1(a, d)", "\n  u1 <- unique(c(l1, l2))\n\
    \  u1[!duplicated(u1)]\n}\n", "\n  commonIdx <- which(outer(l1, l2, `==`))\n \
    \ commonIdx <- commonIdx[commonIdx %in% seq_len(length(l1) %*% length(l2))]\n\
    \  l1[commonIdx]\n}\n", "\n  u1 <- unique(sort(l1))\n  u2 <- unique(sort(l2))\n\
    \  u1[u1 == u2] <- NA\n  u1[is.na(u1)] <- Inf\n  u2[is.na(u2)] <- Inf\n  intersect(sort(u1),\
    \ sort(u2))\n}\n", "\n    l <- sort(c(l1, l2))\n    unique(tail(l, length(l)%%2))\n\
    }\n</code>\nFor small lists, this will be slower than sorting the lists and using\
    \ rle to find common elements.\n<code>\nslower <- function(l1, l2) {\n    l <-\
    \ sort(c(l1, l2))\n    r <- rle(l)\n    rep(r$values[r$lengths >= 2], 2)\n}\n\n\
    library(microbenchmark)\nmicrobenchmark(\n    unique = unique(c(1, 4, 3, 34, 653,\
    \ 2, 5)),\n    sorted = common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121)),\n    duplicate = slower(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121)),\n    times = 5\n)", "\n    n1 <- length(l1)\n    n2 <- length(l2)\n \
    \   if (n1 < n2) \n        l2 <- l2[-1L]\n    if (!all(seq_along(l1) < seq_along(l2)))\n\
    \        stop(\"Lists not of equal length\")\n    common <- l1[n1L] %in% l2[n2L]\n\
    \    if (all(common)) {\n        return(l1)\n    }\n    return(l1[common])\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThis is a great solution. It only requires linear\
    \ time complexity. I'm surprised this isn't more popular.\n<|/ c |>\n<| c |>\n\
    This also seems to work pretty well in R, and is quite fast. However there is\
    \ one issue when running on a data set with NA's in the lists. When I replace\
    \ the NA's with the value 0, it still works. Any ideas why?\n<|/ c |>\n<| c |>\n\
    I guess it's just not clear what to do when there are both NAs and 0's in the\
    \ list. One way is to change the `if` statement to `if (n1 < n2 & !all(seq_along(l1)\
    \ < seq_along(l2))) ...` so that it will return a zero vector if `l1` and `l2`\
    \ are both zero vectors.\n<|/ c |>\n<| c |>\nI see what you're saying! I ended\
    \ up using the following code instead, thanks again for your help.\n<|/ c |>\n\
    <| c |>\nI added a test case that may help.\n<|/ c |>\n<| a dscore=5 |>\nIn R\
    \ version 4.1.0 or later you can use %in% and intersect:\n<code>\n> x <- c(2,3,5,8,9)\n\
    > y <- c(5,7,8,9,11)\n> y %in% x\n[1] FALSE  TRUE FALSE FALSE FALSE\n> y %in%\
    \ intersect(x,y)\n[1] FALSE  TRUE FALSE FALSE  TRUE\n</code>\n<|/ a tags=r,list\
    \ |>\n<| c |>\nthis should be the accepted answer\n<|/ c |>\n<| a |>\nIf you need\
    \ to find if all elements in a list are unique you can use Reduce:\n<code>\nlist1\
    \ <- list(c(1,2,3), c(1,2,2,3), c(1,3), c(1,2,2,3,5))\nlist2 <- list(c(2,3), c(2,3),\
    \ c(2,3,5,6))\nunique(Reduce(\"c\", list1, list2))", "\n    sort(unique(unlist(list(l1,\
    \ l2))))\n}\n</code>\nAnd you can test it as follows\n<code>\n> common(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n[1]  1  5 653\n> common(c(5,\
    \ 3, 2, 8), c(3, 2))\n[1]  2  3\n</code>\nThis will be very efficient and very\
    \ easy to understand.\n<|/ a dscore=4 |>\n<| c |>\nGreat idea! However, this won't\
    \ work for OP because he doesn't want to compare the two vectors with each other.\
    \ He wants them to be compared element by element but still maintain the order\
    \ of the original vector. Example: `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7,\
    \ 1, 5, 9, 653, 121))` will result in the output `c(1,5,653)` while he wants it\
    \ to be `c(1,5,653,34)`.\n<|/ c |>\n<| c |>\nYeah, you're right. I misunderstood\
    \ the question. I'll try to fix it\n<|/ c |>\n<| c |>\nThanks for the answer and\
    \ clarification. Yes, the result would be `c(1,5,653)`, I realize now I needed\
    \ to clarify my question further. What I'm trying to do is basically find all\
    \ the unique elements in two vectors and then compare them element by element,\
    \ while still maintaining the order of the original vectors.\n<|/ c |>\n<| c |>\n\
    , I updated my answer. I think this is what you are looking for.\n<|/ c |>\n<|\
    \ c |>\nThanks so much! This works perfectly, and it's very easy to understand.\n\
    <|/ c |>\n<| a tags=unique,r,intersect |>\n<code>\nv1 <- c(1, 4, 3, 34, 653, 2,\
    \ 5)\nv2 <- c(5, 7, 1, 5, 9, 653, 121)\n\nset.seed(42)\nd1 <- sample(1:1000, 100)\n\
    d2 <- sample(1:1000, 100)\n</code>\nIf your two vectors are sorted then we can\
    \ do this:\n<code>\ni <- order(v1)\nj <- order(v2)\n\nunique(c(v1[i], v2[j]))\n\
    </code>\nbut this won't retain the original order.\nIf you want to retain original\
    \ order then a solution is:\n<code>\nn <- length(v1)\ni <- order(v1)\nj <- order(v2)\n\
    \ni <- rep(i, length(d1))\nj <- rep(j, length(d2))", "\n  # Return common elements\
    \ of two lists.\n  unlist(lapply(l1, intersect, y=l2))\n}\n</code>\n<|/ a dscore=5\
    \ tags=sorting,list,r |>\n<| c |>\nThis should be the accepted answer as the other\
    \ two answer are really unclear. Thanks :)\n<|/ c |>\n<| c |>\nI agree. Nice solution\
    \ :)\n<|/ c |>\n<| c |>\nHow does this work under the hood in `R`? What is the\
    \ logic behind it? `intersect` returns a `data.frame` but what does it return\
    \ when the inputs are `lists` and how does it work under the hood?\n<|/ c |>\n\
    <| c |>\nI'm sorry, but this was so very long ago I don't remember the details.\
    \ I remember this being one of the most elegant solutions I've ever seen! For\
    \ anyone who wants to know how this works under the hood, it's basically a series\
    \ of nested `ifelse`s, e.g. `intersect(a,b)` can be thought of as `ifelse(length(a)\
    \ == length(b), a, ifelse(length(a) > length(b), b, a))`. And as you can see from\
    \ that code the `ifelse` function can take three arguments, one of which is another\
    \ `ifelse` expression!\n<|/ c |>\n<| c |>\nI think this solution is better because\
    \ it doesn't reinvent the wheel.\n<|/ c |>\n<| a tags=sorting,list,r |>\n<code>\n\
    library(dplyr)\nunlist(lapply(list_1, function(x) {\n    lapply(list_2, function(y)\
    \ {\n        intersect(x, y, sort = FALSE)\n    })\n}))\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=sorting,list,r dscore=4 |>\nI took some of the ideas above and\
    \ put it into one function:\n<code>\nintersect <- function(x, y=NULL, ...) {\n\
    \  if(is.null(y)) {\n    y <- x\n  }\n\n  y <- y[names(y) != \"x\"]\n  x <- x[names(x)\
    \ != \"x\"]\n\n  x[intersect(y, y, ...)] <- NA\n  x[is.na(x) & !is.na(y) & !is.na(y)]\
    \ <- y\n\n  return(x)\n}\n</code>\nExample:\n<code>\nl <- list(a = c(1,2,3,4,5,6,7,8,9),\
    \ \n           b = c(1,2,3,4,5,6,7,8,9), \n           c = c(1,2,3,4,5,6,7,8,9",
  "\n  s1 <- sort(sort(l1), decreasing = TRUE)\n  s2 <- sort(sort(l2), decreasing\
    \ = TRUE)\n  setdiff(union(s1, s2), c(NA, NA))\n}\n</code>\nThen you can use it\
    \ in your data frame:\n<code>\ndf$common <- as.factor(common(df$v1, df$v2))\n\
    </code>\n<|/ a tags=r,subset,merge,sorting |>\n<| c |>\nThanks so much! The answer\
    \ was really helpful!\n<|/ c |>\n<| c |>\nNo problem! If this answer solved your\
    \ problem, please consider upvoting and accepting the answer.\n<|/ c |>\n<| a\
    \ |>\nMy solution: \n<code>", "\n  res <- NULL\n  while (nrow(l1) > 0) {\n   \
    \ i <- which.min(l1[,1])\n    l1 <- l1[c(i, -nrow(l1)),]\n    i <- which.min(l2[i,1])\n\
    \    l2 <- l2[i,]\n    \n    if (nrow(l1) <= 0) {\n      break\n    }\n    if\
    \ (nrow(l2) <= 0) {\n      l1 <- rbind(l1, l2)\n      break\n    }\n    res <-\
    \ c(res, l1[i,])\n    l1 <- l1[c(i, -nrow(l1)),]\n  }\n  res\n}\n", "\n    l1\
    \ <- sort(l1)\n    l2 <- sort(l2)\n    idx <- match(l1, l2)\n    sort(unique(c(l1[idx],\
    \ l2[idx])))\n}\n", "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2,\
    \ l1)))\n  common1 <- intersect(c(l1, l2), c(u1, u2))\n  common2 <- intersect(c(l2,\
    \ l1), c(u1, u2))\n  union(common1, common2)\n}\n</cell>\n<text>\nCommon elements\n\
    The common function returns unique common elements between two vectors.\n\n\n\
    </text>\n<cell>\ncommon(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n\
    </cell>\n<cell>\ncommon(c(5, 3, 2, 8), c(3, 2))\n</cell>\n<text>\nCommon elements\
    \ across multiple lists\nThe common function returns common elements across multiple\
    \ lists.\n\n\n</text>\n<cell>\nlist(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9,\
    \ 653, 121),\n     c(5, 3, 2, 8), c(3, 2), c(1, 4, 3, 34, 653, 2, 5), c(5, 7,\
    \ 1, 5, 9, 653, 121),\n     c(5, 3, 2, 8), c(3, 2))\n</cell>\n<cell>\ncommon(list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121),\n           c(5, 3, 2, 8),\
    \ c(3, 2), c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121),\n          \
    \ c(5, 3, 2, 8), c(3, 2)), list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121),\n                                  c(5, 3, 2, 8), c(3, 2), c(4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121),\n                                  c(5,\
    \ 3, 2, 8), c(3, 2)))\n</cell>\n<text>\nCommon elements - the intersection function\n\
    The intersection function returns common elements between two lists while excluding\
    \ duplicate elements.\n\n\n</text>\n<cell>", "\n  sort(union(l1, l2), decreasing\
    \ = TRUE)\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  intersect(u1,\
    \ u2)\n}\n</code>\n<|/ a tags=list,r |>\n<| a dscore=2 |>\nMy function checks\
    \ similarity with another list and returns the similarity with the biggest value:\n\
    <code>\nsim <- function(A, B) {\n  inter <- intersect(A,B)\n  \n  if(length(inter)\
    \ == 0)\n    return(0)\n  \n  A <- A[inter]\n  B <- B[inter]\n  \n  ifelse(length(B)\
    \ == 0, sum(A %in% B), length(B)/length(A))\n}\n\nsim(A,B)", "\n    len <- min(length(l1),\
    \ length(l2))\n    c(l1[1:len], l2[1:len])\n}\n</code>\nTo get the first number\
    \ you can do the following:\n<code>\ndf$first_number <- apply(df, 1, function(x)\
    \ min(which(x == min(x))))\n</code>\n<|/ a |>\n<| a tags=min,r,group-by,unique\
    \ dscore=2 |>\nYou can try with dplyr :\n<code>\nlibrary(dplyr)\n\ndf %>%\n  group_by(ID)\
    \ %>%\n  mutate(min_number = min(df$number)) %>%\n  ungroup()\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u1[u1 == l1] <- NA\n  u1[u1 == l2] <- NA\n  return(u1)\n}\n", "\n  \
    \  comb <- as.vector(sort(c(l1[1], l2[1])))\n    i <- 1\n    while (i <= length(comb))\
    \ {\n        x <- comb[i]\n        if (l1[i] == l2[i]) {\n            comb <-\
    \ c(comb, x)\n            i <- i + 1\n        } else if (x < l1[i]) {\n      \
    \      comb <- c(comb, x)\n            i <- i + 1\n        } else if (x > l2[i])\
    \ {\n            comb <- c(comb, x)\n            i <- i + 1\n        } else {\n\
    \            comb <- c(comb, x)\n            i <- i + 1\n        }\n    }\n  \
    \  comb\n}\n</code>\nI haven't tested this against your data, but I think it should\
    \ work.  Here are some test cases:\n<code>\n> common(c(1,2,3), c(3,2,1))\n[1]\
    \ 1 2 3\n> common(c(1,2,3), c(3,2,5))\n[1] 1 2 3\n> common(c(1,2,3), c(3,2,6))\n\
    [1] 1 2 3\n> common(c(1,5,6), c(5,6,1))\n[1] 1 5 6\n> common(c(1,5,6), c(5,6,3))\n\
    [1] 1 5 6\n> common(c(1,5,6), c(5,6,8))\n[1] 1 5 6\n</code>\n<|/ a tags=r,data.table\
    \ |>\n<| a dscore=2 |>\nAnother variation is to convert the first list to a vector\
    \ with unique elements, then use setdiff and intersect to find those elements\
    \ that are common between the two lists. Finally convert the resulting vector\
    \ back to a list using as.list\n<code>\nf1 <- function(l1, l2) {\n   u1 <- unique(unlist(l1))\n\
    \   u2 <- unique(unlist(l2))\n   setdiff(as.list(u1), as.list(u2))\n}\n\nf1(list(a=1,\
    \ b=2), list(a=11, c=1))", "\n  sort.list(\n    sort(sort(sort(intersect(sort(l1),\
    \ sort(l2))), decreasing = TRUE), decreasing = TRUE)\n  )\n}\n</cell>\n<cell>",
  "\n  len1 <- length(l1)\n  len2 <- length(l2)\n  commonElements <- numeric(len1\
    \ + len2)\n  for(i <- seq(len1)) commonElements[i] <- l1[i]\n  for(i <- seq(len2))\
    \ commonElements[len1 + i] <- l2[i]\n  commonElements\n}\n", "\n    sort(union(sort(l1),\
    \ sort(l2)))\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting |>\nYou can use\
    \ a combination of merge and sort, as follows:\n<code>\ndf <- data.frame(\n  a\
    \ = c(1, 2, 3, 4, 5),\n  b = c(5, 6, 3, 2, 1)\n)\n\nmerge(df, df[order(df$a),\
    \ ], by = \"a\")\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIf I have a data frame\
    \ of 2 million rows, would this solution perform well? What are some alternatives?\n\
    <|/ c |>\n<| c |>\nYes, the code above is efficient but slow, see the speed comparison\
    \ below.\n<|/ c |>\n<| a |>\nYou can try:\n<code>\na<-c(1, 4, 3, 34, 653, 2, 5)\n\
    b<-c(5, 7, 1, 5, 9, 653, 121)\n\ndf1 <- data.frame(a, b)\ndf2 <- data.frame(b,\
    \ a)\nmerge(df1, df2)\n</code>\n<|/ a tags=r,sorting dscore=1 |>\n<| a tags=r,sorting\
    \ |>\nOne way is to use setdiff:\n<code>\na <- c(1, 4, 3, 34, 653, 2, 5)\nb <-\
    \ c(5, 7, 1, 5, 9, 653, 121)\n\nsetdiff(a, b)", "\n  if (length(l1) > length(unique(sort(l1))))\n\
    \    l1 <- sort(l1)\n  if (length(l2) > length(unique(sort(l2))))\n    l2 <- sort(l2)\n\
    \  unique(sort(unique(c(l1, l2))))\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis\
    \ answer is not correct. I don't know why, but when I ran it, I got c(1, 3, 5,\
    \ 7, 9, 65, 34, 653, 121, 5, 3, 653) as the common elements. But the correct answer\
    \ is c(2, 3) as two unique numbers in both lists are 2 and 3.\n<|/ c |>\n<| c\
    \ |>\nGood point, I should have mentioned the sort step. I've amended my answer\
    \ to take that into account\n<|/ c |>\n<| c |>\n, if you run my code with the\
    \ input I provided, you get `c(2, 3)` as the common elements.\n<|/ c |>\n<| c\
    \ |>\nI tested it on two lists containing `c(5,3,2)` and `c(3,2)`, and got `c(2,\
    \ 3)` as the common elements, which is not correct. But I got `c(2, 3)` as the\
    \ common elements because when I sort the lists, I get the common elements. So\
    \ I think your answer is correct, just not to the point. I'm curious why you get\
    \ different result from the one I provided. Anyway, thanks for the help :D\n<|/\
    \ c |>\n<| c |>\n, I did say that the correct answer was `c(2, 3)` and that's\
    \ what my code gives you. If you want to see the difference between mine and yours,\
    \ just `sort(c(5,3,2)) == sort(c(3,2))`\n<|/ c |>\n<| a tags=sorting,r |>\nA solution\
    \ using data.table\n<code>\na <- c(5,3,2)\nb <- c(3,2)\n\nlibrary(data.table)\n\
    c(a, b) %>% \n  as.data.table() %>% \n  unique() %>% \n  sort()\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 tags=sorting,r |>\nWe can use intersect\n<code>\n\
    intersect(sort(a), sort(b))", "\n  common1 <- setdiff(unique(l1), unique(l2))\n\
    \  common2 <- setdiff(unique(l2), unique(l1))\n  c(common1, common2)\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for sharing! I thought of writing something similar,\
    \ only using `ifelse` to make sure that the two lists are equal length before\
    \ running `common1` and `common2` but couldn't figure out how to do it. I'll post\
    \ my code here if it works out for me.\n<|/ c |>\n<| a dscore=2 |>\nThis might\
    \ do the trick. Not sure about the efficiency. \n<code>\ncommon <- function(x,y){\n\
    \        common <- which(x == y)\n        common1 <- which(x %in% y[common])\n\
    \        common2 <- which(y %in% x[common])\n\n        return(c(common1,common2))\n\
    }\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work. If there are any values\
    \ that are in `y` and not in `x`, your function will throw an error.\n<|/ c |>\n\
    <| a dscore=2 tags=r |>\nThis seems like an efficient way to do it if your lists\
    \ have equal length:\n<code>\n> set.seed(1)\n> x <- sample(1:10, 10)\n> y <- sample(1:10,\
    \ 10)\n> identical(x,y)\n[1] FALSE\n> x <- sample(1:10, 5)\n> y <- sample(1:10,\
    \ 5)\n> identical(x,y)\n[1] TRUE\n> common <- function(x,y){\n+     common1 <-\
    \ which(x %in% y[common])\n+     common2 <- which(y %in% x[common])\n+     return(c(common1,common2))\n\
    + }\n> common(x,y)\n[1] 1 2\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if\
    \ you have any values that are in `x` but not in `y`.\n<|/ c |>\n<| c |>\n- I\
    \ did not consider that. Thanks. I've updated the answer to take that into account.\n\
    <|/ c |>\n<| a |>\nThis solution works in O(n) and O(m) time. It can be easily\
    \ adapted into other situations (see my other answer for examples).\n<code>\n\
    common <- function(lst1, lst2) {\n  n <- length(lst1)\n  m <- length(lst2)\n \
    \ uncommon.idx <- setdiff(1:m, lst1)\n  uncommon.list1 <- lst1[uncommon.idx]\n\
    \  uncommon.list2 <- lst2[uncommon.idx]\n\n  lists <- ", "\n  common_l1_l2 <-\
    \ function(l1, l2) length(intersect(l1, l2)) / length(l1)\n  common_l1 <- common_l1_l2(l1,\
    \ l2)\n  common_l2 <- common_l1_l2(l2, l1)\n  if (common_l1 < common_l2) common_l1\
    \ else common_l2\n}\n", "\n  l1 <- sort(unique(l1))\n  l2 <- sort(unique(l2))\n\
    \  l1 <- l1[1:length(unique(c(l2, l1)))]\n  l2 <- l2[1:length(unique(c(l1, l2)))]\n\
    \  return(union(l1, l2))\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for the great\
    \ answer, but I think this is not what I'm looking for. \nThe result must be the\
    \ most common element of each of the lists combined and NOT the most common element\
    \ of all lists combined.\n<|/ c |>\n<| c |>\nThank you for the answer, but I think\
    \ this is not what I'm looking for. \nThe result must be the most common element\
    \ of each of the lists combined and NOT the most common element of all lists combined.\
    \ \nI appreciate your efforts to help. \nPlease check my comment above again.\
    \ \nI think your solution is only to find common elements from each list.\n<|/\
    \ c |>\n<| c |>\nNo worries, I got it working in the following way:\n\n`common1\
    \ <- function(l1, l2) {\n  common(sort(unique(l1)), sort(unique(l2)))\n}\n\ncommon2\
    \ <- function(l1, l2) {\n  common1 <- common1(sort(unique(l1)), sort(unique(l2)))\n\
    \  common2 <- common1(sort(unique(l2)), sort(unique(l1)))\n  common1 <- common1[common1\
    \ != common2]\n  return(common1)\n}`\n<|/ c |>\n<| c |>\nThank you for you answer.\
    \ \nI will check it right away and will let you know the result.\n<|/ c |>\n<|\
    \ a |>\nThe function you provided in your comment is very close, but you don't\
    \ need to use two separate functions for this. You can just use a single function\
    \ with nested ifelse statements and use each of the two inputs in each ifelse\
    \ condition. So you could use something like the following which uses mapply and\
    \ an anonymous function. This works if your inputs are all vectors.\n<code>\n\
    common <- function(x) {\n  mapply(function(a, b) {\n    ifelse(a==b, a, b)\n \
    \ }, x, names(x))\n}\n", "\n  commonInd <- intersect(l1, l2)\n  if(length(commonInd)\
    \ > 0) commonInd else l1 %in% l2\n}\n</cell>\n<cell>", "\n  u <- unique(c(l1,\
    \ l2))\n  u[!is.na(u)]\n}\n", "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2,\
    \ l1)))\n  u1[u1 == u2] <- NA\n  u1[is.na(u1)] <- NA\n  u1\n}\n</code>\nThe function\
    \ uses na.locf from the zoo package to fill missing values. In the next step we\
    \ calculate the difference between two consecutive elements in each vector and\
    \ assign NA to the one which is not common between two vectors.\n<code>\nna.locf(diff(c(sort(l1),\
    \ sort(l2))))\n[1]    1 NA    1 NA    1 NA    1\n</code>\n<|/ a |>\n<| c |>\n\
    Nice solution. However, this doesn't preserve the order of elements if there are\
    \ duplicates. The result is `[1] 1 NA  1 NA  1 NA  1`\n<|/ c |>\n<| c |>\n. Good\
    \ catch. One could sort the result afterwards `res[order(res)] <- NA; res`\n<|/\
    \ c |>\n<| c |>\nNice, but you lose the order of the first vector.\n<|/ c |>\n\
    <| a |>\nTry this\n<code>\nlibrary(dplyr)", "\n  # Sort the input lists.\n  l1\
    \ <- sort(l1)\n  l2 <- sort(l2)\n  \n  # Create empty list of unique common elements.\n\
    \  common <- list()\n  \n  # Loop through each element of list1 and see if it\
    \ is also in list2\n  # and add it to the list of common elements.\n  for (i in\
    \ l1) {\n    if (i in l2) {\n      common <- c(common, i)\n    }\n  }\n  \n  #\
    \ Return sorted unique common elements.\n  common <- sort(common)\n  return(common)\n\
    }\n</cell>\n<text>\nAnd now we compute the intersection between the two lists\
    \ we defined above.\n\n\n</text>\n<cell>", "\n  commonElements <- NULL\n  l1 <-\
    \ l1[!is.na(l1)]\n  l2 <- l2[!is.na(l2)]\n  commonElements <- intersect(l1, l2)\n\
    \  return(commonElements)\n}\n", "\n  # Get unique elements, sort them and remove\
    \ duplicates.\n  u <- sort(unique(c(l1, l2)))\n  u <- u[!duplicated(u)]\n  u\n\
    }\n", "\n  u1 <- unique(sort(l1))\n  u2 <- unique(sort(l2))\n  uni <- unique(u1)\n\
    \  common <- intersect(which(uni == u2), which(uni == u1))\n  if(length(common)\
    \ == 0) common <- c(l1, l2)\n  else common\n}\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nYes, I did misspell the function name. Fixed now. Thanks.\n<|/ c |>\n\
    <| c |>\nAh okay, now I got it! I guess you just have to sort the common elements\
    \ before unifying the two lists. Thanks.\n<|/ c |>\n<| c |>\nYes, as you said,\
    \ I should sort the common elements before unification. Thanks again.\n<|/ c |>\n\
    <| a dscore=3 |>\nI came up with this, and thought it might be helpful to someone:\n\
    <code>", "\n  u <- unique(c(l1, l2))\n  sort(unique(u[order(u)]))\n}\n", "\n \
    \ u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nGreat answer! You mentioned that you can sort a list. This makes\
    \ me wonder how you did this. Maybe you can answer http://stackoverflow.com/questions/43962492/how-to-find-common-elements-in-a-list-of-vectors-in-the-same-order\n\
    <|/ c |>\n<| c |>\nThis also works in data.table:\n`dt[, common(val), by=names(dt)]`\n\
    <|/ c |>\n<| c |>\nNice answer! In my opinion it could be even nicer if we had\
    \ something like `common(..., na.rm=TRUE)`\n<|/ c |>\n<| c |>\n, `common(...,\
    \ FUN=mean, na.rm=TRUE)` is pretty neat\n<|/ c |>\n<| c |>\nThis could be vectorized\
    \ with: `intersect(x,y)[!intersect(x, y) %in% y]`\n<|/ c |>\n<| a tags=r |>\n\
    Here's a method that uses intersect() and setdiff():\n<code>\ncommon = function(x,\
    \ y){\n    setdiff(y, intersect(x,y))\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3\
    \ tags=r |>\nHere's a method that uses intersect(x, y) and setdiff():\n<code>\n\
    intersect(x, y)[!intersect(x, y) %in% y]\n</code>\nHere are some examples:\n<code>\n\
    intersect(list(c(1, 2, 3), c(5, 7, 1, 5, 9, 653, 121)), \n          list(c(5,\
    \ 3, 2, 8), c(3, 2)))", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  commons <-\
    \ intersect(u1, u2)\n  return(commons)\n}\n</cell>\n<cell>", "\n  sort(unique(union(l1,\
    \ l2)))\n}\n</cell>\n<text>\nQuestion 8\nCreate a function to determine if two\
    \ strings are anagrams of each other.  If the input is an anagram of each other,\
    \ return TRUE.  Otherwise, return FALSE.\n\n\n</text>\n<cell>", "\n  return(Reduce(intersect,\
    \ lapply(l1, function(x) names(which(c(l1, l2) %in% x)))))\n}\n</code>\nThis solution\
    \ does use an intermediate result from the Reduce call which I haven't bothered\
    \ to check what it actually contains, but I don't see any way to avoid that. \
    \ I believe the intermediate result should be the sorted unique elements from\
    \ each of the l1 and l2 arguments, but the sorting is inevitable.  You can check\
    \ that for yourself by running this code and looking at the intermediate result\
    \ from Reduce:\n<code>\n> Reduce(intersect, lapply(c(1, 4, 3, 34, 653, 2, 5),\
    \ function(x) names(which(c(1, 4, 3, 34, 653, 2, 5) %in% x))), simplify = FALSE)\n\
    [[1]]\n[1] \"1\" \"4\" \"3\" \"5\" \n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like\
    \ your first solution. Do you know if this also handles non-unique items well?\n\
    <|/ c |>\n<| c |>\nI do now. Thanks.\n<|/ c |>\n<| a dscore=2 |>\nHere's a way\
    \ with base R. I think it's pretty straightforward but it relies on having a list\
    \ of all the common items first:\n<code>\nx <- c(1, 4, 3, 34, 653, 2, 5)\ny <-\
    \ c(5, 7, 1, 5, 9, 653, 121)\n", "\n  sort(sort(unique(c(l1, l2))))\n}\n", "\n\
    \  s1 <- sort(l1)\n  s2 <- sort(l2)\n  i <- 0\n  while(i <= length(s1) && i <=\
    \ length(s2)) {\n    if (s1[i] == s2[i]) {\n      i <- i + 1\n      next\n   \
    \ } else if (s1[i] > s2[i]) {\n      break\n    } else {\n      i <- i + 1\n \
    \   }\n  }\n  unlist(unique(s1[i : (length(s1)-i)]))\n}\n", "\n    common <- sort(sort(unique(c(l1,\
    \ l2))))\n    common\n}\n", "\n    indices <- which(mapply(is.element, l1, l2))\n\
    \    sorted <- sort(c(l1[indices], l2[indices]))\n    unique(c(sorted[!duplicated(sorted)],\
    \ sorted[duplicated(sorted)]))\n}\n</code>\n<|/ a tags=list,r,unique |>\n<| c\
    \ |>\nThis seems to work but how could I make use of this to sort out my list\
    \ of lists? I am still stuck on how to do this properly.\n<|/ c |>\n<| c |>\n\
    If your list of lists has the same length for each list then you should be able\
    \ to use the example above.  If they do not, then this solution doesn't work because\
    \ it will only return a list with the first element from each list.  Maybe you\
    \ could post a more specific example of your problem.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI think I've come up with a solution which I believe is fairly efficient.\
    \ I'm posting it in case others have the same problem and want to know about a\
    \ more efficient way of doing it.\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  unique(c(u1[u1 != u2], u2[u2 != u1]))\n}\n</code>\n\
    Then the result can be obtained as follows:\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=3\
    \ tags=r,list |>\n<| c |>\nA very interesting solution.  I was thinking about\
    \ creating a function that will do this for me but you did it much faster.\n<|/\
    \ c |>\n<| c |>\nThis solution was very useful to me.  I took some time to understand\
    \ how the function is working.  I think it would be helpful to somebody if they\
    \ saw the code and made a few edits to explain.\n<|/ c |>\n<| c |>\nThank you\
    \ so much for posting this solution -- it works great!\n<|/ c |>\n<| c |>\nThis\
    \ is an awesome solution, but in my case, the order in which each element appears\
    \ doesn't matter.  So I'm able to just do `common(list1,list2)` and have it return\
    \ a vector of the elements present in both lists.\n<|/ c |>\n<| a tags=r,list\
    \ |>\n<code>\nx <- c(1,2,3,4,5,6,7,8,9,10)\ny <- c(2,4,6,8,10,12,14,16,18,20)\n\
    \nlist1 <- list()\nlist1[[1]] <- x\nlist1[[2]] <- y\n\nlist2 <- list()\nlist2[[1]]\
    \ <- y\nlist2[[2]] <- x\n\nz <- intersect(list1,list2)\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nthis won't work if list1 has duplicates or list2 has duplicates\n\
    <|/ c |>\n<| a tags=r,list |>\nIf you're not concerned about order or duplicates,\
    \ then this will work:\n<code>\na <- list(1,2,3,4,5)\nb <- list(2,3,4,5,6)\nintersect(names(a),names(b))\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\na <- list(1,2,3,4,5)\nb <- list(2,3,4,5,6)\n\
    intersect(names(a),names(b))\n\n[1] \"1\" \"2\" \"3\"\n</code>\n<|/ a dscore=2\
    \ tags=r,list |>\n<| a dscore=2 tags=r,list |>\nI wrote a function for this purpose:\n\
    <code>", "\n  if (length(l1) != length(l2)) stop(\"Unequal length lists\")\n \
    \ setdiff(l1, l2)\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=2 |>\nI wrote a package\
    \ that uses hash tables to do this for vectors of different lengths.\n<code>\n\
    install.packages(\"hash\")\nlibrary(hash)\n\nvec <- c(4, 3, 2)\nh <- hash(vec)\n\
    h[\"2\"]", "\n  # If the lists are of unequal length, return a list of common\
    \ elements.\n  if(length(l1) != length(l2))\n    commons <- intersect(l1, l2)\n\
    \  else\n    commons <- l1[[1]]\n  # Return the common elements sorted by their\
    \ position in sorted lists.\n  commons[order(order(commons), which(commons > l1[[2]]))]\n\
    }\n", "\n  sort(unique(c(l1, l2)))\n}\n</code>\n<|/ a tags=sorting,r,list dscore=3\
    \ |>\n<| a dscore=3 |>\nIf all the elements in the list are of the same type,\
    \ you can do \n<code>\nsort(unlist(lst))\n</code>\nIf they are not the same, you\
    \ can do\n<code>\nsort(unlist(lapply(lst, as.character)))\n</code>\n<|/ a tags=sorting,r,list\
    \ |>\n<| c |>\n`as.character` will convert any list item to a character.\n<|/\
    \ c |>\n<| a |>\nAnother option is to reorder the elements of the list with order()\
    \ and then reorder the list with list().  Here is a reproducible example:\n<code>\n\
    library(tidyverse)\n\nlst <- list(\n  c(4, 3, 5, 1, 2), \n  c(6, 9, 7, 1, 3),\
    \ \n  c(3, 2, 1), \n  c(4, 5, 6)\n)\n", "\n  # Find length of longest list in\
    \ l1 and l2 before running loop\n  # so as to save comparisons\n  len_l1 <- length(l1)\n\
    \  len_l2 <- length(l2)\n  # initialize a result list with elements from l1 and\
    \ l2\n  # with that index matching the indices from each input\n  result <- integer(len_l1)\n\
    \  for(idx in seq_len(len_l1)) result[[idx]] <- l1[[idx]]\n  for(idx in seq_len(len_l2))\
    \ result[[idx]] <- l2[[idx]]\n  # Sort result list so that all items in common\
    \ are at the end\n  # and remove duplicates\n  result <- result[order(result)]\n\
    \  result <- result[!duplicated(result)]\n  return(result)\n}\n</code>\n<|/ a\
    \ tags=unique,r,list dscore=2 |>\n<| a |>\n<code>\nset.seed(1)\nx1 <- rnorm(3)\n\
    x2 <- rnorm(3)\nx3 <- rnorm(3)\nlist1 <- list(x1,x2,x3)\nnames(list1) <- c(\"\
    a\",\"b\",\"c\")\nx4 <- rnorm(3)\nx5 <- rnorm(3)\nx6 <- rnorm(3)\nlist2 <- list(x4,x5,x6)\n\
    names(list2) <- c(\"d\",\"e\",\"f\")\n", "\n  l1 <- as.vector(l1)\n  l2 <- as.vector(l2)\n\
    \  idx <- sort(unique(c(l1, l2)))\n  l1[l1 == l2] <- NA\n  l1[is.na(l1)] <- NA\n\
    \  l1[!is.na(l1)] <- idx[!is.na(l1)]\n  l2[l2 == l1] <- NA\n  l2[is.na(l2)] <-\
    \ NA\n  l2[!is.na(l2)] <- idx[!is.na(l2)]\n  common(idx)\n}\n</cell>\n<text>\n\
    Example: Common elements in two lists\n\n</text>\n<cell>\na <- c(\"a\", \"b\"\
    , \"c\", \"d\", \"e\")\nb <- c(\"c\", \"d\", \"e\", \"f\", \"g\")\ncommon(unique(a),\
    \ unique(b))\n</cell>\n<text>\nExample: Common elements in lists of lists.\n(Note:\
    \ If your list elements are lists, you can just use apply(x, 2, common)\nto apply\
    \ the common function to each element. The function will use the common function\
    \ defined above to test each element.)\n\n\n</text>\n<cell>\nlist1 <- list(a =\
    \ c(\"a\", \"b\", \"c\", \"d\", \"e\"), \n              b = c(\"c\", \"d\", \"\
    e\", \"f\", \"g\"), \n              c = c(\"c\", \"d\", \"e\", \"f\", \"g\"),\
    \ \n              d = c(\"c\", \"d\", \"e\", \"f\", \"g\"))\nlist2 <- list(a =\
    \ c(\"c\", \"d\", \"e\", \"f\", \"g\"), \n              b = c(\"c\", \"d\", \"\
    e\", \"f\", \"g\"), \n              c = c(\"c\", \"d\", \"e\", \"f\", \"g\"),\
    \ \n              d = c(\"c\", \"d\", \"e\", \"f\", \"g\"))\ncommon(list1, list2)\n\
    </cell>\n<text>\nExample: Common elements in lists containing lists.\n(Note: If\
    \ your list elements are lists, you can just use apply(x, 2, common)\nto apply\
    \ the common function to each element. The function will use the common function\
    \ defined above to test each element.)\n\n\n</text>\n<cell>\nlist1 <- list(a =\
    \ list(\"a\", \"b\", \"c\", \"d\", \"e\"), \n              b = list(\"c\", \"\
    d\", \"e\", \"f\", \"g\"), \n              c = list(\"c\", \"d\", \"e\", \"f\"\
    , \"g\"), \n              d = list(\"c\", \"d\", \"e\", \"f\", \"g\"))\nlist2\
    \ <- list(a = list(\"c\", \"d\", \"e\", \"f\", \"g\"), \n              b = list(\"\
    c\", \"d\", \"e\", \"f\", \"g\"), \n              c = list(\"c\", \"d\", \"e\"\
    , \"f\", \"g\"), \n              d = list(\"c\", \"d\", \"e\", \"f\", \"g\"))\n",
  "\n  tmp <- intersect(l1, l2)\n  if (length(tmp) == 0) {\n    return(NULL)\n  }\n\
    \  else {\n    x <- sort(c(l1, tmp))\n    y <- sort(c(l2, tmp))\n    length(which(x\
    \ %in% y)) / (length(which(x %in% y)))\n  }\n}\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nI did not realize this function existed in base R. Thanks!\n<|/ c |>\n<|\
    \ c |>\nHaving said that, I'm getting an odd number when using `common(c(1,4,3,34,653,2,5),c(5,7,1,5,9,653,121))`.\
    \ `common(c(1,4,3,34,653,2,5),c(3,2))` returns 0.74, but `common(c(1,4,3,34,653,2,5),c(7,1,5,9,653,121))`\
    \ returns 0.76. `common(c(1,4,3,34,653,2,5),c(2,3))` returns 0.66, and so on...\n\
    <|/ c |>\n<| c |>\nThe `common` function was written by Jared Burton. He also\
    \ wrote the R Cookbook for `common` which he calls \"Intersection by Elements\"\
    . His book also has a chapter on how to get the intersection.\n<|/ c |>\n<| c\
    \ |>\nThanks so much for the help.\n<|/ c |>\n<| c |>\n`common(c(1,4,3,34,653,2,5),c(7,1,5,9,653,121))`\
    \ returns `c(5, 7)` and this should be `c(5, 653)` based on your example.\n<|/\
    \ c |>\n<| a dscore=5 |>\nHere is a different approach which might work better\
    \ for larger data sets. I'm using the data.table package. \n<code>\nlibrary(data.table)\n\
    dt1 <- data.table(a = c(2,3,4,1,5,6,2))\ndt2 <- data.table(a = c(1,4,3,5,6,1,2))\n\
    dt1[dt2,\n    list(unique.count = uniqueN(a)), \n    on = .(a), \n    .SDcols\
    \ = c(\"a\")]\n   a unique.count\n1: 1            2\n2: 2            1\n3: 3 \
    \           1\n4: 4            1\n5: 5            1\n6: 6            1\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nIt works perfectly for my purpose, but a small clarification:\
    \ It works because it returns the number of *unique* elements in each of the groups\
    \ in both ", "\n    sort.list(as.list(unique(c(l1, l2))))\n}\n</code>\n<|/ a tags=r\
    \ dscore=3 |>\n<| c |>\nI thought of this solution as well, but I decided that\
    \ for my purposes, using `intersect` would result in two `list` objects with slightly\
    \ different properties, namely that each element was converted to a vector, and\
    \ that the order of the elements was different to the result of `intersect` from\
    \ my original question (which would have resulted in a `list` object with two\
    \ `vector` objects and a `character` `character` vector).\n<|/ c |>\n<| c |>\n\
    The output from `intersect` would be the union of the two lists. `unique` will\
    \ remove the duplicates. `as.list` is needed to convert the result from `intersect`\
    \ to the desired `list` output.\n<|/ c |>\n<| c |>\nAh, sorry, I misunderstood\
    \ you earlier. I'm sure this would have worked for me, but I decided to go with\
    \ Josh's solution, since his was the clearest to me (with my limited R experience).\n\
    <|/ c |>\n<| a |>\nYou can simply use setdiff function:\n<code>\nsetdiff(list1,\
    \ list2)\n</code>\n<|/ a dscore=3 tags=r |>\n<| a |>\nHere is a base R solution\n\
    <code>\ncommonElements <- function(lst1, lst2) {\n  l <- intersect(lst1, lst2)\n\
    \  l2 <- intersect(lst2, lst1)\n  sapply(c(l, l2), unique)\n}\n</code>\n<|/ a\
    \ tags=r dscore=2 |>\n<| a dscore=2 |>\n<code>\nlibrary(dplyr)\nlist1 <- c(\"\
    a\", \"b\", \"c\")\nlist2 <- c(\"a\", \"b\", \"d\", \"e\")\n\nlist1_list <- list1\
    \ %>% \n  map(~list(.))\nlist2_list <- list2 %>% \n  map(~list(.))\n\nlist1_list\
    \ %>%\n  unnest %>% \n  inner_join(list2_list) %>% \n  select(matches(\"^a.*b.*\"\
    ))\n\n  matches(\"^a.*b.*\") ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n", "\n    common(sort(unique(l1)), sort(unique(l2)))\n\
    }\n", "\n  # Return sorted unique common elements for two lists.\n  len1 <- length(l1)\n\
    \  len2 <- length(l2)\n  lenMin <- min(len1, len2)\n  lenMax <- max(len1, len2)\n\
    \  l1 <- l1[seq_len(lenMin)]\n  l2 <- l2[seq_len(lenMin)]\n  common <- l1\n  for(i\
    \ in 1:(lenMax - lenMin)) {\n    for(j in (i+1):lenMax) {\n      if(l1[[i]] ==\
    \ l2[[j]]) {\n        common <- c(common, l1[[i]])\n        break\n      }\n \
    \   }\n  }\n  return(common)\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,python,r,c++\
    \ |>\nThe question is about the fastest algorithm to find common elements in two\
    \ lists (in O(n)). Below is my solution in R, which is a bit different, but still\
    \ fast enough. Although I used a set and a binary search to find the common elements.\n\
    <code>\nlibrary(tidyverse)\n\nfind_common_elements <- function(x, y) {\n  n <-\
    \ length(x)\n  x <- unique(x)\n  y <- unique(y)\n  common <- setNames(integer(0),\
    \ n)\n  for (i in seq_len(n)) {\n    common <- common %l% y\n    x <- setdiff(y,\
    \ common)\n    y <- setdiff(common, x)\n  }\n  common\n}\n\nfind_common_elements(c(2,\
    \ 4, 3, 2, 5), c(6, 3, 8, 2, 6))", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  inter <- u1 %in% u2\n  if(any(inter)) {\n    return(u1[inter])\n  }\
    \ else {\n    return(NULL)\n  }\n}\n</code>\n<|/ a tags=r |>\n<| a |>\nHow about\
    \ this one using sort and the function match\n<code>\nsort(sort(l), match(l, sort(c(l1,\
    \ l2))))\n</code>\n<|/ a tags=r dscore=1 |>\n<| a |>\n<code>\nsl <- sort(c(l1,\
    \ l2))\nsl <- sl[sl %in% c(l1, l2)] #remove duplicates\nsl <- sl[sl %in% c(l2,\
    \ l1)] #remove duplicates\n</code>\n<|/ a tags=r dscore=1 |>\n<| a tags=r |>\n\
    <code>\nunique(c(sort(c(l1, l2)), sort(c(l2, l1))))\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis is just a variation on 's answer\n<|/ c |>\n<| a dscore=0 |>\nHere\
    \ is a base R solution:\n<code>\nu <- unique(c(l1, l2))\nv <- unique(c(l2, l1))\n\
    u %in% v", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  common_index\
    \ <- intersect(c(which(u1 == u2), which(u1 != u2)))\n  if(length(common_index)\
    \ == 0) return(NULL)\n  common(c(which(u1 == u2), which(u1 != u2))[common_index])\n\
    }\n", "\n  sort(union(l1, l2))\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is\
    \ awesome!  I wish I'd seen it before I wrote my own, because it didn't work that\
    \ well for me when I wanted a comparison function that would go from high to low\
    \ instead of low to high.  I ended up writing an `order` function that basically\
    \ does `sort(union(l1,l2))`, but with a `rev` on both sides.  Thanks!\n<|/ c |>\n\
    <| c |>\nI added a `sort_rev` function that does what you suggested.\n<|/ c |>\n\
    <| c |>\nI was having problems with `sort_rev`.  It was returning `list` and `list`\
    \ was causing problems.  If you put `unlist(sort(union(l1, l2)))` instead it works\
    \ great and avoids the need for `rev`.  Also `sort` works with `list` objects\
    \ and `union` works with vectors.\n<|/ c |>\n<| c |>\nAh, thanks for pointing\
    \ that out.  I fixed my answer.  I'll also make `sort_rev` work for `list`s.\n\
    <|/ c |>\n<| c |>\nAwesome solution. I was getting an error with the `sort` and\
    \ `union` functions when I was trying to put them in a function. I had to put\
    \ it in a list. `lapply(list1, function(x) sort(union(x,list2)))`\n<|/ c |>\n\
    <| a |>\nYou can use the merge function:\n<code>\nmerge(list1, list2)\n</code>\n\
    <|/ a tags=sorting,r dscore=5 |>\n<| c |>\n+1 because this is quicker and you\
    \ don't have to merge anything\n<|/ c |>\n<| a |>\nIf you want a function that\
    \ gives you a sorted unique set of values from two vectors, try this:\n<code>\n\
    unique_sorted_union_of <- function(x, y) {\n    sort(union(x,y))\n}\n</code>\n\
    Example usage:\n<code>\nx <- c(4,5,7,9,14,15,16,18,19,23,24)\ny <- c(1,4,6,8,12,14,15,20,21,22,25,26,27,28,29)\n\
    unique_sorted_union_of(x, y)\n\n[1]  1  2 15 16 17 18 19 20 21 22 23 24 25 26\n\
    </code>\n<|/ a tags=sorting,r dscore=5 |>\n<| a dscore=4 |>\nI made a function\
    \ that does what I want:\n<code>\nsort_unique_common <- function(l1, l2) {\n \
    \ sort(union(l1,l2))\n}\n</code>\nIt returns an object that ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nYes, this does work. However, the result is not quite what I was\
    \ looking for. I'm interested in getting a sorted unique set with duplicates as\
    \ well.\n<|/ c |>\n<| a dscore=0 |>\nUsing igraph, it is very easy to find the\
    \ longest common subgraph within 2 sets. Here, I've included a function that will\
    \ print out the nodes that are shared between the 2 input sets, as well as how\
    \ many common nodes there are in each of the two input sets. \n<code>\nlibrary(igraph)\n\
    \nshared_nodes <- function(set1, set2) {\n  g <- graph.ring(length(set1), length(set2))\n\
    \n  set.1 <- set1\n  set.2 <- set2\n  set.1 <- induced_subgraph(g, set.1)\n  set.2\
    \ <- induced_subgraph(g, set.2)\n\n  common.names <- set.1[set.2]\n  nodes <-\
    \ length(intersect(set1, set2))\n\n  return(list(common.names = common.names,\
    \ nodes = nodes))\n}\n\nset.1 <- c(1, 4, 3, 34, 653, 2, 5)\nset.2 <- c(5, 7, 1,\
    \ 5, 9, 653, 121)\n\nshared_nodes(set.1, set.2)\n\ncommon.names\nnodes\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  intersect(c(u1, u2),\
    \ sort(unique(c(u2, u1))))\n}\n", "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <-\
    \ sort(unique(c(l2, l1)))\n  common <- u1[u2 %in% u1]\n  if (length(common) >\
    \ 1) common else NULL\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is a nice\
    \ approach, though it has a bug. It won't work if the same element appears in\
    \ both vectors. E.g. common(c(1, 2, 3), c(3, 2)) returns only c(1, 3) rather than\
    \ c(1, 2, 3).\n<|/ c |>\n<| c |>\nFixed, by only comparing against those that\
    \ are in the first set. Thanks.\n<|/ c |>\n<| c |>\nIt might be worth pointing\
    \ out that `setdiff` will give the unique elements in `l1` that are not in `l2`,\
    \ not `l1` that are not in `l2`. But that's easily corrected with a bit of code\
    \ `setdiff(l1, l2) %in% l1`, which will do `setdiff(l1, l2)`, then compare it\
    \ to the elements of `l1`.\n<|/ c |>\n<| c |>\nThanks for the solution. Is it\
    \ possible to achieve this without using the `setdiff` function? If not then I\
    \ will accept your answer as the solution.\n<|/ c |>\n<| c |>\nI posted another\
    \ solution below that doesn't use the `setdiff` function, but it relies on sorting\
    \ the vectors and then finding adjacent pairs of common elements. It's not very\
    \ efficient.\n<|/ c |>\n<| a tags=r,set,algorithm dscore=5 |>\nYou can implement\
    \ a very efficient solution without using sort. See my solution below:\n<code>\n\
    common <- function(l1,l2){\n    unique(c(l1, l2))\n    stopifnot(length(l1) >\
    \ length(l2))\n    idx <- unlist(lapply(seq_along(l1), function(i){\n        i\
    \ <- min(i:length(l2))\n        if(l1[i] > l2[i]) i <- length(l1)-i\n        i\n\
    \    }))\n    i <- min(idx:length(l2))\n    i <- i + seq_along(l1) - idx\n   \
    \ l1[seq(i)]\n}\n</code>\nHere are the benchmarks:\n<code>\nlibrary(microbenchmark)\n\
    \nn <- 1e6\nv1 <- sample(n)\nv2 <- sample(n)\n\nf1 <- function() common(v1,v2)\n\
    f2 <- function() common(v2,v1)\nf3 <- function() common(v1,v1)\nf4 <- function()\
    \ common(v1,v2)\n\nf5 <- function() {\n    u1 <- ", "\n  sort(unique(c(l1, l2)))\n\
    }\n", "\n  # First check if both are empty.\n  if (is.null(l1) && is.null(l2))\
    \ {\n    return(NULL)\n  }\n  # Both are non-empty so compare two vectors.\n \
    \ if (is.null(l1)) {\n    return(l2)\n  }\n  if (is.null(l2)) {\n    return(l1)\n\
    \  }\n  # Check if vectors are of different length.\n  if (length(l1) != length(l2))\
    \ {\n    return(NULL)\n  }\n  # If vectors are of same length check element-wise.\n\
    \  commonElements <- function(x, y) {\n    common <- unlist(lapply(seq_along(x),\
    \ function(i)\n      identical(x[i], y[i])))\n    if (length(common) != 0) {\n\
    \      return(common)\n    }\n  }\n  return(apply(cbind(l1, l2), 1, commonElements))\n\
    }\n", "\n  commonInd <- which(cumsum(c(TRUE, l1 != l2)) == length(l1) + 1)\n \
    \ intersect(sort(l1[na.omit(commonInd)]), sort(l2[na.omit(commonInd)]))\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nSorry for the delay in responding, I was working on\
    \ another project and didn't have time to try this. This worked really well though\
    \ and I learned a lot about `R` thanks to all the answers here.\n<|/ c |>\n<|\
    \ a dscore=2 tags=r,performance,algorithm,mergesort |>\nI hope this helps.\n<code>",
  "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  common1 <- intersect(u1, u2)\n  common2\
    \ <- intersect(u2, u1)\n  common <- union(l1, l2)\n  common <- common[!(common\
    \ %in% c(common1, common2))]\n  return(common)\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
