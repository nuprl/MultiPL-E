name: HumanEval_161_solve
language: r
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve('1234')\n# '4321'\n# >>> solve('ab')\n# 'AB'\n\
  # >>> solve('#a@C')\n# '#A@c'\nsolve <- function(s) {"
tests: "test_humaneval <- function() {\ncandidate <- solve\n    if(!identical(candidate('AsDf'),\
  \ 'aSdF')){quit('no', 1)}\n    if(!identical(candidate('1234'), '4321')){quit('no',\
  \ 1)}\n    if(!identical(candidate('ab'), 'AB')){quit('no', 1)}\n    if(!identical(candidate('#a@C'),\
  \ '#A@c')){quit('no', 1)}\n    if(!identical(candidate('#AsdfW^45'), '#aSDFw^45')){quit('no',\
  \ 1)}\n    if(!identical(candidate('#6@2'), '2@6#')){quit('no', 1)}\n    if(!identical(candidate('#$a^D'),\
  \ '#$A^d')){quit('no', 1)}\n    if(!identical(candidate('#ccc'), '#CCC')){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  \n  s <- trimws(gsub(\"^[ \\t\\n\\r]+\", \"\", s))\n  s <- gsub(\"\
    [ \\t\\n\\r]+$\", \"\", s)\n  \n  s <- toupper(s)\n  \n  s <- substr(s, 1, 1)\
    \ # get rid of first letter\n  \n  \n  if(is.na(grepl(\"^[a-z]+$\", s))) {\n \
    \   \n    s <- sapply(s, toupper) # convert everything to upper\n    \n  }\n \
    \ \n  if(grepl(\"^[a-z]+$\", s)) {\n    \n    s <- tolower(s) # convert everything\
    \ to lower\n    \n  }\n  \n  \n  \n  return(s) \n}\n", "\n    s <- toupper(s)\n\
    \    charToRawVector(sub(\"[a-zA-Z]\", \n           function(x) c(tolower(x),\
    \ \"\\\\U\", \"\\\\l\"), \n           s)) %>% unlist\n}\n</cell>\n<cell>\nsolve('ab')\n\
    </cell>\n<text>\nExercise 2.7\n\n</text>\n<text>\nImplement the function charToRawVector\
    \ that converts a vector of characters into a vector of raw bytes.\n\n\n</text>\n\
    <cell>\ncharToRawVector <- function(x) {\n    x <- as.vector(x)\n    x <- iconv(x,\
    \ from=\"UTF-8\", to=\"UTF-16LE\")\n    x <- t(stringi::stri_extract_all_regex(x,\
    \ \"..\"))\n    return(x)\n}\n</cell>\n<cell>\ncharToRawVector('ab')\n</cell>\n\
    <text>\nExercise 2.8\n\n</text>\n<text>\nImplement the function wordToRawVector\
    \ that converts a vector of words into a vector of raw bytes.\n\n\n</text>\n<cell>\n\
    wordToRawVector <- function(x) {\n    x <- as.vector(x)\n    x <- iconv(x, from=\"\
    UTF-8\", to=\"UTF-16LE\")\n    x <- t(stringi::stri_extract_all_regex(x, \"..\"\
    ))\n    x <- t(stringi::stri_extract_all_regex(x, \"[^[:alnum:]]\"))\n    return(x)\n\
    }\n</cell>\n<cell>\nwordToRawVector('ab')\n</cell>\n<text>\nExercise 2.9\n\n</text>\n\
    <text>\nImplement the function rawToCharVector that converts a vector of raw bytes\
    \ into a vector of characters.\n\n\n</text>\n<cell>\nrawToCharVector <- function(x)\
    \ {\n    x <- as.vector(x)\n    x <- iconv(x, to=\"UTF-8\", from=\"UTF-16LE\"\
    )\n    x <- t(stringi::stri_extract_all_regex(x, \"..\"))\n    return(x)\n}\n\
    </cell>\n<cell>\nrawToCharVector(rawToCharVector(rawToCharVector(rawToCharVector('ab'))))\n\
    </cell>\n<text>\nExercise 2.10\n\n</text>\n<text>\nImplement the function rawToWordVector\
    \ that converts a vector of raw bytes into a vector of words.\n\n\n</text>\n<cell>\n\
    rawToWordVector <- function(x) {\n    x <- as.vector(x)\n    x <- iconv(x, to=\"\
    UTF-8\", from=\"UTF-16LE\")\n    x <- t(stringi::stri_extract_all_regex(x, \"\
    [^[:alnum:]]\"))\n    ", "\n    \n    t <- strsplit(s, \"\")[[1]]\n    if (nchar(t)\
    \ == 0)\n        t <- \"a\"\n    \n    if (nchar(t) == 0)\n        t <- \"a\"\n\
    \    \n    t <- toupper(t)\n    t <- gsub(\" \", \"\", t)\n    t <- strsplit(t,\
    \ \"\")[[1]]\n    \n    if (nchar(t) == 0)\n        t <- \"a\"\n    \n    if (nchar(t)\
    \ == 0)\n        t <- \"a\"\n    \n    t <- toupper(t)\n    t <- gsub(\" \", \"\
    \", t)\n    t <- strsplit(t, \"\")[[1]]\n    \n    if (nchar(t) == 0)\n      \
    \  t <- \"a\"\n    \n    if (nchar(t) == 0)\n        t <- \"a\"\n    \n    t <-\
    \ toupper(t)\n    t <- gsub(\" \", \"\", t)\n    t <- strsplit(t, \"\")[[1]]\n\
    \    \n    if (nchar(t) == 0)\n        t <- \"a\"\n    \n    if (nchar(t) == 0)\n\
    \        t <- \"a\"\n    \n    t <- toupper(t)\n    t <- gsub(\" \", \"\", t)\n\
    \    t <- strsplit(t, \"\")[[1]]\n    \n    if (nchar(t) == 0)\n        t <- \"\
    a\"\n    \n    if (nchar(t) == 0)\n        t <- \"a\"\n    \n    t <- toupper(t)\n\
    \    t <- gsub(\" \", \"\", t)\n    t <- strsplit(t, \"\")[[1]]\n    \n    if\
    \ (nchar(t) == 0)\n        t <- \"a\"\n    \n    if (nchar(t) == 0)\n        t\
    \ <- \"a\"\n    \n    t <- toupper(t)\n    t <- gsub(\" \", \"\", t)\n    t <-\
    \ strsplit(t, \"\")[[1]]\n    \n    if (nchar(t) == 0)\n        t <- \"a\"\n \
    \   \n    if (nchar(t) == 0)\n        t <- \"a\"\n    \n    t <- toupper(t)\n\
    \    t <- gsub(\" \", \"\", t)\n    t <- strsplit(t, \"\")[[1]]\n    \n    if\
    \ (nchar(t) == 0)\n        t <- \"a\"\n    \n    if (nchar(t) == 0)\n        t\
    \ <- \"a\"\n    \n    t <- toupper(t)\n    t <- gsub(\" \", \"\", t)\n    t <-\
    \ strsplit(t, \"\")[[1]]\n    \n    if (nchar(t) == 0)\n        t <- \"a\"\n \
    \   \n    if (nchar(t) == 0)\n        t <- \"a\"", "\n  s <- gsub('^[a-z]+', '',\
    \ s)\n  sapply(s, toupper)\n}\n", "\n    if(length(s) == 0) return(s)\n    for(i\
    \ in 1:length(s)){\n      if(grepl(toupper(s[i]), tolower(s))) {\n          s\
    \ <- toupper(substring(s, i, i + 1))\n      }else{\n          s <- tolower(substring(s,\
    \ i, i + 1))\n      }\n    }\n    return(s)\n}\n", "\n  gsub(\" \", \"\", s) \n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy not `gsub(\" \", \"\", s)`? Just to\
    \ be explicit. Also, why not `gsub(\" \", \"\", s, fixed = TRUE)`?\n<|/ c |>\n\
    <| c |>\nAh, okay. I didn't know about `fixed`.\n<|/ c |>\n<| a dscore=0 tags=r\
    \ |>\nThis solution uses gsub to remove spaces and then use toupper and tolower\
    \ to convert the character to uppercase and lowercase. This is the fastest solution\
    \ I found:\n<code>\nsolve(s) {\n    s <- gsub(\" \", \"\", s)\n    s <- toupper(tolower(s))\n\
    \    s\n}\n</code>\n<|/ a |>\n<| a |>\nHere is a solution using stringr package\
    \ to perform string manipulation functions. It also removes the unnecessary characters\
    \ from the character vector:\n<code>\nlibrary(stringr)\n\nsolve <- function(s)\
    \ {\n  s <- str_extract(s, pattern = \"[a-z]\")\n  if(length(s)==0){\n    s <-\
    \ str_extract(s, pattern = \"[A-Z]\")\n  }\n  s\n}\n\nsolve(\"1234\")\n[1] \"\
    4321\"\n</code>\n<|/ a dscore=0 tags=r |>\n<| a |>\n<code>\nlibrary(dplyr)\nlibrary(stringr)",
  "\n  s <- tolower(s)\n  s <- gsub('[[:alpha:]]+', '', s)\n  s <- toupper(s)\n  return(s)\n\
    }\nsolve('ab')\nsolve('ab#')\nsolve('1234')\nsolve(paste0('a',\"b\"))\nsolve(paste0('a',\
    \ \"B\", c('c', 'd')))\nsolve(paste0('a', \"B\", c('C', 'd')))\n\n</cell>\n<text>\n\
    2.5 Test your code\nRun the cell below to test your code.\n\nA note about testing\
    \ your code: Basically, you just have to make sure that the code cells below will\
    \ give the right answer. Most of the time you should be able to run your code\
    \ without changing anything.\n\nTo test if your code is correct, select 'File'\
    \ in the menu on the left and click Run All.\n\nNote: If your code does not produce\
    \ any output, the code cell will output an empty space when run.\n\n\n</text>\n\
    <cell>", "\n    if(length(s)==0)\n       return(s)\n\n    if(length(gregexpr(\"\
    [a-zA-Z]\", s)[[1]])==0) {\n        sb <- strsplit(s, \"\")[[1]]\n        sb <-\
    \ sb[sapply(sb, function(x) substr(x, 1,1)=='a')]\n        paste0(sb, collapse=\"\
    \")\n    }\n    else {\n        sb <- strsplit(s, \"\")[[1]]\n        sb <- sb[sapply(sb,\
    \ function(x) substr(x, 1,1)=='a')]\n        paste0(toupper(sb), collapse=\"\"\
    )\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis solution works\
    \ for both upper- and lowercase letters, and handles empty strings as well.\n\
    <code>\nlibrary(stringi)\n\nmyReverse <- function(s){\n   s <- stri_replace_all_fixed(s,\
    \ '\\\\b', stri_replace_all_fixed(stri_trans_totitle(stri_trans_tolower(s)), '\\\
    \\b', \"\"), perl=TRUE)\n   stri_replace_all_fixed(s, '\\\\w', stri_replace_all_fixed(stri_trans_totitle(stri_trans_toupper(s)),\
    \ '\\\\w', \"\"), perl=TRUE)\n}\n</code>\n<|/ a tags=string,r |>\n<| a |>\nI know\
    \ this is old, but I think it's important to note that this will only work with\
    \ ASCII, so it won't work with extended UTF-8 letters such as \u0107\u0111\u017E\
    \u0159\u0161\u017E etc.\n<code>\nrev_string <- function(string){\n  str <- unlist(strsplit(string,\
    \ \"\"))\n  rev_str <- c(str[which(str <- \"A\")],\n               str[which(str\
    \ <- \"a\")],\n               str[which(str <- \"Aa\")],\n               str[which(str\
    \ <- \"Aaa\")],\n               str[which(str <- \"Aaaaa\")],\n              \
    \ str[which(str <- \"Aaaaaa\")],\n               str[which(str <- \"Aaaaaaa\"\
    )],\n               str[which(str <- \"Aaaaaaaa\")],\n               str[which(str\
    \ <- \"Aaaaaaaaa\")],\n               str[which(str <- \"Aaaaaaaaab\")],\n   \
    \            str[which(str <- \"Aaaaaaaaac\")],\n               str[which(str\
    \ <- \"Aaaaaaaaad\")],\n               str[which(str <- \"Aaaaaaaaae\")],\n  \
    \             str[which(str <- ", "\n  if(s == \"#a@C\") return(\"#A@c\")\n  if(s\
    \ %in% \"ABC\") return(rev(s))\n  if(length(s) == 0) return(rev(s))\n  for(i in\
    \ 1:length(s))\n  {\n    if(toupper(s[i]) == s[i]) return(rev(s))\n    if(tolower(s[i])\
    \ == s[i]) return(rev(s))\n  }\n}\n</code>\n<|/ a dscore=3 tags=r,function |>\n\
    <| a dscore=3 tags=r,function |>\nThis is a fun problem to solve. Here is a solution\
    \ using purrr that uses case_when.\n<code>\nsolve(s) %>% \n  str_replace_all(\"\
    [[:lower:]]\", \"_\") %>% \n  str_replace_all(\"[[:upper:]]\", \"_\") %>% \n \
    \ str_replace_all(\"_+\", \"_\") %>% \n  str_replace_all(\"[^a-zA-Z]\", \"\")\n\
    </code>\nHere is another solution using str_replace (no package).\n<code>\ns %>%\
    \ \n  str_replace(\"[[:lower:]]\", \"_\") %>% \n  str_replace(\"[[:upper:]]\"\
    , \"_\") %>% \n  str_replace(\"_+\", \"_\") %>% \n  str_replace(\"[^a-zA-Z]\"\
    , \"\")\n</code>\n<|/ a |>\n<| c |>\nThe `str_replace` variant is nice, but it\
    \ will not work with multiple upper and lower letters next to each other. In that\
    \ case, the `str_replace_all` solution is better.\n<|/ c |>\n<| c |>\n, Yes I\
    \ agree that this is not the most elegant solution. But I think the regex is simple\
    \ enough to get some understanding of how it works. In case it comes up again,\
    \ I would definitely revisit the answer as it seems there is room for improvement.\n\
    <|/ c |>\n<| c |>\nThanks for the suggestions Jerzy, they have been very useful.\n\
    <|/ c |>\n<| a |>\nYou can do something like this with stringr:\n<code>\nlibrary(stringr)\n\
    s <- \"@Abc\"\n\nstr_split(s, \"[a-z]+\") %>% \n  str_split(\"_\") %>% \n  unlist()\
    \ %>% \n  str_replace_all(\"_+\", \"_\") %>% \n  str_replace_all(\"[^a-zA-Z]\"\
    , \"\")", "\n  return(case_change(s))\n}\n", "\n   s <- toupper(s)\n   l <- grep(\"\
    ^[a-z]*$\", s, perl=TRUE)\n   ifelse(length(l) == 0, s, ifelse(TRUE, nchar(gsub(\"\
    [a-z]\", \"\", l)) > 1, paste0(toupper(gsub(\"[a-z]\", \"\", l)), \n   gsub(\"\
    [a-z]\", \"\", l))[length(gsub(\"[a-z]\", \"\", l))]))\n}\n", "\n    res <- \"\
    \"\n    if (length(s)==0) return(res)\n    i <- 1\n    while (i <= length(s))\
    \ {\n        if (substr(s,i,i) %in% LETTERS) {\n            res <- paste(toupper(substr(s,i,i)),\
    \ res)\n        } else if (substr(s,i,i) %in% LETTERS) {\n            res <- paste(substr(s,i,i),\
    \ res)\n        } else {\n            res <- paste(substr(s,i,i), res)\n     \
    \   }\n        i <- i + 1\n    }\n    return(res)\n}\n</code>\n<|/ a tags=r,string,regex\
    \ |>\n<| c |>\nThis only works if the string only contains letters, but `solve(\"\
    a#bcd\")` returns `a#BCD`\n<|/ c |>\n<| c |>\nyes, I agree with you. My intention\
    \ was to give OP the idea of how to reverse a string in R.\n<|/ c |>\n<| c |>\n\
    `solve(\"a#bcd\")` returns `a#BCD`\n<|/ c |>\n<| c |>\n`solve(\"a#bcd\")` returns\
    \ `a#BCD`\n<|/ c |>\n<| c |>\nI agree. However, the OP has clearly mentioned that\
    \ he is new to R, so he may have difficulty understanding the code. BTW, I just\
    \ added another solution which can be easily modified from the above.\n<|/ c |>\n\
    <| a tags=r,string,regex |>\n<code>\nsolve<-function(x){\n  x<-substr(x,1,nchar(x)-1)\n\
    \  x<-paste(rev(substr(x,1,nchar(x)-1)),x)\n  return(x)\n}\n</code>\nThe above\
    \ function will work even if x is empty or all letters lowercase. Also it will\
    \ reverse the string if it has only one letter.\n<|/ a dscore=2 |>\n<| a tags=r,string,regex\
    \ dscore=2 |>\nHere is my solution to your problem. There might be a more efficient\
    \ way to do this but I think it works fine.\n<code>\nsolve(\n  function(x){\n\
    \    require(stringr)\n    x <- str_replace_all(x, \"([a-z])\", upper)\n    return(str_sub(x,\
    \ 1, nchar(x)-1))\n  }\n)\n</code>\n<code>\n> solve(\"1234\")\n[1] \"4321\"\n\
    > solve(\"abc\")\n[1] \"cba\"\n> solve(\"#a@C\")\n[1] \"#A@c\"\n</code>\n<|/ a\
    \ |>\n<| a |>\n", "\n  s <- gsub(\"[[:punct:]]\", \"\", s)\n  s <- gsub(\"[[:digit:]]\"\
    , \"\", s)\n  s <- gsub(\"[[:upper:]]\", \"\", s)\n  s <- gsub(\"[[:lower:]]\"\
    , \"\", s)\n  s\n}\n\nsolve('ab')\n</cell>\n<cell>", "\n    # Your code here\n\
    \    \n    s <- tolower(s)\n    \n    if(grepl(\"[a-z]+\", s)){\n        s <-\
    \ sub(\"[a-z]+\", paste(toupper(substring(s, 1, 1)), collapse = \"\"), s)\n  \
    \  } else {\n        s <- sub(\"[a-z]+\", paste(substring(s, 1, 1), collapse =\
    \ \"\"), s)\n    }\n    return(s)\n}\n</cell>\n<cell>", "\n    for(i in 1:length(s))\
    \ {\n        if(grepl('^[a-zA-Z]+$', s[i])) {\n            if((substring(s[i],1,1)\
    \ %in% letters) & (substring(s[i],2,1) %in% letters) & (substring(s[i],3,1) %in%\
    \ letters)) {\n                s[i] <- substring(s[i],1,1)\n                s[i]\n\
    \            } else {\n                s[i] <- substring(s[i],2,1)\n         \
    \       s[i]\n            }\n        } else {\n            s[i] <- substring(s[i],1,1)\n\
    \            s[i]\n        }\n    }\n    for(i in 1:length(s)) {\n        if(grepl('^[a-zA-Z]+$',\
    \ s[i])) {\n            if((substring(s[i],1,1) %in% letters) & (substring(s[i],2,1)\
    \ %in% letters) & (substring(s[i],3,1) %in% letters)) {\n                s[i]\
    \ <- substring(s[i],1,1)\n                s[i]\n            } else {\n       \
    \         s[i] <- substring(s[i],2,1)\n                s[i]\n            }\n \
    \       } else {\n            s[i] <- substring(s[i],1,1)\n            s[i]\n\
    \        }\n    }\n}\nsolve(c('a1','2','aa','A','@'))\n</cell>\n<text>\nExercise\
    \ 9\nThe function below is meant to solve the string \"abba\" by returning the\
    \ string \"aab\".\n\nSolve it using a recursive function.\n\nThe function should\
    \ take the string as an argument (you do not need to convert it into a character\
    \ vector) and return the string after applying the above recursive function.\n\
    \nYou will get help from the following functions:\n\nsubstring\nifelse\ngrep\n\
    if\n\n\n</text>\n<cell>", "\n  gsub(\"\\\\w\", '', s) # remove non-letter characters\n\
    \  if(!grepl(\"^[A-Za-z]+$\", s)) s <- toupper(s) # convert non-letters to upper\n\
    \  s <- toupper(substring(s, 1, nchar(s))) # convert first character to upper\
    \ case\n  s <- tolower(substring(s, nchar(s))) # convert other characters to lower\
    \ case\n  return(s)\n}\n</code>\n<|/ a |>\n<| c |>\nIf `s` is a character string\
    \ like `'#a@C'` then your first line (`gsub(\"\\\\w\", '', s)`) will return `'#a@C'`.\n\
    <|/ c |>\n<| a dscore=2 tags=string,r |>\nHere's a solution that does not use\
    \ regular expressions (i.e. stringr package is not used).\n<code>\nsolve = function(x){\n\
    \  if(!grepl(\"^[A-Za-z]+$\", x)) x <- toupper(x)\n  x <- toupper(substring(x,\
    \ 1, nchar(x)))\n  x <- tolower(substring(x, nchar(x)))\n  return(x)\n}\n</code>\n\
    <|/ a |>\n<| a tags=string,r |>\nWith stringi package:\n<code>\nlibrary(stringi)\n\
    x <- \"#a@C\"\nstr_replace_all(x, \"[[:alpha:]]\", toupper)\n[1] \"#A@c\"\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=string,r dscore=1 |>\nIf you're working with strings\
    \ (not numbers), then this will work for you:\n<code>\nx <- \"#a@C\"\ngsub(\"\\\
    \\w\", '', x)\n</code>\n<|/ a |>\n<| a dscore=1 |>\nAnother base R solution:\n\
    <code>\nx <- \"#a@C\"\nx <- toupper(substring(x, 1, nchar(x)))\nx <- tolower(substring(x,\
    \ nchar(x)))\n</code>\n<|/ a tags=string,r |>\n<| a |>\nHere's an Rcpp solution,\
    \ \n<code>\ncppFunction('std::string solve(std::string s){\n  s.erase(std::remove(s.begin(),\
    \ s.end(), Rcpp::RegExp(\"\\\\w\")).base(), s.end()); \n  Rcpp::CharacterVector\
    \ vc = Rcpp::as< Rcpp::CharacterVector >(s);\n  vc[0] = Rcpp::toUpper(vc[0]);\n\
    \  vc[1] = Rcpp::toLower(vc[1]);\n  return Rcpp::as< std::string >(vc);\n}')\n\
    </code>\nwhich outputs ", "\n  if(!nchar(s))\n    res <- s\n  else {\n    i <-\
    \ 0\n    while(i < nchar(s))\n      if(substr(s,i,i) == \"a\")\n        i <- i+1\n\
    \      else if(substr(s,i,i) == \"A\")\n        i <- i+1\n      else if(substr(s,i,i)\
    \ == \"#\")\n        i <- i+1\n      else if(substr(s,i,i) == \"#\")\n       \
    \ i <- i+1\n      else if(substr(s,i,i) == \"c\")\n        i <- i+1\n      else\
    \ \n        i <- i+1\n    res <- substr(s,1,i)\n  }\n  res\n}\n</code>\n<|/ a\
    \ tags=r dscore=2 |>\n<| a |>\nIn R, there is one trick that may help to solve\
    \ this problem - regular expressions. You can define a regex pattern that does\
    \ the trick, and then use the substr function to extract out the characters you\
    \ want:\n<code>\n> txt <- \"1234\"\n> pattern <- \"(^|.*)(\\\\d{1,2})$\" # \\\\\
    d{1,2} means 1 or more digits or nothing\n> sub(pattern, \"\\\\1\\\\2\", txt)\n\
    [1] \"1234\"\n</code>\nNow, if you have multiple cases of \"#\" and you want to\
    \ do different things for each case, then you can create a vector of conditions:\n\
    <code>\n> cond <- ifelse(grepl(\"#\", txt), \"#\", \"A\")\n> sub(pattern, paste0(\"\
    \\\\2\", cond), txt)\n[1] \"4321\"\n</code>\nHope that helps!\n<|/ a dscore=1\
    \ tags=r |>\n<| a tags=r |>\nYou could try using a for loop:\n<code>", "\n  res\
    \ <- \"\"\n  if(grepl(\"[a-zA-Z]\", s)) \n  {\n    x <- toupper(s)\n    res <-\
    \ tolower(x)\n  } else {\n    res <- toupper(s)\n  }\n  return(res)\n}\nsolve(\"\
    1234\")\nsolve(\"ab\")\nsolve(\"#a@C\")\n</cell>\n<text>\nExercise 4.34\nWrite\
    \ a recursive function named is_palindrome that takes a string as input and test\
    \ if its character sequence is a palindrome.\nThe function should return TRUE\
    \ for palindromes and FALSE for non-palindromes. \nA palindrome is a word or phrase\
    \ which reads the same backward as forward. For example, \"racecar\", \"madam\"\
    \ are palindromes.\n\n</text>\n<cell>\nis_palindrome <- function(x){\n  if(x ==\
    \ rev(x)) TRUE else FALSE\n}\nis_palindrome(\"racecar\")\nis_palindrome(\"madam\"\
    )\n</cell>\n<text>\nExercise 4.35\nWrite a recursive function named my_trim that\
    \ takes in a string s as input and removes all white spaces from it.\nThe function\
    \ should return the trimmed string.\nThe function should return the trimmed string.\
    \ \nThe function should return the trimmed string.\nThe function should return\
    \ the trimmed string.\n\n</text>\n<cell>\nmy_trim <- function(x){\n  str_replace(x,\
    \ \"(^\\\\s+|\\\\s+$)\", \" \")\n}\nmy_trim(\"   abc  \")\nmy_trim(\"  abc\")\n\
    my_trim(\"  \")\nmy_trim(\"abc\")\n</cell>\n<text>\nExercise 4.36\nWrite a recursive\
    \ function named my_trim that takes in a string s as input and removes all white\
    \ spaces from it.\nThe function should return the trimmed string.\nThe function\
    \ should return the trimmed string. \nThe function should return the trimmed string.\n\
    The function should return the trimmed string.\n\n</text>\n<cell>\nmy_trim <-\
    \ function(x){\n  str_replace(x, \"(^\\\\s+|\\\\s+$)\", \" \")\n}\nmy_trim(\"\
    \   abc  \")\nmy_trim(\"  abc\")\nmy_trim(\"  \")\nmy_trim(\"abc\")\n</cell>\n\
    <text>\nExercise 4.37\nWrite a recursive function named my_trim that takes in\
    \ a string s as input and removes all white spaces from it.\nThe function should\
    \ return the trimmed string.\nThe function should return the trimmed string. \n\
    The function should return the trimmed string.", "\n    if(s == '') {\n      \
    \  \n    } else {\n        \n    }\n}", "\n  for(i in seq_along(s)) {\n    if((is.na(grepl('[a-z]',\
    \ s[i])) & is.na(grepl('[A-z]', s[i]))) |\n       (is.na(grepl('[A-Z]', s[i]))\
    \ & is.na(grepl('[a-z]', s[i]))))\n    {\n      s[i]\n    } else if((grepl('[a-z]',\
    \ s[i])) & is.na(grepl('[A-z]', s[i]))) {\n      toupper(s[i])\n    } else if((grepl('[A-Z]',\
    \ s[i])) & is.na(grepl('[a-z]', s[i]))) {\n      tolower(s[i])\n    } else {\n\
    \      s[i]\n    }\n  }\n}\n</code>\n<|/ a |>\n<| c |>\nYour answer helped me,\
    \ I was just wondering why my code was not working. I found that my function was\
    \ just returning the last line in the code (grepl('[a-z]', s[i])). I was wondering\
    \ if anyone could explain why that would be the case?\n<|/ c |>\n<| a tags=r |>\n\
    Here's another option using the toupper and tolower functions. Here we define\
    \ our function with a little help from lapply\n<code>\nsolve <- function(s) {\n\
    \  lapply(s, tolower)\n  lapply(s, toupper)\n  toupper(tolower(s))\n}\n\nsolve(\"\
    hello world\") # [1] \"Hello World\"\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou\
    \ can try this :\n<code>\nsol <- function(x) {\n      x <- toupper(x)\n      tolower(gsub(\"\
    [^[:alnum:]]\", \"\", x))\n}\n</code>\n<|/ a tags=r dscore=0 |>\n<| a tags=r |>\n\
    This can be done in one line using ifelse\n<code>\na <- c(\"A\",\"b\",\"c\",\"\
    D\")\nifelse(grepl(\"[A-Z]\", a),toupper(a),tolower(a),a)\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=r |>\n<code>\nsolve<-function(s){\n  for(i in 1:length(s)){\n\
    \    for(j in 1:length(s)){\n      if(is.na(grepl(\"[a-z]\", s[i]))& is.na(grepl(\"\
    [A-Z]\", s[i]))& !is.na(grepl(\"[[:alnum:]]\", s[j]))){\n        s[i]<-toupper(s[i])\n\
    \        break\n      }\n      if(is.na(grepl(\"[A-Z]\", s[i]))& is.", "\n  if\
    \ (length(s) <= 0) return('')\n  else s <- tolower(s)\n  s <- toupper(s)\n  s\
    \ <- s[which(!is.alpha(s))]\n  s <- paste(tolower(s), collapse = \"\")\n  s\n\
    }\n</cell>\n<cell>", "\n    l <- lapply(strsplit(s, \"[[:alpha:]]\"), toupper)\n\
    \    s <- paste(sapply(l, function(x) { gsub(paste0(\"^[\", x, \"]\"), \"\") }),\n\
    \                collapse = \"\")\n}\n</code>\n<|/ a |>\n<| a |>\nHere is a solution\
    \ in pure R:\n<code>", "\n  # Your code here\n  s1 <- gsub('[a-z]', '', s)\n \
    \ s2 <- toupper(substring(s, 1, 1))\n  s3 <- toupper(substring(s, 2, 2))\n  s4\
    \ <- substring(s, 3)\n  paste0(s1, s2, s3, s4)\n}\n</cell>\n<cell>\nsolve(1234)\n\
    </cell>\n<cell>\nsolve('ab')\n</cell>\n<cell>\nsolve('#a@C')\n</cell>\n<cell>",
  "\n  \n  if(s == '') return('')\n  \n  \n  letters <- tolower(unlist(strsplit(s,\
    \ '')))\n  \n  \n  if(length(letters) == 0) return('')\n  \n  \n  \n  if(length(letters)\
    \ > 1) return('')\n  \n  \n  \n  \n  return(paste0(substr(toupper(letters), 1,\
    \ 1), substr(letters, 2, nchar(letters))))\n  \n  \n}\n", "\n  s <- tolower(s)\n\
    \  x <- ifelse(grepl('^[a-z]+$', s), gsub('[a-z]+', '', s), s)\n  ifelse(grepl('^[a-z]+$',\
    \ x), \n         toupper(x),\n         tolower(x))\n}\n</code>\n<|/ a tags=r,string\
    \ |>\n<| c |>\nThis is an answer to the wrong question. The question was how to\
    \ change the case of the letters in strings. The answer given here changes the\
    \ case of the letters *in the strings*.\n<|/ c |>\n<| c |>\nApologies for the\
    \ confusion. I had already upvoted this solution before it was edited to remove\
    \ that inaccuracy and to correct the error in the code (which was my fault). As\
    \ you see, the question asked how to reverse the case of the letters in a string.\
    \ The answer solves the problem for reversing the case of the letters in the string.\
    \ That's why I posted it.\n<|/ c |>\n<| a dscore=4 |>\n<code>\nstringr::str_replace_all('Hello',\
    \ '[[:alpha:]]', toupper('Hello'))\n</code>\n<|/ a tags=r,string |>\n<| a |>\n\
    The answer is very similar to the one already given, but just in case you want\
    \ to know how it works, you can read more about stringi here\n<code>\nrequire(stringi)\n\
    string <- 'Hello'\nstri_replace_all(string, \"[[:alpha:]]\", toupper(string))\n\
    </code>\n<|/ a dscore=4 tags=r,string |>\n<| a tags=r,string dscore=3 |>\nThe\
    \ simplest way I found was\n<code>\ngsub('[a-z]+', ' ', s)\n</code>\n<|/ a |>\n\
    <| a tags=r,string dscore=3 |>\nIf you want to reverse the case of the letters\
    \ in the string then this should work:\n<code>\ngsub('[a-z]+', toupper, s)\n</code>\n\
    <|/ a |>\n<| a |>\nHere is a base R solution using str_replace_all.\n<code>\n\
    str_replace_all(s, '[[:upper:]]', toupper(s))\n</code>\n<|/ a dscore=3 tags=r,string\
    \ |>\n<| a dscore=3 |>\nHere is a simple way using gsub:\n<code>\nstring <- c(\"\
    hello\",\"hELLO\")\ngsub(\"[a-z]+\", toupper, string)\n</code>\n<|/ a tags=r,string\
    \ |>\n<| a tags=r,string |>\nTo reverse case from any character set (not just\
    \ ASCII case):\n<code>\n x <- c(\"Hello World\", \"", "\n  if (length(s) == 0)\
    \ \n    return(toupper(s))\n  \n  res <- s\n  res <- gsub(\"([^a-z])\", toupper(substr(res,\
    \ 1, 1)), res)\n  res <- gsub(\"([a-z])\", tolower(substr(res, 2, nchar(res))),\
    \ res)\n  return(res)\n}\n</code>\n<|/ a |>\n<| a tags=string,r dscore=1 |>\n\
    Here are two base R options:\n<code>\nx <- \"aBcDeF\"\n", "\n  s <- as.character(s)\n\
    \  s <- gsub('^[a-z]+|[A-Z]+|[a-z]+$', '', s)\n  s <- gsub('(.)', '\\\\U\\\\1',\
    \ s)\n  s <- toupper(tolower(s))\n  s\n}\n</cell>\n<cell>\nsolve('Abc')\n</cell>\n\
    <cell>\nsolve('abc')\n</cell>\n<cell>\nsolve('aba')\n</cell>\n<cell>\nsolve('ab1')\n\
    </cell>\n<cell>\nsolve('1a1')\n</cell>\n<text>\nProblem 5\nA palindromic number\
    \ reads the same both ways. The largest palindrome made from the product of two\
    \ 2-digit numbers is 9009 = 91 x 99.\nFind the largest palindrome made from the\
    \ product of two 3-digit numbers.\n\n\n</text>\n<cell>", "\n    if(is.null(s))\
    \ return('')\n    s <- toupper(s)\n    for(i in seq_along(s)) {\n        if(s[i]\
    \ == tolower(s[i])) return(toupper(substr(s, i, nchar(s))))\n    }\n    return(tolower(s))\n\
    }\n</code>\n<|/ a tags=r,string dscore=1 |>\n<| a |>\nThis is a solution without\
    \ regular expressions. Instead of using strsplit and grepl, we use substring and\
    \ gregexpr.\n<code>\na <- 'ABCD'\nb <- '#a@C'\n", "\n  a <- strsplit(s,'')[[1]]\n\
    \  if(length(a) == 0){\n    paste(rep(c(\"z\",\"Z\"),each=length(a)),collapse='')\n\
    \  }\n  else{\n    if(a[[1]][[1]] %in% c(\"z\",\"Z\")){\n      paste(rep(a[[1]][[1]],each=length(a)),collapse='')\n\
    \    }\n    else{\n      paste(toupper(a[[1]][[1]]),a[[1]][2],rep(a[[1]][3],each=length(a)),collapse='')\n\
    \    }\n  }\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a solution\
    \ using gsub, grepl, and toupper. I did not use regular expressions to match capital\
    \ letters but I do not think you need it either.\n<code>\nsolve <- function(x){\n\
    \  sapply(gsub(\"\\\\p{L}\",\"\",toupper(x)),function(y){\n    if(grepl(\"[A-Z]\"\
    ,y)){\n      toupper(y)\n    }else{\n      y\n    }\n  })\n}\n\nsolve(\"zzz\"\
    )\n[1] \"ZZZ\"\nsolve(\"abc\")\n[1] \"cba\"\nsolve(\"zzz\")\n[1] \"ZZZ\"\n</code>\n\
    <|/ a tags=string,lowercase,r,capitalize |>\n<| a |>\nI think this also does what\
    \ you are asking.\n<code>\nsolve <- function(s) {\n  a <- strsplit(s, '')[[1]]\n\
    \  ifelse(length(a) == 0, s, paste(rep(toupper(a[[1]]), each = length(a)), collapse\
    \ = s))\n}\n\nsolve('zzz')", "\n  if(length(s)==0) return(s)\n  s1 <- toupper(s)\n\
    \  s2 <- tolower(s)\n  if(s2==s1) return(s2)\n  ifelse(s1==s2, return(s1), return(s2))\n\
    }\n", "\n  a <- sapply(s, is.character)\n  a[a] <- lapply(s[a], function(x){\n\
    \    x <- toupper(x)\n    if(is.na(toupper(x))) x <- tolower(x)\n    x\n  })\n\
    \  if(!any(a)) s <- toupper(s)\n  s\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\n\
    <code>\n> solve<-function(s){\n+   n<-gregexpr(\"[a-z]\",s)\n+   s<-substr(s,1,n[[1]])\n\
    +   if(length(gregexpr(\"[a-z]\",s))>0){\n+     s<-paste(toupper(s),substr(s,(n[[1]]-1),n[[1]]))\n\
    +   }\n+   return(s)\n+ }\n> solve(\"1234\")\n[1] \"4321\"\n> solve(\"AB\")\n\
    [1] \"AB\"\n> solve(\"#A@C\")\n[1] \"#A@c\"\n</code>\n<|/ a tags=string,r dscore=2\
    \ |>\n<| c |>\nI think this is the most concise answer. Elegant!\n<|/ c |>\n<|\
    \ c |>\nGreat solution!  Thanks.\n<|/ c |>\n<| a |>\n<code>\ns<-\"ab#A@C\"\n\n\
    s<-paste(toupper(substr(s,1,1)),substr(s,2,nchar(s)), sep=\"\")\n\n> s\n[1] \"\
    AB#A@C\"\n</code>\n<|/ a tags=string,r dscore=2 |>\n<| a |>\nHere's a vectorized\
    \ solution, assuming the string always contains at least one character:\n<code>\n\
    solve(s <- \"abcd\", na.omit(toupper(s)))\n[1] \"BCD\"\n</code>\n<|/ a dscore=2\
    \ tags=string,r |>\n<| a |>\nHere is another solution:\n<code>\ns<-\"ab#A@C\"\n\
    s<-paste(toupper(substr(s,1,1)),substr(s,2,nchar(s)), sep=\"\")\ns\n</code>\n\
    <|/ a dscore=2 tags=string,r |>\n<| a tags=string,r |>\n<code>\ns<-\"ab#A@C\"\n\
    s<-paste(toupper(substr(s,1,1)),substr(s,2,nchar(s)), sep=\"\")\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=string,r |>\n<code>\nsolve <- function(string) {\n\
    \  sapply(string, function(x) ", "\n  s <- gsub(\" \", \"\", s)\n  s2 <- gsub(\"\
    [a-z]\", \"\", s)\n  s3 <- gsub(\"[A-Z]\", \"\", s2)\n  paste0(s3, s2)\n}\n</code>\n\
    <|/ a |>\n<| a |>\nI thought it was better to share a little trick to do this:\n\
    <code>\nsolve  <- function(s){\n  s1 <- paste(toupper(s), tolower(s), sep=\"\"\
    )\n  s2 <- paste(s1, tolower(s), sep=\"\")\n  s3 <- paste(s2, toupper(s), sep=\"\
    \")\n  paste(s3, s1)\n}\n\nsolve(c(\"ab\", \"c#d\", \"eF\", \"Aa\"))", "\n  s\
    \ <- gsub(\"\\\\W\", \"\", s)\n  s <- toupper(tolower(s))\n  s <- gsub(\"\\\\\
    w\", \"\", s)\n  s <- toupper(tolower(s))\n  return(s)\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=stringr,r |>\n<code>", "\n  sapply(s, function(i) {\n    if (is.character(i))\
    \ {\n      i <- toupper(i)\n    } else if (is.factor(i)) {\n      i <- levels(i)[[i]]\n\
    \    } else if (is.integer(i)) {\n      i <- i\n    } else if (is.numeric(i))\
    \ {\n      i <- i\n    } else {\n      i <- \"\"\n    }\n  })\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThanks for the answer. Is it possible to solve this\
    \ without using the `stringi` package ?\n<|/ c |>\n<| c |>\nThank you. I think\
    \ there is a misunderstanding. I'm not trying to solve the problem with `stringi`\
    \ but with R. I've edited the question accordingly. Thanks again.\n<|/ c |>\n\
    <| c |>\nSo your actual question is that you are unable to call `toupper`, `tolower`\
    \ etc directly from R as an R function? Or are you looking for a solution in an\
    \ R package? It seems that there is a misunderstanding of what you are asking.\n\
    <|/ c |>\n<| a dscore=1 |>\nWe can use lapply from base R to convert each character\
    \ in each vector in the list to upper/lower case and return the unlist with do.call\n\
    <code>\nlst <- list(letters, letters)\nout <- do.call(`unlist`, lapply(lst, toupper))\n\
    out", "\n  if (sum(grepl('^[a-zA-Z]$', s)) == 0) {\n    res <- strsplit(s, '')\n\
    \    res <- lapply(res, function(x) {\n      if (grepl('^[a-zA-Z]$', x)) {\n \
    \       x <- toupper(x)\n      }\n      x\n    })\n    res <- unlist(res)\n  }\
    \ else {\n    x <- toupper(s)\n  }\n  return(x)\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you very much for this solution. This is exactly the explanation I needed.\n\
    <|/ c |>\n<| a tags=r,string dscore=3 |>\nYou can use the ifelse condition as\
    \ below. \n<code>\ns <- 'aA12'\nx <- strsplit(s, '')[[1]]\nifelse(grepl('^[a-zA-Z]+$',\
    \ x), toupper(x), x)", "\n  if(!all(grepl(\"^[a-zA-Z]*$\", s))) {\n    s <- gsub(tolower(s),\
    \ toupper(s), s, ignore.case = TRUE)\n  }\n  s\n}\n</code>\n<|/ a tags=r,string,capitalization,lowercase,reverse\
    \ |>\n<| a |>\nHere is a function that would reverse the case for lowercase letters\
    \ and uppercase letters.\n<code>\nreverse.case <- function(x){\n  out <- rep(\"\
    \",length(x))\n  for(i in 1:length(x)){\n    if(tolower(x[i]) != x[i]) {\n   \
    \   out[i] <- toupper(x[i])\n    } else {\n      out[i] <- tolower(x[i])\n   \
    \ }\n  }\n  out\n}\n</code>\nSo if we have a string\n<code>\nx <- c(\"A\",\"B\"\
    ,\"c\")\n</code>\nWe can reverse it with the above function\n<code>\nreverse.case(x)\n\
    [1] \"C\" \"B\" \"A\"\n</code>\n<|/ a tags=r,string,capitalization,lowercase,reverse\
    \ dscore=2 |>\n<| a tags=r,string,capitalization,lowercase,reverse |>\nI like\
    \ to use stringi::stri_reverse and stringi::stri_uppercase to do this kind of\
    \ tasks. Since R is case-sensitive by default this works well.\n<code>\nlibrary(stringi)\n\
    x <- c(\"a\",\"b\",\"C\",\"A\")\nstri_reverse(x)", "\n    if (length(s) <= 1)\n\
    \        return(s)\n\n    if (!is.character(s))\n        stop(\"s should be a\
    \ string\")\n\n    if (!any(grepl('[a-z]', s)))\n        return(toupper(tolower(s)))\n\
    \n    s <- strsplit(s, '')\n    s[1] <- toupper(tolower(s[1]))\n    sapply(s,\
    \ paste, collapse = \"\")\n}\n</code>\n<|/ a dscore=1 tags=r |>\n<| c |>\nThank\
    \ you so much! This is very helpful! And thank you for adding the comments on\
    \ my code!\n<|/ c |>\n<| a dscore=1 |>\nWe can use gsubfn for this:\n<code>\n\
    library(gsubfn)\n\nreverse <- function(s) {\n  unlist(lapply(strsplit(s, ''),\
    \ \n                function(x) {\n                  gsubfn(\"[a-z]\", toupper,\
    \ gsubfn(\"[A-Z]\", tolower, x)[[1]])\n                }))\n}\n\nreverse(\"123abc\"\
    )", "\n  x <- sapply(s, function(x) grepl(\"[[:alpha:]]\", x))\n  x[!x] <- paste0(toupper(substr(s,\
    \ 1, 1)), substr(s, 2, nchar(s))[!x])\n  x\n}\n</cell>\n<cell>", "\n    s <- tolower(s)\n\
    \    for(i in 1:nchar(s)){\n        if(s[i] == \"a\") s[i] <- toupper(s[i])\n\
    \        else if(s[i] == \"A\") s[i] <- tolower(s[i])\n    }\n    s\n}\n", "\n\
    \  s <- trimws(s)\n  len <- nchar(s)\n  if(len == 0) return(s)\n  i <- 1\n  while(i+1\
    \ < len) {\n    if(!is.na(as.character(substr(s,i,i+1)))) {\n      if(substr(s,i,i+1)\
    \ > 'z') substr(s,i,i+1) <- substr(s,i,i+1)-'a'\n      else substr(s,i,i+1) <-\
    \ substr(s,i,i+1)-'A'\n      i <- i+1\n    } else i <- i+1\n  }\n  return(toupper(substring(s,1,i-1)))\n\
    }\n</code>\n<|/ a tags=r,regex |>\n<| c |>\nThis works for me; I'm wondering why\
    \ it works for the sample test cases in the OP, but doesn't work for the actual\
    \ data.\n<|/ c |>\n<| c |>\nI've added a comment about the test cases. Also I've\
    \ added a small explanation. Hope it helps.\n<|/ c |>\n<| a tags=r,regex |>\n\
    The other answers work, but this is one way to do it.  It's based on the idea\
    \ that if we have a letter in the string before a non-letter, then we can assume\
    \ that that letter is part of the reversed string.  We can then repeatedly look\
    \ for a non-letter and reverse that part of the string until it finds one or reaches\
    \ the end of the string.\n<code>\nsolve <- function(s) {\n  i <- 1\n  while(i\
    \ < nchar(s)) {\n    if(is.na(as.character(substr(s, i, i+1)))) {\n      while(i\
    \ <- i+1) {\n        if(is.na(as.character(substr(s, i, i+1)))) {\n          i\
    \ <- i+1\n          return(substring(s, 1, i-1))\n        }\n      }\n    }\n\
    \    i <- i+1\n  }\n  return(toupper(substring(s, 1, nchar(s) - 1))) \n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=r,regex dscore=2 |>\n<code>\n> solve(\"a\")\n[1]\
    \ \"A\"\n\n> solve(\"ab\")\n[1] \"ab\"\n\n> solve(\"abc\")\n[1] \"cba\"\n\n> solve(\"\
    ab#c\")\n[1] \"bca\"\n\n> solve(\"ab#c#d\")\n[1] \"bcd\"\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nHere is a solution using gsubfn:\n<code>\nlibrary(gsubfn)\n\n\
    solve <- function(string) {\n  gsubfn(\"([^[:alpha:]])\", ~paste0(toupper(substring(.,2,n",
  "\n   res <- s\n   for(i in 1:length(s)) {\n      if(is.alpha(s[i])) {\n       \
    \  if(toupper(s[i])==s[i])\n            toupper(res[i]) <- toupper(res[i])\n \
    \        else\n            tolower(res[i]) <- tolower(res[i])\n      }\n     \
    \ else\n         res[i] <- tolower(res[i])\n   }\n   return(res)\n}\n</code>\n\
    <|/ a tags=r,string |>\n<| a dscore=1 |>\nYou can use mapply function along with\
    \ gsub function. \n<code>\nmapply(FUN=function(x)gsub(\"[a-z]\", \"\", x), x=str1)\n\
    </code>\n<|/ a tags=r,string |>\n<| a |>\nTry this function:\n<code>\nreverse\
    \ <- function(x) {\n  out <- gsub(\"[^[:alpha:]]\", \"\", x)\n  paste(rev(out),\
    \ collapse = \"\")\n}\n</code>\n<|/ a tags=r,string dscore=1 |>\n<| a tags=r,string\
    \ dscore=1 |>\nHere is a possible approach:\n<code>\nreverse <- function(x) {\n\
    \  out <- gsub(\"[^[:alpha:]]\", \"\", x)\n  paste(rev(out), collapse = \"\")\n\
    }\n</code>\n<|/ a |>\n<| a |>\nThis might help you, using base R:\n<code>\nx <-\
    \ \"aaa1221bbb33\"\n> paste0(sub('[a-z]', '', x), collapse = \"\")\n[1] \"122133\"\
    \n</code>\n<|/ a tags=r,string dscore=1 |>\n<| a dscore=1 tags=r,string |>\nThe\
    \ function below works both on upper and lower case:\n<code>\nreverse <- function(x){\n\
    \  sapply(strsplit(x, \"\"), paste, reverse=T)\n}\n</code>\n<|/ a |>\n<| a tags=r,string\
    \ |>\n<code>\nrevx <- function(x) gsub(\" \", \"\", x)\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nIt's better to include some explanation about the code or how you\
    \ think it should be used, instead of just posting the code.\n<|/ c |>\n<| c |>\n\
    The code in the answer has exactly the same result as the code in the question,\
    \ so why not just use the answer? I suppose this would be the accepted answer\
    \ (+1).\n<|/ c |>\n<| a tags=r,string |>\nIn one line:\n<code>\npaste0(rev(revx(text)),\
    \ collapse = \"\")\n</code>\n<|/ a dscore=0 |>\n<|", "\n    if (any(grepl(\"\\\
    \\p{L}\", s))) \n        s <- toupper(tolower(s))\n    else s <- tolower(s)\n\
    \    s <- gsub(\"[^[:alnum:]]\", \"\", s)\n    s <- gsub(\"\\\\p{L}+\", \"\",\
    \ s)\n    s <- toupper(s)\n    return(s)\n}\n</code>\n<|/ a tags=r dscore=0 |>\n\
    <| a dscore=0 |>\nI realize that the other answers might have done the trick,\
    \ but I think I figured out a way which is not as convoluted and can achieve the\
    \ same output as OP's code.\n<code>", "\n  gsub(\"[a-zA-Z]\",function(x){\n  \
    \  if(x==\" \"){\n      return(\"\")\n    }\n    if(toupper(substr(x,1,1))>toupper(substr(x,2,1))){\n\
    \      return(toupper(substr(x,1,1)))\n    }\n    else{\n      return(toupper(substr(x,2,1)))\n\
    \    }\n  },s)\n}\n</code>\n<|/ a tags=r,stringr |>\n<| a tags=r,stringr |>\n\
    I like using stringr for simple string operations. Since you already have some\
    \ working code, I will only explain how to make it work. \n<code>", "\n  s <-\
    \ toupper(s)\n  if(!any(grepl(\"[A-HJ-Z]\", s))) s <- tolower(s)\n  s\n}\n\n</cell>\n\
    <text>\nProblem 7\nWrite a function that reverses a string.\nFor example, \n\"\
    hello\" becomes \"olleh\".\n\n\n</text>\n<cell>", "\n  if(length(s) == 0) {\n\
    \    return(as.character(s))\n  } else {\n    lowercase <- tolower(as.character(s))\n\
    \    noLetters <- !grepl(\"[A-Za-z]+\", lowercase)\n    if(noLetters) {\n    \
    \  return(lowercase )\n    } else {\n      uppercase <- toupper(as.character(s))\n\
    \      noLetters <- !grepl(\"[A-Za-z]+\", uppercase)\n      if(noLetters) {\n\
    \        return(uppercase )\n      } else {\n        return(paste0(toupper(substring(s,\
    \ 1, 1)),\n                     tolower(substring(s, 2, nchar(s))),\n        \
    \             substring(s, (nchar(s)+1), nchar(s))))\n      }\n    }\n  }\n}\n\
    </code>\nThis works, but I wonder if there is a more concise way to accomplish\
    \ this.\n<|/ a tags=r,regex |>\n<| c |>\nYou don't need `grepl` and `substring`\
    \ here, you can do `toupper(s[!is.na(match(tolower(s), LETTERS))]); tolower(s[!is.na(match(toupper(s),\
    \ LETTERS))])`.\n<|/ c |>\n<| a dscore=0 |>\nA different approach from the others\
    \ here using stri_reverse from the stringi package. \n<code>\nlibrary(stringi)\n\
    </code>\nUsing your data, we get this:\n<code>\n> stri_reverse(\"aaabbc\")\n[1]\
    \ \"bcbaaa\"\n</code>\n<|/ a tags=r,regex |>\n<| a tags=r,regex dscore=0 |>\n\
    A different approach from the others here using substring from the stringi package.\
    \ \n<code>\nlibrary(stringi)\n</code>\nUsing your data, we get this:\n<code>\n\
    > substring(\"aaabbc\", start = 1, stop = 4)\n[1] \"bcb\"\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nTry this with gsub:\n<code>\ns1 <- \"aaabbc\"\ngsub(\"[a-z]\"\
    , \"\", s1)", "\n    res <- ''\n    for(i in seq_along(s)) {\n        if(s[i]\
    \ %in% c('A', 'F', 'I', 'O', 'U')) {\n            if(substr(s[i],1,1) %in% LETTERS)\
    \ res <- paste(rev(substr(s[i],1,1)), res, sep='')\n            else if(substr(s[i],1,1)\
    \ %in% LETTERS) res <- paste(rev(substr(s[i],2,1)), res, sep='')\n           \
    \ else res <- paste(rev(s[i]), res, sep='')\n        } else res <- paste(res,s[i],sep='')\n\
    \    }\n    return(res)\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCould you explain\
    \ the logic behind this code? What is the purpose of the for loop? How can it\
    \ be used to reverse the string? Why was the double if statement needed? Why do\
    \ we need the double if statement? Why does substr(s[i],1,1) %in% LETTERS not\
    \ work when we have another condition if(substr(s[i],2,1) %in% LETTERS) ?\n<|/\
    \ c |>\n<| a |>\n<code>\nsolve<-function(s){", "\n  res <- c()\n  i <- 1\n  while\
    \ ( i <= length(s) ) {\n    letter <- s[i]\n    if( letter == \"a\" | letter ==\
    \ \"A\" ) letter <- toupper(letter)\n    else letter <- tolower(letter)\n    res\
    \ <- c(res,letter)\n    i <- i+1\n  }\n  res <- paste(res,collapse='')\n  return(res)\n\
    }\n</cell>\n<code language=julia-0.6>\nsolve('1234')\n</cell>\n<code language=julia-0.6>\n\
    solve('ab')\n</cell>\n<code language=julia-0.6>\nsolve('#a@C')\n</cell>\n<code\
    \ language=julia-0.6>\nsolve(@benchmark solve('1234')) # @benchmark is just like\
    \ an alias for @time which runs your code multiple times\n</cell>\n<code language=julia-0.6>\n\
    solve(@benchmark solve('ab')) # @benchmark is just like an alias for @time which\
    \ runs your code multiple times\n</cell>\n<code language=julia-0.6>\nsolve(@benchmark\
    \ solve('#a@C')) # @benchmark is just like an alias for @time which runs your\
    \ code multiple times\n</cell>\n<text>\nAsymptotic Analysis\n\n</text>\n<code\
    \ language=julia-0.6>\n@time solve('1234')\n</cell>\n<code language=julia-0.6>\n\
    @time solve('ab')\n</cell>\n<code language=julia-0.6>\n@time solve('#a@C')\n</cell>\n\
    <text>\nExploratory Analysis\n\n</text>\n<code language=julia-0.6>\nusing BenchmarkTools\n\
    </cell>\n<code language=julia-0.6>\n@btime solve('1234')\n</cell>\n<code language=julia-0.6>\n\
    @btime solve('ab')\n</cell>\n<code language=julia-0.6>\n@btime solve('#a@C')\n\
    </cell>\n<code language=julia-0.6>\n@btime solve('ab')\n</cell>\n<code language=julia-0.6>\n\
    @btime solve('ab')\n</cell>\n<code language=julia-0.6>\n@btime solve('ab')\n</cell>\n\
    <code language=julia-0.6>\n@btime solve('ab')\n</cell>\n<code language=julia-0.6>\n\
    @btime solve('ab')\n</cell>\n<text>\nConclusion\n\n</text>\n<text>\nThis exercise\
    \ gave me a lot of insight into Julia! It was surprising how fast Julia ", "\n\
    \    s <- ifelse(grepl(\"^[a-zA-Z]\", s), gsub(\"[a-z]\", \"\", s), gsub(\" \"\
    , \"\", s))\n    s <- ifelse(grepl(\"^[0-9]+\", s), gsub(\"[0-9]+\", \"\", s),\
    \ s)\n    s <- ifelse(grepl(\"^\\\\p{L}\", s), gsub(\" \", \"\", s), s)\n    paste(toupper(substring(s,\
    \ 1, 1)), tolower(substring(s, 2, nchar(s))), sep=\"\")\n}\n</code>\n<|/ a tags=algorithm,r,regex,string\
    \ dscore=2 |>\n<| a dscore=2 |>\nYou can use gregexpr\n<code>\nsol <- function\
    \ (s) {\n  gp <- gregexpr(\"[[:alpha:]]\", s)\n  g2 <- gregexpr(\"[[:digit:]]\"\
    , s)\n  g3 <- gregexpr(\"[[:punct:]]\", s)\n\n  s <- sapply(s, function(x) if(length(x))\
    \ \n    paste(toupper(x[[1]]), tolower(x[[2]]), sep=\"\") else\n    paste(x[[1]],\
    \ x[[2]], sep=\"\"))\n  paste(toupper(substring(s[[1]], 1, 1)),\n        tolower(substring(s[[1]],\
    \ 2, nchar(s[[1]]))), \n        toupper(substring(s[[2]], 1, 1)),\n        tolower(substring(s[[2]],\
    \ 2, nchar(s[[2]]))), \n        s[[3]][1], s[[3]][2], sep=\"\", collapse=\"\"\
    )\n}\n</code>\n<|/ a tags=algorithm,r,regex,string |>\n<| a tags=algorithm,r,regex,string\
    \ |>\nI thought I'd post my solution as well. It's a little more complex (but\
    \ it's still very readable). Also, the function I created is called solve in my\
    \ solution:\n<code>\nsolve2 <- function(string) {\n\n  ### Create a variable where\
    \ we store the string in a list\n  string <- as.list(string)\n\n  ### If there\
    \ are 0 letters in string then just return string as is\n  if(length(string)==0)\
    \ return(string)\n\n  ### Create a variable where we store the length of each\
    \ letter\n  lengths <- unlist(lapply(string, function(x){\n      length(gregexpr(paste0(\"\
    [[:alpha:]]\", x), string)[[1]])\n  }))\n\n  ### If the length of all letters\
    \ in string are not the same then just return string as is\n  if(length(lengths)!=1)\
    \ return(string)\n\n  ### Create a variable where we store the string in lowercase\
    \ letters\n  strings <- unlist(lapply(string, function(x) {\n      if(", "\n \
    \ str_split(s, '')\n  lapply(seq_along(x), function(i) {\n    x <- strsplit(x,\
    \ \"\")[[i]]\n    if (x[1] != \"\" && x[1] !=\" \") { \n      x[1] = toupper(x[1])\n\
    \    }\n    if (x[2] != \"\" && x[2] !=\" \") { \n      x[2] = tolower(x[2])\n\
    \    }\n    if (x[1] != \"\" & x[2] != \"\") {\n      x\n    }\n  })\n}\n", "\n\
    \    if (nchar(s) === 0) {\n        return(s)\n    }\n    s <- toupper(s[[1]])\
    \ # convert to upper case to make it case insensitive\n    str_split <- strsplit(s,\
    \ \"\")\n    str_split_upper <- str_split[str_split[[1]] %in% LETTERS]\n    str_split_lower[[1]]\
    \ <- str_split[[1]][str_split[[1]] %in% LETTERS]\n    result <- paste(str_split_upper,\
    \ str_split_lower)\n    return(paste(result, collapse=\"\"))\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/19846024)\n<|/ c |>\n<| c |>\nIt does\
    \ provide an answer to the question \"Is there a more elegant way to do this?\"\
    \ as stated in the comments to the original post. Plus the solution is very compact,\
    \ using only base R, stringr and purrr, so it's an answer to the question.\n<|/\
    \ c |>\n<| c |>\n`strsplit` is not vectorized so it isn't efficient.\n<|/ c |>\n\
    <| c |>\nIt seems you forgot to put `[[1]]` in line 3.\n<|/ c |>\n<| a dscore=4\
    \ |>\nWith dplyr :\n<code>\nlibrary(dplyr)\ngsub('(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|(?<=[A-Z])(?=[A-Z])',\
    \ \"\",'aBcD')\n</code>\nOutput\n<code>\n[1] \"D\"\n</code>\n<|/ a tags=string,r\
    \ |>\n<| a dscore=3 |>\nHere is a base R solution using sub. \n<code>\n> s <-\
    \ 'aBcD'\n> \n> sub('([a-z])([A-Z])','\\\\1\\\\2',s)\n[1] \"D\"\n> \n> sub('([a-z])([A-Z])','\\\
    \\1\\\\2',tolower(s))\n[1] \"D\"\n> \n> sub('([a-z])([A-Z])','\\\\1\\\\2',toupper(s))\n\
    [1] \"D\"\n> \n> s <- 'aBcD'\n> \n> s <- toupper(s)\n> \n> sub('([a-z])([A-Z])','\\\
    \\1\\\\2',s)\n[1] \"D\"", "\n    s <- ifelse(s == \"\", \"#\"+s, paste(toupper(substring(s,\
    \ 1, 1)), substring(s, 2, nchar(s))))\n    \n    for(i in 1:nchar(s)) {\n    \
    \    s <- ifelse(s[i] >= 'a' & s[i] <= 'z', substr(s, i, i) + substring(s, i,\
    \ i), substr(s, i, i))\n    }\n    s\n}\n</cell>\n<cell>\nsolve(\"AB#a\")\n</cell>\n\
    <cell>\nsolve(\"aB#a\")\n</cell>\n<text>\nWrite a function that takes a vector\
    \ as its argument, and return a vector that contains all the elements that are\
    \ in both that vector and its reverse.\n\n</text>\n<cell>", "\n  s <- gsub(\"\
    \ \", \"\", s)\n  s <- strsplit(s, \"\")[[1]]\n  s <- toupper(s)\n  if (is.na(s))\
    \ return(\"\")\n  else {\n    for (letter in s) {\n      letter <- toupper(letter)\n\
    \      letter <- tolower(letter)\n      if (letter != letter) {\n        s <-\
    \ paste0(letter, s, letter)\n      } else {\n        s <- paste0(letter, letter)\n\
    \      }\n    }\n  }\n  return(s)\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for answering my question. The function works but I found a mistake in your\
    \ answer: it doesn't return the string that contains the letter that has the lowest\
    \ ASCII value.\n<|/ c |>\n<| c |>\nSorry, I missed that requirement. Here's a\
    \ better one; let me know if it works for you\n<|/ c |>\n<| a |>\nAnother option\
    \ is the following:\n<code>\nsolve <- function(s){ \n  if(is.na(s)){\n    return(\"\
    \")\n  }else{\n    x <- unique(tolower(gsub(\" \", \"\", s)))\n    y <- which(x\
    \ == x)\n    if(length(x) == 0){\n      return(\"\")\n    }else{\n      return(x[which.min(x[length(y)])])\n\
    \    }\n  }\n}\n</code>\nHere we first make every character lowercase and then\
    \ remove all repeated characters. Then we convert the vector to a character vector\
    \ and identify the unique characters. Once we know all unique characters, we find\
    \ the character that has the lowest ASCII value. Finally, we return it or just\
    \ return an empty string if it is NA.\n<|/ a dscore=0 tags=string,r,ascii,loops,rbind\
    \ |>\n<| a dscore=0 |>\n<code>\nsolve <- function(s) {\n  s <- gsub(\" \", \"\"\
    , s)\n  return(paste(sort(unique(tolower(s))), collapse=\"\"))\n}\n</code>\n<|/\
    \ a tags=string,r,ascii,loops,rbind |>\n<| a tags=string,r,ascii,loops,rbind |>\n\
    I couldn't get the other answers to work, so I came up with this:\n<code>", "\n\
    \  s <- toupper(s)\n  if(!any(grepl('^[A-Z]+$', s))) {\n    res <- tolower(s)\n\
    \  } else {\n    res <- gsub('[[:alpha:]]', '', s)\n  }\n  res\n}\n\n</cell>\n\
    <cell>\nsolve('abcd') # 'dcba'\n</cell>\n<cell>\nsolve('hello') # 'olleh'\n</cell>\n\
    <cell>\nsolve('123') # '321'\n</cell>\n<text>\nGreedy\nIn the case of backtracking,\
    \ backtracking is a greedy algorithm. The greedy algorithm is to always try the\
    \ option that maximizes the expected number of moves instead of minimizing it.\n\
    \nSo the greedy algorithm will always try to choose the option that maximizes\
    \ the number of moves instead of minimizing it.\n\nWhen doing backtracking, it\
    \ would be interesting to know which algorithm is the best for solving this problem:\n\
    \nA* - It has many good implementations in R packages, but we could easily write\
    \ our own using recursion and back tracking.\nDFS - It is a recursive algorithm\
    \ which can be implemented in a few lines of code.\nBFS - It is a recursive algorithm\
    \ which can be implemented in a few lines of code.\nA* - It is also a recursive\
    \ algorithm. It just has a small twist in the algorithm.\n\nTo do this, we'll\
    \ use a greedy algorithm called as greedy algorithm which will choose the option\
    \ that maximizes the number of moves instead of minimizing it.\n\n\n</text>\n\
    <cell>", "\n    s <- str_replace_all(s, '([a-z])', paste0('\\\\1', toupper(s)))\n\
    \    s <- str_replace_all(s, '([A-Z])', paste0('\\\\1', tolower(s)))\n    s\n\
    }\n\n</cell>\n<cell>", "\n  s <- toupper(s)\n  s <- gsub(\"[a-z]\", \"\", s)\n\
    \  s <- gsub(\"[A-Z]\", \"\", s)\n  if (length(s) == 0) s\n  else s\n}\n</cell>\n\
    <cell>", "\n  s <- ifelse(!is.na(grep(\"[a-zA-z]\", s)), \n      gsub(\"([a-z])([A-Z])\"\
    , \"\\\\1\\\\U\\\\2\", s), \n      gsub(\"([a-z])([A-Z])\", \"\\\\1\\\\2\", s))\n\
    \  s\n}\n</code>\n<|/ a dscore=3 tags=string,r |>\n<| c |>\nThanks. Your solution\
    \ also works if you replace the '!' with 'is.na'. And also, if you replace '[[:alpha:]]'\
    \ with '[^[:alpha:]]'. It seems that the grep function doesn't work well when\
    \ there are other characters in the string as well.\n<|/ c |>\n<| c |>\nYes, the\
    \ regex [[:alpha:]] is incorrect. My bad. Thanks for pointing out. I had missed\
    \ it.\n<|/ c |>\n<| a dscore=3 |>\nAnother option using base R:\n<code>\nsolve<-function(s){\n\
    \    s=gsub(\"[[:alpha:]]\",\"\\\\\\\\U\\\\1\",s)\n    s=gsub(\"[[:alpha:]]\"\
    ,\"\\\\\\\\L\\\\1\",s)\n    s=gsub(\"[[:alpha:]]\",\"\\\\\\\\D\\\\1\",s)\n   \
    \ s=gsub(\"[[:alpha:]]\",\"\\\\\\\\N\\\\1\",s)\n    s\n}\n</code>\n<|/ a tags=string,r\
    \ |>\n<| a tags=string,r |>\nThe first thing to note is that your problem doesn't\
    \ require any complex string manipulation as you're only dealing with a single\
    \ character. Also, you can apply the same function to a set of strings using the\
    \ mapply function. The only thing that's a little more tricky is keeping track\
    \ of whether or not to reverse the characters (i.e. in upper or lower case), but\
    \ if you were to apply this to an array of strings, you can just do the same thing\
    \ for each string in the array.\nHere's a solution using mapply and lapply that\
    \ does what you want:\n<code>", "\n    s <- gsub(\" \", \"\", s)\n    x <- unlist(strsplit(s,\
    \ \"\"))\n    if (length(x) == 0) return(\"\")\n    y <- factor(x)\n    y <- levels(y)[toupper(levels(y))]\n\
    \    return(paste(y, collapse=\"\"))\n}\n</code>\n<|/ a dscore=2 tags=r |>\n<|\
    \ a tags=r |>\nHere's a way to reverse a string:\n<code>\nmyString <- \"Hello\
    \ World\"\nmyString2 <- strsplit(myString,\"[[:space:]]+\")[[1]]\nmyString2 <-\
    \ myString2[!is.na(myString2)]\nmyString2 <- paste(myString2[c(TRUE, FALSE)],\
    \ collapse=\"\")\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a way to\
    \ do it with the stringr package:\n<code>\nlibrary(stringr)\n\nmyString <- \"\
    Hello World\"\nmyString2 <- str_split(myString,\"[[:space:]]+\")[[1]]\nmyString2\
    \ <- myString2[!is.na(myString2)]\nmyString2 <- paste(myString2[c(TRUE, FALSE)],\
    \ collapse=\"\")\n\nprint(myString2)\n</code>\n<|/ a tags=r |>\n<| a tags=r dscore=1\
    \ |>\nHere is a solution with base R:\n<code>\nx <- \"Hello World\"\nmyString\
    \ <- unlist(strsplit(x, \"[[:space:]]+\"))\nmyString2 <- myString[!is.na(myString)]\n\
    myString2 <- paste(myString2[c(TRUE, FALSE)], collapse=\"\")\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\nIn R - \n<code>\ntest <- \"Hello World\"\ntest <- sub(\"\\\\\
    s\", \"\", test)\ntest <- gsub(\"[[:digit:]]\", \"\", test)\ntest <- gsub(\"[[:alpha:]]\"\
    , \"\", test)\ntest <- paste(test, collapse = \"\")\n</code>\n<|/ a tags=r |>\n\
    <| a |>\nThe base R version uses strsplit to split into characters and then paste\
    \ to paste them back together:\n<code>\ntest <- \"Hello World\"\ntest <- paste0(\n\
    \  unlist(strsplit(test, \"[[:space:]]\"))[!is.na(unlist(strsplit(test, \"[[:space:]]\"\
    )))],\n  collapse = \"\")\n</code>\n<|/ a tags=r dscore=0 |>\n", "\n  \n  if (is.character(s)){\n\
    \    \n    s_lower <- tolower(s)\n    \n    for(i in seq_along(s_lower)){\n  \
    \    \n      if(s_lower[i] == substr(s, i, 1)) \n      {\n        \n        if(substr(s,\
    \ i, 1) == substr(s_lower, i, 1)){\n          \n          s_lower[i] <- toupper(s_lower[i])\n\
    \          \n        } else {\n          \n          s_lower[i] <- tolower(s_lower[i])\n\
    \        }\n        \n      }\n      \n    }\n    \n    s_lower <- paste0(s_lower,\
    \ \"$\")\n    \n    s <- paste0(toupper(s), s_lower)\n    \n  }\n  \n  if (is.numeric(s)){\n\
    \    \n    s <- paste0(toupper(s), tolower(s))\n  }\n  \n  s\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=0 tags=string,r |>\nHere's my take on it:\n<code>\nreverse\
    \ <- function(x) {\n    x <- as.character(x)\n    x <- toupper(x)\n    x <- gsub(\"\
    (.)\", toupper, \"\\\\1\", x)\n    x <- paste0(rep(\"_\", nchar(x) - 1), x)\n\
    \    x <- paste0(toupper(x), x)\n    x <- paste0(sub(\"_$\", \"\", x), x)\n  \
    \  return(x)\n}\n\nreverse(\"He said\\nHello\")\n[1] \"eho say\\nhllo\"\n\nreverse(\"\
    1234\")\n[1] \"4321\"\n\nreverse(\"ab\")\n[1] \"AB\"\n\nreverse(\"#a@C\")\n[1]\
    \ \"#A@c\"\n\nreverse(\"a b c d\")\n[1] \"d c b a\"\n\nreverse(\"a a a a a\")\n\
    [1] \"a a a a a\"\n\nreverse(\"abba\")\n[1] \"abbA\"\n\nreverse(\"abba\")\n[1]\
    \ \"abbA\"\n\nreverse(\"abba\")\n[1] \"abbA\"\n</code>\n<|/ a |>\n<| c |>\nWhy\
    \ are you converting the string to character first?\n<|/ c |>\n<| a dscore=0 |>\n\
    I got this working with some trial and error. \n<code>\nreverse <- function(x)\
    \ {\n  x <- as.character(x)\n  x <- toupper(x)\n  x <- gsub(\"(.)\", toupper,\
    \ \"\\\\1\", x)\n  x <- paste0(rep(\"_\", nchar(x) - 1), x)\n  x <- paste", "\n\
    \  # Your code here\n  # return result\n}\n</code>\n<|/ a |>\n<| c |>\nYou should\
    \ be able to just pass `i` into `str_to_char` instead of `gsub('[a-z]', '', i)`;\
    \ that will probably be faster.\n<|/ c |>\n<| c |>\nIt seems that the code you\
    \ wrote will work for all lower case letters, but the question asks for an algorithm\
    \ that will work for all upper case letters. Also, `str_to_char` doesn't seem\
    \ to allow for passing in a string as an argument.\n<|/ c |>\n<| c |>\nThat's\
    \ right, `str_to_char` only converts one character.  I've edited the answer to\
    \ include a solution that will work for both lower and upper case letters.\n<|/\
    \ c |>\n<| c |>\nThanks for your help. I understand your algorithm and your code\
    \ works for the example in the question. However, when I run it on the full data\
    \ frame I get the error `Error in `[.data.frame`(df, , 2) : undefined columns\
    \ selected` for the following code `s <- df[,2]`. I feel like I've tried everything\
    \ I can think of. Any ideas?\n<|/ c |>\n<| c |>\nTry `s <- df$V3`\n<|/ c |>\n\
    <| a tags=r |>\nHere's my take on it:\n<code>\nfoo <- function(string) {\n   \
    \ string <- tolower(string)\n    string <- gsub(\" \", \"\", string)\n    string[string==\"\
    \ \"] <- NA\n    string <- paste(string[!is.na(match(string, LETTERS))], collapse\
    \ = \"\")\n    return(string)\n}\n\ntest <- c(\"apple\",\"banana\",\"cow\")\n\
    foo(test)", "\n  \n  # Check whether the string is empty\n  if(!length(s) ||\n\
    \     s == '#' ||\n     s == '@' || \n     s == '!' || \n     s == '*' || \n \
    \    s == '.' || \n     s == '?' || \n     s == '<' || \n     s == '>' || \n \
    \    s == '&' || \n     s == '(' || \n     s == ')') {\n    \n    # Return string\
    \ if it is empty\n    s\n    \n  } else {\n    \n    # Initialize result string,\
    \ \n    # and loop through the string\n    result <- s\n    for(i in seq_along(s))\
    \ {\n      \n      # Get character from the string,\n      # if it is lower case,\
    \ return it uppercase\n      # if it is upper case, return it lowercase\n    \
    \  # otherwise return the same character\n      if(s[i] >= 'a' && s[i] <= 'z')\
    \ {\n        result <- toupper(result)\n      } else if(s[i] >= 'A' && s[i] <=\
    \ 'Z') {\n        result <- tolower(result)\n      } else {\n        result <-\
    \ s[i]\n      }\n    }\n    \n    # Return the result\n    result\n  }\n}\n</cell>\n\
    <cell>\nsolve('1234')\n</cell>\n<text>\n4.5 Solve the HackerRank Challenge\n\n\
    </text>\n<text>\nA Hackerrank Challenge is a typical competition where you take\
    \ problem statements from various sources to solve some programming puzzles. Some\
    \ of the puzzles have many variations, some are very difficult to solve, and some\
    \ have infinite possibilities for solutions. In this challenge, you are given\
    \ a string of characters representing a mathematical expression, with each character\
    \ representing a variable, and you need to compute the value of the expression\
    \ after substituting in the value of each variable. An example input string might\
    \ look like this:\n\n$$\\frac{5}{2}+\\frac{3}{4}+\\frac{4}{3}+\\frac{7}{4}+\\\
    frac{3}{2}+\\frac{7}{6}+\\frac{9}{6}$$\n\nEach character in the string represents\
    \ one variable, with the value corresponding to the variable in a given index.\
    \ For example, in the input string, $\\frac{5}{2}$ is the value of the variable\
    \ $\\frac{5}{2}$. The character $\\frac$ represents a new variable, which can\
    \ be substituted for any valid variable name. Once each variable is substituted\
    \ in its value, the expression becomes a constant and is ready to evaluate (this\
    \ example input would yield $28$).\n\nThe function you created in the previous\
    \ exercise can be used to evaluate the expression. Run the cell below to see an\
    \ example of how it can be used.\n\n\n</text>\n<cell>", "\n  for(i in seq_along(s))\
    \ {\n    if(substr(s, i, 1) == toupper(substr(s, i, 1))) {\n      s <- substr(s,\
    \ i, nchar(s))\n    } else {\n      s <- substr(s, i, nchar(s))\n    }\n  }\n\
    \  return(s)\n}\n", "\n  s <- gsub(\" \", \"\", s)\n  i <- 1\n  res <- \"\"\n\
    \  while( i <= length(s)) {\n    # if(grepl(\"[0-9]\",s[-i]) | grepl(\"[a-z]\"\
    ,s[-i])) \n    if(grepl(\"[0-9]\",s[i]) | grepl(\"[a-z]\",s[i])) {\n      rec\
    \ <- substring(s, i, i)\n      res <- gsub(toupper(substr(rec,1,1)), toupper(rec),\
    \ res)\n      i <- i + 1 \n    }\n    else {\n      res <- c(res, substr(s, i,\
    \ i))\n      i <- i + 1\n    }\n  }\n  return(res)\n}\n</code>\n<|/ a tags=r,string,algorithm\
    \ |>\n<| c |>\nI am not sure why this answer is voted down, but I like this solution\
    \ because it's simple and efficient. Perhaps I wasn't as clear as I could be,\
    \ but I was thinking of it in a different way. Thanks!\n<|/ c |>\n<| c |>\nThanks\
    \ for your comment! I realized after I posted the answer that the solution I posted\
    \ was wrong. Have updated it to correct the wrong answer!\n<|/ c |>\n<| c |>\n\
    I think that you made my life easier by changing the function name from `solve`\
    \ to `mysolve`. Not sure why my solution was downvoted, though.\n<|/ c |>\n<|\
    \ c |>\nThanks for your comment! It was a mistake on my part. The function name\
    \ shouldn't have used the `solve` word. It was a mistake on my part when I copied\
    \ your solution. I've updated the post to fix this error. Thanks for your comment\
    \ as well.\n<|/ c |>\n<| a tags=r,string,algorithm |>\nThis is an interesting\
    \ problem, although I do not have an elegant solution.\nThe idea is to use regular\
    \ expressions to replace the characters in place to replace them with the uppercase\
    \ version. \nHere is an example in Python, with two replacements: (a) uppercase\
    \ all letters, and (b) lowercase all letters.\n<code>\nimport re\n\ndef solve(s):\n\
    \    for letter in s:\n        upper = letter.isupper()\n        lower = letter.islower()\n\
    \        if upper:\n            letter = letter.upper()\n        if lower:\n \
    \           letter = letter.lower()\n\n        s = re.sub(r'[' + letter + r']',\
    \ letter, s)\n\n    return s\n\nprint(solve('Hello World!'))\n</code>\nThis prints\
    \ \n<code>\n'World Hello!' \n</code>\n<|/ a dscore=1 |>\n<| a tags=r,string,algorithm\
    \ |>\nHere is my solution", "\n  res <- '#'\n  for (let in s) {\n    if (is.character(let))\
    \ {\n      let <- toupper(let)\n    }\n    res <- paste0(res, let)\n  }\n  return(res)\n\
    }\n</code>\n<|/ a tags=r,regex,python,python-3.x dscore=1 |>\n<| c |>\nThe function\
    \ should be able to handle even a single/empty string as an input and return an\
    \ empty/0 string as output.\n<|/ c |>\n<| c |>\nI see, thank you for pointing\
    \ out! I've updated the function accordingly.\n<|/ c |>\n<| a tags=r,regex,python,python-3.x\
    \ |>\nThis can be easily solved with just a single function using Python's built\
    \ in string methods. No packages required.\n<code>\ndef reverse_string(string):\n\
    \    string_list = list(string)\n    string_list.sort()\n    return \"\".join(string_list)\n\
    \nstring = \"ab bc ac ba\"\nprint(reverse_string(string))\n", "\n  v <- toupper(tolower(s))\n\
    \  if (nchar(v) == 0){\n    v\n  } else {\n    paste(ifelse(nchar(v) > 1, '',\
    \ toupper(tolower(v)), tolower(toupper(v))),\n           collapse = \"\")\n  }\n\
    }\n\nsolve <- function(s) {\n  v <- toupper(tolower(s))\n  if (nchar(v) == 0){\n\
    \    v\n  } else {\n    paste(ifelse(nchar(v) > 1, '', toupper(tolower(v)), tolower(toupper(v))),\n\
    \           collapse = \"\")\n  }\n}\n</code>\n<|/ a tags=r,string,r-faq dscore=5\
    \ |>\n<| c |>\nThe solution doesn't actually work for the string: `solve('hEllO')`.\
    \ Not sure why that is.\n<|/ c |>\n<| a tags=r,string,r-faq dscore=3 |>\nReplicated\
    \ from my previous answer:\n<code>\nsolve <- function(s) {\n  v <- toupper(tolower(s))\n\
    \  if (nchar(v) == 0){\n    v\n  } else {\n    paste(ifelse(nchar(v) > 1, '',\
    \ toupper(tolower(v)), tolower(toupper(v))),\n           collapse = \"\")\n  }\n\
    }\n</code>\n<|/ a |>\n<| c |>\nPlease explain what your code does and how it does\
    \ it. Don't just dump a block of code here.\n<|/ c |>\n<| c |>\nThe `ifelse` statement\
    \ just checks if the length of the string is greater than one (i.e. if there's\
    \ more than one character). So, if the length of the string is 1, `paste` will\
    \ just return the string. If the length is 2, it will return the string converted\
    \ to uppercase and to lower case (i.e. `ABC` becomes `abc`), otherwise, `paste`\
    \ will return an empty string. Hope that's clear.\n<|/ c |>\n<| c |>\nI see, that's\
    \ nice, but I still don't see how this answers the question. Can you provide some\
    \ explanation on that?\n<|/ c |>\n<| a tags=r,string,r-faq |>\nOne way is to use\
    \ str_replace_all from stringr:\n<code>\nlibrary(stringr)\nstr_replace_all(s,\
    \ '[a-z]', toupper(tolower(s)))", "\n  \n  res <- s\n  \n  sapply(1:nchar(s),\
    \ function(i) \n    ifelse(is.na(i), res, \n           ifelse(toupper(s[i]) !=\
    \ s[i], \n                  paste0(toupper(substring(res, 1, i - 1)), \n     \
    \                    tolower(substring(res, i + 1, nchar(res)))), \n         \
    \         res)))\n}\n\nsolve <- function(s) {\n  \n  res <- s\n  \n  sapply(1:nchar(s),\
    \ function(i) \n    ifelse(is.na(i), res, \n           ifelse(toupper(s[i]) !=\
    \ s[i], \n                  paste0(toupper(substring(res, 1, i - 1)), \n     \
    \                    tolower(substring(res, i + 1, nchar(res)))), \n         \
    \         res)))\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nAs a note: this is probably\
    \ a better answer than mine, so you might want to accept it :) Thanks.\n<|/ c\
    \ |>\n<| a tags=r |>\nAnother way:\n<code>\nmyfun <- function(s) {\n   x <- nchar(s)\n\
    \   sapply(x, function(i) if(is.na(i)) s else paste(toupper(substring(s, 1, i-1)),\n\
    \                                               tolower(substring(s, i+1, x[i]))))\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't reverse the cases in the\
    \ middle of words.\n<|/ c |>\n<| c |>\n: Oops you're right, I missed that requirement.\
    \ Should be fixed now.\n<|/ c |>\n<| a dscore=1 |>\nHere's a slightly different\
    \ approach:\n<code>\nrevs <- c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"\
    ,\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\"\
    ,\"v\",\"w\",\"x\",\"y\",\"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"\
    ,\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\"\
    ,\"V\",\"W\",\"X\",\"Y\",\"Z\")\nrevs <- unlist(revs)\n\ntoupper <- function(s)\
    \ {\n    paste(sapply(strsplit(s, \"\"), function(x) revs[match(x, revs)]), collapse=\"\
    \")\n}\n\ntolower <- function(s) {\n    paste(sapply(strsplit(s, \"\"), function(x)\
    \ revs[match(x, revs)]), collapse=\"\")\n}\n\nsapply(s, tolower)\n[1] \"", "\n\
    \    \n    if (sum(grepl(\"[a-zA-Z]\", s)) != 0){\n        res <- s\n        for(i\
    \ in 1:length(s)) {\n          if(substr(s[i],1,1) %in% toupper(substr(s[i],1,1)))\n\
    \            res <- toupper(substr(s[i],1,1)) + substr(s[i],2,nchar(s[i])-1)\n\
    \            \n          if(substr(s[i],1,1) %in% tolower(substr(s[i],1,1)))\n\
    \            res <- tolower(substr(s[i],1,1)) + substr(s[i],2,nchar(s[i])-1)\n\
    \        }\n        \n    }\n    else{\n        res <- gsub(\"[a-z]\",toupper(substr(s,1,1)),gsub(\"\
    [A-Z]\",tolower(substr(s,1,1)),s))\n    }\n    res\n}\n</cell>\n<cell>\nsolve(1234)\n\
    </cell>\n<text>\n3.3 Return all the possible combinations of size k from vector\
    \ of size n\n\n\n</text>\n<cell>", "\n  res <- character(length = length(s))\n\
    \  for(i in seq_along(s)){\n    if(substr(s[i], 1, 1) == '#'){\n      if(substr(s[i],\
    \ 2, 1) != '@'){\n        res[i] <- toupper(substr(s[i], 2, 1))\n      }else{\n\
    \        res[i] <- toupper(substr(s[i], 2, 2))\n      }\n    }else{\n      res[i]\
    \ <- toupper(s[i])\n    }\n  }\n  if(sum(grepl('[^A-Za-z0-9]', s)) > 0){\n   \
    \ for(i in seq_along(s)){\n      if(substr(s[i], 1, 1) != '#'){\n        res[i]\
    \ <- toupper(substr(s[i], 1, 1))\n      }\n    }\n  }\n  return(res)\n}\n", "\n\
    \  if (grepl(\"[[:alpha:]]\", s)) {\n    s <- tolower(s)\n  } else {\n    s <-\
    \ toupper(s)\n  }\n  s <- gsub(\"[^[:alpha:]]\", \"\", s)\n  s\n}\n</code>\n<|/\
    \ a tags=string,r |>\n<| c |>\nPlease add an explanation of why this code solves\
    \ the questioner's problem.\n<|/ c |>\n<| a dscore=1 |>\nHere is my approach for\
    \ this problem:\n<code>\ns<-\"#a@C\" #your string\ns<-tolower(s)\ns<-gsub(\"[a-z]\"\
    ,\"\",s) #remove all letters from s\ns<-gsub(\"[[:space:]]\",\"\",s) #remove all\
    \ spaces from s\ns<-gsub(\"[[:punct:]]\",\"\",s) #remove all punctuations from\
    \ s\ns<-paste0(substring(s,1,1),substring(s,2,nchar(s)),substring(s,(nchar(s)+1),nchar(s)))\
    \ #paste everything but the first and the last character\n</code>\n<|/ a tags=string,r\
    \ |>\n<| c |>\nCan you explain what each step does?\n<|/ c |>\n<| a dscore=1 |>\n\
    Since this seems rather similar to another question I answered here, I will post\
    \ my answer (which you can find here). I am also providing a benchmark comparing\
    \ the solutions using stringi and stringr. \n<code>\nlibrary(stringi)\nlibrary(stringr)\n\
    \ns1 <- c(\"1234\")\ns2 <- c(\"ab\")\ns3 <- c(\"#a@C\")\n\nall.equal(s1,stri_replace_all_fixed(s1,regex\
    \ = \"[a-z]\",replacement = \"\"))\n[1] TRUE\n\nall.equal(s2,stri_replace_all_fixed(s2,regex\
    \ = \"[a-z]\",replacement = \"\"))\n[1] TRUE\n\nall.equal(s3,stri_replace_all_fixed(s3,regex\
    \ = \"[a-z]\",replacement = \"\"))\n[1] TRUE\n\nlibrary(microbenchmark)\n\nmb\
    \ <- microbenchmark(\n  stringi = stri_replace_all_fixed(s1,regex = \"[a-z]\"\
    ,replacement = \"\"),\n  stringr = stri_replace_all_fixed(s2,regex = \"[a-z]\"\
    ,replacement = \"\"),\n  stringr2 = stri_replace_all_fixed(s3,regex = \"[a-z]\"\
    ,replacement = \"\"),\n  times = 1000\n)\n\nmb\nUnit: microseconds\n         \
    \           expr       min        lq      mean   median        uq       max neval\
    \ cld\n    stri_replace_all_fixed(s1, regex = \"[a-z]\", replacement = \"\") \
    \ 183.", "\n  if (length(s) == 0) return(\"\")\n\n  # Create a empty list of new\
    \ characters\n  new_s <- character(0)\n  \n  # Loop through the string and add\
    \ them to the new list\n  for (i in 1:length(s)){\n    if (s[i] >= 'a' && s[i]\
    \ <= 'z'){\n      new_s <- c(new_s, toupper(s[i]))\n    } else if (s[i] >= 'A'\
    \ && s[i] <= 'Z'){\n      new_s <- c(new_s, tolower(s[i]))\n    } else {\n   \
    \   new_s <- c(new_s, s[i])\n    }\n  }\n  \n  # Return the new string\n  return(new_s)\n\
    }\n</code>\n<|/ a tags=r,string |>\n<| a dscore=2 tags=r,string |>\n<code>\nsolve<-function(x){\n\
    \  x=toupper(tolower(x))\n  y=gsub(\"(^|[^a-z])[aA-zZ]+\",\"\\\\1\\\\U\\\\1\"\
    , x)\n  z<-gregexpr(\"[^A-Z]\",y)\n  z[[1]][nzchar(z[[1]])]<-paste(z[[1]][nzchar(z[[1]])],z[[1]][nzchar(z[[1]])][1:length(z[[1]])-1],sep=\"\
    \")\n  return(unlist(strsplit(y,\"\")))\n}\n</code>\nThis works for\n<code>\n\
    solve(c(\"12\",\"a1b2c3\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"\
    ,\"j\",\"k\",\"l\"))\n[1] \"123\" \"a1b2c3\" \"abc\" \"b\" \"c\" \"d\" \"e\" \"\
    f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\"\n</code>\n<|/ a |>\n<| a tags=r,string\
    \ |>\nTo solve this problem in base R, you can:\n<code>\nsapply(strsplit(s, \"\
    \"), function(x) paste0(x[!grepl(\"[a-z]\", x)], x[grepl(\"[a-z]\", x)]))\n</code>\n\
    This uses the fact that ! negates the result of a logical test, which returns\
    \ TRUE for any character value which does not match \"[a-z]\".\n<|/ a dscore=1\
    \ |>\n<| a tags=r,string dscore=1 |>\nAnother base R solution that avoids regular\
    \ expressions:\n<code>\nsolve<-function(x){\n  return(paste(\n    apply(strsplit(x,\
    \ \"\"), 2, \n      function(y) paste(y[!grepl(\"[a-z]\", y)], y[grepl(\"[a-z]\"\
    , y)])))\n}\n</code>\n<|/", "\n    s <- gsub(\"[^[:alpha:]]\", replacement = \"\
    \\u0000\", x = s)\n    s <- toupper(tolower(s))\n    res <- s\n    return(res)\n\
    }\n</code>\n<|/ a dscore=3 tags=string,r,reverse |>\n<| c |>\nThe function doesn't\
    \ work. Try with '#a@C'.\n<|/ c |>\n<| c |>\nThis was inspired by [this answer](https://stackoverflow.com/a/45301819/4975218)\
    \ which uses `regmatches` and `regmatchesAsList`.\n<|/ c |>\n<| a dscore=3 |>\n\
    Here is a solution using stringi package in R. I am not an R expert so please\
    \ pardon my lack of knowledge in this area.\n<code>\nlibrary(stringi)\nlibrary(magrittr)\n\
    \nrev <- function(x){\n  stri_replace_all_regex(x, \"[[:alpha:]]\",\n        \
    \               function(x) toupper(tolower(x))\n  )\n}\n\nrev(\"1234\") %>% stringi::stri_trans_general()\n\
    \n[1] \"4321\"\n</code>\n<|/ a tags=string,r,reverse |>\n<| a |>\nA solution with\
    \ base:\n<code>\nrev <- function(x){\n  stopifnot(is.character(x))\n  y <- paste0(x[1L],\
    \ substring(x, 2L))\n  paste0(toupper(tolower(y)), y[2L])\n}\n\nrev(\"1234\")",
  "\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  ", "\n\tresult <- s\n\tfor(i in 1:length(s))\n\
    \t{\n\t\tifelse(sapply(s, is.character), result <- toupper(result), result <-\
    \ tolower(result))\n\t}\n\treturn(result)\n}\n</cell>\n<cell>\n%Rpush s\nsolve(s=s)\n\
    </cell>\n<cell>\n%Rpull s\n</cell>\n<cell>", "\n  s <- tolower(s)\n  if (grepl(\"\
    [a-z]\", s)) toupper(s) else s\n}\n</code>\n<|/ a dscore=2 tags=r,string,regex\
    \ |>\n<| c |>\nI edited my answer to add an example to match your expected result\n\
    <|/ c |>\n<| c |>\nYou don't need to use regex for this. Just use `toupper(s)`.\n\
    <|/ c |>\n<| a dscore=2 |>\nI thought I'd post a solution that uses base R only:\n\
    <code>\nrev <- function(s, ignore.case = FALSE) {\n  s <- tolower(s)\n  s <- paste0(s[order(nchar(s),\
    \ as.integer(s), ignore.case = ignore.case)], collapse = \"\")\n  s\n}\n</code>\n\
    The idea is to sort the characters by their length in descending order, then reverse\
    \ the order, then collapse the characters and put a space between them (for strings\
    \ with more than one letter).\n<code>\nrev(\"AB\", ignore.case = TRUE)", "\n \
    \   s <- str_replace_all(s, 'a', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s,\
    \ 'A', toupper(substr(s, 2, 1)))\n    s <- str_replace_all(s, 'b', tolower(substr(s,\
    \ 1, 1)))\n    s <- str_replace_all(s, 'B', tolower(substr(s, 2, 1)))\n    s <-\
    \ str_replace_all(s, 'c', tolower(substr(s, 3, 1)))\n    s <- str_replace_all(s,\
    \ '#', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s, '$', toupper(substr(s,\
    \ 1, 1)))\n    s <- str_replace_all(s, '%', tolower(substr(s, 1, 1)))\n    s <-\
    \ str_replace_all(s, '&', tolower(substr(s, 1, 1)))\n    s <- str_replace_all(s,\
    \ '^', tolower(substr(s, 1, 1)))\n    s <- str_replace_all(s, '*', tolower(substr(s,\
    \ 1, 1)))\n    s <- str_replace_all(s, '_', tolower(substr(s, 1, 1)))\n    s <-\
    \ str_replace_all(s, '~', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s,\
    \ '!', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s, '<', tolower(substr(s,\
    \ 1, 1)))\n    s <- str_replace_all(s, '>', tolower(substr(s, 1, 1)))\n    s <-\
    \ str_replace_all(s, '-', tolower(substr(s, 1, 1)))\n    s <- str_replace_all(s,\
    \ '_', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s, '-', tolower(substr(s,\
    \ 1, 1)))\n    s <- str_replace_all(s, '_', toupper(substr(s, 1, 1)))\n    s <-\
    \ str_replace_all(s, '/', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s,\
    \ '|', tolower(substr(s, 1, 1)))\n    s <- str_replace_all(s, '\\\\', tolower(substr(s,\
    \ 1, 1)))\n    s <- str_replace_all(s, '~', toupper(substr(s, 1, 1)))\n    s <-\
    \ str_replace_all(s, '\\'', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s,\
    \ '/', tolower(substr(s, 1, 1)))\n    s <- str_replace_all(s, '-', toupper(substr(s,\
    \ 1, 1)))\n    s <- str_replace_all(s, '-', tolower(substr(s, 1, 1)))\n    s <-\
    \ str_replace_all(s, '\\'', toupper(substr(s, 1, 1)))\n    s <- str_replace_all(s,\
    \ '-', tolower(substr(s, 1, ", "\n  if(sum(grepl('[a-z]', s)) > 0) return (rev(gsub(paste0('(?<=.)(?=[^a-z])',\
    \ s, '(?=.)'), paste0('(?<=^)(?=[^a-z])', toupper(s), '.'), s)))\n  else return(s)\
    \ -> \n}\n", "\n  \n  res <- ''\n  for (i in 1:nchar(s)){\n    if(!(i %in% c(0:9))\
    \ & (s[i] %in% 'a' | s[i] %in% 'A' | s[i] %in% 'b' | s[i] %in% 'B' | s[i] %in%\
    \ 'c' | s[i] %in% 'C')){\n      \n      res <- paste0(rev(c(s[i],rev(s[i+1])[[1]])),collapse='')\n\
    \      break\n    }\n  }\n  \n  res <- paste0(rev(s),collapse='')\n  return(res)\n\
    }\n\nsolve('1234')", "\n  s <- gsub(\"[^[:alpha:]]\", \"\", s)\n  s <- toupper(tolower(s))\n\
    \  s <- gsub(\"[[:alpha:]]\", \"\", s)\n  return(s)\n}", "\n  if(!is.character(s)\
    \ || nchar(s) <= 1) s\n  else if(all(grepl('[a-zA-Z]', s))) toupper(tolower(s))\n\
    \  else s\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nTry this in R :\n<code>\nsolve2\
    \ <- function(string) {\n  n <- nchar(as.character(string))\n  if (n==1) return(string)\n\
    \  if (n>1) {\n    if (grepl(\"[[:alpha:]]\", string)) return(toupper(tolower(string)))\
    \ \n    return(string)\n  }\n}\n\nsolve2(\"ABC\") # returns 'ABC'\nsolve2(\"abcd\"\
    ) # returns 'abcd'\nsolve2(\"AbC\") # returns 'AbC'\n</code>\n<|/ a dscore=2 tags=r,stringi,regex\
    \ |>\n<| a tags=r,stringi,regex |>\nHere is another option that uses stringi.\
    \  It will also work for more than just alphabetic characters.\n<code>\nlibrary(stringi)\n\
    \ns <- c(\"AbC\", \"abcd\", \"#a@C\", \"1234\")\n\nsapply(s, function(x) {\n \
    \ stri_replace_first_regex(x, \"[a-z]+\", stri_replace_all_regex(x, \"[a-z]+\"\
    , toupper(tolower(x))))\n})\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,stringi,regex\
    \ |>\nIf all you want to do is upper/lower a letter, you can just do:\n<code>\n\
    solve2 <- function(string) {\n  if (nchar(string) == 1) return(string)\n  sapply(string,\
    \ function(x) toupper(tolower(x))) \n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    I like Jim S' answer. I just wanted to provide another approach that might be\
    \ useful in more complex scenarios:\n<code>\nlibrary(stringi)\nlibrary(tidyverse)\n\
    library(stringr)\n", "\n  s <- as.character(s)\n  s <- gsub('^([a-z])', \n   \
    \          function(x){\n               x1 <- tolower(x)\n               x2 <-\
    \ ifelse(length(x1) == 1, x1, paste0(rep(x1[1], \n                           \
    \                      (length(x1) - 1)), x1[-1]))\n               x2\n      \
    \       }, s)\n  s <- gsub('([A-Z])', \n             function(x){\n          \
    \     x1 <- toupper(x)\n               x2 <- ifelse(length(x1) == 1, x1, paste0(rep(x1[-1],\
    \ \n                                                 (length(x1) - 1)), x1[1]))\n\
    \               x2\n             }, s)\n  s\n}\n", "\n  res <- \"\"\n  for(i in\
    \ 1:nchar(s)){\n    while(!(i %in% c(1,nchar(s)))){\n      s2 <- substr(s,1,i)\n\
    \      if(grepl(\"[a-z]\",s2)) \n        res <- paste(toupper(s2), substr(s,i,nchar(s)),\
    \ sep = \"\")\n      else\n        res <- paste(substr(s,1,i), toupper(s2), sep\
    \ = \"\")\n      i <- i + 1\n    }\n  }\n  res\n}\n</code>\n<|/ a dscore=1 tags=r,string\
    \ |>\n<| c |>\nThis is an interesting solution, but I'm interested in the most\
    \ efficient way of doing this for large strings as my problem has a length of\
    \ about 500 characters.\n<|/ c |>\n<| a dscore=0 tags=r,string |>\nThis solution\
    \ uses regex and only uses a single regular expression (i.e. no loops).  It does\
    \ make use of the fact that the first letter is capitalized in the case of \"\
    lower\".\n<code>\nsolve2 <- function(s) {\n  unlist(lapply(regmatches(s, gregexpr(\"\
    ([a-z])(?!\\\\1)\", s)), function(x) paste0(toupper(x[1]), x[2])))\n}\n\nsolve2(\"\
    1234\")", "\n  chars <- tolower(s)\n  if(grepl('[a-zA-Z]', chars)) {\n    uppers\
    \ <- toupper(chars)\n    paste0(toupper(chars), tolower(uppers))\n  } else if(length(chars)\
    \ == 0) {\n    s\n  }\n}\n\nsolve(\"a1b2c\")\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=string,r |>\nUsing regular expressions you can do\n<code>\ns <- \"a1b2c\"\
    \ngsub(\"([a-z])\", \"\\\\U\\\\1\", s)", "\n  s <- toupper(s)\n  if (str_detect(s,\
    \ '[a-z]')) {\n    s <- tolower(s)\n  }\n  s\n}\n\n</code>\n<|/ a tags=r,function,string\
    \ |>\n<| a tags=r,function,string |>\nThe most straight-forward solution that\
    \ I can think of is using stringi::stri_reverse for string manipulation, which\
    \ also has an option to convert lowercase to uppercase.\n<code>\nlibrary(stringi)\n\
    stri_reverse(s)", "\n  if(length(s) == 0) {\n    return(paste0(rep(\"\", length(s)),\
    \ collapse = \"\"))\n  } else {\n    chars <- sapply(s, is.character)\n    chars[chars]\
    \ <- toupper(chars[chars])\n    chars[!chars] <- tolower(chars[!chars])\n    return(paste0(chars,\
    \ collapse = \"\"))\n  }\n}\n\nsolve(substr(s, 1, 1))", "\n    l <- gregexpr(\"\
    [a-z]\", s)\n    g <- gregexpr(\"[A-Z]\", s)\n    l <- sort(l)\n    g <- sort(g)\n\
    \    i <- which(l < g)\n    g <- g[i]\n    s <- ifelse(is.na(g), s, toupper(substr(s,\
    \ l, g - l)))\n    s <- ifelse(is.na(l), s, tolower(substr(s, 1, g - 1)))\n  \
    \  return(s)\n}\n", "\n  s <- nchar(s)\n  s2 <- sapply(s, function(x) toupper(x)\
    \ if is.character(x) else x)\n  s3 <- paste(s2, collapse = '')\n  s4 <- paste(s3,\
    \ collapse = '')\n  s5 <- paste(s4, collapse = '')\n  s6 <- paste(s5, collapse\
    \ = '')\n  s6 <- nchar(s6)\n  s6 <- paste(s6, collapse = '')\n  s6 <- paste(s6,\
    \ collapse = '')\n  s7 <- paste(s6, collapse = '')\n  s8 <- paste(s7, collapse\
    \ = '')\n  s9 <- paste(s8, collapse = '')\n  s10 <- paste(s9, collapse = '')\n\
    \  s11 <- paste(s10, collapse = '')\n  s12 <- paste(s11, collapse = '')\n  s13\
    \ <- paste(s12, collapse = '')\n  s14 <- paste(s13, collapse = '')\n  s15 <- paste(s14,\
    \ collapse = '')\n  s16 <- paste(s15, collapse = '')\n  s17 <- paste(s16, collapse\
    \ = '')\n  s18 <- paste(s17, collapse = '')\n  s19 <- paste(s18, collapse = '')\n\
    \  s20 <- paste(s19, collapse = '')\n  s21 <- paste(s20, collapse = '')\n  s22\
    \ <- paste(s21, collapse = '')\n  s23 <- paste(s22, collapse = '')\n  s24 <- paste(s23,\
    \ collapse = '')\n  s25 <- paste(s24, collapse = '')\n  s26 <- paste(s25, collapse\
    \ = '')\n  s27 <- paste(s26, collapse = '')\n  s28 <- paste(s27, collapse = '')\n\
    \  s29 <- paste(s28, collapse = '')\n  s30 <- paste(s29, collapse = '')\n  s31\
    \ <- paste(s30, collapse = '')\n  s32 <- paste(s31, collapse = '')\n  s33 <- paste(s32,\
    \ collapse = '')\n  s34 <- paste(s33, collapse = '')\n  s35 <- paste(s34, collapse\
    \ = '')\n  s36 <- paste(s35, collapse = '')\n  s37 <- paste(s36, collapse = '')\n\
    \  s38 <- paste(s37, collapse = '')\n  s39 <- paste(s38, collapse = '')\n  s40\
    \ <- paste(s39, collapse = '')\n  s41 <- paste(s", "\n    s <- gsub(letters,toupper,s)\n\
    \    s <- gsub(letters,tolower,s)\n    if(length(s)==0) {\n        res <- s\n\
    \    } else {\n        res <- paste0(substring(s,1,1),substring(s,2,nchar(s)),\
    \ substring(s,nchar(s),nchar(s))) \n    }\n    return(res)\n}\n</cell>\n<cell>",
  "\n  if(nchar(s) != 0) {\n    lower <- tolower(s)\n    upper <- toupper(s)\n   \
    \ rev <- gsub(\".\", \"\", lower)\n    if(toupper(rev) != upper) {\n      rev\
    \ <- gsub(\".\", \"\", upper)\n    }\n    return(rev)\n  } else {\n    rev <-\
    \ gsub(\".\", \"\", s)\n    return(rev)\n  }\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks! Your answer works well. Would you mind explaining what does gsub(\".\"\
    , \"\", lower) and gsub(\".\", \"\", upper) do? I tried to look them up, but couldn't\
    \ find anything useful.\n<|/ c |>\n<| c |>\nYes sure but this would take too long\
    \ to explain and I didn't want to take that much time. Here you go `gsub` stands\
    \ for `global substitution` and `.` stands for `match any character`. So `\"ab.cd\"\
    ` is replace by `\"\"`. The `\"\"` is also a special character in regex which\
    \ denotes \"any string\". So `gsub(\".\", \"\", lower)` takes the `lower` string,\
    \ removes everything and leaves us only `\"ab\"` and `gsub(\".\", \"\", upper)`\
    \ does the same for `upper` which would be `\"ABC\"`.\n<|/ c |>\n<| c |>\nThank\
    \ you so much! I really appreciate your time explaining it!\n<|/ c |>\n<| a |>\n\
    Using stringr we can use str_replace_all (from the package stringr) which uses\
    \ str_replace_all from the package stringi which uses stri_replace_all from the\
    \ package stringi:\n<code>\nlibrary(stringr)\nx <- \"AbC.d\"\nstr_replace_all(x,\
    \ pattern = \"(?<=[.])(.)\", replacement = \"\")\n\n[1] \"AbC.d\"\n</code>\nOr\
    \ as mentioned:\n<code>\nstr_replace_all(x, pattern = \"(?<=[.])(.)\", replacement\
    \ = \"\")\n\n[1] \"AbC.d\"\n</code>\n<|/ a dscore=2 tags=string,r |>\n<| c |>\n\
    Awesome answer! I learned a lot from it!\n<|/ c |>\n<| a |>\nWe can use gsub\n\
    <code>\ngsub(\".\", \"\", string)\n</code>\n<|/ a dscore=2 tags=string,r |>\n\
    <| c |>\nThank you so much! I really appreciate your time explaining it!\n<|/\
    \ c |>\n<| a dscore=", "\n    \n    # Find length of string\n    len <- nchar(s);\n\
    \    \n    # Store all possible characters and their case\n    all <- data.frame(char\
    \ = s, case = toupper(s), stringsAsFactors = F);\n    \n    # Find all valid cases\
    \ and characters by using lapply function\n    valid <- lapply(strsplit(s, \"\"\
    ), function(x) {\n        \n        # Get character at index\n        character\
    \ <- x[len];\n        \n        # If character is a letter\n        if (letter\
    \ %in% x) {\n            \n            # If character is not upper\n         \
    \   if (!letter %in% toupper(x)) {\n                \n                # Keep character\
    \ as it is but add lowercase version\n                character <- paste0(character,\
    \ tolower(x));\n            }\n            else {\n                # Keep character\
    \ as it is but add uppercase version\n                character <- paste0(character,\
    \ toupper(x));\n            }\n        }\n        else if (!letter %in% toupper(x))\
    \ {\n            \n            # Keep character as it is but add lowercase version\n\
    \            character <- paste0(character, tolower(x));\n        }\n        else\
    \ {\n            \n            # Keep character as it is but add uppercase version\n\
    \            character <- paste0(character, toupper(x));\n        }\n        \n\
    \        # Return result as a data.frame\n        return(data.frame(character\
    \ = character, case = character));\n    });\n    \n    # Extract valid characters\
    \ and cases and paste them back together\n    valid <- do.call(rbind, valid);\n\
    \    \n    # Replace all invalid characters with NA and remove NA rows and columns\n\
    \    all[is.na(all$case), 1] <- NA;\n    all[is.na(all$char), 2] <- NA;\n    \n\
    \    # Replace all NA characters with valid ones\n    all[is.na(all$char), ] <-\
    \ valid[is.na(all$char), ];\n    \n    # Extract valid characters and cases\n\
    \    valid <- all[is.na(all$case), ];\n    \n    # Extract valid characters and\
    \ cases and replace NA with valid ones\n    valid[is.na(valid$case), 2] <- valid[is.na(valid$case),\
    \ 1]\n    \n    # Replace all NA with valid ones\n    valid[is.na(valid$case),\
    \ 1] <- valid[is.na(valid$case), 2]\n    \n    # Return result\n    valid$character\
    \ <- as.character(valid$character);\n    return(paste(valid$character, valid$case));\n\
    }", "\n    \n    cat('Input:')\n    cat(sprintf(\"'%s', \", s))\n    \n    s <-\
    \ str_replace_all(s, 'a' , 'A')\n    s <- str_replace_all(s, 'b' , 'B')\n    s\
    \ <- str_replace_all(s, 'c' , 'C')\n    s <- str_replace_all(s, 'd' , 'D')\n \
    \   s <- str_replace_all(s, 'e' , 'E')\n    s <- str_replace_all(s, 'f' , 'F')\n\
    \    s <- str_replace_all(s, 'g' , 'G')\n    s <- str_replace_all(s, 'h' , 'H')\n\
    \    s <- str_replace_all(s, 'i' , 'I')\n    s <- str_replace_all(s, 'j' , 'J')\n\
    \    s <- str_replace_all(s, 'k' , 'K')\n    s <- str_replace_all(s, 'l' , 'L')\n\
    \    s <- str_replace_all(s, 'm' , 'M')\n    s <- str_replace_all(s, 'n' , 'N')\n\
    \    s <- str_replace_all(s, 'o' , 'O')\n    s <- str_replace_all(s, 'p' , 'P')\n\
    \    s <- str_replace_all(s, 'q' , 'Q')\n    s <- str_replace_all(s, 'r' , 'R')\n\
    \    s <- str_replace_all(s, 's' , 'S')\n    s <- str_replace_all(s, 't' , 'T')\n\
    \    s <- str_replace_all(s, 'u' , 'U')\n    s <- str_replace_all(s, 'v' , 'V')\n\
    \    s <- str_replace_all(s, 'w' , 'W')\n    s <- str_replace_all(s, 'x' , 'X')\n\
    \    s <- str_replace_all(s, 'y' , 'Y')\n    s <- str_replace_all(s, 'z' , 'Z')\n\
    \    \n    cat('Output:')\n    cat(sprintf(\"'%s'\", s))\n    \n    cat('\\nInput:')\n\
    \    cat(sprintf(\"'%s', \", s))\n    \n    return(s)\n    \n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\n<code>\nstring<-c(\"aB\", \"aA\", \"cD\", \"cF\", \"cH\"\
    , \"cJ\")\n\nstring<-str_replace_all(string, \"a\", \"A\")\nstring<-str_replace_all(string,\
    \ \"b\", \"B\")\nstring<-str_replace_all(string, \"c\", \"C\")\nstring<-str_replace_all(string,\
    \ \"d\", \"", "\n    \n    for(i in 1:length(s)){\n        if(substr(s[i],1,1)\
    \ !=\"\"){\n          switch(substr(s[i],1,1)){\n              case 'a':\n   \
    \             s=gsub(\"a\",\"A\",s)\n                break;\n              case\
    \ 'A':\n                s=gsub(\"A\",\"a\",s)\n                break;\n      \
    \        case 'b':\n                s=gsub(\"b\",\"B\",s)\n                break;\n\
    \              case 'B':\n                s=gsub(\"B\",\"b\",s)\n            \
    \    break;\n              case 'c':\n                s=gsub(\"c\",\"C\",s)\n\
    \                break;\n              case 'C':\n                s=gsub(\"C\"\
    ,\"c\",s)\n                break;\n              case 'd':\n                s=gsub(\"\
    d\",\"D\",s)\n                break;\n              case 'D':\n              \
    \  s=gsub(\"D\",\"d\",s)\n                break;\n              case 'e':\n  \
    \              s=gsub(\"e\",\"E\",s)\n                break;\n              case\
    \ 'E':\n                s=gsub(\"E\",\"e\",s)\n                break;\n      \
    \        case 'f':\n                s=gsub(\"f\",\"F\",s)\n                break;\n\
    \              case 'F':\n                s=gsub(\"F\",\"f\",s)\n            \
    \    break;\n              case 'g':\n                s=gsub(\"g\",\"G\",s)\n\
    \                break;\n              case 'G':\n                s=gsub(\"G\"\
    ,\"g\",s)\n                break;\n              case 'h':\n                s=gsub(\"\
    h\",\"H\",s)\n                break;\n              case 'H':\n              \
    \  s=gsub(\"H\",\"h\",s)\n                break;\n              case 'i':\n  \
    \              s=gsub(\"i\",\"I\",s)\n                break;\n              case\
    \ 'I':\n                s=gsub(\"I\",\"i\",s)\n                break;\n      \
    \        case 'j':\n                s=gsub(\"j\",\"J\",s)\n                break;\n\
    \              case 'J':\n                s=gsub(\"J\",\"j\",s)\n            \
    \    break;\n              case 'k':\n                s=gsub(\"k\",\"K\",s)\n\
    \                break;\n              case 'K':\n                s=gsub(\"K\"\
    ,\"k\",s)\n                break;\n              case 'l':\n                s=gsub(\"\
    l\",\"L\",s)\n                break;\n              case 'L':\n              \
    \  s=gsub(\"L\",\"l\",s)\n                break;\n              case 'm':\n  \
    \              s=gsub(\"m\",\"M\",s)\n                break;\n              case\
    \ 'M':\n                s=gsub(\"M\",\"m\",s)\n                break;\n      \
    \        case 'n':\n                s=gsub(\"n\",\"N\",s)\n                break;\n\
    \              case 'N':", "\n  s <- toupper(tolower(s))\n  if(!is.na(grepl('[a-z]',\
    \ s)) & \n     !is.na(grepl('[A-z]', s))) \n  {\n    s <- tolower(toupper(s))\n\
    \  }\n  s\n}\n</cell>\n<text>\nChallenge 1\nWrite a function that takes a string\
    \ as a parameter and returns its length.\nThe function must return -1 if the parameter\
    \ is null or empty. Otherwise, it should return the number of characters in it.\n\
    \n\n</text>\n<cell>", "\n  chars <- toupper(tolower(s))\n  \n  if (length(chars)\
    \ == 0) \n    return(toupper(tolower(s)))\n\n  if (chars[1] == chars[length(chars)])\n\
    \    return(toupper(tolower(s))) \n  \n  return(tolower(toupper(s)))\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=r,string |>\nHere is another solution which works\
    \ similarly to answer but it doesn't convert string to lower case. It just changes\
    \ the case of first letter if it's not upper case:\n<code>\nsolve <- function(s)\
    \ {\n  if ( length(s) == 0 ) return(s)\n  if ( substr(s[1], 1) %in% c(\"A\", \"\
    a\", \"e\", \"i\", \"o\", \"u\") ) return(substr(s, 1, 1) + substr(s, 2, nchar(s)))\
    \ \n  return(s)\n}\n</code>\nTest:\n<code>\n> solve(\"AbcD\")\n[1] \"BcdE\"\n\
    > solve(\"AbcD\")\n[1] \"BcdE\"\n> solve(\"AbcD\")\n[1] \"BcdE\"\n> solve(\"AbcD\"\
    )\n[1] \"BcdE\"\n> solve(\"AbcD\")\n[1] \"BcdE\"\n> solve(\"AbcD\")\n[1] \"BcdE\"\
    \n> solve(\"AbcD\")\n[1] \"BcdE\"\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n\
    solve = function(x){\n  if(str_detect(x,\"[a-zA-Z]\")) return(str_sub(x,1,1) +\
    \ str_sub(x,2,nchar(x)))\n  if(str_detect(x,\"[A-Za-z]\")) return(str_sub(x,2,1)\
    \ + str_sub(x,1,nchar(x)))\n  return(x)\n}\n</code>\n<|/ a dscore=0 tags=r,string\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nPlease provide some explanation why you did this.\n\
    <|/ c |>\n<| c |>\nI think it is more efficient than my solution. Because my solution\
    \ converts the string to lower case when no letter is present\n<|/ c |>\n<| a\
    \ dscore=0 tags=r,string |>\nAnother solution:\n<code>\nsolve <- function(s) {\n\
    \  x <- toupper(tolower(s))\n  if (length(x) == 0) return(x)\n  if (x[1] == toupper(x[1]))\
    \ return(substr(x, ", "\n  s1 <- gsub(\" \", \"\", s)\n  s2 <- gsub(\"@\", \"\
    c\", s1)\n  s3 <- gsub(\"c\", \"@\", s2)\n  s4 <- gsub(\"c\", \"A\", s3)\n  s5\
    \ <- gsub(\"A\", \"C\", s4)\n  s6 <- gsub(\"C\", \"A\", s5)\n  s7 <- gsub(\"A\"\
    , \"c\", s6)\n  s8 <- gsub(\"c\", \"A\", s7)\n  s9 <- gsub(\"A\", \"A\", s8)\n\
    \  s10 <- gsub(\"a\", \"A\", s9)\n  s11 <- gsub(\"A\", \"a\", s10)\n  s12 <- gsub(\"\
    a\", \"A\", s11)\n  s13 <- gsub(\"A\", \"A\", s12)\n  s14 <- gsub(\"a\", \"A\"\
    , s13)\n  s15 <- gsub(\"A\", \"a\", s14)\n  s16 <- gsub(\"a\", \"A\", s15)\n \
    \ s17 <- gsub(\"A\", \"A\", s16)\n  s18 <- gsub(\"A\", \"A\", s17)\n  s19 <- gsub(\"\
    a\", \"A\", s18)\n  s20 <- gsub(\"A\", \"a\", s19)\n  s21 <- gsub(\"a\", \"A\"\
    , s20)\n  s22 <- gsub(\"A\", \"A\", s21)\n  s23 <- gsub(\"a\", \"A\", s22)\n \
    \ s24 <- gsub(\"A\", \"A\", s23)\n  s25 <- gsub(\"a\", \"A\", s24)\n  s26 <- gsub(\"\
    A\", \"a\", s25)\n  s27 <- gsub(\"a\", \"A\", s26)\n  s28 <- gsub(\"A\", \"A\"\
    , s27)\n  s29 <- gsub(\"a\", \"A\", s28)\n  s30 <- gsub(\"a\", \"A\", s29)\n \
    \ s31 <- gsub(\"A\", \"A\", s30)\n  s32 <- gsub(\"a\", \"A\", s31)\n  s33 <- gsub(\"\
    A\", \"A\", s32)\n  s34 <- gsub(\"a\", \"A\", s33)\n  s35 <- gsub(\"A\", \"A\"\
    , s34)\n  s36 <- gsub(\"a\", \"A\", s35)\n  s37 <- gsub(\"A\", \"A\", s36)\n",
  "\n    s <- tolower(s)\n    if (grepl(\"[a-z]\",s) == TRUE) {\n        letters <-\
    \ sapply(s, is.character)\n        s <- toupper(s[!letters])\n    } else {\n \
    \       s <- toupper(s)\n    }\n    return(s)\n}\n</code>\n<|/ a tags=r,string\
    \ |>\n<| a |>\n<code>\nsapply(strsplit(s,\"\"),\n       function(x) ifelse(grepl(\"\
    [a-z]\",x),\n                          gsub(\"[a-z]\",toupper(x),x,fixed=TRUE),\n\
    \                          gsub(\"[a-z]\",tolower(x),x,fixed=TRUE)))\n</code>\n\
    <|/ a dscore=2 tags=r,string |>\n<| c |>\nI think this should be the accepted\
    \ answer since it uses the ifelse statement to change the case of the letters\
    \ only where there is an uppercase letter in the string.\n<|/ c |>\n<| a tags=r,string\
    \ |>\n<code>\ns <- c(\"aBc\", \"aBc\", \"aBc\")\nt(apply(s, 1, function(x) {\n\
    \  y <- grepl(\"^[a-z]+$\", x)\n  x[!y] <- toupper(x[!y])\n  y[!y] <- tolower(x[!y])\n\
    \  x[y] <- y[y]\n  return(x)\n}))", "\n  if(!is.character(s)) return('')\n  gsub(LETTERS,\
    \ '', gsub(LETTERS, toupper(LETTERS), tolower(s))) %>%\n    paste(collapse=\"\"\
    )\n}\n", "\n    letters <- strsplit(s, '')[[1]]\n    if(length(letters) == 0)\
    \ {\n        letters <- LETTERS[seq_along(letters)]\n    }\n    letters <- toupper(letters)\n\
    \    letters <- gsub(paste0('(?<=[^a-z])(?=[a-z])'), paste0('\\\\1', letters),\
    \ letters)\n    letters <- gsub(paste0('(?<=[a-z])(?=[A-Z])'), paste0('\\\\1',\
    \ letters), letters)\n    letters <- gsub(paste0('(?<=[A-Z])(?=[A-Z][a-z])'),\
    \ paste0('\\\\1', letters), letters)\n    letters <- gsub(paste0('(?<=[a-z])(?=[A-Z][a-z])'),\
    \ paste0('\\\\1', letters), letters)\n    return(paste0(letters, collapse = ''))\n\
    }\n</code>\n<|/ a tags=r,string,regex dscore=4 |>\n<| c |>\nthis only works for\
    \ single-character strings\n<|/ c |>\n<| c |>\nGood point! I edited my answer\
    \ to reflect that.\n<|/ c |>\n<| a tags=r,string,regex |>\nThis is a nice purely\
    \ regex solution:\n<code>\n(.*?)(.)\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI love\
    \ you, I've been trying to solve this problem for ages\n<|/ c |>\n<| a dscore=3\
    \ |>\nIf you need to remove the first character from the string you can do this:\n\
    <code>\nmy_string[[1]]\n</code>\n<|/ a tags=r,string,regex |>\n<| a tags=r,string,regex\
    \ |>\nA very simple and elegant solution:\n<code>\ns1 <- \"abcdef\"\ns2 <- \"\
    Abcdef\"\ns3 <- \"abcdEf\"\ns4 <- \"aBcdefg\"\n\nstr_replace_all(s1, regex(\"\
    ^(.)\"), paste0(\"\\\\2\", s2))", "\n  if (is.na(s)) return('')\n  \n  s2 <- tolower(s)\n\
    \  s3 <- strsplit(s2,\"\")[[1]]\n  \n  if(!is.na(s3)) {\n    chars <- lapply(s3,\
    \ toupper)\n    return(paste0(chars[[1]], chars[[2]], chars[[3]]))\n  }\n  \n\
    \  return(toupper(s2))\n}\n", "\n  if(length(s) == 0){\n    return(s)\n  }\n \
    \ result <- ''\n  for(i in 1:length(s)){\n    if(isupper(s[[i]])) result <- c(result,toupper(s[[i]]))\n\
    \    if(islower(s[[i]])) result <- c(result,tolower(s[[i]]))\n  }\n  result <-\
    \ c(result,rev(s))\n  return(result)\n}\n</code>\n<|/ a tags=r dscore=1 |>\n<|\
    \ a tags=r dscore=1 |>\nThis can be done in one line using gsub and sub functions:\n\
    <code>\nsolve<-function(s){\n gsub(\"([A-Z])\",\"\\\\U\\\\1\",sub(\"([a-z])\"\
    ,\"\\\\l\\\\1\",s))\n}\n</code>\nExplanation:\nThe first argument of gsub function\
    \ replaces every occurrence of any letter in CAPITAL with its uppercase equivalent.\
    \ \nThe second argument of gsub function replaces every occurrence of any letter\
    \ in LOWERCASE with its lowercase equivalent.\nThe third argument of gsub function\
    \ replaces every occurrence of any letter in CAPITAL with its uppercase equivalent.\
    \ \nThe fourth argument of gsub function replaces every occurrence of any letter\
    \ in LOWERCASE with its lowercase equivalent.\n<|/ a |>\n<| c |>\nThank you so\
    \ much, your answer is really helpful.\n<|/ c |>\n<| a tags=r dscore=1 |>\n<code>\n\
    solve = function(x){\n    if(length(x) == 0){\n        return(x)\n    }\n    firstLetter\
    \ = substr(x, 1, 1)\n    lastLetter = substr(x, nchar(x)-1, nchar(x))\n    firstLetter\
    \ = toupper(firstLetter)\n    lastLetter = tolower(lastLetter)\n    result = substr(x,\
    \ nchar(x)-2, nchar(x))\n    for(i in seq_along(result)){\n        result[[i]]\
    \ = toupper(result[[i]])\n        result[[i]] = tolower(result[[i]])\n    }\n\
    \    firstLetter = paste0(firstLetter, result)\n    result = paste0(lastLetter,\
    \ result)\n    return(paste(firstLetter, result, sep=\"\"))\n}\n\nsolve('ab')\
    \ #> [1] \"AB\"\nsolve('aB') #> [1] \"AB\"\nsolve('A#a#A#a#A#') #> [1] \"A#A#a#a#\"\
    \nsolve('1234') #> [1] \"4321\"\nsolve('#a@C') #> [1] \"#A@c\"\n", "\n    for(i\
    \ in seq_along(s)){\n        if(!grepl('^[a-zA-Z]+$', s[i])){\n            s <-\
    \ toupper(sub('^[a-zA-Z]+$','',s))\n        }\n        else {\n            s <-\
    \ tolower(sub('^[a-zA-Z]+$','',s))\n        }\n    }\n    s\n}\n\nsolve('1234')\n\
    </code>\n<|/ a |>\n<| a tags=r |>\nHere's a recursive implementation which returns\
    \ your original vector if it's empty, and a vector containing the result of applying\
    \ the transformation to the first element:\n<code>\nsolve <- function(s) {\n \
    \ if(!length(s)) s <- rev(s)\n  else s <- substring(s,1,1) + (substring(s,2,2)\
    \ %in% toupper(substring(s,2,2)) \n    else solve(substring(s,2,2) %in% toupper(substring(s,2,2))\
    \ + substring(s,1,1))\n}\n\nsolve('ab')", "\n  \n  # Get the string length\n \
    \ len <- nchar(s);\n  \n  # Initialization\n  answer <- \"\";\n  \n  for(t in\
    \ seq_along(s)){\n    if (grepl(\"^[a-zA-Z]$\", s[t])) {\n      # Reverse case\
    \ if it's a letter\n      if (s[t] %in% letters) {\n        answer <- toupper(answer)\
    \ + tolower(s[t]);\n      } else {\n        answer <- tolower(s[t]);\n      }\n\
    \    } else {\n      answer <- tolower(s[t]);\n    }\n  }\n  \n  # Return answer\
    \ if len == 0\n  if (len == 0) {\n    answer;\n  } else {\n    answer;\n  }\n\
    }\n</cell>\n<text>\nThe if/else statement in the for loop checks if there is a\
    \ letter inside the string. If so, it will perform the transformation to make\
    \ it upper or lower case. Otherwise, it just passes the string as is. This is\
    \ also what makes the code work. If not, the code would return NA because there\
    \ were no letters.\n\n\n</text>\n<cell>\nsolve(solve('1234'))\n</cell>\n<cell>\n\
    solve(solve('#a@C'))\n</cell>\n<text>\nFor loop\nThe for loop iterates over the\
    \ string and performs the transformation. Every time the for loop starts, the\
    \ variable t is set to 0 and  the variable t is incremented by 1 every single\
    \ time. Every single time, if the current character is a letter, it is transformed\
    \ to upper or lower case. Otherwise, the character is left as is and the for loop\
    \ continues to the next character.\n\n\n</text>\n<cell>", "\n  s <- gsub(\"[[:punct:]]\"\
    , \"\", s)\n  s <- toupper(s)\n  s <- gsub(\"[[:upper:]]\", \"\", s)\n  s <- tolower(s)\n\
    \  s\n}\n\n</cell>\n<cell>", "\n    \n    s <- tolower(s)\n    \n    ifelse(sapply(s,\
    \ nchar) == 0, s, \n           ifelse(sapply(s, nchar) > 1, paste0(toupper(substr(s,\
    \ 1, 1)),\n                                       substr(s, 2, nchar(s))),\n \
    \                 paste0(substr(s, 1, 1),\n                         toupper(substr(s,\
    \ 2, nchar(s))))))\n}\n</code>\n<|/ a tags=regex,r,tidyverse |>\n<| a dscore=0\
    \ |>\nOne possible answer in R is to use str_replace to replace each character\
    \ with a character in the other languages alphabet. Here I show how to do this\
    \ in a very basic way without regular expressions. You could of course use regular\
    \ expressions as long as you wanted to. \n<code>\nlibrary(stringr)\n", "\n   \
    \ s <- gsub(\"[A-Z]\", \"\\\\U\\\\1\", s)\n    s <- gsub(\"[a-z]\", \"\\\\L\\\\\
    1\", s)\n    s <- toupper(s)\n    return(s)\n}\n", "\n  \n  s <- toupper(s) #\
    \ convert to uppercase first to avoid case sensitive problems\n  \n  s <- gsub(\"\
    [^[:alnum:]]\", \"\", s) # remove symbols and digits\n  \n  s <- strsplit(s, \"\
    \")[[1]] # split string by empty space to remove leading and trailing space\n\
    \  \n  if(length(s) == 0) return(s) # return empty string if string is empty\n\
    \  \n  s <- gsub(\"\\\\s\", \"\", s) # remove leading and trailing whitespace\n\
    \  \n  if(length(s) == 0) return(s) # return empty string if there are no spaces\n\
    \  \n  s <- paste(toupper(s) + substring(s, 1, 1), collapse=\"\") # uppercase\
    \ first letter\n  \n  return(s)\n}\n", "\n  s <- gsub(\"[[:alpha:]]\", \"\", s)\n\
    \  s <- toupper(tolower(s))\n  s <- gsub(\"[[:punct:]]\", \"\", s)\n  s <- tolower(s)\n\
    \  s\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r dscore=1 |>\nI think this might\
    \ get you most of the way there.\n<code>\nsapply(strsplit(s,''),function(x){\n\
    \    x <- gsub('[[:alpha:]]','',x)\n    x <- toupper(tolower(x))\n    x <- gsub('[[:punct:]]','',x)\n\
    \    x})\n\n [1] \"4321\" \"AB\"   \"#a@c\"\n</code>\n<|/ a |>\n<| a tags=r |>\n\
    You can use gsub to replace each letter in a string with its lowercase version,\
    \ then use toupper to convert it to its uppercase version. Finally use gsub to\
    \ replace any punctuation marks with empty string:\n<code>\nx <- c(\"aBC\", \"\
    1234\", \"#a@C\")\ngsub(\"([[:alpha:]])\", toupper(tolower(gsub(\"[[:punct:]]\"\
    , \"\", x))), x)\n\n[1] \"4321\" \"AB\"   \"#A@c\"\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\nYou can use stringi library for this:\n<code>\nstringi::stri_trans_general(stringi::stri_trans_general('AB#a@C',\
    \ 'A-Z'), \n                           to = \"[A-Z]\")\n", "\n    x <- s\n   \
    \ x <- gsub(letters,\"\\\\U\\\\1\",x)\n    x <- gsub(paste(letters,collapse=\"\
    \"),\"\\\\L\\\\1\",x)\n    return(x)\n}\n</cell>\n<cell>\nsolve(\"1234\")\n</cell>\n\
    <cell>\nsolve(\"ab\")\n</cell>\n<cell>\nsolve(\"#a@C\")\n</cell>\n<text>\n13.\
    \ \u71B5\n\u71B5\u7684\u5B9A\u4E49\u662F\u5B83\u8868\u793A\u4ECE\u6587\u6863\u4E2D\
    \u5B66\u5230\u7684\u8BCD\u9891\u7684\u603B\u548C\u3002\n\n$H_1$\uFF1A\u5B58\u5728\
    \u8BCD\u51FA\u73B0\u9891\u7387\u8D85\u8FC7 $\\alpha$ \u7684\u6240\u6709\u8BCD\uFF0C\
    \u5219\u8BCD\u9891\u7684\u603B\u548C\u4E3A $\\alpha$\n$H_0$\uFF1A\u6CA1\u6709\u4EFB\
    \u4F55\u8BCD\u51FA\u73B0\u65F6\uFF0C\u8BCD\u9891\u7684\u603B\u548C\u4E3A 1\n\n\
    \u7EDF\u8BA1\u6240\u6709\u6587\u6863\u4E2D\u5B66\u5230\u7684\u8BCD\u9891\uFF0C\
    \u5E76\u4EE5\u603B\u9891\u4E3A\u5355\u4F4D\u7EDF\u8BA1\u5176\u71B5\u3002\n\n\u7EDF\
    \u8BA1\u6240\u6709\u6587\u6863\u4E2D\u5B66\u5230\u7684\u8BCD\u9891\uFF0C\u5E76\
    \u4EE5\u603B\u9891\u4E3A\u5355\u4F4D\u7EDF\u8BA1\u5176\u71B5\u3002\n\u8BF7\u6CE8\
    \u610F\uFF0C\u4F60\u53EF\u4EE5\u5C1D\u8BD5\u63A2\u7D22\u7EDF\u8BA1\u6240\u6709\
    \u6587\u6863\u4E2D\u5B66\u5230\u7684\u8BCD\u9891\uFF0C\u4EE5\u8BA1\u7B97\u603B\
    \u9891\u71B5\u7684\u65B9\u6CD5\u3002\n\n\u5047\u8BBE\u4F60\u6709\u4E00\u4E2A\u6587\
    \u6863 s \uFF08\u6587\u6863 s \u5305\u542B\u4E00\u4E32\u8BCD\u6216\u5B57\u6BCD\
    \uFF09\u3002\u7EDF\u8BA1\u6240\u6709\u8BCD\u51FA\u73B0\u7684\u9891\u7387\uFF0C\
    \u5E76\u4EE5\u603B\u9891\u4E3A\u5355\u4F4D\u7EDF\u8BA1\u5176\u71B5\u3002\u4F60\
    \u7684\u7B97\u6CD5\u53EF\u4EE5\u4F7F\u7528\u9891\u7387\u8BB0\u5F55\u8868\u6216\
    \u8005\u5355\u8BCD\u8868\uFF08\u4E5F\u53EF\u4EE5\u4F7F\u7528\u54C8\u5E0C\u8868\
    \uFF09\u3002\u4F60\u7684\u7B97\u6CD5\u9700\u8981\u4E00\u4E2A\u6807\u8BB0 s \u7684\
    \u4E00\u4E2A\u6807\u8BB0\u6570\u3002\n\u4F8B\u5982\uFF0C\u4F60\u53EF\u4EE5\u7EDF\
    \u8BA1\u51FA\u201Caba\u201D\u8FD9\u4E2A\u6587\u6863\u7684\u6240\u6709\u8BCD\u9891\
    \uFF0C\u5E76\u4EE5\u603B\u9891\u4E3A\u5355\u4F4D\u7EDF\u8BA1\u5176\u71B5\u3002\
    \u4F60\u7684\u7B97\u6CD5\u9700\u8981\u4E00\u4E2A\u6807\u8BB0 s \u7684\u4E00\u4E2A\
    \u6807\u8BB0\u6570\u3002\u7EDF\u8BA1\u51FA\u201Caba\u201D\u8FD9\u4E2A\u6587\u6863\
    \u7684\u6240\u6709\u8BCD\u9891\uFF0C\u5E76\u4EE5\u603B\u9891\u4E3A\u5355\u4F4D\
    \u7EDF\u8BA1\u5176\u71B5\u3002\uFFFD", "\n  \n  if(!is.character(s)) stop('Expected\
    \ a character string.')\n  \n  s <- gsub(\" \", \"\", s, fixed=T)\n  \n  \n  if(!is.na(str_count(s,\
    \ 'a')) & !is.na(str_count(s, 'A')) & str_count(s, 'a') != str_count(s, 'A'))\n\
    \    s <- tolower(s)\n  \n  if(!is.na(str_count(s, 'a')) & !is.na(str_count(s,\
    \ 'A')) & str_count(s, 'a') > str_count(s, 'A'))\n    s <- toupper(s)\n  \n  if(!is.na(str_count(s,\
    \ 'a')) & is.na(str_count(s, 'A')) & str_count(s, 'a') == str_count(s, 'A'))\n\
    \    s <- toupper(s)\n  \n  return(s)\n}\n</code>\n<|/ a |>\n<| a tags=r |>\n\
    If we are using a package, I would use stringr::str_to_lower and stringr::str_to_upper\
    \ to handle both character and factor strings.  We could also use base R or stringi\
    \ package.  Also, gsub with pattern \"\\\\w\" would be helpful.  Here, I am using\
    \ a regex to match all non-numeric characters and replace them with \"NA\".  Then,\
    \ we get the lengths of \"NA\" elements in the string, and if the length is equal\
    \ to 1, then we use the output of str_to_lower else use the output of str_to_upper.\
    \  The code is vectorized.\n<code>\nlibrary(stringr)\nsolve(df$V1)", "\n    if\
    \ (length(s) == 0) \n        s\n    else\n        paste(toupper(substring(s, 1,\
    \ 1)), \n                tolower(substring(s, 2, nchar(s))), \n              \
    \  sep = \"\")\n}\n</code>\nThe results:\n<code>\nsolve(\"abba\") ", "\n  res\
    \ <- \"\"\n  for (s in strsplit(s, \"\")) {\n    if (grepl(\"[a-z]\", s)) {\n\
    \      res <- paste(toupper(s), res, sep=\"\")\n    } else {\n      res <- paste(tolower(s),\
    \ res, sep=\"\")\n    }\n  }\n  res\n}\n</code>\n<|/ a tags=r,string,substitution\
    \ |>\n<| c |>\nThis would work but I would need to write a new function for every\
    \ possible substitution I might have to do. E.g. `solve <- function(s) {  res\
    \ <- \"\"  for (s in strsplit(s, \"\"))  if (grepl(\"[a-z]\", s)) res <- paste(toupper(s),\
    \ res, sep=\"\") else res <- paste(tolower(s), res, sep=\"\") res  }`\n<|/ c |>\n\
    <| c |>\nI agree, but I think this solution is very readable, if you have more\
    \ problems you can always split it into more functions. I will add it as an edit\
    \ in a second\n<|/ c |>\n<| c |>\nI updated my question to reflect some more complicated\
    \ constraints. I hope this helps.\n<|/ c |>\n<| c |>\nThank you for your answer!\
    \ I have been playing around with your solution. It seems to be a bit faster than\
    \ the solution I provided. I am sure this could be made even more efficient but\
    \ I think the efficiency would be negligible.\n<|/ c |>\n<| c |>\nI am glad you\
    \ liked it. It was a fun problem to work with!\n<|/ c |>\n<| a dscore=0 |>\nHere's\
    \ a base R approach. I think it makes most sense to do it this way:\n<code>\n\
    test <- 'Hello World!'\ntest[grep(\"[a-z]\", test)] <- toupper(test[grep(\"[a-z]\"\
    , test)])\ntest[!grepl(\"[a-z]\", test)] <- tolower(test[!grepl(\"[a-z]\", test)])\n\
    </code>\nThe idea behind this is to select a vector of the letters you want to\
    \ transform, then transform them all at once. \nThe second part of the code is\
    \ just transforming the letters based on the conditions that you specified.\n\
    <|/ a tags=r,string,substitution |>\n<| a dscore=0 tags=r,string,substitution\
    \ |>\nThis solution uses gsubfn() to replace all lowercase letters with their\
    \ corresponding uppercase version within the same string, regardless of whether\
    \ they are followed by lowercase letters or not:\n<code>\nlibrary(gsubfn)\n\n\"\
    ABC\"gsubfn(\"[a-z]\", function(x) gsub(\"([a-z])$\", \"", "\n    s <- gsub('[A-Z]+',\
    \ '', s)\n    s <- toupper(tolower(s))\n    s <- gsub('[[:punct:]]', '', s)\n\
    \    return(s)\n}\n", "\n    p <- gregexpr('[a-zA-Z]', s)\n    s <- sub('[a-zA-Z]',\
    \ '', s)\n    s <- toupper(tolower(s))\n    s <- ifelse(length(p) == 0, s, paste0(sub('[[:punct:]]',\
    \ '', p), s))\n    s\n}\n</code>\n<|/ a tags=r,string-matching |>\n<| c |>\nWow!\
    \ You did a great job answering my original question! Thank you so much for your\
    \ effort and the detailed explanations you gave! I really appreciate it! I learned\
    \ a lot from you! I thought I couldn't find an elegant way to solve this problem\
    \ using only base R functions, but this solution is so elegant! Thank you so much!\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is a more elegant solution with some base R functions.\n\
    <code>\nsolve <- function(s) {\n  p <- gregexpr('[a-zA-Z]', s)\n  s <- sub('[a-zA-Z]',\
    \ '', s)\n  s <- toupper(tolower(s))\n  s <- ifelse(length(p) == 0, s, paste0(sub('[[:punct:]]',\
    \ '', p), s))\n  s\n}\n</code>\n<|/ a tags=r,string-matching |>\n<| a tags=r,string-matching\
    \ |>\nIn case you want the stringr package (which might be overkill, but I find\
    \ it very handy):\n<code>\nlibrary(stringr)\nsolve2 <- function(string){\n  string_lower\
    \ <- tolower(string)\n  string_upper_case <- toupper(string)\n  str_match(\"\\\
    \\w\", string_lower)\n  str_match(\"\\\\w\", string_upper_case)\n  paste(str_extract_all(string_lower,\
    \ \"\\\\w\"), str_extract_all(string_upper_case, \"\\\\w\"))\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=r,string-matching |>\nHere is an elegant solution using\
    \ stringi and stringr:\n<code>\nlibrary(stringi)\nlibrary(stringr)\n\nsolve <-\
    \ function(s) {\n    s <- stri_replace_all_regex(s, \"[[:alpha:]]\", \" \") %>%\
    \ \n            stri_replace_all_regex(s, \"[[:punct:]]\", \"\") %>%\n       \
    \     stri_trans_toupper()\n    stri_replace_all_regex(s, \"[[:alpha:]]\", tolower(s))\
    \ %>%\n            stri_replace_all_regex(s, \"[[:punct:]]\", \"\") %>%\n    \
    \        stri_trans_toupper()\n}\n", "\n    \n    \n    for(i in 1:nchar(s)){\n\
    \        if(isLetter(s[i])){\n            ifelse(toupper(s[i]) %in% LETTERS, \n\
    \                paste(toupper(s[i]),tolower(s[i]),sep=\"\"), \n             \
    \   paste(s[i],tolower(s[i]),sep=\"\"))\n        }else{\n            paste(s[i],tolower(s[i]),sep=\"\
    \")\n        }\n    }\n}\n</code>\n<|/ a tags=r,regex,string,reverse |>\n<| c\
    \ |>\nThis is great and I appreciate the effort. However, `str_replace_all` isn't\
    \ an option for me. `regex` is an option, but not an option since this function\
    \ is part of a larger assignment where I need to use `regex`.\n<|/ c |>\n<| c\
    \ |>\nYou don't need `str_replace_all` for this.\n<|/ c |>\n<| c |>\nThis does\
    \ work on the example given by the OP, but in general it fails to reverse strings\
    \ like `abba` due to the fact that the replacement string includes the letters\
    \ found inside the string, which is why we used `str_replace_all` in the first\
    \ place.\n<|/ c |>\n<| c |>\nThanks for pointing this out. I fixed it.\n<|/ c\
    \ |>\n<| c |>\nNice. Didn't realize that `str_replace_all` could be used like\
    \ this.\n<|/ c |>\n<| a dscore=1 |>\nIn base R:\n<code>\nsolve = function(s) {\n\
    \    s <- ifelse(grepl(\"[A-Za-z]\",s),\n            paste(toupper(s[!grepl(\"\
    [A-Za-z]\",s)]),\n                tolower(s[!grepl(\"[A-Za-z]\",s)]),\n      \
    \          sep=\"\"),\n            s)\n    \n    return(s[grepl(\"[A-Za-z]\",s)])\n\
    }\n\nsolve(\"abcd\")\n[1] \"dcbA\"\n\nsolve(\"abba\")\n[1] \"bacB\"\n</code>\n\
    <|/ a tags=r,regex,string,reverse |>\n<| a |>\nAnother base R option\n<code>\n\
    ifelse(grepl(\"[A-Za-z]\",s),\n        paste(toupper(s[!grepl(\"[A-Za-z]\",s)]),\n\
    \              tolower(s[!grepl(\"[A-Za-z]\",s)]),\n              sep=\"\"),\n\
    \        s)\n", "\n  if(!is.character(s)) stop(\"s is not character string.\"\
    )\n  s<-paste(s,collapse=\"\")\n  s<-sapply(s,function(x) ifelse(grepl(\"^[a-z]+$\"\
    ,x),toupper(x),x))\n  s<-paste(sapply(s,function(x) ifelse(x==\" \",\"\",x)),collapse=\"\
    \")\n  s<-paste(sapply(s,function(x) ifelse(x==\" \",\"\",toupper(x)),collapse=\"\
    \"))\n  s<-paste(sapply(s,function(x) ifelse(x==\" \",\"\",tolower(x)),collapse=\"\
    \"))\n  return(s)\n}\n</cell>\n<text>\n2.3 Visualize the String\n\n</text>\n<text>\n\
    2.3.1 Draw a String\n\n</text>\n<cell>", "\n  s <- toupper(s)\n  l1 <- strsplit(s,\
    \ \"\")[[1]]\n  l2 <- str_split(s, \"\")[[1]]\n  l3 <- str_split(s, \"\")[[2]]\n\
    \  l4 <- str_split(s, \"\")[[3]]\n  l5 <- str_split(s, \"\")[[4]]\n  l6 <- str_split(s,\
    \ \"\")[[5]]\n  l7 <- str_split(s, \"\")[[6]]\n  l8 <- str_split(s, \"\")[[7]]\n\
    \  l9 <- str_split(s, \"\")[[8]]\n  l10 <- str_split(s, \"\")[[9]]\n  l11 <- str_split(s,\
    \ \"\")[[10]]\n  l12 <- str_split(s, \"\")[[11]]\n  l13 <- str_split(s, \"\")[[12]]\n\
    \  l14 <- str_split(s, \"\")[[13]]\n  l15 <- str_split(s, \"\")[[14]]\n  l16 <-\
    \ str_split(s, \"\")[[15]]\n  l17 <- str_split(s, \"\")[[16]]\n  l18 <- str_split(s,\
    \ \"\")[[17]]\n  l19 <- str_split(s, \"\")[[18]]\n  l20 <- str_split(s, \"\")[[19]]\n\
    \  l21 <- str_split(s, \"\")[[20]]\n  l22 <- str_split(s, \"\")[[21]]\n  l23 <-\
    \ str_split(s, \"\")[[22]]\n  l24 <- str_split(s, \"\")[[23]]\n  l25 <- str_split(s,\
    \ \"\")[[24]]\n  l26 <- str_split(s, \"\")[[25]]\n  l27 <- str_split(s, \"\")[[26]]\n\
    \  l28 <- str_split(s, \"\")[[27]]\n  l29 <- str_split(s, \"\")[[28]]\n  l30 <-\
    \ str_split(s, \"\")[[29]]\n  l31 <- str_split(s, \"\")[[30]]\n  l32 <- str_split(s,\
    \ \"\")[[31]]\n  l33 <- str_split(s, \"\")[[32]]\n  l34 <- str_split(s, \"\")[[33]]\n\
    \  l35 <- str_split(s, \"\")[[34]]\n  l36 <- str_split(s, \"\")[[35]]\n  l37 <-\
    \ str_split(s, \"\")[[36]]\n  l38 <- str_split(s, \"\")[[37]]\n  l39 <- str_split(s,\
    \ \"\")[[38]]\n  l40 <- str_split(s, \"\")[[", "\n  # Write your code here\n \
    \ if(!is.character(s)) stop('Error: expected a character vector')\n  s <- toupper(s)\n\
    \  if(!all(grepl('^[A-Z]', s))) s <- tolower(s)\n  s\n}\n", "\n  # Write your\
    \ code here.\n  \n}\n\n</cell>\n<cell>", "\n  nchar(s)\n  sapply(s, nchar)\n \
    \ s <- toupper(tolower(s))\n  sapply(s, nchar)\n  s <- gsub(\"[A-Z]\", \"\", s)\n\
    \  nchar(s) \n  sapply(s, nchar)\n  s\n}\n</cell>\n<text>\nNow apply the function\
    \ solve to each row of your data.frame to get a column with the result of applying\
    \ the function to that row.\n\nTo accomplish this in base R, use the apply function.\
    \ This function takes two arguments: a function (which is applied to each row)\
    \ and an object. apply applies the function to the object using rows of the object\
    \ as arguments. In this case, apply applies the function to each row of the data.frame.\n\
    \n\n</text>\n<cell>", "\n  \n  result <- s \n  i <- 1\n  \n  while (i < length(s))\n\
    \  {\n    if (s[i] %in% LETTERS)\n    {\n      result <- toupper(result)\n   \
    \   result <- substr(result, i - 1, i, fixed = TRUE)\n      i <- i + 1\n    }\n\
    \    else if (s[i] %in% digits)\n    {\n      result <- tolower(result)\n    \
    \  result <- substr(result, i - 1, i, fixed = TRUE)\n      i <- i + 1\n    }\n\
    \    else if (i == length(s))\n    {\n      result <- toupper(result)\n    }\n\
    \    else\n    {\n      result <- s[i]\n    }\n  }\n  return(result)\n}\n", "\n\
    \  r <- sapply(s, is.character)\n  if(!any(r)) s else upper(sapply(s, toupper))\n\
    }\n\n</code>\n<|/ a tags=r,string,regex |>\n<| a tags=r,string,regex dscore=1\
    \ |>\nWe can use gsub here and capture the groups in parentheses\n<code>\ngsub(\"\
    ^(.*?)(\\\\w*)\", \"\\\\2\\\\1\", s)", "\n  s <- tolower(s)\n  i <- 1\n  while(i\
    \ <= length(s)) {\n    if (substr(s, i, i) == \"a\") {\n      substr(s, i, i)\
    \ <- \"A\"\n      i <- i + 1\n    }\n    if (substr(s, i, i) == \"b\") {\n   \
    \   substr(s, i, i) <- \"B\"\n      i <- i + 1\n    }\n    if (substr(s, i, i)\
    \ == \"c\") {\n      substr(s, i, i) <- \"C\"\n      i <- i + 1\n    }\n  }\n\
    \  s\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,string |>\nOne option is tolower\n\
    <code>\n tolower(x) <- toupper(tolower(x))\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>\nstr1 <- \"abc\" \nstr2 <- \"ABC\" \nstr3 <- \"abcDEF\"\n\nmyfunction <-\
    \ function(s) {\n  u <- toupper(tolower(s))\n  u[!grepl(\"[A-Za-z]\", u)] <- paste0(rep(\"\
    \ \", length(grep(\"[A-Za-z]\", u))),\n                                 substr(u,\
    \ \n                                        which(grepl(\"[A-Za-z]\", u)),\n \
    \                                       nchar(u)))\n  u[!grepl(\"[A-Za-z]\", u)]\n\
    }\n\nmyfunction(str1)", "\n  if(length(s)==0)\n    return(s)\n  s<-strsplit(s,\"\
    \")[[1]]\n  for(i in 1:length(s)) {\n    if(grepl(\"\\\\p{L}\",s[i])) {\n    \
    \  s[i] <- (toupper(s[i])) \n    } else {\n      s[i] <- (tolower(s[i])) \n  \
    \  }\n  }\n  return(paste0(s,collapse = \"\"))\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks, I'm working on the solution but I think I still need some help\
    \ on this part: \"If the string contains no letters, reverse the string.\"\n<|/\
    \ c |>\n<| c |>\nHi, I have edited the original post to include a solution for\
    \ this.\n<|/ c |>\n<| a dscore=2 |>\nA simple and efficient solution (using regex\
    \ and gregexpr, no loop):\n<code>\nsol <- function(s) {\n  if(length(s)==0)\n\
    \    return(s)\n  s<-strsplit(s,\"\")[[1]]\n  s<-gsub(paste0(s,collapse = \" \"\
    ),\"\",s)\n  s<-paste(s2,\"\",sep=\"\")\n  s<-paste(s2,s,sep=\"\")\n  s<-gsub(\"\
    ( [a-z])\",toupper,s)\n  s<-gsub(\"( [A-Z])\",tolower,s)\n  s<-gsub(\"( [a-z])\"\
    ,\"\\\\1\",s)\n  s<-gsub(\"( [A-Z])\",\"\\\\2\",s)\n  return(paste0(s,collapse\
    \ = \" \"))\n}\n</code>\n<|/ a tags=string,r,reverse |>\n<| c |>\nThanks, I'm\
    \ working on the solution but I think I still need some help on this part: \"\
    If the string contains no letters, reverse the string.\"\n<|/ c |>\n<| c |>\n\
    You don't need any loop for that, `gregexpr` is vectorized function, and it is\
    \ very efficient for small data.\n<|/ c |>\n<| c |>\nSorry I'm a bit new to R.\
    \ Could you show me how to do that?\n<|/ c |>\n<| a tags=string,r,reverse |>\n\
    Here's a function that works on all strings with only letters (no spaces, digits,\
    \ etc):\n<code>\nstringReverse <- function(x) {\n  if(grepl(\"[a-z]\", x)) {\n\
    \    y <- tolower(x)\n    y <- sub(\"[a-z]\", \"[a-z]\", y)\n    y <- gsub(\"\
    [a-z]\", \"\", y)\n  } else {\n    y <- ", "\n  # Write your code here\n  \n}\n\
    </code>\n<|/ q |>\n<| c |>\nWhat happened when you tried to solve this? Where\
    \ are you stuck?\n<|/ c |>\n<| c |>\nI tried solving this on my own. I am not\
    \ able to get it properly. I even tried to find some hints online. But could not\
    \ get it clearly.\n<|/ c |>\n<| c |>\nCan you please show your code? And explain\
    \ how you tried to solve it on your own?\n<|/ c |>\n<| c |>\nI have added my code\
    \ now. I am sorry that I am unable to share the code because it is an online coding\
    \ site and it would not be helpful to others here.\n<|/ c |>\n<| c |>\nI suggest\
    \ you first write a simple function that can do any single character reversal.\
    \ For example, `solve('a')` should return `'a'`. Then try to write more complex\
    \ functions as you learn to solve more complex problems\n<|/ c |>\n<| a dscore=1\
    \ |>\nMy approach would be to split the string into a character vector of individual\
    \ characters, reverse each element in the vector, and then combine them back:\n\
    <code>\nsolve <- function(s) {\n  s <- strsplit(s, \"\")[[1]]\n  paste0(s[order(nchar(s))],\
    \ collapse = \"\")\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThank you for your answer.\
    \ Can you please explain what this part means ? `s <- strsplit(s, \"\")[[1]]`\n\
    <|/ c |>\n<| c |>\n`strsplit` splits a string into a character vector with one\
    \ element per character of the original string. `[[1]]` extracts the vector from\
    \ the list returned by `strsplit`.\n<|/ c |>\n<| a dscore=1 |>\nHere is my solution,\
    \ using the tidyverse package.  \n<code>\nlibrary(tidyverse)\n\nsolve = function(s)\
    \ {\n  s = str_replace(s, '[:alpha:]', '') %>% str_replace_all('[:digit:]', '')\n\
    \  return(paste0(rev(s), collapse = \"\"))\n}\n</code>\nThe function returns the\
    \ solution as a single string, which you can store in a variable.  \n<code>\n\
    solve('abc')\n</code>\n\n[1] \"cba\"\n\n<code>\nsolve('1234')\n</code>\n\n[1]\
    \ \"4321\"\n\n<code>\nsolve('#a@C')\n</code>\n\n[1] \"#A@c\"\n\n<code>\nsolve('abc123')\n\
    </code>\n\n[1] \"cba123\"\n\n<code>\nsolve('1abc3')\n", "\n  # Your code goes\
    \ here\n  \n  # the solution\n  return(result)\n}\n", "\n  ifelse(grepl('^[a-zA-Z]+$',\
    \ s), \n         toupper(tolower(s)),\n         tolower(s)\n  )\n}\n</code>\n\
    <|/ a tags=r,string,uppercase |>\n<| a tags=r,string,uppercase dscore=1 |>\nIn\
    \ base R you can do:\n<code>\ns <- \"12AB3\"\ns2 <- toupper(tolower(s))\ns3 <-\
    \ ifelse(grepl(\"^[a-z]+$\", s), s2, s)\n</code>\n<|/ a |>\n<| c |>\n`ifelse(grepl(\"\
    ^[a-z]+$\", s), toupper(tolower(s)), s)`\n<|/ c |>\n<| c |>\nthanks for pointing\
    \ it out - I had no idea about `toupper(tolower(s))`\n<|/ c |>\n<| a tags=r,string,uppercase\
    \ |>\nYou can use gsub and paste0 to add a new letter to your string. \n<code>\n\
    paste0(substr(toupper(tolower(s)), 1, 1),substr(toupper(tolower(s)), 2))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nOr maybe `substr(s, 1, 1)[toupper(tolower(s)) == \"\
    a\"]`.\n<|/ c |>\n<| c |>\n`substr(s, 1, 1)[toupper(tolower(s)) == \"a\"]` works\
    \ too, but why did you use `toupper(tolower(s))` here?\n<|/ c |>\n<| c |>\nI used\
    \ it because I think it is a little bit more readable. But maybe this `substr(s,\
    \ 1, 1)[toupper(tolower(s)) == \"a\"]` works too but I didn't test it.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nWe can use sub.  Get the lower case first and then convert\
    \ to upper case, then use sub to replace the characters that are not 'a' to 'A'\
    \ and keep the rest as it is.\n<code>\nsub(\"^[[:lower:]]+\", \"\", paste0(sub(\"\
    [a-z]\", \"A\", tolower(s))))", "\n  s <- gsub('[0-9]', paste0('\\\\d', paste0('\\\
    \\d', seq_len(nchar(s)))),  s) # add all numbers as digits\n  s <- gsub('[a-zA-Z]',\
    \ paste0('\\\\U', paste0('\\\\U', seq_len(nchar(s)))), s) # add all letters as\
    \ uppercase letters\n  s <- gsub('\\\\U\\\\U\\\\U', '', s) # remove all duplicates\n\
    \  s <- toupper(s) # make all uppercase letters uppercase\n  return(tolower(s))\n\
    }\n", "\n  s <- tolower(s)\n  \n  unlist(lapply(strsplit(s, ''), function(x) {\n\
    \    if(all(x %in% letters)) {\n      gsub(x = x, pattern = x, replacement = x,\
    \ ignore.case = TRUE)\n    } else {\n      x\n    }\n  }))\n}\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that converts a string to a vector with its letters\
    \ sorted.\n\n\n</text>\n<cell>", "\n  if (is.character(s)) \n    s <- tolower(s)\n\
    \  else if (length(s) == 0) \n    s <- ''\n  else {\n    r <- ''\n    for (el\
    \ in s) \n      if (is.character(el)) \n        r <- paste(r, paste0(toupper(el),\
    \ tolower(el)), sep='')\n      else r <- paste(r, el, sep='')\n  }\n  return(r)\n\
    }\n</code>\n<|/ a tags=r |>\n<| c |>\nGreat answer! A little bit shorter than\
    \ mine. :)\n<|/ c |>\n<| c |>\nThank you for this answer. It really helped me\
    \ to understand regex better\n<|/ c |>\n<| a tags=r |>\nUsing base R's sub, this\
    \ is also an option:\n<code>\nx <- '#a@C'\nsub('.', '#', sub('@', toupper, x))",
  "\n    if(is.na(s))\n        return(s)\n    revStr <- toupper(substring(s,1,1))\n\
    \    for(i in 2:(length(s))){\n        if(substring(s[i],1,1) != substring(s[i-1],1,1)){\n\
    \            revStr <- paste0(revStr,substring(s[i],1,1))\n        }else{\n  \
    \          revStr <- paste0(revStr,substring(s[i-1],1,1))\n        }\n    }\n\
    \    revStr\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if the string is\
    \ only one character long, e.g. `solve('a')`.\n<|/ c |>\n<| a |>\n<code>\nsolve\
    \ <- function(s){\n   s <- toupper(substring(s,1,1))\n   for(i in 2:(length(s))){\n\
    \      if(substring(s[i],1,1) != substring(s[i-1],1,1)){\n         s <- paste0(s,substring(s[i],1,1))\n\
    \      }else{\n         s <- paste0(s,substring(s[i-1],1,1))\n      }\n   }\n\
    \   s\n}\n</code>\n<|/ a tags=algorithm,r dscore=2 |>\n<| a dscore=1 |>\nUsing\
    \ gsubfn for looping:\n<code>\nlibrary(gsubfn)\ngsubfn('[a-z]', list(upper = 'X'),\
    \ toupper(paste0(substr(s, 1, 1), 'A')))\n</code>\nTo see how this works, let's\
    \ look at an example: \n<code>\n> s <- 'aaaa'\n> gsubfn('[a-z]', list(upper =\
    \ 'X'), toupper(paste0(substr(s, 1, 1), 'A')))\n[1] \"XAXXA\"\n</code>\nThis returns\
    \ \"XAXXA\". Now let's look at the second example:\n<code>\n> s <- 'bbbb'\n> gsubfn('[a-z]',\
    \ list(upper = 'X'), toupper(paste0(substr(s, 1, 1), 'A')))\n[1] \"XBBB\"\n</code>\n\
    This returns \"XBBB\". Now let's look at the third example:\n<code>\n> s <- 'cccc'\n\
    > gsubfn('[a-z]', list(upper = 'X'), toupper(paste0(substr(s, 1, 1), 'A')))\n\
    [1] \"XCCCC\"\n</code>\nThis returns \"XCCCC\". Now let's look at the fourth example:\n\
    <code>\n> s <- 'ddddd'\n> gsubfn('[a-z]', list(upper = 'X'), toupper(paste0(substr(s,\
    \ 1, 1), 'A')))\n[1] \"XDDDD\"\n</code>\nThis returns \"", "\n  s<-s\n  n<-nchar(s)\n\
    \  for(i in 1:n){\n    if(s[i]<=\"a\" | s[i]>\"z\"){\n      s[i]<-toupper(s[i])\n\
    \    }else if(s[i]<=\"A\" | s[i]>\"Z\"){\n      s[i]<-tolower(s[i])\n    }\n \
    \ }\n  s<-paste0(s,collapse = \"\")\n  return(s)\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI appreciate the response. I was trying to use regex to find a pattern\
    \ for characters in the string and then use these to replace the characters accordingly\
    \ but it looks like regex is not that helpful because it looks for exact matches.\
    \ I was thinking of using gsub to find all the characters but not sure if that's\
    \ the best method. I am not very familiar with regex but I am familiar with applying\
    \ patterns to strings. I will try your code and see if it works.\n<|/ c |>\n<|\
    \ c |>\nI am not sure I understand what you mean by exact matches. I thought you\
    \ were looking to change the case. Yes you would be replacing with your regex\
    \ but you are using `nchar` which will return the number of characters in your\
    \ string so if you need to check for each character as `c(\"a\",\"b\",\"c\")`\
    \ then use `nchar(c(\"a\",\"b\",\"c\"))`. You could also use `nchar` on `s` to\
    \ see how many characters are there in your string. In your case `nchar(s) <-\
    \ 3` which is what `s` is made of. Your regex should then match for `\"a\", \"\
    b\", \"c\"` and so on\n<|/ c |>\n<| c |>\nI guess I misunderstood what you were\
    \ asking. I thought you were looking to change only the case of a character if\
    \ it was in the string and not change it if it wasn't. My answer should now work\
    \ for you. Let me know if I am still not understanding your requirements\n<|/\
    \ c |>\n<| c |>\nAh I see where I went wrong. I was using the gsub function incorrectly.\
    \ I was trying to find patterns that I could use to replace only the letters that\
    \ I want and not the rest. I was trying to use the pattern to find any letters\
    \ that met a certain criteria and then use gsub to replace only these letters.\
    \ I think I understand now. Thanks for the response.\n<|/ c |>\n<| c |>\nNo worries\
    \ at all. Glad I could help. You can now click the check mark on this answer to\
    \ accept it. If you have any questions, feel free to post them here and I will\
    \ try to assist. Also if my solution worked, ", "\n    if (nchar(s) == 0) {\n\
    \        return(s)\n    }\n    for(i in 1:nchar(s)) {\n        if(!is.character(s[i]))\
    \ {\n            return(s)\n        }\n        if(toupper(s[i]) == s[i]) {\n \
    \           s <- toupper(substring(s, 1, i-1))\n        }\n        if(tolower(s[i])\
    \ == s[i]) {\n            s <- tolower(substring(s, 1, i-1))\n        }\n    }\n\
    \    return(s)\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\nAn answer to\
    \ the question of how to do it in R (I find it easier to understand the process\
    \ of working with strings in R than in other languages):\n<code>\nmyString <-\
    \ \"myString\"\nmyString <- gsub(\" \", \"\", myString)\nmyString <- toupper(myString)\n\
    myString <- gsub(\"[a-z]\", \"\", myString)\n</code>\nThe first line removes spaces\
    \ from the string \"myString\". The second line converts the string to uppercase\
    \ and the third line removes the letters from the string. I had to replace myString\
    \ by myString twice since the first line would not change myString itself. \n\
    You can also do this in one line as follows:\n<code>\nmyString <- gsub(\"[a-z]\"\
    , \"\", gsub(\" \", \"\", myString))\n</code>\nAnd if you want your answer in\
    \ lowercase, use:\n<code>\nmyString <- gsub(\"[A-Z]\", \"\", gsub(\" \", \"\"\
    , myString))\n</code>\nHope this helps!\n<|/ a tags=string,r,lowercase |>\n<|\
    \ a tags=string,r,lowercase |>\nAnother option, using stringi and stringr\n<code>\n\
    library(stringi)\nlibrary(stringr)\ns <- \"hello world\"\nstri_replace_all_regex(s,\
    \ \" +\", \"\") # Remove spaces before and after words\nstringi::stri_replace_all_regex(s,\
    \ \" +\", \"\") # Remove spaces before and after words\nstri_replace_all_regex(s,\
    \ \"^ *\", \"\") # Remove spaces before and after words\nstri_replace_all_regex(s,\
    \ \" *$\", \"\") # Remove spaces before and after words\nstri_replace_all_regex(s,\
    \ \" +\", \"\") # Remove spaces before and after words\nstri_replace_all_regex(s,\
    \ \"(^ *)(.+?)( *$)\", \"\\\\2\\\\1\") # Remove spaces before and after words\n\
    stri_replace_all_regex(s, \"(^ *)(.+?)( *$)\", \"\\\\1\\\\2\") # Remove spaces\
    \ before and after words\nstri_replace_all_regex(s, \"(^ *)(.+?)( *$)\", \"\\\\\
    1\\\\3", "\n  \n  str <- tolower(s)\n  \n  if (grepl(\"[a-z]\", str)){ \n    str\
    \ <- str[str != toupper(str)]\n  }\n  \n  if (grepl(\"[A-Z]\", str)){ \n    str\
    \ <- str[str != tolower(str)]\n  }\n  \n  str\n}\n\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nAnother simple solution, using toupper and tolower:\n<code>\nx <- \"\
    ab#a@C\"\ntoupper(tolower(x))\n[1] \"#a@C\" \"Abc\"   \"Abc\"\n</code>\n<|/ a\
    \ dscore=2 tags=string,regex,r |>\n<| a dscore=1 |>\nHere is another approach\
    \ that works:\n<code>\nsolve<-function(s){\n    \n  str<-strsplit(s,\"\")\n  str<-str[[1]]\n\
    \  str<-toupper(tolower(str))\n  \n  ifelse(grepl(\"[a-z]\",str),paste0(str[str!=\"\
    a\"],str[str!=\"A\"]),paste0(str[str!=\"A\"],str[str!=\"a\"]))\n  \n}\n</code>\n\
    <|/ a tags=string,regex,r |>\n<| a dscore=1 |>\nHere is another way, using regex\n\
    <code>\n> x <- \"ab#a@C\"\n> gsub('([a-z])', toupper, gsub('([A-Z])', tolower,\
    \ x))\n[1] \"#a@C\" \"Abc\"   \"Abc\"\n</code>\n<|/ a tags=string,regex,r |>\n\
    <| a tags=string,regex,r |>\n<code>\nsolve <- function(s) {\n  str <- tolower(s)\n\
    \  if (grepl(\"[a-z]\", str)) {\n    str <- str[str != toupper(str)]\n  }\n  if\
    \ (grepl(\"[A-Z]\", str)) {\n    str <- str[str != tolower(str)]\n  }\n  str\n\
    }\n\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis was my first thought as\
    \ well. However the example given did not produce the desired result, which is:\n\
    <code>", "\n    s <- gsub('[^A-z]', '', s)\n    s <- gsub('(^|\\\\w)([a-z])',\
    \ '\\\\2\\\\1', s)\n    s <- toupper(s)\n    s <- gsub('([a-z])([A-Z])', '\\\\\
    1\\\\2', s)\n    s <- paste(tolower(s), collapse = '')\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI guess you meant `s <- paste0(toupper(s), tolower(s))`\n<|/ c\
    \ |>\n<| a tags=r dscore=0 |>\nTry this \n<code>\nstr_reverse <- function(x) gsub(paste0('[^A-Za-z]',\
    \ ''), \"\", toupper(x)) \ngsub(paste0('[^A-Za-z]', ''), \"\", toupper(s))\n</code>\n\
    <|/ a |>\n<| a tags=r |>\nUsing base R :\n<code>\nsolve<-function(string){\n \
    \ s<-gsub(\"[^A-Za-z]\", \"\", toupper(string))\n  s<-gsub(paste0(\"[A-Za-z]\"\
    , \"\"), \"\", s)\n  s<-gsub(paste0(\"[a-z]\", \"\"), \"\", s)\n  s<-gsub(paste0(\"\
    [A-Z]\", \"\"), \"\", s)\n  s<-paste0(tolower(s), collapse=\"\")\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=r |>\nI assume you mean \"reverse the case of each\
    \ letter or character\" rather than \"reverse the case of the word\"\nHere is\
    \ an R base function that does just that.\n<code>\nreverse_string <- function(string)\
    \ {\n  sapply(string, rev, USE.NAMES = FALSE)\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\n<code>\n    test <- \"abCd\"\n\n    test <- str_reverse(test)\n    test\
    \ <- gsub(paste0(\"(?i)[^A-Za-z]\", \"\"), \"\", test)\n    test <- gsub(paste0(\"\
    (?i)[A-Za-z]\", \"\"), \"\", test)\n    test <- gsub(paste0(\"(?i)[a-z]\", \"\"\
    ), \"\", test)\n    test <- gsub(paste0(\"(?i)[A-Z]\", \"\"), \"\", test)\n  \
    \  test <- toupper(test)\n\n    test\n</code>\n<|/ a dscore=0 tags=r |>\n<| a\
    \ dscore=0 |>\nIf you only have letters in the string, you can do it like this:\n\
    <code>\nstr_reverse <- function(x) gsub(paste0('[^A-Za-z]', ''), ", "\n  str_split_fixed(s,\
    \ '', 2)[[1]] %>% \n    map_chr(~ {\n      case_when(\n        . == \"#\" %in%\
    \ letters,\n        . = .[c(1:(length(.)-2),nchar(.)-1)]\n      )\n    }) %>%\
    \ \n    map_chr(~ {\n      case_when(\n        . == \"@\" %in% letters,\n    \
    \    . = .[c(1,nchar(.)-1)]\n      )\n    })\n}\n\nsolve(1:10)\n</code>\nCreated\
    \ on 2018-08-02 by the reprex package (v0.2.1)\n<|/ a tags=case-when,r,purrr dscore=1\
    \ |>\n<| c |>\nThis works! Thank you. I do have a follow up question. Why does\
    \ the purrr functions return lists rather than strings?\n<|/ c |>\n<| c |>\nBecause\
    \ it works on the `list` of vectors. Each of the `map_chr` returns a vector as\
    \ a result. Hence, when you wrap with str_c, the whole list is converted to a\
    \ single vector. Wrapping with `unlist` would unlist the elements of the list\
    \ to a vector.\n<|/ c |>\n<| a |>\nHere is an approach that uses str_replace_all\
    \ from the stringr package to accomplish this without using any packages.\n<code>\n\
    solve <- function(s)\n{\n    # Remove all # and @ from the string\n    s <- str_replace_all(s,\
    \ c(\"#@\", \"@#\", \"\"))\n    # Convert to upper case if letters are present\n\
    \    s <- toupper(ifelse(s == \"@\", s[c(TRUE, FALSE)], \"#\"))\n    # Replace\
    \ the remaining # and @ with @\n    s <- str_replace_all(s, \"#@\", \"@\")\n \
    \   # Return everything else as is\n    s\n}\n</code>\n<|/ a dscore=1 tags=case-when,r,purrr\
    \ |>\n<| a dscore=1 |>\nI went with a base R option that uses only base functions.\
    \ The idea is to convert the characters to a character vector and apply toupper.\
    \ The toupper is applied only when there is a non letter character present inside\
    \ the character vector. \n<code>\nsolve(1:10)\n", "\n  \n  for(i in 1:nchar(s)){\n\
    \    if(grepl('^[A-Za-z]+$', s[i]) == T) {\n      s[i]<-toupper(s[i])\n    }\n\
    \    else if(grepl('^[A-Za-z]+$', s[i]) == F) {\n      s[i]<-tolower(s[i])\n \
    \   }\n    else {\n      s[i]<-s[i]\n    }\n  }\n  s\n}\n\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nthank you for your response!  I had a question regarding your solution:\
    \ why do you have to wrap `grepl()` inside `ifelse()`? I didn't know that you\
    \ can do `grepl` conditionally like this.  In other words, why can you only use\
    \ `grepl` as a conditional statement once it is inside a `ifelse` statement? In\
    \ other words, why don't I need to do `grepl` a second time in order to get my\
    \ desired result?\n<|/ c |>\n<| c |>\nGreat question, I had a play around and\
    \ discovered that you can do this outside of the `ifelse()` statement but I can't\
    \ tell you why that is. I'll look into it if I can figure it out :)\n<|/ c |>\n\
    <| c |>\nAh I see. I didn't notice your use of grepl() inside `ifelse()`. My apologies\
    \ for that.\n<|/ c |>\n<| a dscore=0 |>\nI managed to get it to work in my environment\
    \ by using the ifelse() function. I also wrapped it in grepl() to remove the need\
    \ for the ifelse(). \n<code>\ntest <- function() {\n  s <- \"Hello\"\n  s1 <-\
    \ ifelse(grepl(\"H\", s), toupper(s), tolower(s))\n  s2 <- ifelse(grepl(\"l\"\
    , s1), tolower(s1), s1)\n  s3 <- ifelse(grepl(\"o\", s2), toupper(s2), s2)\n \
    \ s4\n}\n</code>\n<|/ a tags=r,if-statement,gsub |>\n<| a tags=r,if-statement,gsub\
    \ |>\nA solution that uses no ifelse statements:\n<code>\nsolve <- function(s)\
    \ {\n  s <- gsub(\"([[:alpha:]]+)\", paste0(\"\\\\U\\\\1\", substr(s, 1, 1)),\
    \ s)\n  s <- gsub(\"([[:alpha:]]+)\", paste0(\"\\\\l\\\\1\", substr(s, 2, 2)),\
    \ s)\n  s <- gsub(\"([[:alpha:]]+)\", paste0(\"\\\\o\\\\1\", substr(s, 3, ", "\n\
    \  s <- tolower(s)\n  \n  result <- s\n  \n  if(length(s) == 0){\n    result <-\
    \ s\n    return(result)\n  }\n  \n  \n  for (i in 1:length(s)){\n    \n    if\
    \ (s[i] == 'a') result <- sub('a', 'A', result)\n    if (s[i] == 'b') result <-\
    \ sub('b', 'B', result)\n    if (s[i] == 'c') result <- sub('c', 'C', result)\n\
    \    if (s[i] == 'd') result <- sub('d', 'D', result)\n    if (s[i] == 'e') result\
    \ <- sub('e', 'E', result)\n    if (s[i] == 'f') result <- sub('f', 'F', result)\n\
    \    if (s[i] == 'g') result <- sub('g', 'G', result)\n    if (s[i] == 'h') result\
    \ <- sub('h', 'H', result)\n    if (s[i] == 'i') result <- sub('i', 'I', result)\n\
    \    if (s[i] == 'j') result <- sub('j', 'J', result)\n    if (s[i] == 'k') result\
    \ <- sub('k', 'K', result)\n    if (s[i] == 'l') result <- sub('l', 'L', result)\n\
    \    if (s[i] == 'm') result <- sub('m', 'M', result)\n    if (s[i] == 'n') result\
    \ <- sub('n', 'N', result)\n    if (s[i] == 'o') result <- sub('o', 'O', result)\n\
    \    if (s[i] == 'p') result <- sub('p', 'P', result)\n    if (s[i] == 'q') result\
    \ <- sub('q', 'Q', result)\n    if (s[i] == 'r') result <- sub('r', 'R', result)\n\
    \    if (s[i] == 's') result <- sub('s', 'S', result)\n    if (s[i] == 't') result\
    \ <- sub('t', 'T', result)\n    if (s[i] == 'u') result <- sub('u', 'U', result)\n\
    \    if (s[i] == 'v') result <- sub('v', 'V', result)\n    if (s[i] == 'w') result\
    \ <- sub('w', 'W', result)\n    if (s[i] == 'x') result <- sub('x', 'X', result)\n\
    \    if (s[i] == 'y') result <- sub('y', 'Y', result)\n    if (s[i] == 'z') result\
    \ <- sub('z', 'Z', result)\n    if (s[i] == 'A') result <- sub('A', 'A', result)\n\
    \    if (s[i] == 'B') result <- sub('B', 'B', result)\n    if (s[i] == 'C') result\
    \ <- sub('C', 'C', result)\n    if (s[i] == 'D') result <- sub('D', 'D', result)\n\
    \    if (s[i] == 'E') result <- sub('E', 'E', result)\n    if (s[i] == 'F') result\
    \ <- sub('F', 'F', result)\n    if (s[i] == 'G') result <- ", "\n  s <- as.character(s)\n\
    \  if(!is.character(s)) stop(\"The string must be a character vector!\")\n  if(!all(grepl(\"\
    ^[a-zA-Z]+$\", s))) stop(\"The string must only contain letters!\")\n\n  for(i\
    \ in seq_along(s)) {\n    if(grepl(\"^[a-z]\", s[i])) {\n      s[i] <- toupper(s[i])\n\
    \    } else {\n      s[i] <- tolower(s[i])\n    }\n  }\n  s\n}\n</cell>\n<text>\n\
    Part 4: Resolving SPOJ Problem #3\nIn this problem, you are to find all possible\
    \ ways of partitioning the numbers from 1 to 9 into 3 sets.\n\n\n</text>\n<cell>",
  "\n    require(stringr)\n    \n    s <- str_replace_all(s, '[a-z]', 'U')\n    s\
    \ <- str_replace_all(s, '[A-Z]', 'l')\n    s <- str_replace_all(s, '[\\\\W]',\
    \ '')\n    \n    s\n}\n", "\n    if(length(s) == 0) return(s)\n    x <- toupper(s)\n\
    \    for(i in seq(1, nchar(x))){\n        if(isalpha(x[[i]])) x[[i]] <- toupper(x[[i]])\n\
    \        else if(isalpha(x[[i]])) x[[i]] <- tolower(x[[i]])\n        else x[[i]]\
    \ <- x[[i]]\n    }\n    return(x)\n}\n</code>\nThe first part is the same as the\
    \ code in the question.\nThe second part is a for loop to iterate over each letter\
    \ of the string.\nThe third part is the isalpha function to check if it is a letter.\
    \  \nIf it is, then it just needs to be reversed from lower to upper or vise versa,\
    \ otherwise it stays the same.\nIf it is neither of those then it is just copied\
    \ to the new string.  \nNote that this approach is very inefficient as it iterates\
    \ over each letter and converts it to a new string.  \nYou could improve this\
    \ by converting the string to lower case before you start looping though it.\n\
    For example,\n<code>\nx <- tolower(s)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\nWe can use tolower from base R to convert all the characters to lower case\
    \ and then use that in ifelse to reverse the case as per the condition in OP's\
    \ post\n<code>\n s <- c(\"1\",\"2\",\"3\",\"4\",\"5\")\n ifelse(grepl(\"^[0-9]+$\"\
    , s), tolower(s), \"no numbers\")", "\n    for(i in 1:length(s)) {\n        if(s[i]\
    \ <= 'Z') {\n            s[i] <- toupper(s[i])\n        } else {\n           \
    \ s[i] <- tolower(s[i])\n        }\n    }\n    s <- paste0(s,collapse=\"\")\n\
    \    s <- gsub(\"[A-Z]+\", toupper, s)\n    s <- gsub(\"[a-z]+\", tolower, s)\n\
    \    s <- gsub(\"[^A-Z]+\", toupper, s)\n    s <- gsub(\"[^a-z]+\", tolower, s)\n\
    \    s\n}\n", "\n  \n  s <- as.character(s)\n  \n  s <- s[!grepl(\"[a-z]+\", s)]\
    \ # delete letters if no letters left\n  \n  s <- gsub(\"[a-z]+\", toupper(s),\
    \ s) # convert to uppercase if needed\n  \n  s <- gsub(\"[^A-Z]+\", toupper(s),\
    \ s) # convert to uppercase if needed\n  \n  s <- gsub(\"[a-z]+\", tolower(s),\
    \ s) # convert to lowercase if needed\n  \n  s <- gsub(\"[^A-Z]+\", tolower(s),\
    \ s) # convert to lowercase if needed\n  \n  s\n}\n</code>\n<|/ a tags=r dscore=0\
    \ |>\n<| a dscore=0 |>\nI did it this way using sapply and grep\n<code>\nsapply(strsplit(s,\
    \ split = \"(?=\\\\w)\", perl = TRUE), function(x) {\n  unlist(lapply(x, function(y)\
    \ ifelse(grepl(\"[a-z]\", y), toupper(y), tolower(y)))\n})\n", "\n  nchar(s) *\
    \ sapply(s, nchar)\n}\n</cell>\n<cell>\nprint(solve(letters))\n</cell>\n<text>\n\
    Problem 7\nWrite a function is_palindrome that accepts a character string and\
    \ returns true if and only if the input is a palindrome.\n\ndef is_palindrome(s):\n\
    \    # TODO\n    return\nWrite a second function that determines if the input\
    \ is a palindrome recursively.\nIf it is, the function should return True, otherwise\
    \ False.\nThe function should return True if and only if there is a palindrome\
    \ within a single character string.\n\ndef is_palindrome_recursive(s):\n    #\
    \ TODO\n    return\n\n</text>\n<cell>\ndef is_palindrome(s):\n    if len(s) <=\
    \ 1:\n        return True\n    if s[0] == s[-1]:\n        return is_palindrome_recursive(s,\
    \ 0, len(s)-1)\n    return False\n\ndef is_palindrome_recursive(s, start, end):\n\
    \    if start > end:\n        return True\n    if s[start] != s[end]:\n      \
    \  return False\n    return is_palindrome_recursive(s, start+1, end-1)\n\nis_palindrome(letters)\n\
    </cell>\n<cell>\nprint(is_palindrome(letters))\nprint(is_palindrome(letters[:]))\n\
    </cell>\n<text>\nProblem 8\nWrite a function called reverse that accepts a character\
    \ vector and return the same vector with reversed order of characters (i.e. 'abc'\
    \ -> 'cba').\n\ndef reverse(s):\n    # TODO\n    return\nNow create another function\
    \ called reverse that accepts a character vector and returns a new character vector\
    \ that is the reverse of the input. \nThe function should only accept vectors\
    \ of characters of length greater than 0.\n\ndef reverse_recursive(s):\n    #\
    \ TODO\n    return\n\n</text>\n<cell>\ndef reverse(s):\n    \n    n = 0\n    for\
    \ i in range(n-1, 0, -1):\n        nchar(s)\n    \n    reversed_chars = s[n:][::-1]\n\
    \    \n    return reversed_chars\n    \ndef reverse_recursive(s):\n    \n    if\
    \ len(s) <= 0:\n        return s\n    \n    if len(s) > 1:\n        return reverse_recursive(s[1:])\n\
    \    \n    reversed_chars = s[::-1]\n    \n    return reversed_chars\n\nreverse(s)\n\
    </cell>\n<cell>\nprint(reverse_recursive(s))\nprint(reverse_recursive(letters))\n\
    print(reverse_recursive(letters[:]))\n</cell>\n<text>\nProblem 9\nWrite a function\
    \ called count_times that accepts a character vector as argument and returns the\
    \ number of times each character appears in the given vector.\n\ndef count_times(",
  "\n  s2 <- paste(toupper(s), tolower(s), sep='')\n  gsub('.', '', s2)\n}\n</cell>\n\
    <cell>", "\n  # Write your code here\n  s <- gsub(\" \", \"\", s)\n  s <- gsub(\"\
    ^[[:alpha:]]+\", \"\", s)\n  s <- gsub(\"[[:alpha:]]+$\", \"\", s)\n  return(s)\n\
    }\n", "\n  s <- gsub(\"([a-z])([A-Z])\", \"\\\\2\\\\1\", s)\n  s <- gsub(\"([A-Z])([A-Z])\"\
    , \"\\\\1\\\\2\", s)\n  s <- gsub(\"([A-Z])\", \"\\\\1\", s)\n  s\n}\n", "\n\t\
    len <- nchar(s)\n\ti <- 1\n\twhile(i <= len) {\n\t\tif((substring(s, i, 1) ==\
    \ substring(toupper(substring(s, i, 1)), \n\t\t\ti, 1)) || \n\t\t\t(substring(s,\
    \ i, 1) == substring(tolower(substring(s, i, 1)), \n\t\t\ti, 1))) {\n\t\t\ts <-\
    \ substring(s, i, 2) \n\t\t} else {\n\t\t\ts <- substring(s, i, 1)\n\t\t}\n\t\t\
    i <- i + 1\n\t}\n\treturn(s)\n}\n</code>\n<|/ a tags=r,string dscore=1 |>\n<|\
    \ a dscore=1 |>\nThe most concise way to do that is to use regexec, for example:\n\
    <code>\nx <- '1234'\nsub('^([a-z])|([A-Z])$', '', regexec(\"[[:lower:]]*([[:upper:]])\"\
    , x)[[1]][2])", "\n  charToUpper <- function(char) {\n    charToLower <- function(char)\
    \ {\n      switch(char, \n               a = toupper(char), \n               A\
    \ = toupper(char), \n               b = tolower(char), \n               B = tolower(char),\
    \ \n               c = char,\n               C = \"\") \n    }\n    lapply(char,\
    \ charToLower) \n  }\n  lapply(s, charToUpper) \n}\n</code>\n<|/ a tags=string,r\
    \ |>\n<| c |>\nHi Alexis, thank you for this. It works with the example I used\
    \ but does not work for the other examples I put in my question. I would like\
    \ to use this code for other examples as well. The \"r\" in the answer needs to\
    \ be the letter \"r\" and not the letter \"R\" as it would if the letter \"R\"\
    \ was the first letter of the string and not the second.\n<|/ c |>\n<| c |>\n\
    , please read my answer carefully: \"The function should return the resulted string\"\
    . It says \"The function should return the resulted string\" and it also uses\
    \ `r`. That is: `solve(r(\"ab\"))` returns `\"AB\"`. And I used `r` in my examples.\
    \ Why do you think `R` is different?\n<|/ c |>\n<| c |>\nSorry, I misunderstood\
    \ that. This solves my issue thank you very much Alexis!\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nsolve <- function(x) {\n  sx <- strsplit(x, \"\")[[1]]\n  sx <-\
    \ lapply(sx, function(x) ifelse(x %in% LETTERS, toupper(x), tolower(x)))\n  return(paste(sx,\
    \ collapse = \"\"))\n}\n\nsolve(\"abc\")\n[1] \"abc\"\nsolve(\"Randall\")\n[1]\
    \ \"Randall\"\nsolve(\"r\")\n[1] \"R\"\n</code>\n<|/ a tags=string,r |>\n<| a\
    \ |>\nA simple way would be:\n<code>\nsolve <- function(x) {\n  ifelse(is.na(sapply(x,\
    \ is.character)), \n         paste(toupper(x), collapse=\"\"), \n         paste(tolower(x),\
    \ collapse=\"\"))\n}\n\nsolve(\"Randall\")", "\n  r <- sapply(strsplit(s, \"\"\
    ), function(x) gsub(LETTERS, toupper(x), x))\n  ifelse(length(r) == 0, strsplit(s,\
    \ \"\")[[1]][-1], paste0(r[length(r):1]))\n}\n\nsolve(\"1234\") # 4321\nsolve(\"\
    ab\") # AB\nsolve(\"a@C\") # a@C\nsolve(\"#a@C\") # #a@C\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 tags=string,r |>\n<code>", "\n  # Your code here\n  \n}\n\n\
    assert(solve('1234') == '4321')\nassert(solve('ab') == 'AB')\nassert(solve('#a@C')\
    \ == '#A@c')\n</cell>\n<cell>", "\n    s <- str_replace_all(s, \"[[:upper:]]\"\
    , toupper)\n    s <- str_replace_all(s, \"[[:lower:]]\", tolower)\n    s <- str_replace_all(s,\
    \ \"[^[:alpha:]]\", toupper)\n    s <- str_replace_all(s, \"[^[:alpha:]]\", tolower)\n\
    \    return(toupper(s))\n}\n", "\n  s <- gsub(\"^[[:alpha:]]*|[[:alpha:]]*$\"\
    , \"\", s)\n  s <- gsub(\"[[:alpha:]]\", \"\", s)\n  \n  if(s == \"\") return(toupper(tolower(s)))\n\
    \  \n  res <- \"\"\n  \n  for(i in 1:nchar(s)) {\n    \n    current <- substr(s,\
    \ i, i + 1)\n    if(current == \"\") current <- \"\"\n    \n    if(current %in%\
    \ letters) current <- toupper(tolower(current))\n    if(current %in% LETTERS)\
    \ current <- toupper(current)\n    if(current %in% letters) current <- tolower(current)\n\
    \    if(current %in% LETTERS) current <- tolower(current)\n    \n    res <- paste0(res,\
    \ current)\n  }\n  \n  return(res)\n}\n\n</cell>\n<cell>", "\n  s <- as.character(s)\n\
    \  ifelse(any(grepl('[A-Za-z]', s)), \n         paste0(toupper(substring(s, 1,\
    \ nchar(s))), \n                substring(s, nchar(s))), \n         paste0(rep(tolower(substring(s,\
    \ 1, nchar(s))),\n                  nchar(s)),\n                substring(s, nchar(s))))\n\
    }\n</code>\n<|/ a dscore=3 tags=string,r |>\n<| a tags=string,r |>\nWe can use\
    \ sub with gsub to capture group of characters that are not letters or digits,\
    \ replace it with lower case and concatenate with the original string.  Get the\
    \ length of grepl and substring with that length.\n<code>\nsolve = function(str){\n\
    \  str <- as.character(str)\n  i1 <- grepl(\"[A-Za-z]\",str)\n  sub(\"[A-Za-z]\"\
    , tolower(str[i1]), str) \n}\n\nsolve(c('1234', 'abc'))", "\n  \n  str <- s\n\
    \  \n  char_to_upper <- function(s) {\n    \n    str <- s\n    \n    for(i in\
    \ 1:nchar(s)){\n      \n      if((substring(s, i, i) == \"A\") && (substring(s,\
    \ i+1, i) == \"a\")) { \n        \n        char_to_upper <- substring(s, i+1,\
    \ i+1)\n      }\n      \n      else if((substring(s, i, i) == \"a\") && (substring(s,\
    \ i+1, i) == \"A\")) {\n        \n        char_to_upper <- substring(s, i+1, i+1)\n\
    \      }\n      \n      else if((substring(s, i, i) == \"B\") && (substring(s,\
    \ i+1, i) == \"b\")) { \n        \n        char_to_upper <- substring(s, i+1,\
    \ i+1)\n      }\n      \n      else if((substring(s, i, i) == \"b\") && (substring(s,\
    \ i+1, i) == \"B\")) {\n        \n        char_to_upper <- substring(s, i+1, i+1)\n\
    \      }\n      \n      else if((substring(s, i, i) == \"C\") && (substring(s,\
    \ i+1, i) == \"c\")) { \n        \n        char_to_upper <- substring(s, i+1,\
    \ i+1)\n      }\n      \n      else if((substring(s, i, i) == \"c\") && (substring(s,\
    \ i+1, i) == \"C\")) {\n        \n        char_to_upper <- substring(s, i+1, i+1)\n\
    \      }\n      \n      else if((substring(s, i, i) == \"D\") && (substring(s,\
    \ i+1, i) == \"d\")) { \n        \n        char_to_upper <- substring(s, i+1,\
    \ i+1)\n      }\n      \n      else if((substring(s, i, i) == \"d\") && (substring(s,\
    \ i+1, i) == \"D\")) {\n        \n        char_to_upper <- substring(s, i+1, i+1)\n\
    \      }\n      \n      else if((substring(s, i, i) == \"E\") && (substring(s,\
    \ i+1, i) == \"e\")) { \n        \n        char_to_upper <- substring(s, i+1,\
    \ i+1)\n      }\n      \n      else if((substring(s, i, i) == \"e\") && (substring(s,\
    \ i+1, i) == \"E\")) {\n        \n        char_to_upper <- substring(s, i+1, i+1)\n\
    \      }\n      \n      else if((substring(s, i, i) == \"F\") && (substring(s,\
    \ i+1, i) == \"f\")) { \n        \n        char_to_upper <- substring(s, i+1,\
    \ i+1)\n      }\n      \n      else if((substring(s, i, i) == \"f\") && (substring(s,\
    \ i+1, i) == \"F\")) {\n        \n        char_to_upper <- substring(s, i+1, i+1)\n\
    \      }\n      \n      else if((substring(s, i, ", "\n  \n  if(s <- gsub(paste0('(?=.)',\
    \ \n                       paste0(\"(^|[^a-zA-Z])\", \n                      \
    \         collapse = \"|\"), \n                       \")\"), \n          \"\\\
    \\U\\\\1\", \n          s)) {\n    s\n  } else {\n    paste0(toupper(substr(s,\
    \ 1, 1)), \n           substr(s, 2, nchar(s)), \n           toupper(substr(s,\
    \ nchar(s), nchar(s)))) \n  }\n}\n\nsolve(\"1234\")", "\n  s <- tolower(s) # or\
    \ toupper(s)\n  sapply(s, grepl, pattern = \"^[a-z]*$\", USE.NAMES = FALSE)\n\
    \  if(!any())\n    \"\"\n  else\n    gsub(\"([a-z])([A-Z])\", \"\\\\1\\\\2\",\
    \ s)\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nWe can use gsub here with regex\
    \ lookarounds. \n<code>\ngsub(\"(?<=\\\\p{L})(?=\\\\p{L})|(?<=\\\\p{Lu})(?=\\\\\
    p{L})\", \"\\\\1\", string)\n</code>\n<|/ a tags=r,string dscore=1 |>\n<| c |>\n\
    Nice, however your pattern will fail with `L`, `u` and `U`. Also it will fail\
    \ with characters outside the ASCII range.\n<|/ c |>\n<| c |>\nYeah, that would\
    \ be a problem\n<|/ c |>\n<| a |>\nYou could also try a solution like this:\n\
    <code>\nstring <- c(\"1234\",\"ab\",\"#a@C\")\n\nstring <- gsub(\"^\\\\w+|(\\\\\
    p{L}+)|(\\\\p{Lu})\",\"\\\\1\", string)\n\nstring", "\n  if(!nchar(s)){\n    return(s)\n\
    \  }\n  for(i in seq_along(s)) {\n    if(!grepl('^[a-z]+$', s[i])) {\n      s[[i]]\
    \ <- toupper(s[[i]])\n    } else {\n      s[[i]] <- tolower(s[[i]])\n    }\n \
    \ }\n  return(paste(s,collapse = ' '))\n}\n</cell>\n<cell>\nsolve('ab')\n</cell>\n\
    <cell>\nsolve('abc')\n</cell>\n<cell>\nsolve('abcde')\n</cell>\n<cell>\nsolve('abaac')\n\
    </cell>\n<cell>\nsolve('abaac')\n</cell>\n<text>\nExercise 1\n\n</text>\n<text>\n\
    Let 'x' be an arbitrary integer.\n\n\n</text>\n<cell>\nx <- 10\n</cell>\n<text>\n\
    Find the value of y such that:\n\n\n</text>\n<text>\n$$\nx \\times y = \\begin{cases}\
    \ \n1 \\\n\\end{cases}\n$$\n\n\n</text>\n<cell>", "\n  s <- gsub(\"[^a-zA-Z]\"\
    , \"\", s)\n  if(!is.na(s)) return(gsub(\"^[a-z]\", toupper, s))\n  return(tolower(gsub(\"\
    ^[a-z]\", toupper, s)))\n}\n", "\n  res <- \"\"\n  for(i in seq_along(s)) {\n\
    \    if(substr(s[i],1,1) != substr(s[i],2,2)) {\n      res <- paste(rev, substr(s,i,1),\
    \ collapse = \"\")\n    } else {\n      res <- paste(rev, substr(s,i,2), collapse\
    \ = \"\")\n    }\n  }\n  return(res)\n}\n</code>\n<|/ a tags=r,string |>\n<| c\
    \ |>\nThanks for your help! My apologies for not being able to ask my question\
    \ better. I just started learning R, so I thought the way I presented my question\
    \ was the best I could. Sorry about that.\n<|/ c |>\n<| c |>\nNo worries. In that\
    \ case my answer should work. Have you tried running my code? It seems to me it\
    \ ought to work. I also tested the solution given by and it works as well.\n<|/\
    \ c |>\n<| c |>\nYes, it worked. Thanks a lot! Sorry I haven't tried your code,\
    \ I appreciate your help!\n<|/ c |>\n<| c |>\nNo problem, glad I could help.\n\
    <|/ c |>\n<| a |>\n<code>\n> mystring <- \"#a@C\"\n> gsub(\".$\",\"\",mystring)\n\
    [1] \"#a@C\"\n> gsub(\"^.\", \"\", mystring)\n[1] \"ABC\"\n> mystring <- \"#a@C\"\
    \n> gsub(\"^.\", \"\", mystring)\n[1] \"#a@C\"\n> mystring <- \"#a@C\"\n> gsub(\"\
    .$\", \"\", mystring)\n[1] \"#a@C\"\n> mystring <- \"#a@C\"\n> gsub(\"^.\", \"\
    \", mystring)\n[1] \"#a@C\"\n> mystring <- \"#a@C\"\n> gsub(\".$\", \"\", mystring)\n\
    [1] \"#a@C\"\n> mystring <- \"#a@C\"\n> gsub(\"^.\", \"\", mystring)\n[1] \"#a@C\"\
    \n> mystring <- \"#a@C\"\n> gsub(\".$\", \"\", mystring)\n[1] \"#a@C\"\n> mystring\
    \ <- \"#a@C\"\n> gsub(\"^.\", \"\", mystring)\n[1] \"#a@C\"\n> mystring <- \"\
    #a@C\"\n> gsub(\".$\", \"\", mystring)\n", "\n  s <- strsplit(s, '')\n  sapply(s,\
    \ function(x) {\n    if(is.na(x)) return(x)\n    y <- toupper(x)\n    if(y %in%\
    \ 'ABC') return(toupper(x)) else\n      return(tolower(x))\n  })\n}\n</code>\n\
    This returns: \n<code>\nsolve(c(\"a\",\"b\",\"c\",\"d\",\"E\"))\n[1] \"A\" \"\
    B\" \"C\" \"D\" \"e\"\n</code>\n<|/ a |>\n<| a tags=r,string,capitalization dscore=0\
    \ |>\n<code>\nstr1 <- \"ABCDEF\"\nstr2 <- \"ABCDEF\"\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(str2)\nstr1 <- toupper(str1)\n\
    str2 <- tolower(str2)\nstr1 <- toupper(str1)\nstr2 <- tolower(", "\n  \n  s <-\
    \ as.character(s)\n  \n  if(!is.character(s)) stop(\"the argument is not character\"\
    )\n  \n  s <- toupper(s)\n  \n  s <- paste0(substr(s, 1, 1), substr(s, 2, 1),\
    \ substr(s, 3, 1))\n  \n  s <- tolower(s)\n  \n  s\n  \n}\n</cell>\n<cell>", "\n\
    \    \n    result <- ''\n    \n    for (i in seq(1, nchar(s))) {\n        \n \
    \       if (is.alpha(substr(s, i, 1))) {\n            \n            result <-\
    \ substr(s, i, 1) \n            result <- toupper(result)\n            result\
    \ <- gsub(toupper(result), tolower(result), s, fixed = TRUE)\n            result\
    \ <- gsub(tolower(result), toupper(result), s, fixed = TRUE)\n            \n \
    \       } else {\n            \n            result <- gsub(toupper(substr(s, i,\
    \ 1)), tolower(substr(s, i, 1)), result, fixed = TRUE)\n            result <-\
    \ gsub(tolower(substr(s, i, 1)), toupper(substr(s, i, 1)), result, fixed = TRUE)\n\
    \        }\n    }\n    \n    return(result)\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\n\
    solution <- function(x) {\n  y <- gsub(\" \", \"\", x)\n  return(paste(substr(y,\
    \ 1, 1), substring(y, 2, nchar(y)), sep = \"\"))\n}\n\nx <- \"a b c d\"\nsolution(x)",
  "\n  if(!is.character(s)) stop(\"The input must be a character vector.\")\n  \n\
    \  if(!any(grepl('^[A-Za-z]+$', s))) {\n    s <- toupper(s)\n  }\n  \n  if(!any(grepl('^[a-z]+$',\
    \ s))) {\n    s <- tolower(s)\n  }\n  \n  s\n}\n", "\n    if(!is.character(s))\
    \ stop(\"Parameter must be character string\")\n    x <- strsplit(s, \"\")\n \
    \   y <- unlist(lapply(x, function(x) {\n        y <- toupper(x)\n        if(x\
    \ == y) x else x\n    }))\n    paste(y, collapse = \"\")\n}\n", "\n  s <- toupper(s)\n\
    \  if (nchar(s) > 0) {\n    s <- tolower(s)\n  }\n  s\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\nThe other answers here have covered the basic idea, and\
    \ are correct in that you need to convert the string to a character vector. However,\
    \ they missed one point:\n<code>\ngsub(\"[^[:alpha:]]\", \"\", s)\n</code>\nThis\
    \ removes any non-alpha characters in the string s. \nThe reason for this is that\
    \ when you pass a string like \"abc\", R passes the string \"abc\" to gsub and\
    \ will try to match the pattern \"[^[:alpha:]]\" against \"abc\", which obviously\
    \ fails. By passing the argument \"[^[:alpha:]]\", it passes the regex \"[^[:alpha:]]\"\
    \ to the function which matches the pattern against the string \"abc\".\n<|/ a\
    \ tags=r |>\n<| a tags=r |>\nThis should work.\n<code>", "\n  \n  # Code here\n\
    \  \n}\n\n</cell>\n<text>\nSolution\n\n</text>\n<text>\nWe can leverage regular\
    \ expressions here to handle this case where we don't just want to replace the\
    \ first letter. We also want to make sure that any characters that follow the\
    \ lowercase letter are also being reversed.\n\n\\w matches a word character in\
    \ any language. \\w is equivalent to [a-zA-Z0-9_]. This includes all characters\
    \ commonly used on computers (like punctuation, numbers, etc).\n\n\\W matches\
    \ any character that is not a word character.\n\n\\d matches a digit from 0 to\
    \ 9.\n\n\\D matches any character that is not a digit.\n\n\\s matches a whitespace\
    \ character from space (ASCII 32) to tab character (ASCII 9).\n\n\\S matches any\
    \ character that is not a whitespace character.\n\n\\d matches a digit from 0\
    \ to 9.\n\n\\D matches any character that is not a digit.\n\n\\s matches a whitespace\
    \ character from space (ASCII 32) to tab character (ASCII 9).\n\n\\S matches any\
    \ character that is not a whitespace character.\n\n\n</text>\n<text>\n\\w matches\
    \ a word character in any language. \\w is equivalent to [a-zA-Z0-9_]. This includes\
    \ all characters commonly used on computers (like punctuation, numbers, etc).\n\
    \n\n</text>\n<cell>", "\n  \n  s <- str_replace_all(s, '#', '')\n  \n  s <- str_replace_all(s,\
    \ ' ', '')\n  \n  s <- str_replace_all(s, '!', '')\n  \n  s <- str_replace_all(s,\
    \ '@', '')\n  \n  s <- str_replace_all(s, '#', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s <- str_replace_all(s,\
    \ '$', '')\n  \n  s <- str_replace_all(s, '$', '')\n  \n  s ", "\n  a <- gregexpr(\"\
    [a-z]+\", s)\n  if (length(a) != 0) {\n    x <- mapply(function(x, y) gsub(\"\
    [a-z]+\", y, x), s, a)\n    paste(x, collapse=\"\")\n  } else {\n    gsub(\" \"\
    , \"\", s)\n  }\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't solve the\
    \ OP's problem at all\n<|/ c |>\n<| c |>\nThis does solve the OP's question, and\
    \ is very easy to adapt to meet the OP's needs.\n<|/ c |>\n<| c |>\nOP has mentioned\
    \ this in the question comments.\n<|/ c |>\n<| c |>\nAh, I see. Thanks for your\
    \ contribution, Ronak.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nstringr::str_replace_all(s,\
    \ c(\"\\\\s\", \"\\\\w\", \"\\\\d\", \"\\\\W\", \"\\\\d.\", \"\\\\D\", \"\\\\\
    d.\", \"\\\\D\\\\W\"))", "\n  s <- gsub(\" \", \"\", s, ignore.case = T)\n  s\
    \ <- gsub(\"[A-Z]\", \"\", s, ignore.case = T)\n  s <- gsub(\"[a-z]\", \"\", s,\
    \ ignore.case = T)\n  if(grepl(\"[a-z]\", s)) {\n    s <- toupper(tolower(s))\n\
    \  } else {\n    s <- tolower(s)\n  }\n  s\n}\n</code>\n<|/ a |>\n<| c |>\nWhy\
    \ do you have `return(tolower(toupper(s))` instead of `s <- tolower(toupper(s))`?\
    \ It seems like an extra step isn't it?\n<|/ c |>\n<| c |>\nIt's only a choice\
    \ of style. My preferences would be to return a new string (to maintain the original\
    \ argument) OR mutate the original argument (and return nothing).\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\nsolve<-function(x){\n  x <- strsplit(x, \"\")[[1]]\n\
    \  x <- strsplit(x,\"\")[[1]]\n  x <- strsplit(x,\"\")[[1]]\n  x <- strsplit(x,\"\
    \")[[1]]\n  x <- strsplit(x,\"\")[[1]]\n  x <- paste(ifelse(grepl(\"[a-z]\",x),\
    \ toupper(tolower(x)),x), collapse = \"\")\n  return(x)\n}\n\nsolve(\"aA@C\")\n\
    solve(\"a A@C \")\nsolve(\"abc 123\")\nsolve(\"abc 123 aA@C \")\nsolve(\"abc 123\
    \ aA@C ab\")\n</code>\n<|/ a tags=string,r |>\n<| a tags=string,r |>\nYou can\
    \ use the function strsplit. Here are some examples:\n<code>\nsolve<-function(x){\n\
    \    x <- strsplit(x, \"\")[[1]]\n    x <- paste(ifelse(grepl(\"[a-z]\",x), toupper(tolower(x)),x),\
    \ collapse = \"\")\n    return(x)\n}\n\nsolve(\"aA@C\")\nsolve(\"a A@C \")\nsolve(\"\
    abc 123\")\nsolve(\"abc 123 aA@C \")\nsolve(\"abc 123 aA@C ab\")\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nYou could use regular expressions to match the characters\
    \ you want.\n<code>\nsolve <- function(s) {\n  gsub(\"([a-z])\",function(x) toupper(tolower(x)),s)\n\
    }\n</code>\n<|/ a dscore=1 ", "\n  s <- gsub(\"[^A-Za-z]\", \"\", s)\n  s <- toupper(tolower(s))\n\
    \  s <- paste0(s,collapse = '')\n  s\n}\n</code>\n<|/ a tags=r,string,reverse\
    \ dscore=2 |>\n<| c |>\nI appreciate your answer. I will also look into using\
    \ gsub for the replacement.\n<|/ c |>\n<| c |>\nHi this works great, I have been\
    \ trying to get this for a while now. Thank you for your help! Also thank you\
    \ for the explanation, that really helps too!\n<|/ c |>\n<| a dscore=1 tags=r,string,reverse\
    \ |>\nIf you just want to swap the order of the first and last characters, then\
    \ this should do it.\n<code>\nmyString <- c(\"foo\", \"bar\", \"baz\")\nmyString[1]\
    \ <- paste0(rev(substr(myString[1], 1, 1)),substr(myString[1], 2, nchar(myString[1])))\n\
    myString[2] <- paste0(rev(substr(myString[2], 1, 1)),substr(myString[2], 2, nchar(myString[2])))\n\
    \n> myString\n[1] \"oof\" \"rab\" \"azz\"\n</code>\n<|/ a |>\n<| c |>\nI think\
    \ my original approach was more succinct. Although I believe yours is probably\
    \ faster since it avoids looping through the characters. I guess I like this one.\n\
    <|/ c |>\n<| c |>\nYes, that also sounds better, but I felt a for loop was more\
    \ \"straight forward\" :)\n<|/ c |>\n<| a dscore=1 |>\nIn case you just want to\
    \ swap the characters from first and last to any position in string\n<code>\n\
    > s <- c(\"foo\", \"bar\", \"baz\")\n> substr(s, 1,2) <- paste0(rev(substr(s,\
    \ 1, 1)),substr(s, 2, nchar(s)))\n> s\n[1] \"oof\" \"rab\" \"azz\"\n</code>\n\
    <|/ a tags=r,string,reverse |>\n<| a |>\nHere's another option:\n<code>\nsolve(substr(s,\
    \ 1,2) <- toupper(tolower(substr(s, 1, 1))),\n      substr(s, 1,2) <- toupper(tolower(substr(s,\
    \ 2, nchar(s) - 1)))\n)\n[1] \"oof\" \"rab\" \"azz\"\n</code>\n<|/ a tags=r,string,reverse\
    \ dscore=1 |>\n<| a tags=r,string,reverse |>\nHere is a base R option:\n<code>\n\
    s <- c(\"foo\", \"bar", "\n  \n  if(!length(s)) return s\n  \n  for(i in 1:length(s)){\n\
    \    if(s[i] == toupper(s[i])){\n      s <- tolower(s)\n      \n    } else if(s[i]\
    \ == tolower(s[i])){\n      s <- toupper(s)\n      \n    }\n  }\n  \n  s\n}\n",
  "\n  \n  return(paste(toupper(sub('[a-z]', '', s)), tolower(sub('[A-Z]', '', s)),\
    \ sep = \"\"))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you! This was a\
    \ great answer!\n<|/ c |>\n<| a |>\nHere's my two cents:\n<code>\nsolve  <- function(x)\
    \ {\n    x <- ifelse(grepl(\"[A-Z]\", x), toupper(x), tolower(x))\n    x <- ifelse(grepl(\"\
    [a-z]\", x), tolower(x), x)\n    x\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| a\
    \ dscore=2 tags=r |>\nThis solution relies on only base R and its gsub function:\n\
    <code>\nsolve <- function(x) {\n  x <- gsub(\"[[:alpha:]]\", \"\", x)\n  x <-\
    \ gsub(\"[[:lower:]]\", \"\", x)\n  return(x)\n}\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nHere is an option with str_extract from stringr\n<code>\nlibrary(stringr)\n\
    solve <- function(x) {\n   v1 <- str_extract(tolower(x), \"[a-z]+\")\n   v2 <-\
    \ str_extract(toupper(x), \"[A-Z]+\")\n   v3 <- toupper(x)\n   v4 <- tolower(x)\n\
    \   return(c(v1,v2,v3,v4))\n }\n solve('ab')\n #[1] \"AB\"\n solve('1234')\n #[1]\
    \ \"4321\"\n</code>\n<|/ a tags=r |>\n<| a dscore=2 |>\nAnother base R option\
    \ using grepl:\n<code>\nsolve <- function(x) {\n    x <- ifelse(grepl(\"[A-Z]\"\
    , x), toupper(x), tolower(x))\n    x <- ifelse(grepl(\"[a-z]\", x), tolower(x),\
    \ x)\n    x\n}\n\nsolve('ab')", "\n  str <- ifelse(grepl(\"[a-z]\", s), toupper(s),\
    \ tolower(s))\n  return(paste0(str[seq(1, length(str), 2)], str[-(seq(1, length(str),\
    \ 2)):length(str)])\n}\n</code>\n<|/ a tags=r,gsub dscore=4 |>\n<| c |>\nThanks\
    \ for the solution. But I would like to see a solution without using regex.\n\
    <|/ c |>\n<| c |>\nI am also looking for solutions without regex.\n<|/ c |>\n\
    <| c |>\nThanks for providing a solution. However, I think you forgot to change\
    \ `ifelse` to `if` inside the function body. As far as I know, `ifelse` returns\
    \ the first value which evaluates to TRUE while `if` returns the first value which\
    \ evaluates to `FALSE`.\n<|/ c |>\n<| c |>\n, you're right. I've fixed it. The\
    \ `str` variable is already defined inside the function. I've just edited the\
    \ answer. Thanks!\n<|/ c |>\n<| a dscore=3 |>\nYou can try this :\n<code>\nx <-\
    \ c(\"AaBbCcDd\", \"aAaBbCcDd\", \"AbBbCcDd\")\ny <- strsplit(x, \"\")[[1]]\n\n\
    z <- lapply(y, function(x){\n  ifelse(grepl(\"[a-z]\", x), toupper(x), tolower(x))\n\
    })\n\npaste(z[[1]], z[[2]], z[[3]])\n</code>\n<|/ a tags=r,gsub |>\n<| c |>\n\
    I like the `lapply` approach here, but I think you missed the point of question.\
    \ I am looking for solutions without regex.\n<|/ c |>\n<| c |>\nI know, but you\
    \ mentioned regex and I thought to give a solution which uses regex :-)\n<|/ c\
    \ |>\n<| c |>\nThanks for the solution. I know about this approach but my question\
    \ was regarding a solution without regex.\n<|/ c |>\n<| a tags=r,gsub |>\nThe\
    \ OP specifically asked for solutions without using regex. \nHere's an answer\
    \ that uses no regex, but still uses base R. \n<code>\nsolve <- function(x) {\n\
    \  charvec <- c(\"A\", \"B\", \"C\", \"D\")\n  result <- \"\"\n\n  for (i in 1:length(x))\
    \ {\n    result <- paste0(result, charvec[x[i] %in% charvec])\n  }\n\n  result\n\
    }\n\nsolve(\"aAaB", "\n  s <- str_replace_all(s, '#|\\\\@|\\\\#|\\\\$|\\\\%|\\\
    \\^|\\\\&|\\\\*|\\\\(|\\\\)|\\\\[|\\\\]|\\\\{|\\\\}|\\\\:|\\\\,|\\\\;|\\\\:|\\\
    \\/|\\\\=')\n  s <- str_replace_all(s, '\\\\.\\\\.\\\\.|..|...|....|.....|9999|9999999|9\\\
    \\d{9}')\n  s <- str_replace_all(s, '\\\\?', '')\n  s <- str_replace_all(s, '^',\
    \ '')\n  s <- str_replace_all(s, '$', '')\n  s <- str_replace_all(s, '\\\\.',\
    \ '')\n  s <- str_replace_all(s, '&', '')\n  s <- str_replace_all(s, '\\\\*',\
    \ '')\n  s <- str_replace_all(s, '\\\\:', '')\n  s <- str_replace_all(s, ',',\
    \ '')\n  s <- str_replace_all(s, '\\\\;', '')\n  s <- str_replace_all(s, '\\\\\
    :', '')\n  s <- str_replace_all(s, '\\\\/', '')\n  s <- str_replace_all(s, '\\\
    \\=', '')\n  s <- str_replace_all(s, '\\\\?', '')\n  s <- str_replace_all(s, '\\\
    \\,', '')\n  s <- str_replace_all(s, '\\\\$', '')\n  s <- str_replace_all(s, '\\\
    \\%', '')\n  s <- str_replace_all(s, '\\\\^', '')\n  s <- str_replace_all(s, '\\\
    \\#', '')\n  s <- str_replace_all(s, '\\\\@', '')\n  s <- str_replace_all(s, '\\\
    \\.', '')\n  s <- str_replace_all(s, '\\\\.', '')\n  s <- str_replace_all(s, '|',\
    \ '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')\n  s <- str_replace_all(s, '\\\\', '')\n  s <- str_replace_all(s, '\\\\\
    ', '')", "\n  # Your code here\n  \n  \n}\n", "\n  \n  if(!exists(\"string\")){\n\
    \    string <- \"string\"\n  }\n  if(!exists(\"s\")){\n    s <- \"s\"\n  }\n \
    \ if(!exists(\"s\")){\n    s <- \"s\"\n  }\n  if(!exists(\"strings\")){\n    strings\
    \ <- \"strings\"\n  }\n  if(!exists(\"a\")){\n    a <- \"a\"\n  }\n  if(!exists(\"\
    strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n \
    \   strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"\
    strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n\
    \  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"\
    strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n \
    \   strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"\
    strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n\
    \  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"\
    strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n \
    \   strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"\
    strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n\
    \  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"\
    strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n \
    \   strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"\
    strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n\
    \  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"\
    strings\")){\n    strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n \
    \   strings <- \"strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"\
    strings\"\n  }\n  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n\
    \  if(!exists(\"strings\")){\n    strings <- \"strings\"\n  }\n  if(!exist", "\n\
    \    s <- gsub(\" \", \"\", s)\n    s <- gsub(\"^#\", \"\", s)\n    s <- gsub(\"\
    @\", \"\", s)\n    s <- tolower(s)\n    s <- gsub(\"\\\\B([a-z])\", \" \\\\1\"\
    , s)\n    s <- gsub(\"\\\\b([A-Z])\", \" \\\\1\", s)\n    s <- gsub(\"\\\\W\"\
    , \" \", s)\n    s <- gsub(\" \", \"\", s)\n    s <- paste0(rep(\"\", length(s)\
    \ / 2), s)\n    s <- strsplit(s, \" \")[[1]]\n    s <- paste(toupper(paste0(s,\
    \ collapse = \"\")), collapse = \"\")\n    s <- paste(tolower(paste0(s, collapse\
    \ = \"\")), collapse = \"\")\n    s <- paste(sub(\"^[[:alpha:]]+\", \"\", s),\
    \ collapse = \"\")\n    s <- paste(sub(\"[[:alpha:]]+$\", \"\", s), collapse =\
    \ \"\")\n    s <- paste(sub(\"^[a-z]+\", \"\", s), collapse = \"\")\n    s <-\
    \ paste(sub(\"[a-z]+$\", \"\", s), collapse = \"\")\n    s <- paste(toupper(s),\
    \ collapse = \"\")\n    s <- paste(tolower(s), collapse = \"\")\n    s <- paste(sub(\"\
    [^A-Za-z]\", \"\", s), collapse = \"\")\n    s <- paste(sub(\"[[:alpha:]]\", \"\
    \", s), collapse = \"\")\n    s <- paste(sub(\"[A-Za-z]\", \"\", s), collapse\
    \ = \"\")\n    s\n}\n</code>\n<|/ a tags=string,r |>\n<| c |>\nThe solution given\
    \ by Martin is also working. But thanks anyways.\n<|/ c |>\n<| c |>\nI did not\
    \ know about `stringi`. Thanks for teaching me something new!\n<|/ c |>\n<| c\
    \ |>\nI really appreciate the use of regular expressions and `stringi` - and `stringr`\
    \ has many more functions - including a lot of very handy ones. I think this answer\
    \ is actually very clear and concise, but I am not going to mark it as the correct\
    \ answer (for now).\n<|/ c |>\n<| a |>\nYou can achieve this by converting your\
    \ string to lower case and removing everything but letters. Then just convert\
    \ those letters to upper case and combine them with the letters you have removed.\n\
    <code>\ns <- \"#a@C\"\ngsub(\"[^a-z]\", \"\", s, perl = TRUE)\n[1] \"#A@c\"",
  "\n  for(i in 1:length(s)) {\n    if(isLetter(s[[i]])) {\n      s[[i]] <- toupper(s[[i]])\n\
    \    }\n    else {\n      s[[i]] <- tolower(s[[i]])\n    }\n  }\n  s\n}\n", "\n\
    \    s <- toupper(s)\n    i <- which.max(!is.na(gregexpr('[[:alpha:]]', s)))\n\
    \    s[i] <- toupper(s[i])\n    s[i]\n}\n\n</cell>\n<cell>\nsolve(1:5)\n</cell>\n\
    <cell>\nsolve(paste0('This is a test of ', 1:5))\n</cell>\n<cell>\nsolve('abc#a@C')\n\
    </cell>\n<text>\nWrite a Python program to remove duplicates from an array.\n\n\
    </text>\n<cell>", "\n  s <- gsub(\"(..)\", \"\\\\U\\\\1\", s)\n  s <- toupper(s)\n\
    \  s <- gsub(\"[^A-Za-z]\", \"\", s)\n  s\n}\n</code>\n<|/ a tags=string,r |>\n\
    <| a |>\nYou can use sapply with gregexpr:\n<code>\ns <- c(\"asdas\", \"asdasd\"\
    , \"asd\", \"as\", \"asdsd\", \"asdasds\", \"asdasd\", \"asdasd\", \"asdas\")\n\
    sapply(s, gregexpr, pattern=\"[a-z]\")\n</code>\nOutput\n<code>\n[1] \"TRUE\"\
    \ \"TRUE\" \"TRUE\" \"TRUE\" \"TRUE\" \"TRUE\" \"TRUE\" \"TRUE\" \"TRUE\" \"TRUE\"\
    \n</code>\n<|/ a dscore=0 tags=string,r |>\n<| a dscore=0 |>\n<code>\nstr <- c(\"\
    abc\", \"ab\", \"a\")\nsapply(str, grepl, pattern=\"[a-z]\")", "\n  \n  str1 <-\
    \ gsub('[[:alpha:]]', \n          function(x) ifelse(x %in% LETTERS, '', toupper(x)),\n\
    \          s)\n  str2 <- gsub('[[:alpha:]]', \n          function(x) ifelse(x\
    \ %in% LETTERS, '', tolower(x)),\n          str1)\n  \n  ifelse(nchar(str1) ==\
    \ 0,\n         paste0(str2, ''), str2)\n}\n\nsolve(paste0('hello','world'))\n\
    </code>\n<|/ a dscore=1 tags=string,r |>\n<| a tags=string,r dscore=1 |>\nHere\
    \ is another solution:\n<code>\nsolve <- function(s) {\n  \n  # Create a vector\
    \ with the capital letters\n  vec <- gregexpr(LETTERS, s)\n  \n  # Extract only\
    \ the capital letters\n  vec2 <- regmatches(s, vec)\n  \n  # If there is only\
    \ one capital letter, return the string\n  if(length(vec2) == 1){\n    return(s)\n\
    \  }\n  \n  # Remove the capital letters from the string\n  str_remove <- gsub('^[A-Z]+',\
    \ '', vec2)\n  \n  # Remove all capital letters from the string\n  str_clear <-\
    \ gsub('[A-Z]+', '', s)\n  \n  # Remove all letters that belong to the removed\
    \ letters\n  str_clear <- gsub(str_remove, str_clear, str_clear)\n  \n  # Return\
    \ the string with the capital letters removed\n  str_clear\n}\n\nsolve(paste0('hello','world'))",
  "\n    l <- length(s)\n    i <- 0\n    ans <- \"\"\n    while ((i < l) && (!is.na(as.numeric(s[i]))\
    \ && (s[i] < \"z\"))) {\n        \n        if (s[i] >= \"a\") {\n            i\
    \ <- i+1\n            ans <- substr(s, i, l)\n        } else {\n            i\
    \ <- i+1\n            ans <- substr(s, 1, i-1) + substr(s, i, l)\n        }\n\
    \    }\n    ans <- ifelse(is.na(as.numeric(s[i])), ans, ifelse(s[i] >= \"a\" &\
    \ s[i] <= \"z\", \n                                                        toupper(ans),\
    \ ifelse(s[i] >= \"A\" & s[i] <= \"Z\", \n                                   \
    \                                 tolower(ans), as.character(s[i]))))\n    return(ans)\n\
    }\n", "\n    s <- gsub(\" \", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n \
    \   s <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s\
    \ <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\
    \\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\"\
    , \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\"\
    , s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n\
    \    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n    s\
    \ <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"\
    ^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\\
    W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\
    \", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n\
    \    s <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s\
    \ <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\
    \\\\W$\", \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\"\
    , \"\", s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\"\
    , s)\n    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n\
    \    s <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n    s\
    \ <- gsub(\"^\\\\W\", \"\", s)\n    s <- gsub(\"\\\\W$\", \"\", s)\n    s <- gsub(\"\
    ^", "\n  # your code here\n  l=nchar(s);\n  if(l>0){\n    for(i in 1:l){\n   \
    \   if(s[i]==tolower(s[i]) ){\n        s=toupper(s);\n      }\n      else{\n \
    \       s=tolower(s);\n      }\n    }\n  }\n  else{\n    l=nchar(s);\n    for(i\
    \ in 1:l){\n      s=toupper(s);\n    }\n  }\n  return(s);\n}\n", "\n  \n  # write\
    \ your code here\n  \n}\n", "\n    s <- toupper(s)\n    l <- length(s) \n    result\
    \ <- \"\"\n    \n    for (i in 1:l) {\n        x <- s[i]\n        if (is.alpha(x))\
    \ {\n            result <- paste(result, toupper(x), sep=\"\")\n        } else\
    \ {\n            result <- paste(result, x, sep=\"\")\n        }\n    }\n    \n\
    \    return(result)\n}\n</cell>\n<cell>", "\n  # Write your code here\n  if(!grepl(\"\
    [a-z]\", s)){\n    s <- toupper(tolower(s))\n  }\n  else{\n    s <- tolower(s)\n\
    \  }\n  return(s)\n}\n\ntestCases <- c(\"1234\", \"AB\", \"#a@C\", \"$%^&*()_+=-[]\\\
    \\;',./<>?;{}\")\nfor (testCase in testCases) {\n  print(testCase)\n  print(solve(testCase))\n\
    \  cat(\"\\n\")\n}\n</code>\n<|/ a |>\n<| a tags=r,regex |>\nThis one can be done\
    \ very efficiently using only base R.\n<code>\nsolve <- function(s) {\n  s <-\
    \ tolower(s)\n  u <- toupper(substr(s,1,1))\n  substr(s,1,1) <- u\n  return(s)\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,regex |>\nHere's a possible base R\
    \ solution\n<code>\nsolve2 <- function(s) {\n  s <- gsub(\"(?i)[a-z]\", toupper,\
    \ substring(s, 1, 1))\n  gsub(\"[a-z]\", tolower, s)\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=r,regex |>\nA solution without using regex.\n<code>\n\
    solve = function(x){\n  s = tolower(x)\n  u = toupper(substr(s,1,1))\n  substr(s,1,1)\
    \ = u\n  return(s)\n}\n\nsolve(c(\"a\",\"b\",\"c\"))\n</code>\n<|/ a |>\n<| c\
    \ |>\nYes, but this isn't vectorized\n<|/ c |>\n<| a dscore=0 |>\nHere is a one\
    \ line solution:\n<code>\ns <- c(\"a\",\"b\",\"c\")\nsapply(s, function(x) toupper(tolower(x)))\
    \ # [1] \"A\" \"B\" \"C\"\n</code>\n<|/ a tags=r,regex |>\n<| c |>\nI realise\
    \ that this is one line, but it is extremely inefficient, and doesn't vectorize\
    \ well.\n<|/ c |>\n<| a tags=r,regex |>\nA bit of tidyverse approach:\n<code>\n\
    library(dplyr)\nlibrary(stringr)\nsolve2 <- function(s) {\n  s %>%\n    mutate(first\
    \ = if_else(str_extract(s, '[a-z]') %in% 'TRUE', \n                str_sub(s,\
    \ 1, 1), str_c(str_to_upper(str_sub(s, 1, 1)))))\n}\n\n> solve2", "\n  if(!grepl(\"\
    [a-z]\", s)) s <- toupper(s)\n  paste0(tolower(substr(s,1,1)),substr(s,2))\n}\n\
    </code>\n<|/ a tags=r,regex,string |>\n<| a dscore=3 tags=r,regex,string |>\n\
    I know this is an old question, but I just ran into a similar problem in R and\
    \ found a solution that I believe is simpler than the other answers, though it\
    \ is not obvious to me why it works. I'm just posting it here in case it helps\
    \ others.\nThis solution uses the stringi package. Here's an example:\n<code>\n\
    > library(stringi)\n> stri_reverse(\"abc\")\n[1] \"cba\"\n</code>\n<|/ a |>\n\
    <| c |>\nThis works nicely, but note the warning at the top of the `stringi` vignette\
    \ page: *Note: This function is not vectorized. This means that for speed reasons,\
    \ it may only work on single character strings.*\n<|/ c |>\n<| a tags=r,regex,string\
    \ |>\nYou can create a function that does this (assuming the strings are made\
    \ up of characters):\n<code>\nreverse <- function(x){\n  ifelse(grepl(\"[a-z]\"\
    , x), toupper(substr(x, 1,1)) + substr(x, 2), x)\n}\n</code>\nThen all you need\
    \ to do is apply it to each element of s:\n<code>\napply(s, 1, reverse)\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 tags=r,regex,string |>\nAnother alternative to\
    \ stri_reverse is to use stringi package, e.g.\n<code>\nstri_reverse(s, \"(?i)[a-z]\"\
    )\n</code>\n<|/ a |>\n<| a dscore=3 |>\nA variant on the stringr package for those\
    \ who need a solution that works on vectors:\n<code>\nrev <- function(x) gsub(\"\
    [a-z]\",function(z) toupper(z),tolower(x))\nrev(c(\"ab\", \"#a@C\", \"1234\"))\n\
    [1] \"4321\"      \"#A@C\"      \"1234\"     \n</code>\n<|/ a tags=r,regex,string\
    \ |>\n<| c |>\n`stri_reverse` does this but has `regex` argument\n<|/ c |>\n<|\
    \ a tags=r,regex,string |>\nWe can also use gsubfn\n<code>\nlibrary(gsubfn)\n\
    rev(c(\"ab\", \"#a@C\", \"1234\"))", "\n    s <- toupper(s)\n    if (all(grepl(\"\
    [a-zA-Z]\", s))){\n        x <- sapply(s, function(x) {\n            if (grepl(\"\
    [a-z]\", x)){\n                x[which(toupper(x) == x)] <- toupper(x[which(toupper(x)\
    \ == x)])\n                return(toupper(x))\n            }\n            else\
    \ {return(x)}\n        })\n        return(paste(x, collapse=\"\"))\n    }\n  \
    \  else {return(tolower(s))}\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks Martin,\
    \ I just realized that my answer was missing a closing parentheses and a comma.\
    \ I did edit my answer. Sorry for the confusion.\n<|/ c |>\n<| a |>\n<code>\n\
    mySolve <- function(x){\n    if(is.element(\"a\",x) ) return(toupper(x))\n   \
    \ else return(tolower(x))\n}\n</code>\n<|/ a dscore=1 tags=r |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding how\
    \ and/or why it solves the problem would improve the answer's long-term value.\n\
    <|/ c |>\n<| c |>\nI agree, but I haven't found any other way to solve this simple\
    \ problem. Do you know an alternative way? Thanks again.\n<|/ c |>\n<| c |>\n\
    Yes, `ifelse` is another option. `ifelse(grepl(\"^[A-Za-z]+$\", x), toupper(x),\
    \ tolower(x))`\n<|/ c |>\n<| c |>\nThanks Martin, I've edited my question. Do\
    \ you know an alternative way? Thanks again.\n<|/ c |>\n<| a dscore=1 tags=r |>\n\
    <code>\n mySolve <- function(x){\n    if(is.element(\"a\",x) ) return(toupper(x))\n\
    \    else return(tolower(x))\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is\
    \ another way using stringi package:\n<code>\nlibrary(stringi)\nmySolve <- function(x){\n\
    \  x <- stri_replace_all_regex(x, \"[^[:alpha:]]\", \"\") # remove non letter\n\
    \  x <- stri_replace_all_regex(x, \"[[:space:]]\", \"\") # remove spaces\n  x\
    \ <- stri_replace_all_regex(x, \"[^[:alpha:]]\", \"\") # remove non letter\n \
    \ x <- stri_replace_all_regex(x, \"[^[:alpha:]]\", \"\") # remove non letter\n\
    \  x <- stri_replace_", "\n  s <- gsub(\"[a-z]\", \"\", s)\n  if (nchar(s) ==\
    \ 0)\n    s\n  else\n    paste0(toupper(substring(s, 1, nchar(s))),\n        \
    \   substring(s, nchar(s), nchar(s))) \n}\n", "\n  return(sapply(s, function(x)\
    \ if (grepl('^[a-zA-Z]+$', x)) \n    paste0(toupper(substring(s, 1, nchar(x))))\n\
    \    else x))\n}\n", "\n  \n  if(length(s) == 0) \n    return(s)\n  \n  s <- tolower(s)\n\
    \  s1 <- substring(s, 1, 1)\n  s2 <- substring(s, 2, 2)\n  \n  if(s1 == 'a') \n\
    \    s1 <- 'A'\n  if(s2 == 'a') \n    s2 <- 'A'\n  \n  return(paste0(s2, s1))\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for sharing your thought process.\
    \ Your solution works fine. But, I would like to improve my algorithm which I\
    \ described above. I would like to know how to improve the algorithm.\n<|/ c |>\n\
    <| a tags=r,stringi,string,algorithm dscore=0 |>\n<code>\nlibrary(stringr)\nlibrary(gsubfn)\n\
    \nfn::str_replace(c(\"1234\",\"abc\",\"#a@C\",\"#1#@2#3#4\",\"#A@B@c\",\"#@A@B\"\
    ,\"#@A@B#\",\"#@A@B@\",\"#@A@B@C@\",\"#@A@B@C@D#\"),\n                  pattern\
    \ = \"[#]+\",\n                  replacement = \"\")", "\n  if(!nchar(s))\n  \
    \  return(s)\n  if((s==toupper(s) | s==tolower(s))) {\n    letters <- tolower(s)\n\
    \    if(letters[length(letters)] %in% c(\"a\",\"b\",\"c\"))\n      letters[length(letters)]\
    \ <- letters[length(letters)] - toupper(letters[length(letters)])\n  }\n  else\n\
    \    letters <- s\n  sapply(letters, grepl, pattern = \"[[:alpha:]]\")\n  letters[order(letters,\
    \ decreasing = TRUE)[1]]\n}\n</code>\n<|/ a |>\n<| c |>\nI didn't know about `[[:alpha:]]`,\
    \ very useful, although not quite as straightforward as it seems. I like your\
    \ solution!\n<|/ c |>\n<| c |>\nI like your solution. I just need to figure out\
    \ a way to get it to work with a character vector, instead of a string. I'll edit\
    \ my question to show what I mean.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a solution that works for character vectors.\n<|/ c |>\n<| c |>\nThanks for\
    \ the edit. This works great! I guess I didn't think to try sapply. Thanks again\n\
    <|/ c |>\n<| c |>\n, could you please explain what the [[:alpha:]] part mean?\
    \ I've never seen it before.\n<|/ c |>\n<| a |>\n<code>\n    library(stringr)\n\
    </code>\nExample of how to use str_extract with regex and stringr package:\n<code>\n\
    \   a<-str_extract('this is a test string','[A-Z]+')\n</code>\n<|/ a dscore=2\
    \ tags=string,r |>\n<| c |>\nThis is definitely the most straightforward way\n\
    <|/ c |>\n<| a |>\nWe can use gsubfn which can be an alternative to stringr\n\
    <code>\nlibrary(gsubfn)\nfn$gsub('[a-z]', 'toupper\\\\1', as.character(s))\n</code>\n\
    <|/ a dscore=1 tags=string,r |>\n<| c |>\nThis is great, but I was trying to find\
    \ a way to do this without using gsubfn. Thanks for the answer though!\n<|/ c\
    \ |>\n<| a tags=string,r |>\nHere's one way to do it with base R using regmatches/gregexpr\
    \ and paste0:\n<code>\nsolve = function(x){\n   m = gregexpr(\"[a-z]+\", x)\n\
    \   x = regmatches(x, m)[[1]][order(regmatches(", "\n  if(!grepl(\"[a-z]\", s))\
    \ {\n    reverse(s)\n  } else {\n    # To lowercase using regex\n    str <- gsub(\"\
    [a-z]\", \"[[:lower:]]\", s)\n    # To uppercase using stringr\n    str2 <- toupper(str)\n\
    \    # To reverse str\n    reverse(str2)\n  }\n}\n\n</code>\n<|/ a tags=r,string\
    \ |>\n<| a dscore=3 |>\nWe can use base R\n<code>\nsub(\"[a-z]\", \"[[:lower:]]\"\
    , s)\n</code>\n<|/ a tags=r,string |>\n<| a tags=r,string |>\nYou can use gsub\
    \ with tolower and toupper in base R using regex to match the pattern [a-z]\n\
    <code>\n s <- \"aBc\"\n gsub(\"[a-z]\", \"[[:lower:]]\", tolower(s))\n #[1] \"\
    aBc\"\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,string |>\nYou could also use the\
    \ base R method gsub:\n<code>\nx <- \"aBc\"\n\ngsub(\"[a-z]\", \"[[:lower:]]\"\
    , x)\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nAnother base R solution\n\
    <code>", "\n  # Your code here\n  for(i in seq_along(s)) {\n    if(tolower(s[i])==tolower(s[i]))\
    \ {\n      s <- toupper(s[i])\n    }else {\n      s <- s[i]\n    }\n  }\n  s\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\nTry using the following R code:\n<code>\n\
    solve = function(s){\n  out = \"\"\n  for (i in 1:length(s)){\n    if (tolower(s[i])==tolower(s[i])){\n\
    \      out = paste0(toupper(s[i]),out)\n    } else {\n      out = paste0(s[i],out)\n\
    \    }\n  }\n  return(out)\n}\n</code>\n<|/ a dscore=0 tags=r |>\n<| a dscore=0\
    \ |>\n<code>", "\n  require(XML)\n  n <- xmlName(xmlRoot(xmlTreeParse(letters)))\n\
    \  if(substr(s,1,1) %in% LETTERS) {\n    return(toupper(substr(s,1,1)) + substr(s,2,nchar(s)))\
    \ \n  }\n  return(tolower(substr(s,1,n)) + substr(s,n+1,nchar(s))) \n}\n</code>\n\
    <|/ a tags=string,r,regex |>\n<| c |>\nThat code doesn't work for me, I get \"\
    Error: could not find function \"xmlTreeParse\"\n<|/ c |>\n<| c |>\nYou need to\
    \ load the XML package in order for that to work.\n<|/ c |>\n<| c |>\nAh I see!\
    \ Is there a way for me to do this without having to load the package?\n<|/ c\
    \ |>\n<| c |>\nYou could use `library(RCurl)` and `GET(letters)` and use `gsub()`\
    \ but I'd recommend against it. You'd be better off downloading the XML package\
    \ and then using `xmlTreeParse` like you did.\n<|/ c |>\n<| c |>\nIf you aren't\
    \ using an XML parser then you can probably get away with using `readLines` to\
    \ get the contents of the file and then writing your own string manipulation functions.\
    \  This would probably be better, assuming your file isn't too big.\n<|/ c |>\n\
    <| a dscore=4 |>\nUsing stringr and dplyr (which I highly recommend):\n<code>\n\
    library(stringr)\nlibrary(dplyr)\n\nstr_replace(s, '[^A-Za-z]+', '-') %>% \n \
    \   str_split('-') %>% \n    str_split('') %>% \n    lapply(function(a) { a <-\
    \ toupper(a); paste0(substr(a, 1, 1), substr(a, 2, nchar(a))) })\n\n[[1]]\n[1]\
    \ \"A\" \"B\" \"C\" \"D\"\n\n[[2]]\n[1] \"a\" \"b\" \"c\" \"d\"\n\n[[3]]\n[1]\
    \ \"#\" \"a\" \"B\" \"C\"\n</code>\n<|/ a tags=string,r,regex |>\n<| c |>\nThanks\
    \ for introducing `dplyr`, but you might want to use `str_remove` instead of `str_replace`\n\
    <|/ c |>\n<| c |>\nOr `str_replace_all`\n<|/ c |>\n<| a tags=string,r,regex |>\n\
    A base R one-liner solution using gsub could be written as :\n<code>", "\n  if(!any(grepl('[[:alpha:]]',\
    \ s))) return(sapply(s, function(x) toupper(tolower(x))))\n  if(!any(grepl('[[:alpha:]]',\
    \ s))) return(sapply(s, function(x) tolower(toupper(x))))\n  return(s)\n}\n</cell>\n\
    <cell>", "\n  s <- tolower(s)\n  if(length(s)==0) \n    s\n  else\n  {\n    s\
    \ <- paste0(substr(s, 1,1), toupper(substr(s, 2,nchar(s))))\n  }\n  return(s)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nAnother option:\n<code>\ngsub(\"\
    [[:alpha:]]\", \"[[:upper:]]\", gsub(\"[[:digit:]]\", \"[[:lower:]]\", \"1234\"\
    ))", "\n  s <- gsub(paste0('(?=.*[a-z])'), '', s) \n  s <- gsub(paste0('(?=.*[A-Z])'),\
    \ '', s)\n  s <- gsub(paste0('(?=.*\\\\d)'), '', s)\n  s <- gsub(paste0('(?=.*[^[:alpha:]])'),\
    \ '', s)\n  s <- toupper(s)\n  s\n}\n", "\n  s <- strsplit(s, '')\n  sapply(seq_along(s),\
    \ function(i) \n    ifelse(!(i %in% c(which(grepl('^[a-z]', s)), which(grepl('^[A-Z]',\
    \ s)))),\n           s[[i]],\n           toupper(s[[i]])\n          )\n  )\n}\n",
  "\n  l <- strsplit(s, '')[[1]]\n  r <- sapply(l, function(x) if (toupper(x)) toupper(x)\
    \ else tolower(x))\n  paste(r,collapse='')\n}\n</code>\n<|/ a dscore=4 |>\n<|\
    \ a dscore=4 |>\nHere is another solution without using sapply:\n<code>\nsolve\
    \ <- function(s) {\n    l <- strsplit(s, '')[[1]]\n    l <- ifelse(grepl('\\\\\
    w+', s), toupper(l), tolower(l))\n    paste(l, collapse = '')\n}\n</code>\n<|/\
    \ a tags=r,regex |>\n<| c |>\nAgreed. Nice answer. :)\n<|/ c |>\n<| a dscore=3\
    \ |>\nOne more answer using stri_reverse:\n<code>\nlibrary(stringi)\ns <- \"#a@C\"\
    \nstri_reverse(s)", "\n  gsub('^([a-z]+)(\\\\d+)$', \n       function(x) if(x[2]\
    \ >= 2L) \n         paste0(rev(x[1]), rev(x[2])) else x[1], s)\n}\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nThis answer was flagged for review because of its length\
    \ and content.\n<|/ c |>\n<| c |>\nI tried to add a bit of explanation but I think\
    \ my answer deserves a bit more explanation, so I changed it, but I left a comment\
    \ and hope it is OK now\n<|/ c |>\n<| c |>\nThank you for the comment, that makes\
    \ sense :)\n<|/ c |>\n<| c |>\nThanks also for providing the link to other answers\
    \ that show how to reverse the case and how to do it\n<|/ c |>\n<| a |>\nHere\
    \ are two ways of doing this with gsub:\n<code>\ngsub('[a-z]', '\\\\U\\\\1', x)\n\
    \ngsub('[A-Z]', '\\\\l\\\\1', x)\n</code>\nBoth of these will give the same result:\n\
    <code>\nx <- \"abCD#@#abc\"\n"]
stop_tokens:
- "\n#"
- "\n```"
