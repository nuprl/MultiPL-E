name: HumanEval_102_choose_num
language: r
prompt: "# This function takes two positive numbers x and y and returns the\n# biggest\
  \ even integer number that is in the range [x, y] inclusive. If \n# there's no such\
  \ number, then the function should return -1.\n# For example:\n# >>> choose_num(12,\
  \ 15)\n# 14\n# >>> choose_num(13, 12)\n# -1\nchoose_num <- function(x, y) {"
tests: "test_humaneval <- function() {\ncandidate <- choose_num\n    if(!identical(candidate(12,\
  \ 15), 14)){quit('no', 1)}\n    if(!identical(candidate(13, 12), -1)){quit('no',\
  \ 1)}\n    if(!identical(candidate(33, 12354), 12354)){quit('no', 1)}\n    if(!identical(candidate(5234,\
  \ 5233), -1)){quit('no', 1)}\n    if(!identical(candidate(6, 29), 28)){quit('no',\
  \ 1)}\n    if(!identical(candidate(27, 10), -1)){quit('no', 1)}\n    if(!identical(candidate(7,\
  \ 7), -1)){quit('no', 1)}\n    if(!identical(candidate(546, 546), 546)){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  big <- Inf\n  for(i in x:y){\n    if(i %% 2 == 0){\n      if(i\
    \ > big){\n        big <- i\n      }\n    }\n  }\n  if(is.finite(big)){\n    big\n\
    \  } else {\n    -1\n  }\n}\n\nchoose_num(6, 5)", "\n    x <- min(y, x)\n    y\
    \ <- max(y, x)\n    x <- min(y, x)\n    y <- max(y, x)\n    y <- min(y, x)\n \
    \   y <- max(y, x)\n    y <- min(y, x)\n    y <- max(y, x)\n    y <- min(y, x)\n\
    \    y <- max(y, x)\n    y <- min(y, x)\n    return(y)\n}\n</code>\nThis works\
    \ reasonably fast with small numbers, as choose_num(5,3) is much faster than choose_num(5,10).\
    \ By the way, the code is taken from my answer to the question \"Find the odd\
    \ numbers in range\".\n<|/ a |>\n<| c |>\nThis works as long as `choose` is monotonic\
    \ and continuous. That's often the case, especially with small numbers, but not\
    \ guaranteed. The `choose` function has some special properties that make it somewhat\
    \ insensitive to small values, but usually not as much as `factorial` is.\n<|/\
    \ c |>\n<| c |>\nIt seems you're right. `choose` seems to work better for larger\
    \ values of `k` than `factorial` does.\n<|/ c |>\n<| c |>\n: thanks! I've tried\
    \ to give some explanation in my answer. Hope it's clear enough.\n<|/ c |>\n<|\
    \ c |>\nThanks. I like your answer, too.\n<|/ c |>\n<| c |>\nI haven't looked\
    \ at it closely but it seems like a great solution. I'll have a go at it later\
    \ today.\n<|/ c |>\n<| a tags=r |>\nIf I have understood correctly, you want the\
    \ largest multiple of 2 that is less than or equal to x.\nHere is a function that\
    \ finds the largest multiple of 2 that is less than or equal to x :\n<code>\n\
    f <- function(x) {\n   y <- x + 1\n   while(y <= x) {\n       x <- x + 1\n   \
    \    y <- x * 2\n   }\n   return(x)\n}\n</code>\nTests:\n<code>\n> f(2)\n[1] 2\n\
    > f(3)\n[1] 6\n> f(15)\n[1] 12\n> f(16)\n[1] 18\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThank you, but this answer only solves half of the problem. The other\
    \ half is how to find the smallest integer of the form `x*n`, where `x <= n`.\n\
    <|/ c |>\n<| c |>\n: I guess my function will solve that for you. Maybe you should\
    \ elaborate on \"the other half is how to find the ", "\n  x <- min(y, x)\n  y\
    \ <- max(y, x)\n  if(x > y || (x == y && x %% 2 == 0)) {\n    x <- x + y + 1\n\
    \  } else {\n    y <- y - x\n  }\n  x <- ifelse(x < 0, -1, ifelse(x %% 2, x, x\
    \ + 1))\n  if(x < y) {\n    x <- x + 1\n  }\n  x\n}\n</code>\n<|/ a tags=function,r\
    \ |>\n<| a dscore=0 tags=function,r |>\nUsing recursion:\n<code>\nchoose_num <-\
    \ function(x,y) {\n  if (x == y) {\n    return(x)\n  }\n  x <- abs(x - y)\n  y\
    \ <- max(x, y)\n  choose_num(y, x)\n}\n\nchoose_num(10, 5)", "\n  x  <- as.numeric(x)\n\
    \  y  <- as.numeric(y)\n  which.max(sapply(seq(x), function(x) any(x>=x & x<=y)))\n\
    }\n", "\n  r <- seq(x, y, by = 1)\n  if(length(r) == 0) return(-1) \n  if(any(r%%2\
    \ != 0)) return(-1) #check if any odd number exists\n  if(all(r %% 2 != 0)) return(NA)\
    \  #check if all numbers are odd\n  names(r) <- seq(x, y, by = 1)\n  r\n}\n\n\
    choose_num(12, 15)", "\n  res <- -1\n  \n  while (x < y) {\n    x <- x + 2\n \
    \   \n    if (x == y) {\n      return(res)\n    }\n    \n    if (x %% 2 == 0)\
    \ {\n      res <- x\n    }\n  }\n  \n  return(res)\n}\n</cell>\n<text>\nTesting\
    \ the function\nTo test the function, we first generate a random integer number\
    \ using rnorm. Then we run our function and compare it to the expected result.\
    \ We'll test the function 10 times to get an idea of how accurate it is.\n\n\n\
    </text>\n<cell>", "\n  ans <- -1\n  \n  if(x > y) return(-1)\n  \n  for(i in 1:x)\
    \ {\n    if(i % 2 == 0) {\n      if((x[i] <= y) && ((ans < 0) || (x[i] > y)))\
    \ {\n        ans <- x[i]\n      }\n    }\n  }\n  \n  ans\n}\n", "\n    if(x >y)\
    \ return(-1)\n    x <- abs(x)\n    y <- abs(y)\n    if(y > x) return (-1)\n  \
    \  while(x <= y){\n        x <- x + 1\n        if(x %% 2 == 0) return(x)\n   \
    \ }\n    return(-1)\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou do not need to\
    \ loop; just use integer arithmetic and modulus.\n<code>\nx <- 10\ny <- 5\n(x\
    \ %% y) + 1", "\n  i <- 1\n  x <- min(x, y) # x must be greater than y\n  y <-\
    \ max(x, y)\n  while(i <= x) {\n    i <- i + 2\n  }\n  return(i)\n}\n</code>\n\
    <|/ a tags=r,optimization dscore=1 |>\n<| a dscore=1 |>\nHere is a brute-force\
    \ approach:\n<code>\nchoose_num <- function(x, y) {\n  i <- 1\n  while (i <= x)\
    \ {\n    i <- i + 2\n  }\n  while (i <= y) {\n    i <- i + 2\n  }\n  return(i)\n\
    }\n</code>\n<|/ a tags=r,optimization |>\n<| a tags=r,optimization dscore=1 |>\n\
    Here is a more efficient solution that is also the best case complexity O(1):\n\
    <code>\nchoose_num <- function(x, y) {\n  i <- 1\n  while(i <= x){\n    i <- i\
    \ + 2\n    while(i <= y){\n      i <- i + 2\n    }\n  }\n  return(i)\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis solution is wrong because of the `i` variable that never\
    \ gets updated.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nchoose_num <- function(x,\
    \ y) {\n  i <- 1\n  while(i <= x) {\n    i <- i + 2\n    while(i <= y) {\n   \
    \   i <- i + 2\n    }\n  }\n  return(i)\n}\n\nchoose_num(25, 100)\n</code>\n<|/\
    \ a tags=r,optimization |>\n<| a |>\n<code>\nchoose_num <- function(x, y) {\n\
    \  n <- min(x, y)\n  i <- 1\n  while(i <= n) {\n    i <- i + 2\n  }\n  return(i)\n\
    }\n\nchoose_num(25, 100)\n</code>\n<|/ a tags=r,optimization dscore=0 |>\n<| c\
    \ |>\nPlease add some explanation to your answer. Code dumping isn't a great idea.\n\
    <|/ c |>\n<| c |>\nWhile this code snippet may solve the question, [including\
    \ an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a tags=r,optimization |>\nHere\
    \ is a solution using the function %/%\n<code>\nchoose_num <- function(x,y){\n\
    \  ", "\n  if(!is.numeric(x) || !is.numeric(y)) -1 \n  if(x < 0 || y < 0) -1 \n\
    \  if(x < y) x \n  if(x > y) y \n  x <- as.numeric(x) \n  y <- as.numeric(y) \n\
    \  y <- y + 1\n  if(x < y) { \n    x <- x + 1 \n    y <- y - 1 \n  } \n  x <-\
    \ x - 1 \n  for(i in 1:(y)) {\n    if(x %% 2 == 0 & y %% 2 == 0) {\n      x <-\
    \ x/2\n      y <- y/2\n      break\n    }\n    if(x %% 2 != 0 & y %% 2 != 0) {\n\
    \      x <- x/2\n      y <- y/2\n      break\n    }\n    if(x %% 2 == 0 & y %%\
    \ 2 != 0) {\n      x <- x/2\n      y <- y/2\n      break\n    }\n  }\n  x\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=r |>\nI wrote this function, which works\
    \ and has good performance, is flexible and can handle larger matrices. \n<code>\n\
    choose.even.number <- function(x) {\n  x.max <- max(x)\n  x.min.odd <- x[x<0]\n\
    \  if(x.min > 0){\n    x.min <- x.min - x.min.odd\n  }\n  x.max.odd <- x[x>0]\n\
    \  x.max.odd <- x.max.odd - x.max\n  if(x.min > 0){\n    x.min <- x.min - x.min.odd\n\
    \  }\n  x.max.odd <- x.max.odd - x.max\n  if(x.min.odd > 0){\n    x.min <- x.min\
    \ - x.min.odd\n  }\n  x.max.odd <- x.max.odd - x.max\n  x.min <- x.min + x.min.odd\n\
    \  x.max <- x.max + x.max.odd\n  x.max.odd <- x.max.odd + x.max\n  x.max <- x.max\
    \ + x.max.odd\n  x.max.odd <- x.max.odd + x.max\n  x.max <- x.max + x.max.odd\n\
    \  x.max.odd <- x.max.odd + x.max\n  if(x.min > 0){\n    x.min <- x.min - x.min.odd\n\
    \  }\n  x.max.odd <- x.max.odd - x.max\n  x.max <- x.max + x.max.odd\n  x.max.odd\
    \ <- x.max.odd + x.max\n  x.max <- x.max + x.max.odd", "\n  xi <- x - 1\n  yi\
    \ <- y - 1\n  z <- 0\n  \n  while(TRUE) {\n    x <- x + 1\n    y <- y + 1\n  \
    \  \n    if(x + 1 < yi & y + 1 < yi) break\n    z <- z + 1\n  }\n  \n  if(z <\
    \ 2) return(-1)\n  return(x)\n}\n", "\n  maxnum <- x\n  while(maxnum < y) {\n\
    \    i <- 1\n    while(i < maxnum/2) {\n      if(maxnum%%i == 0) {\n        maxnum\
    \ <- maxnum/i\n        break\n      }\n      i <- i + 1\n    }\n  }\n  return(maxnum)\n\
    }\n", "\n  if(x %in% c(2,4,6,8,10,12,14,16,18,20)) y <- y\n  if(x %in% c(2,4,6,8,10,12,14,16,18,20))\
    \ y <- y+1\n  if(x %in% c(2,4,6,8,10,12,14,16,18,20)) y <- y-1\n  if(x %in% c(2,4,6,8,10,12,14,16,18,20))\
    \ {\n    if(y%in% c(2,4,6,8,10,12,14,16,18,20)) return(x)\n    if(y%in% c(2,4,6,8,10,12,14,16,18,20))\
    \ return(x+1)\n    if(y%in% c(2,4,6,8,10,12,14,16,18,20)) return(x-1)\n  }\n \
    \ return(NA)\n}\n</cell>\n<text>\nSolution\nTo check if x is in the range, you\
    \ can use  %in% operator. It returns TRUE if the object on the left hand side\
    \ is equal to the object on the right hand side.\n\n\n</text>\n<cell>\nchoose_num(13,\
    \ 12)\n</cell>\n<text>\nFor this case, you don't need to make any changes to the\
    \ function. However, if you have more cases than just choose_num, you can make\
    \ the following changes:\n\n</text>\n<cell>\nchoose_num <- function(x, y) {\n\
    \  if(x %in% c(2,4,6,8,10,12,14,16,18,20)) y <- y\n  if(x %in% c(2,4,6,8,10,12,14,16,18,20))\
    \ y <- y+1\n  if(x %in% c(2,4,6,8,10,12,14,16,18,20)) y <- y-1\n  if(x %in% c(2,4,6,8,10,12,14,16,18,20))\
    \ {\n    if(y%in% c(2,4,6,8,10,12,14,16,18,20)) return(x)\n    if(y%in% c(2,4,6,8,10,12,14,16,18,20))\
    \ return(x+1)\n    if(y%in% c(2,4,6,8,10,12,14,16,18,20)) return(x-1)\n  }\n \
    \ if(x %in% c(10,12,14,16,18,20,22,24,26)) y <- y-1\n  if(x %in% c(10,12,14,16,18,20,22,24,26))\
    \ y <- y+1\n  if(x %in% c(10,12,14,16,18,20,22,24,26)) y <- y\n  if(x %in% c(10,12,14,16,18,20,22,24,26))\
    \ {\n    if(y%in% c(10,12,14,16,18,20,22,24,26)) return", "\n  y <- y\n  x <-\
    \ x\n  if (x > y) {\n    return(-1)\n  } else {\n    if (x <= 0) {\n      return(-1)\n\
    \    } else {\n      return(ceiling(x / y))\n    }\n  }\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nWhy does this produce incorrect output for `choose_num(12, 15)`?\
    \ It returns `7` instead of `14`.\n<|/ c |>\n<| c |>\nYou're right, I was so focused\
    \ on correctness that I overlooked that. Updated the answer.\n<|/ c |>\n<| a dscore=3\
    \ tags=r |>\nHere's a variation on the theme of's answer\n<code>\nchoose_num <-\
    \ function(x, y) {\n  y <- y\n  x <- x\n  if (x > y) {\n    return(-1)\n  } else\
    \ {\n    if (x <= 0) {\n      return(-1)\n    } else {\n      y1 <- y+1\n    \
    \  y2 <- y+2\n      y3 <- y+3\n      if (y >= y1 & y >= y2 & y >= y3) return(y)\n\
    \      else if (y > y1) return(choose_num(x, y1))\n      else if (y > y2) return(choose_num(x,\
    \ y2))\n      else if (y > y3) return(choose_num(x, y3))\n      else return(-1)\n\
    \    }\n  }\n}\n\nchoose_num(12, 15)", "\n  ifelse(x > y, x-y, y-x)\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 tags=r,c++,numeric,integer,algorithm |>\nHere\
    \ is my solution in R:\n<code>\nchoose_num <- function(x, y) {\n  ifelse(x > y,\
    \ x-y, y-x)\n}\n</code>\n<|/ a |>\n<| c |>\nIt's not clear what you're asking\
    \ for.  Are you asking for a function that returns `x` if `x > y` when `x < y`\
    \ is true, and `y` if `y > x` when `y < x` is true?\n<|/ c |>\n<| a |>\nThis is\
    \ what it looks like in R:\n<code>\nchoose_num <- function(x, y) {\n  ifelse(x\
    \ > y, x-y, y-x)\n}\n</code>\n<|/ a tags=r,c++,numeric,integer,algorithm dscore=2\
    \ |>\n<| c |>\nThis is more efficient than my answer. Thanks!\n<|/ c |>\n<| a\
    \ |>\n<code>\nchoose_num <- function(x,y) {\n  ifelse(x>y,x-y,y-x)\n}\n</code>\n\
    <|/ a tags=r,c++,numeric,integer,algorithm dscore=2 |>\n<| a tags=r,c++,numeric,integer,algorithm\
    \ |>\n<code>\nchoose_num <- function(x, y) {\n  ifelse(x>y, x-y, y-x)\n}\n\nchoose_num(6,\
    \ 7)", "\n    if (y > x) stop(\"'y' has to be bigger than 'x'\")\n    # Find out\
    \ the biggest even number in range [x, y]\n    i <- 1\n    while (i <= y && i\
    \ <= x && choose(i, i) == 0) {\n        i <- i + 1\n    }\n    if (i > y) {\n\
    \        stop(\"'y' has to be bigger than 'x'\")\n    } else if (i > x) {\n  \
    \      stop(\"'y' has to be smaller than 'x'\")\n    } else if (i == y) {\n  \
    \      return(x - 1)\n    } else if (i == x) {\n        return(y) # If the range\
    \ is empty\n    } else {\n        i <- 1\n        while (i <= y) {\n         \
    \   i <- i + 1\n            if((x + i) % 2 == 0) {\n                return(x +\
    \ i - 1) # Return the biggest even number that is in the range [x, y]\n      \
    \      }\n        }\n        stop(\"'y' has to be bigger than 'x'\")\n    }\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI'm sure your function does work, although it might\
    \ not be the fastest. However when I run my function with 'choose_num <- function(x,\
    \ y) {\n    if (y > x) stop(\"'y' has to be bigger than 'x'\")\n    # Find out\
    \ the biggest even number in range [x, y]\n    i <- 1\n    while (i <= y && i\
    \ <= x && choose(i, i) == 0) {\n        i <- i + 1\n    }\n    if (i > y) {\n\
    \        stop(\"'y' has to be bigger than 'x'\")\n    } else if (i > x) {\n  \
    \      stop(\"'y' has to be smaller than 'x'\")\n    } else if (i == y) {\n  \
    \      return(x - 1)\n    } else if (i == x) {\n        return(y) # If the range\
    \ is empty\n    } else {\n        i <- 1\n        while (i <= y) {\n         \
    \   i <- i + 1\n            if((x + i) % 2 == 0) {\n                return(x +\
    \ i - 1) # Return the biggest even number that is in the range [x, y]\n      \
    \      }\n        }\n        stop(\"'y' has to be bigger than 'x'\")\n    }\n\
    }' it says 'Error in choose_num(12, 15) : y has to be bigger than x'. Any idea\
    \ why this is happening?\n<|/ c |>\n<| c |>\n: Are you sure that `choose()` works?\n\
    <|/ c |>\n<| c |>\nI have not used choose() before. As I am new to R, it could\
    \ be the problem. I will check it out.\n<|/ c |>\n<| c |>\nThe issue seems to\
    \ be with the 'while' statement. It seems that choose_num function doesn't work\
    \ properly with while loop. Any idea why?\n<|/ c |>\n<|", "\n    if (x < y) {\n\
    \        stop(\"The smallest number has to be bigger than the biggest one!\")\n\
    \    }\n    \n    x <- floor(x / 2)\n    y <- floor(y / 2)\n    \n    if (x ==\
    \ y) {\n        return(x)\n    }\n    \n    while(x < y) {\n        x <- x + 1\n\
    \        y <- y - 1\n    }\n    return(y)\n}\n</cell>\n<cell>\nchoose_num(101,\
    \ 200)\n</cell>\n<cell>\nchoose_num(101, 99)\n</cell>\n<text>\nWe can use the\
    \ function $n!$ (with '!' denoting the factorial operator) to\ncalculate the value\
    \ of $n!$.\n\n$n! = n \\times (n - 1) \\times \\dots \\times 2 \\times 1$.\n\n\
    \n</text>\n<cell>\nfactorial <- function(n) {\n    if (n == 0) {\n        return(1)\n\
    \    }\n    \n    result <- factorial(n - 1)\n    return(result * n)\n}\n</cell>\n\
    <cell>\nfactorial(10)\n</cell>\n<cell>\nfactorial(20)\n</cell>\n<text>\nWe can\
    \ also use recursion to solve these problems. We define a function\nto calculate\
    \ the factorial of an integer $n$, and then use recursion to \ncalculate its value\
    \ for other integers $n$ up to a maximum integer $k$.\n\n\n</text>\n<cell>\nfactorial_recursive\
    \  <- function(n, k = 10, result = 1) {\n    if (n == 1) {\n        return(result)\n\
    \    }\n    \n    return(factorial_recursive(n - 1, k = k, result = result * n))\n\
    }\n</cell>\n<cell>\nfactorial_recursive(10)\n</cell>\n<cell>\nfactorial_recursive(20)\n\
    </cell>\n<cell>\nfactorial_recursive(30, 10)\n</cell>\n<text>\nThe results of\
    \ factorial_recursive are called Fibonacci numbers. The\nfirst two numbers in\
    \ the Fibonacci sequence are 1. Each subsequent\nnumber in the Fibonacci sequence\
    \ is the sum of the previous two numbers.\nFor example, with the argument n =\
    \ 20, the first two numbers would be\n$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,\
    \ 233, 377...$.\n\nWe can also use the modulo operator $%$ to calculate the remainder\
    \ of\na division. For example, with the argument n = 40, the number $40 - 11$\n\
    is $2$, the remainder is $4 \\times 2$. Using the modulus operator, we can\nfind\
    \ the number ", "\n  if (x >= y || x <= 0)\n    return(-1L)\n  \n  max_num <<-\
    \ 0L\n  \n  i <- 0L\n  j <- 0L\n  \n  for(i in 0L:y){\n    for(j in 0:x){\n  \
    \    if(i + j > max_num){\n        max_num <<- i + j\n      }\n    }\n  }\n  \n\
    \  return(max_num)\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nWe can also use\
    \ which.max here to get indices and extract the values\n<code>\nv1 <- c(3, 5,\
    \ 7, 9, 12, 15, 16, 20)\nv2 <- c(9, 10, 11, 12, 13, 15, 16, 17, 20)\n\nwhich.max(v1\
    \ - v2)", "\n    if(x > y) {\n        stop(\"x should be greater than y\")\n \
    \   } else {\n        x <- abs(x)\n        y <- abs(y)\n        x <- ifelse(x\
    \ == 0, 0, x)\n        y <- ifelse(x == 0, 0, y)\n\n        while(x <= y) {\n\
    \            x <- x + y\n            if(x %% 2 == 0) break\n            y <- y\
    \ - 1\n        }\n        return(y)\n    }\n}\n</code>\n<|/ a tags=r,range dscore=4\
    \ |>\n<| c |>\nJust for curiosity, how does it compare to [this answer](https://stackoverflow.com/a/53968488/1412059)?\n\
    <|/ c |>\n<| a tags=r,range |>\nI like the function proposed by, but if you don't\
    \ want to create a function you can use a loop:\n<code>", "\n  biggest_even <-\
    \ -1\n  for(i in seq(x, y)) {\n    if(i %% 2 == 0) {\n      biggest_even <- i\n\
    \      break\n    }\n  }\n  biggest_even\n}\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks very much for the examples. I'm very new to R, so I'm struggling\
    \ to understand your code examples. I've been experimenting with using for loops\
    \ to get results like I want, but these examples are helping me understand R better.\
    \ I'll keep experimenting with different things and see what I can come up with.\
    \ Thanks!\n<|/ c |>\n<| a tags=r |>\n<code>\nchoose_num <- function(x, y) {\n\
    \  if(x < y) {\n    stop(\"x must be less than y\")\n  }\n  x2 <- x\n  y2 <- y\n\
    \  while(x != y && y != x) {\n    if(x %% 2 == 1) {\n      x <- x /2\n      y\
    \ <- y - 1\n    } else {\n      y <- y - 1\n    }\n  }\n  if(x == y && x != 0)\
    \ {\n    x <- x\n    y2 <- y\n  } else {\n    x <- x + 1\n  }\n  y <- y2\n  return(x)\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I ran this in\
    \ my R console and got this error:\n\nError in x%%2 : non-numeric argument to\
    \ binary operator\nIn addition: Warning message:\nIn if (x %% 2 == 1) { :\n  the\
    \ condition has length > 1 and only the first element will be used\n<|/ c |>\n\
    <| c |>\nThe code I provided doesn't have any errors. Are you using it exactly\
    \ as I've posted? You can find what caused the error by adding `cat(y)` before\
    \ `if(x %% 2 == 1)`.\n<|/ c |>\n<| c |>\nWhen I run it in my R console, everything\
    \ seems to run fine. I added cat(y)  before if(x %% 2 == 1) and this is the result\
    \ I get:\n\n[1]  1  1  3  3  3  4  4  5  5  6  6  7  7  8  8  9 10  9 10\n\nWarning\
    \ message:\nIn if (x %% 2 == 1) { :\n  the condition has length > 1 and only the\
    \ first element will be used\n<|/ c |>\n<| c |>\nThat's really strange, I tried\
    \ it on two different machines and it worked fine. Can you post the exact code\
    \ you ran?\n<|/ c |>\n<| c ", "\n  # write your code here\n}\nchoose_num(12, 15)\n\
    </cell>\n<text>\nWe can use the function above with mapply as follows:\n\n\n</text>\n\
    <cell>\nmapply(choose_num, x = c(1,2,3,4,5,6,7,8), y = c(1,3,5,7,9))\n</cell>\n\
    <text>\nNow we want to use the same function on two vectors with different lengths.\
    \ Let's take a vector with 3 elements and a vector with 5 elements:\n\n\n</text>\n\
    <cell>\nx = c(1,2,3,4,5)\ny = c(1,2,3,4,5,6,7,8)\n</cell>\n<text>\nWe would expect\
    \ the function to return the biggest even number in each of the two vectors. Let's\
    \ see how it does:\n\n\n</text>\n<cell>\nmapply(choose_num, x = x, y = y)\n</cell>\n\
    <text>\nAs you can see, the function gives -1 as the second element in the shorter\
    \ vector, because there's no such number in the second vector. Let's see how the\
    \ function behaves with a vector of two numbers:\n\n\n</text>\n<cell>\nmapply(choose_num,\
    \ x = c(1,2,3), y = c(1,3,5,7))\n</cell>\n<text>\nSo now we have a function that\
    \ works both on vectors with different length and on vectors with the same length.\
    \ Now let's use mapply on a list of functions:\n\n\n</text>\n<cell>\nmap(choose_num,\
    \ x = x, y = y)\n</cell>\n<text>\nThis time, we got a list of three elements,\
    \ in which each element is a vector. Let's see how it does:\n\n\n</text>\n<cell>\n\
    map(choose_num, x = x, y = y)\n</cell>\n<text>\nGreat! As you can see, using mapply\
    \ on a list of functions produces the result we want. Now let's move on to another\
    \ function named choose.\n\n\n</text>\n<text>\n2.4 Exercise: Repeat the previous\
    \ exercise using an apply function\n\n</text>\n<text>\nThis time we want to replicate\
    \ the same function we made above using an apply function, mapply. We want to\
    \ use the same function we made above and see if it gives the same results as\
    \ mapply. Let's start by making a list of the same functions:\n\n\n</text>\n<cell>\n\
    fs = list(choose_num, choose_num)\n</cell>\n<text>\nNow let's replicate the mapply\
    \ function with these functions:\n\n\n</text>\n<cell>\nlapply(fs, x = x, y = y)\n\
    </cell>\n<text>\nLooks pretty good! But it's not the same! In fact, the result\
    \ is a nested list, where the outer list contains vectors while the inner lists\
    \ contain the results from each of the functions. Let's see if it can be simplified\
    \ using sapply, which applies a function to a list. We'll use the same ", "\n\
    \  i <- 1\n  while(x <= y) {\n    if(y %% 2 != 0 & x %% 2 != 0) {\n      x <-\
    \ x + 1\n    } else if(y == y) {\n      if(x == x) {\n        break\n      }\n\
    \      y <- y - 1\n    }\n    i <- i + 1\n  }\n  if(i != 0) {\n    x\n  } else\
    \ {\n    -1\n  }\n}\n</code>\n<code>\nchoose_num(12, 15)", "\n    m <- max(x,\
    \ y)\n    while(y >= m) \n        m <- m + m \n    if (x > y) \n        m - m\
    \ else m\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nIt returns `-1` rather than `-2`,\
    \ but I think the intent is clear.\n<|/ c |>\n<| c |>\nOh, you're right. I misread\
    \ the question and thought you wanted the opposite. Edited accordingly.\n<|/ c\
    \ |>\n<| c |>\nThank you for the answer! I have never seen `which.max` before.\
    \ Could you please tell me more about the `which.max` function? How does it work?\n\
    <|/ c |>\n<| c |>\nThe `which.max` function returns the index of the maximal value\
    \ in a vector or array. `max` and `which.max` both return the maximal value. If\
    \ you know that you have an index, you can simply use that index.\n<|/ c |>\n\
    <| c |>\nAh, I see. Thanks a lot!\n<|/ c |>\n<| a dscore=2 tags=r |>\nHere are\
    \ two possible methods which rely on finding the index of the maximal value and\
    \ then using that index to find the corresponding vector element:\n<code>\nchoose2\
    \ <- function(x, y) {\n    idxMax <- which.max(y)\n    x[idxMax]\n}\n\nchoose3\
    \ <- function(x, y) {\n    x <- x[which.max(y)]\n}\n\nchoose(12,15)", "\n  if(x\
    \ > y) stop(\"x must be bigger than y\")\n  if(x <= y) stop(\"x must be smaller\
    \ than y\")\n  if(y == x) return x # if x == y, return x\n  \n  # check from x\
    \ to y\n  for(i in seq(x)) {\n    if(i %% 2 == 0) break\n  }\n  \n  for(i in seq(x\
    \ - 1, y - 1, -1)) {\n    if(i %% 2 == 0) break\n  }\n  \n  return(x - i) # return\
    \ greatest even integer\n}\n", "\n  if(x <= y) {\n    if(x > 0)\n      return(x+1)\n\
    \  } else {\n    if(y > 0)\n      return(y+1)\n  }\n  x <- x\n  y <- y\n  while(x\
    \ < y) {\n    x <- x+2\n    y <- y-2\n    if(x %% 2 != 0 && y %% 2 != 0)\n   \
    \   return(x+y)\n  }\n  return(-1)\n}\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n\
    <cell>\nchoose_num(13, 12)\n</cell>\n<cell>\nchoose_num(3, 2)\n</cell>\n<text>\n\
    2.3 What is a function and what are its arguments?\n\n</text>\n<text>\nA function\
    \ is a named piece of code that performs a specific task when called. \nIts arguments\
    \ should define the task. \nFor example, the add_function() function in R adds\
    \ two numbers and returns the result. \nIn this example, we define add_function()\
    \ as two arguments. \nThe first argument takes a number and adds 2 to it. The\
    \ second argument takes a number and subtracts 1 from it, and returns the result.\
    \ \nLet's see some examples:\n\n\n</text>\n<cell>", "\n  temp <- ceiling(x / 2)\n\
    \  if (x %% 2 == 0) {\n    if (y > temp)\n      temp <- y\n  }\n  else if (y >\
    \ temp)\n    temp <- y\n  else if (x < temp)\n    temp <- x\n  return(temp)\n\
    }\n", "\n    \n    x <- as.integer(x)\n    y <- as.integer(y)\n    \n    x <-\
    \ max(x, y)\n    \n    if(x %% 2 == 0) return(x)\n    \n    y <- x + 1\n    \n\
    \    while(y %% 2 == 0) {\n        y <- y + 1\n    }\n    \n    return(y)\n}\n\
    </cell>\n<cell>", "\n  for(i in seq(x, y)) {\n    if(i %% 2 == 0) {\n      return(i)\n\
    \    }\n  }\n  return(-1)\n}\n", "\n  if(x == min(x, y)) {\n    y <- y-1\n  }\n\
    \  for(i in seq_along(x)) {\n    if(x <= x[i] & y <= y[i]) {\n      tmp <- x[i]\n\
    \      x[i] <- y[i]\n      y[i] <- tmp\n    }\n  }\n  return(which.max(y))\n}\n\
    choose_num(12, 15)", "\n  if (x > y) {\n    stop(\"y should be bigger than x\"\
    )\n  }\n  if (x == y) {\n    return(x)\n  }\n  if (x %% 2 == 0) {\n    return(x)\n\
    \  }\n  return(choose_num(x+1, y))\n}\n", "\n  if (x > y | x == y) return(x) #\
    \ if they're equal, they're the same number\n  x <- x # swap to make sure they're\
    \ in range\n  y <- y\n  x <- x - 1 # subtract one from x to make sure we're in\
    \ range\n  y <- y + 1 # then add the one to it to make sure it's in range\n  \n\
    \  # add some conditionals to keep from going forever\n  if (x < 0) return(-1)\
    \ # if x is negative, return -1\n  if (y < 0) return(-1) # if y is negative, return\
    \ -1\n  \n  # we have the range, now let's find it\n  while ((x + y > 1) | (x\
    \ > y)) {\n    x <- x - 2 # subtract 2 from x to make sure we're in range\n  \
    \  y <- y - 2 # then add the one to it to make sure it's in range\n    if (x <\
    \ 0) return(-1) # if x is negative, return -1\n    if (y < 0) return(-1) # if\
    \ y is negative, return -1\n  }\n  return(x) # return the result\n}\n</cell>\n\
    <cell>", "\n  \n  # Test if x is less than or equal to y, then return the maximum\n\
    \  # number in the range [x, y] inclusive, otherwise return -1\n  if(x < y ||\
    \ (x == y && x > 0)) {\n    return(max(x, y)) + 1\n  }\n  \n  # Otherwise, return\
    \ -1\n  return(-1)\n}\n</cell>\n<text>\nLet's compare the function with ours\n\
    \n</text>\n<cell>\nchoose_num(12, 15)\n</cell>\n<cell>\nchoose_num(13, 12)\n</cell>\n\
    <text>\nThey are equivalent. Let's test our function with the built-in function\
    \ %in%\n\n</text>\n<cell>\nx <- c(12, 13)\ny <- c(11, 12)\nz <- c(12, 13)\ny %in%\
    \ z\n</cell>\n<text>\nThey are equivalent. But we can easily test our function\
    \ with the built-in function is.element\nThis function is exactly like %in% except\
    \ it returns TRUE or FALSE instead of an integer\n\n\n</text>\n<cell>\nis.element(y,\
    \ z)\n</cell>\n<text>\nWe can also test our function with the built-in function\
    \ identical\nThis function takes two objects and compares them for equality and\
    \ returns TRUE/FALSE\n\n\n</text>\n<cell>\nidentical(y, z)\n</cell>\n<text>\n\
    Let's test our function with the built-in function all.equal\nThis function takes\
    \ two objects and compares them for equality and returns TRUE/FALSE\n\n\n</text>\n\
    <cell>\nall.equal(y, z)\n</cell>\n<text>\nIt turns out that our function choose_num\
    \ works as expected in all cases except when x is less than y. In that case, we\
    \ want to return the max number. Let's test this case with the function all_choose_num\n\
    This function takes two objects and compares them for equality and returns TRUE/FALSE\n\
    \n\n</text>\n<cell>\nall_choose_num <- function(x, y) {\n  \n  # Test if x is\
    \ less than or equal to y, then return the maximum\n  # number in the range [x,\
    \ y] inclusive, otherwise return -1\n  if(x < y || (x == y && x > 0)) {\n    return(max(x,\
    \ y)) + 1\n  }\n  \n  # Otherwise, return -1\n  return(-1)\n}\n</cell>\n<text>\n\
    Let's test our function with the built-in function all.equal\nThis function takes\
    \ two objects and compares them for equality and returns TRUE/FALSE\n\n\n</text>\n\
    <cell>\nall_choose_num(12, 15)\n</cell>\n<cell>\nall_choose_num(13, 12)\n</cell>\n\
    <text>\nThey are equivalent. Let's test our function with the built-in function\
    \ all_choose_num\nThis function takes two ", "\n  x <- min(max(x, 1), y)\n  y\
    \ <- min(max(y, 1), x)\n  if(x > y & x <= y)\n    x <- x\n  else\n    y <- y\n\
    \  x <- seq(x, y, by = 2)\n  y <- seq(y, x, by = 2)\n  sapply(seq_along(x), function(x)\
    \ {\n    if(x == 1)\n      return(y)\n    x <- x^2\n    y <- y^2\n    x <- max(x^2,\
    \ y^2)\n    y <- y\n    if(x == y)\n      return(x)\n    return(-1) # this should\
    \ be changed\n  })\n}\n</cell>\n<text>\nThe function above is what we will use\
    \ to solve the problem. Next, we will implement the function below.\n\n\n</text>\n\
    <cell>", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n  \n  # check if x and\
    \ y are both integers\n  if(x < 0 || y < 0) {\n    return (-1)\n  }\n  \n  # check\
    \ if x is smaller that y\n  if(x < y) {\n    return (-1)\n  }\n  \n  # check if\
    \ x is equal to y\n  if(x == y) {\n    return (x)\n  }\n  \n  \n  # check if x\
    \ is greater than y\n  if(x > y) {\n    # add 1 if it's negative\n    if(x ==\
    \ 0) {\n      x <- 1\n    } else {\n      x <- x + 1\n    }\n    \n    # add 1\
    \ if it's positive\n    if(y == 0) {\n      y <- 1\n    } else {\n      y <- y\
    \ + 1\n    }\n  }\n  \n  \n  return(x + y)\n}\n</code>\n<|/ a tags=r,function\
    \ |>\n<| a tags=r,function |>\n<code>\nfindEven <- function(x) return(max(which(x>0)))\n\
    findEven(0:11)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhile this code may provide\
    \ a solution to problem, it is highly recommended that you provide additional\
    \ context regarding why and/or how this code answers the question. Code only answers\
    \ typically become useless in the long-run because future viewers experiencing\
    \ similar problems cannot understand the reasoning behind the solution.\n<|/ c\
    \ |>\n<| c |>\nThe explanation is very clear. `which` gives the indices of all\
    \ the elements that are greater than 0 in the vector `x`. The `max` function returns\
    \ the maximum of all these indices.\n<|/ c |>\n<| c |>\nPlease see [How do I write\
    \ a good answer?](https://stackoverflow.com/help/how-to-answer)\n<|/ c |>\n<|\
    \ a dscore=1 |>\nThis solution works with vectors and does not require any if,\
    \ else or while.\n<code>", "\n  if (x > y) { return(-1); } # if there is no number\
    \ in the given range, return -1\n  while(x>y) { \n    x <- x-2 # move backwards\
    \ to find an even number \n    if (x == 0) { break; } # stop if we find an even\
    \ number in the given range\n  }\n  while(y>x) { \n    y <- y-2 # move backwards\
    \ to find an even number \n    if (y == 0) { break; } # stop if we find an even\
    \ number in the given range\n  }\n  x <- x # move back \n  y <- y\n  return(x+y)\
    \ \n}\n", "\n  if(x == y) {\n    return(-1)\n  } else if((x %% 2 != 0) && (y %%\
    \ 2 != 0)) {\n    x <- x + 1 \n    y <- y - 1\n    choose_num(x, y)\n  } else\
    \ if((x %% 2 == 0) && (y %% 2 == 0)) {\n    x <- x - 1\n    y <- y - 1\n    choose_num(x,\
    \ y)\n  } else {\n    return(y)\n  }\n}\n", "\n  if(x < y | x > y) {\n    return(NA_integer_)\n\
    \  }\n  if(x %% 2 == 0 & y %% 2 == 0) {\n    y <- y - 1\n  }\n  for(i in seq(from\
    \ = 0, to = y)) {\n    if(x %% 2 == 0 & y %% 2 == 0) {\n      break\n    }\n \
    \   x <- x - 1\n    y <- y - 1\n  }\n  return(x)\n}\n", "\n  stopifnot(x > 0)\n\
    \  stopifnot(y > 0)\n  stopifnot(x <= y)\n  \n  i <- 0\n  while(i < (y - x)) {\n\
    \    i <- i + 1\n  }\n  \n  \n  if(i < (y - x)) {\n    return(y - i)\n  } else\
    \ {\n    return(-1)\n  }\n}\n</cell>\n<text>\nNow let's try it out on some examples:\n\
    \n\n</text>\n<cell>\nchoose_num(12, 15)\n</cell>\n<cell>\nchoose_num(12, 10)\n\
    </cell>\n<cell>\nchoose_num(5, 15)\n</cell>\n<cell>\nchoose_num(5, 10)\n</cell>\n\
    <cell>\nchoose_num(10, 15)\n</cell>\n<cell>\nchoose_num(10, 10)\n</cell>\n<text>\n\
    Awesome! But what happens if we run it on something that's not even a number?\
    \ It returns -1:\n\n\n</text>\n<cell>\nchoose_num(letters, 10)\n</cell>\n<text>\n\
    The function stops at the first error it encounters, and returns -1. Try it on\
    \ your own examples and see if you can understand what happened. Can you think\
    \ of a way that we can stop after the first error and still have a useful function?\
    \ Let's look at some other examples:\n\n\n</text>\n<cell>\nchoose_num(\"a\", 5)\n\
    </cell>\n<cell>\nchoose_num(\"a\", 6)\n</cell>\n<cell>\nchoose_num(\"b\", 4)\n\
    </cell>\n<text>\nThere's another way we can stop when we encounter an error. In\
    \ the code above, we can stop after the first error because we only have one value\
    \ to compare it to. We can also stop after two errors, since we have x and y values\
    \ to compare:\n\n\n</text>\n<cell>\nchoose_num(\"a\", 4)\n</cell>\n<cell>\nchoose_num(\"\
    a\", 4)\n</cell>\n<text>\nWe can also stop after three errors, by combining the\
    \ stopifnots with the while loop:\n\n\n</text>\n<cell>\nchoose_num(\"a\", 4)\n\
    </cell>\n<cell>\nchoose_num(\"a\", 4)\n</cell>\n<cell>\nchoose_num(\"a\", 4)\n\
    </cell>\n<cell>\nchoose_num(\"a\", 4)\n</cell>\n<cell>\nchoose_num(\"a\", 4)\n\
    </cell>\n<cell>\nchoose_num(\"a\", 4)\n</cell>\n<text>\nLet's try a more realistic\
    \ example:\n\n\n</text>", "\n    ans <- 0\n    for (i in 1:x) {\n        if (y%%i\
    \ == 0) {\n            ans <- y\n            break\n        }\n    }\n    ans\n\
    }\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n<cell>\nchoose_num(12, 9)\n</cell>\n\
    <cell>\nchoose_num(13, 12)\n</cell>\n<text>\nBONUS: Write a Python function to\
    \ find out if a number is even or odd.\n\n</text>\n<cell>", "\n    if (x < y)\
    \ {\n        x <- y\n        y <- x\n    }\n\n    x <- abs(x)\n    y <- abs(y)\n\
    \n    while(x < y) {\n        x <- x + y\n        y <- y - x\n    }\n\n    if\
    \ (x == y) {\n        return(x)\n    } else {\n        return(NA)\n    }\n}\n\
    </cell>\n<text>\nAnd we get the expected results below:\n\n\n</text>\n<cell>\n\
    choose_num(12,15)\n</cell>\n<cell>\nchoose_num(13,12)\n</cell>\n<text>\nThe function\
    \ works well to find the maximum value in a given range, and it will return an\
    \ error if we try and run it on a negative number or on a number that is too large.\n\
    \nThe function also works well to find the minimum value in a given range, and\
    \ it will return an error if we try and run it on a number that is too small.\n\
    \nWhen we use the function on the two examples above we get the following:\n\n\
    \n</text>\n<cell>\nchoose_num(5,2)\n</cell>\n<cell>\nchoose_num(2,5)\n</cell>\n\
    <text>\nNow let's try it on some more sample numbers:\n\n\n</text>\n<cell>\nchoose_num(3,12)\n\
    </cell>\n<cell>\nchoose_num(10,10)\n</cell>\n<cell>\nchoose_num(15,15)\n</cell>\n\
    <cell>\nchoose_num(-3,12)\n</cell>\n<cell>\nchoose_num(-10,10)\n</cell>\n<cell>\n\
    choose_num(-15,15)\n</cell>\n<text>\nWe can also make a function to check if a\
    \ number is even or odd, which would let us identify any number that is even or\
    \ odd. We'll start with the function below and then try and run it on some sample\
    \ numbers.\n\n\n</text>\n<cell>\nis_even <- function(x) {\n    x <- abs(x)\n \
    \   while(x < 1) {\n        x <- x + x\n    }\n\n    if (x %% 2 == 0) {\n    \
    \    return(1)\n    } else {\n        return(0)\n    }\n}\n</cell>\n<text>\nLet's\
    \ try it on the sample numbers from the previous section:\n\n\n</text>\n<cell>\n\
    is_even(12)\n</cell>\n<cell>\nis_even(10)\n</cell>\n<cell>\nis_even(15)\n</cell>\n\
    <cell>\nis_even(18)\n</cell>\n<cell>\nis_even(19)\n</cell>\n<text>\nWe get the\
    \ following error:\n\n\n</text>\n<cell>\nis_even(24)\n</cell>\n<text>", "\n  \
    \  which.max((x %:%% y)==0) + 1\n}\n", "\n  # check if x and y are positive\n\
    \  if (x < 0) || (y < 0) return(-1)\n\n  # check if x and y are in range\n  if\
    \ (x > y) {\n    x <- y\n    y <- x\n  }\n\n  # check if x and y are even\n  if\
    \ (x %% 2 == 0 && y %% 2 == 0) return(x+y)\n\n  # check if x is an even number\
    \ and y is an odd number\n  if (x %% 2 == 0) return(x + y)\n\n  # check if x is\
    \ an odd number and y is an even number\n  return(x - y)\n}\n</code>\n<|/ a dscore=1\
    \ tags=r |>\n<| c |>\nI like how you think about this problem. Elegant solution.\
    \ Perfect solution. Thank you!\n<|/ c |>\n<| a tags=r |>\nHere's an approach that\
    \ doesn't require for loops or if/else statements:\n<code>\neven.odd <- function(x,\
    \ y){\n    # Find out if x is even or odd\n    ifelse(x%%2 == 0, x + y, x - y)\n\
    }\n\nx <- 5\ny <- 4\neven.odd(x, y)", "\n\ti <- 1\n\twhile(x < y) {\n\t\ti <-\
    \ i + 2\n\t\tif(isTRUE(x %% i == 0 && y %% i == 0)) {\n\t\t\tx <- x+1\n\t\t}\n\
    \t}\n\ti\n}\n</cell>\n<text>\nThe function choose_num takes two numbers and returns\
    \ the biggest even integer number between them inclusive.\n\n\n</text>\n<text>\n\
    Task 4.1.3 \nWrite the function even_num which takes a positive integer number\
    \ and returns True if it's an even number and False if not.\n\n\n</text>\n<cell>",
  "\n  if (y > x)\n    stop(\"x must be smaller than y.\")\n  else if (y == x)\n \
    \   return(x)\n  else {\n    while (y < x) {\n      y <- y + 1\n    }\n    return(y)\n\
    \  }\n}\n", "\n  if(x < y & x > y) {\n    return(y)\n  } else if(x > x & x < y)\
    \ {\n    return(x)\n  } else {\n    return(-1)\n  }\n}\n</cell>\n<text>\nNow,\
    \ let's create the function choose_num_with_if, which is the same as choose_num\
    \ except it has an if statement within it:\n\n\n</text>\n<cell>\nchoose_num_with_if\
    \ <- function(x, y) {\n  if(x < y & x > y) {\n    return(y)\n  } else if(x > x\
    \ & x < y) {\n    return(x)\n  } else {\n    return(-1)\n  }\n}\n</cell>\n<text>\n\
    Let's check out our new version of the function that has an if statement:\n\n\n\
    </text>\n<cell>\nchoose_num_with_if(11, 15)\n</cell>\n<text>\nGreat! Now we can\
    \ use our new version of choose_num to find the biggest even number between 12\
    \ and 15 (the range for x and y):\n\n\n</text>\n<cell>\nchoose_num(12, 15)\n</cell>\n\
    <text>\nNow, let's use our new version of choose_num_with_if to find another even\
    \ bigger number:\n\n\n</text>\n<cell>\nchoose_num_with_if(24, 15)\n</cell>\n<text>\n\
    Finally, let's check out our new version of choose_num_with_if for another even\
    \ bigger number:\n\n\n</text>\n<cell>\nchoose_num_with_if(31, 15)\n</cell>\n<text>\n\
    That's it! With only one if statement, we can find the biggest even number between\
    \ any two numbers by using only a single function.\n\nAs an exercise, you might\
    \ want to write a new function called biggest_even_number, which returns the biggest\
    \ even number between x and y, which should be passed as parameters x and y. Remember,\
    \ you will need two if statements to do this, one to check if x and y are even\
    \ numbers, and one to check if x and y are in the correct range. Again, feel free\
    \ to reuse the function you created for the choose_num function.\n\n\n</text>\n\
    <cell>\nbiggest_even_number <- function(x, y) {\n  if(x < y & x > y) {\n    return(y)\n\
    \  } else if(x > x & x < y) {\n    return(x)\n  } else {\n    return(-1)\n  }\n\
    }\n</cell>\n<text>\nTo test your function, you can use the following code:\n\n\
    \n</text>\n<cell>\nbiggest_even_number(4, 12)\n</cell>\n<text>\nExercise\nWrite\
    \ a function called choose_num_with_if_else that takes in two positive numbers\
    \ x and y and returns -1 if x or y is less than 0, 1 if x and y are in range (including\
    \ x and y), and returns the biggest even number between x and y ", "\n    y <-\
    \ y\n    x <- x\n    for(i in (x - 1):(y))\n        if(x %% i == 0 & y %% i ==\
    \ 0)\n            return i\n    if(y == (x - 1))\n        return -1\n    else\n\
    \        -1 # there is no even number between x and y\n}\n", "\n    even_num <<-\
    \ 0\n    for (i in 0:y) {\n        even_num <<- even_num + i\n    }\n    even_num\
    \ <<- even_num / y\n    if (even_num > x) return(even_num - 1)\n    if (even_num\
    \ < x) return(even_num + 1)\n    return(even_num)\n}\n", "\n   nums <- seq(x,\
    \ y, by = 2)\n   max(nums[nums == x | nums == y])\n}\n</code>\nI didn't bother\
    \ to make it efficient, so you can change it if you'd like.\n<|/ a dscore=4 |>\n\
    <| a dscore=4 |>\nHere's a solution that uses R's vectorization to perform the\
    \ computations faster, and avoids using an explicit loop (which is typically a\
    \ sign that R is doing something inefficient). \nThe function is called choose_num.\n\
    <code>\nchoose_num <- function(x, y) {\n  r <- rbind(-x,-y)\n  r <- rbind(r, x,\
    \ y)\n  r <- r[order(r[,1]),]\n  r[,2] <- 2*r[,1]-1\n  ifelse(r[,2]>0, r[,2],\
    \ NA)\n}\n</code>\nThe above function was adapted from the accepted answer by.\
    \ The function is vectorized over x and y and the function returns the appropriate\
    \ value, and ignores NAs.\n<|/ a tags=r,performance,math,optimization |>\n<| c\
    \ |>\nThe `ifelse` statement in the accepted answer doesn't really accomplish\
    \ anything, since `ifelse` will output `NA` for `x == y`. I guess it serves as\
    \ a reminder that the function was designed for vectorized inputs, so this `ifelse`\
    \ approach is incorrect. Also, the `rbind`ing approach works better than my solution\
    \ because it's vectorized over `r` instead of `x` and `y`, which means that the\
    \ function can be run on `vectorized` inputs.\n<|/ c |>\n<| c |>\nI agree, I didn't\
    \ notice it was the accepted answer when I wrote this. But it's good to know about\
    \ `ifelse` and the `NA` handling.\n<|/ c |>\n<| a tags=r,performance,math,optimization\
    \ dscore=3 |>\nHere is my own solution, which I believe to be a very efficient\
    \ one with O(n) time.\n<code>\nchoose_num <- function(x, y) {\n  x <- max(x:y)\n\
    \  y <- min(x:y)\n  x <- x - 1L\n  y <- y - 1L\n  while(y > 1L) {\n    x <- x\
    \ + 1L\n    y <- y - 1L\n  }\n  x <- x + 1L\n  return(x)\n}\n</code>\nHere is\
    \ a benchmark on my PC:\n<code>\nlibrary(\"rbenchmark\")\nn <- 1e7\nx <- rnorm(n)\n\
    y <- rnorm(n)\n", "\n  if(x > y) {\n    x <- y\n    y <- x\n  }\n  \n  if(x >\
    \ 0 && y > 0){\n    if((x - y) %% 2 != 0){\n      return(x-1)\n    }\n  }\n  \n\
    \  return(-1)\n}\n", "\n  i <- x\n  while (i <= y) {\n    if (i %% 2 == 0) {\n\
    \      i <- i + 1\n    }\n    else {\n      i <- i - 1\n    }\n  }\n  return(i)\n\
    }\n</code>\n<code>", "\n    for(num in x:y) {\n        if(num %% 2 == 0) return(num)\n\
    \    }\n    return(-1)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt doesn't work\
    \ for me. When I enter the numbers 12 and 15 it just returns -1\n<|/ c |>\n<|\
    \ c |>\nWhen I enter 12, 15 and 1 it returns -1. I can't figure out why\n<|/ c\
    \ |>\n<| c |>\nYes. It's returning -1 because there's no even number between 12\
    \ and 15, which is what it says in the code `# If there's no such number, then\
    \ the function should return -1.`\n<|/ c |>\n<| c |>\nOh. I didn't realise that\
    \ part. Thank you very much for your help!\n<|/ c |>\n<| c |>\nGreat, I'm glad\
    \ I could help! :)\n<|/ c |>\n<| a |>\nThis should do the trick:\n<code>\nchoose_num\
    \ <- function(x, y){\n  return(if(x > y) x else y)\n}\n</code>\n<|/ a tags=if-statement,r\
    \ dscore=1 |>\n<| c |>\nThis doesn't work since \"x <-\" doesn't do anything to\
    \ the number in \"x\". R just looks at \"x\" and doesn't know to look at \"y\"\
    .\n<|/ c |>\n<| c |>\nTry this: `x <- 1` `y <- 2` `choose_num(x, y)`\n<|/ c |>\n\
    <| a |>\n<code>\nchoose_num <- function(x, y) {\n  if (x > y) {\n    return(x)\n\
    \  } else{\n    return(y)\n  }\n}\n</code>\n<|/ a tags=if-statement,r dscore=1\
    \ |>\n<| c |>\nThis doesn't work since \"x <-\" doesn't do anything to the number\
    \ in \"x\". R just looks at \"x\" and doesn't know to look at \"y\".\n<|/ c |>\n\
    <| a |>\nThis does work:\n<code>\nchoose_num <- function(x, y) {\n  if(x < y)\
    \ {\n    return(x)\n  } else{\n    return(y)\n  }\n}\n</code>\n<|/ a tags=if-statement,r\
    \ dscore=0 |>\n<| c |>\nThis doesn't work since \"x <-\" doesn't do anything to\
    \ the number in \"x\". R just looks at \"x\" and doesn't know to look at \"y\"\
    .\n<|/ c |>\n<| c |>\nHmm, I guess you are correct. Looks like some of these answers\
    \ have that issue. ", "\n    i <- 1\n    while (i <= x && i <= y) {\n        if\
    \ (x %% i == 0 & y %% i == 0) {\n            x <- x + i\n            y <- y -\
    \ i\n            return(i %% 2)\n        }\n        i <- i + 1\n    }\n    return(-1)\n\
    }\n", "\n  for (i in 1:x)\n    if (i %% y == 0)\n      return(i)\n  return(-1L)\n\
    }\n", "\n  return(max(x, y - (y %% 2L)))\n}\n</code>\nThis works because max(x,\
    \ y - (y %% 2L)) is always equal to y if it's evenly divisible by 2. It's exactly\
    \ the same as y - (y %% 2L).\n<|/ a |>\n<| c |>\nThis doesn't work for `choose_num(12,13)`\
    \ which should return 14, but instead returns 12.\n<|/ c |>\n<| c |>\nYou're absolutely\
    \ right. I've edited my answer to include this case.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere's a solution that works on integers and returns -1 for no solution:\n\
    <code>\nchoose.num <- function(x,y) {\n    max <- max(x, y)\n    if(min <- min(x,\
    \ y)) max <- min\n    max.even <- max/2\n    max.odd <- max-1\n    max.odd <-\
    \ max.odd + max.odd\n    max.even <- max.even + max.even\n    if(max.even > max.odd)\
    \ max.even <- max.odd - 1\n    if(max.even > max.even) max.even <- max.even\n\
    \    return(max.even)\n}\n</code>\n<|/ a tags=math,algorithm,r |>\n<| c |>\nI\
    \ think this one works, I'll try it out.\n<|/ c |>\n<| c |>\nThis answer is more\
    \ efficient in that it is one that uses only modular arithmetic and does not require\
    \ division.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution using modulo: \n<code>\n\
    choose_num <- function(x,y){\n   x %% (x%%2L) + 1L\n}\n</code>\nExample:\n<code>\n\
    choose_num(12,13)\n[1] 14\n</code>\n<|/ a tags=math,algorithm,r |>\n<| c |>\n\
    This doesn't work for `choose_num(12,13)` which should return 14, but instead\
    \ returns 12.\n<|/ c |>\n<| a tags=math,algorithm,r |>\nHere is a solution that\
    \ uses modulo arithmetic:\n<code>\nchoose_num <- function(x,y){\n  if(x <= y)\
    \ return x\n  if(x%2 == 0) y <- y - x\n  y %% (y%%2L) + 1L\n}\n</code>\nExamples:\n\
    <code>\n> choose_num(12,13)\n[1] 14\n> choose_num(12,15)\n[1] 14\n> choose_num(13,12)\n\
    [1] 14\n> choose_num(10,10)\n[1] 10\n</code>\n", "\n  return(\n    ifelse(x <\
    \ y | x < 1, x, \n        ifelse(y < 1 | y < x, y, \n              ifelse(x >\
    \ y | x < y, y, \n                     ifelse(y > x | y < x, \n              \
    \              ifelse(x > y | x < y | x > x > y, x, y), \n                   \
    \         -1)))))\n}\n", "\n    p <- seq(x, y, 2)\n    p[is.na(p)]<-1\n    p <-\
    \ p[-length(p)]\n    which.max(p)\n}\n</cell>\n<cell>\nchoose_num(12,15) # This\
    \ works because 12 is in the range (12, 15]\nchoose_num(13,12) # This returns\
    \ -1 because 12 is not in the range (13, 12]\n</cell>\n<cell>", "\n\tans <- numeric(0)\n\
    \tfor(i in 1:length(x)) {\n\t\tif(y[i] > x[i]) {\n\t\t\tans <- c(ans, y[i])\n\t\
    \t}\n\t}\n\tans[length(ans)]\n}\n", "\n  # your code here\n}\n</cell>\n<cell>",
  "\n  if((x > y)) {\n    stop(\"Invalid range: x must be greater than y\");\n  }\n\
    \  if((x < 1)) {\n    stop(\"Invalid range: x must be greater than or equal to\
    \ 1\");\n  }\n  if((y > x)) {\n    stop(\"Invalid range: y must be greater than\
    \ or equal to x\");\n  }\n  \n  while((x < y)) {\n    x <- x + 1;\n    while((x\
    \ > y)) {\n      y <- y - 1;\n      x <- x + 1;\n      if((x %% 2) == 0) {\n \
    \       y <- y - 1;\n      }\n    }\n    if(y > x) {\n      x <- x + 1;\n    }\n\
    \  }\n  \n  return(x);\n}\n</code>\n<|/ a tags=integer,r,function,integer-overflow\
    \ |>\n<| c |>\nI think it should be possible to generalize this to any integer\
    \ range.  I've updated my answer to show how this can be done with integers within\
    \ the ranges given and to show how it can be generalized to any integer range.\n\
    <|/ c |>\n<| c |>\nYour code does exactly what I wanted, but it's limited to the\
    \ range [1, 10000]. Could you please tell me how to modify the code so that it\
    \ can use bigger number as well.\n<|/ c |>\n<| c |>\nIt can use any arbitrary\
    \ range you want, just change the bounds of the for loops.  You also can change\
    \ the bounds based on your needs.  For example, if you want the smallest number\
    \ in the range [1, 1e15], you can change `if(x %in% 1:1e15)` to `if(x %in% 1:1e15)`\
    \ etc.\n<|/ c |>\n<| a tags=integer,r,function,integer-overflow |>\nI modified\
    \ the function by Ben. Thanks.\n<code>\nchoose_num <- function(x, y) {\n  if((x\
    \ > y)) {\n    stop(\"Invalid range: x must be greater than y\");\n  }\n  if((x\
    \ < 1)) {\n    stop(\"Invalid range: x must be greater than or equal to 1\");\n\
    \  }\n  if((y > x)) {\n    stop(\"Invalid range: y must be greater than or equal\
    \ to x\");\n  }\n  \n  while((x < y)) {\n    x <- x + 1;\n    while((x > y)) {\n\
    \      y <- y - 1;\n      x <- x + 1;\n      if((x %% 2) == 0) {\n        y <-\
    \ y - 1;\n      }\n    }\n    if(y > x) {\n      x <- x + 1;\n    }\n  }\n  \n\
    \  return(x);\n}\n", "\n  i <- 0\n  while(i < y && i < x) {\n    i <- i+1\n  }\n\
    \  if(i < y) {\n    return(x)\n  }\n  if(i < x) {\n    return(y)\n  }\n  return(abs(x-y))\n\
    }\n", "\n  xr <- x + 1\n  yr <- y + 1\n  if (x < yr) {\n    return(if(x == yr\
    \ | x == yr | x == xr | x == xr | x == yr | x == yr) {\n      x \n    } else {\n\
    \      choose_num(x, yr) \n    })\n  } else if (x > yr){\n    return(if(x == yr\
    \ | x == yr | x == xr | x == xr | x == yr | x == yr) {\n      x \n    } else {\n\
    \      choose_num(xr, y) \n    })\n  } else {\n    return(-1) \n  }\n}\n</cell>\n\
    <text>\nExercise: Write an R function that receives two floating point numbers\
    \ x and y and returns their sum. Then, use these two functions to determine whether\
    \ your answer is correct or not.\n\n\n</text>\n<cell>", "\n  if(!is.integer(x)\
    \ || is.integer(y) || x < 0 || y < 0 || (x >= y && x < y))\n    stop(\"The first\
    \ argument must be an integer number and must be smaller than the second argument.\"\
    )\n  y <- max(y, x)\n  x <- min(x, y)\n  y <- x + (y - x) / 2\n  while(x <= y\
    \ && x %% 2 != 0 && y %% 2 != 0) {\n    x <- x + (y - x) / 2\n    y <- y + (y\
    \ - x) / 2\n  }\n  if(y %% 2 != 0)\n    stop(\"The first argument must be an integer\
    \ number and must be smaller than the second argument.\")\n  if(x < y)\n    x\
    \ <- y\n  x\n}\n", "\n  ans <- -1\n  for(i in 1:x) if(i %% 2 == 0) ans <- max(ans,\
    \ i)\n  ans\n}\n", "\n  if (x > y) return(-1);\n  if(x < y) {\n    if(x %% 2 ==\
    \ 0) return(x);\n    else return(-1);\n  } \n  \n  y <- y+1; y <- y-1; \n  x <-\
    \ x+1; x <- x-1; \n  \n  while(x %% 2 == 0 && y %% 2 == 0){\n    if(x %% 2 ==\
    \ 0){\n      y <- y-1;\n    }\n    else {\n      x <- x+1;\n    }\n  }\n  \n \
    \ return(x); \n}\n", "\n\tx <- as.numeric(x)\n\ty <- as.numeric(y)\n\tx <- x +\
    \ ifelse(x < y, x, y - 1)\n\ty <- y - 1\n\twhich.max(x %/% y == 0) + 1\n}\n",
  "\n  \n  if (x == y) return -1\n  \n  a <- 0\n  b <- 0\n  c <- 0\n  d <- 0\n  \n\
    \  for (j in seq(from=1, to=y, by=2)) {\n    if (j%2 == 0) {\n      a <- j\n \
    \   } else {\n      b <- j\n    }\n  }\n  \n  for (k in seq(from=1, to=y, by=2))\
    \ {\n    if (k%2 == 1) {\n      c <- k\n    } else {\n      d <- k\n    }\n  }\n\
    \  \n  if(a > b && a > c) return a\n  if(b > c && b > d) return b\n  \n  if(b\
    \ > c && b > d) return b\n  \n  if(c > d && c > a) return c\n  \n  if(d > a &&\
    \ d > b) return d\n}\n", "\n  if(x <= y) {\n    stop('x must be bigger than y')\n\
    \  }\n  if(x >= y) {\n    stop('x must be smaller than y')\n  }\n  for(i in seq_len(y))\
    \ {\n    if(x %% i == 0) {\n      return(ceil(x/i))\n    }\n  }\n  return(-1)\n\
    }\n</code>\nTesting:\n<code>\n> choose_num(12, 15)\n[1] 14\n> choose_num(12, 12)\n\
    [1] -1\n> choose_num(13, 12)\n[1] -1\n> choose_num(13, 15)\n[1] 14\n> choose_num(-5,\
    \ 5)\n[1] 5\n</code>\n<|/ a |>\n<| a tags=r,algorithm |>\nHere is a solution using\
    \ the tidyverse packages:\n<code>\nlibrary(tidyverse)\n\nchoose_num <- function(x,y)\
    \ {\n  if(x <= y) {\n    stop('x must be bigger than y')\n  }\n  if(x >= y) {\n\
    \    stop('x must be smaller than y')\n  }\n  x %>% \n    as.integer()%>%\n  \
    \  unique()%>%\n    min()%>%\n    max()\n\n}\n\nchoose_num(12,15)", "\n  y <-\
    \ ifelse(x >= y, \"y\", \"x\")\n  x <- ifelse(x < y, \"x\", \"y\")\n  y <- as.numeric(y)\n\
    \  x <- as.numeric(x)\n  y <- y - 1\n  x <- x - 1\n  for(i in x:y) if (i %% 2\
    \ == 0) i <- i + 1\n  return(i)\n}\n", "\n  \n  # Initialize the output variable\n\
    \  best_num <- -1\n  \n  # If x == y then there's no such number \n  if(x == y)\
    \ {\n    return(-1)\n  }\n  \n  # If x is smaller than y then loop through all\
    \ even numbers\n  # in the range [x, y] and find the biggest even number\n  while(x\
    \ <= y) {\n    \n    if(x %% 2 == 0) {\n      \n      if((x > y && x %% 2 == 1)\
    \ || (x == y && x %% 2 == 0)) {\n        \n        if(x > best_num) {\n      \
    \    best_num <- x\n        }\n      }\n    }\n    \n    x <- x + 2\n  }\n  \n\
    \  return(best_num)\n}\n", "\n  if(x > y) {\n    return(choose_num(y, x))\n  }\n\
    \  if(y == 0) {\n    return(x) # x is even\n  }\n  if(y > 0 && x % y == 0) {\n\
    \    return(choose_num(y, x // y))\n  }\n  if(y == -1) {\n    return(x) # y is\
    \ even\n  }\n  if(y > 0 && x %  y == 0) {\n    return(choose_num(y // x, x))\n\
    \  }\n  return(-1) # y > 0 and x is not even\n}\n</code>\n<|/ a tags=recursion,math,r\
    \ |>\n<| c |>\nI like the answer. However the problem states that \"The function\
    \ should return -1 if there's no such number\".  But when y > 0, x % y returns\
    \ 0.  So the function returns y when x > y, but does not when y < 0.\n<|/ c |>\n\
    <| c |>\n: You're right, thank you. I guess I didn't fully read the problem statement,\
    \ though -- I only read the body of the question. Fixed it now :)\n<|/ c |>\n\
    <| a tags=recursion,math,r |>\nThis is a variation on a theme I've seen people\
    \ use for these kind of problems:\n<code>\nchoose_num <- function(x, y) {\n  if\
    \ (x >= y) stop(\"invalid input order\")\n  m <- min(x, y)\n  s <- signif(x-m,\
    \ digits = 5)\n  u <- signif(y-m, digits = 5)\n  if (m %% 2 == 0) u <- \"-\" else\
    \ s <- \"-\"\n  paste(m, s, u, sep=\"\")\n}\n</code>\nThe idea is to first make\
    \ sure that we actually have both numbers, by checking the sign of the first one.\
    \ This will make sure that the function works correctly if either argument is\
    \ negative, which is what we do if neither argument is positive.\nThen we use\
    \ the fact that if y >= x, then the difference between them is at most 1, and\
    \ we can work out what the corresponding difference is by taking the absolute\
    \ value of x - y and taking the sign (which is either \"-\" or \"+\", depending\
    \ on whether the absolute value is odd or even). Then we combine that with either\
    \ the sign of the second argument, or the sign of the difference in the second\
    \ argument, depending on the signs of the first two arguments.\nThe only thing\
    \ left to do is to make sure that the sign of the resulting number is either \"\
    -\" if the first argument is negative, or \"+\" if the second argument is negative,\
    \ or \"-\" or \"+\" depending on which of x or y is negative.\nNote that this\
    \ solution works for any positive integers in x (or y), because it will always\
    \ produce the correct sign and add \"-\" or \"+\" to the result, regardless of\
    \ what actual values x and y have", "\n  \n  if(x < y) {\n    if(y %% 2 == 0)\
    \ {\n      return(x % 2 * y)\n    } else {\n      return(-1)\n    }\n  } else\
    \ {\n    if(x %% 2 == 0) {\n      return(y % 2 * x)\n    } else {\n      return(-1)\n\
    \    }\n  }\n}\n", "\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_bigger(x,\
    \ y))\n  y <- y-1\n  if(x > y || x == 0) return(-1)\n  if(x <= y) return(find_big",
  "\n  if (x < y) { x <- y; y <- x; } else { x <- y; y <- x; }\n\n  while(x < y) {\n\
    \    a <- floor(x/2)\n    b <- floor((x-a)/2)\n    if(b == 0) return(a);\n   \
    \ if (a == 0) return(b);\n    if (a > b) x <- b\n    else x <- a\n  }\n\n  return(-1)\n\
    }\n\nchoose_num(7, 11)\nchoose_num(17, 12)\nchoose_num(13, 12)\nchoose_num(17,\
    \ 12)\nchoose_num(21, 20)\nchoose_num(17, 12)\nchoose_num(21, 12)\nchoose_num(23,\
    \ 20)\nchoose_num(23, 20)\nchoose_num(23, 20)\nchoose_num(23, 12)\nchoose_num(17,\
    \ 12)\nchoose_num(12, 23)\nchoose_num(18, 17)\nchoose_num(14, 15)\nchoose_num(13,\
    \ 12)\nchoose_num(18, 17)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(14,\
    \ 15)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(12, 15)\nchoose_num(14,\
    \ 15)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(14,\
    \ 15)\nchoose_num(15, 14)\nchoose_num(13, 12)\nchoose_num(15, 14)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(12, 15)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(12, 15)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15, 14)\nchoose_num(15,\
    \ 14)\nchoose_num(15, 14)\ncho", "\n    x <- as.integer(x)\n    y <- as.integer(y)\n\
    \    \n    # Check that x < y \n    if (x < y) {\n        stop(\"'x' must be less\
    \ than 'y'.\")\n    }\n    \n    # Check that x & y are both positive\n    if\
    \ (x <= 0) {\n        stop(\"'x' must be a positive number.\")\n    }\n    \n\
    \    # Check that y & y are both positive\n    if (y <= 0) {\n        stop(\"\
    'y' must be a positive number.\")\n    }\n    \n    # Find maximum evenly divisible\
    \ integer in x..y\n    max <- which.max(x %% y == 0)\n    \n    # Return value\
    \ of max if not out of bounds\n    if (max == length(which(x %% y == 0))) return(max)\
    \ \n    \n    # Return value if out of bounds\n    return(-1)\n}\n", "\n  if(!((x\
    \ >= 0) && (y >= 0))) {\n    return(-1L)\n  }\n  \n  i <- 0L\n  while(i <= x &\
    \ i <= y) {\n    if((x %  2L) == (y %  2L)) {\n      break\n    }\n    i <- i\
    \ + 1L\n  }\n  \n  return(i %  2L)\n}\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n\
    <text>\n\u041E\u0431\u044A\u044F\u0432\u043B\u0435\u043D\u0438\u0435 \u0432\u0435\
    \u043A\u0442\u043E\u0440\u043E\u0432\n\u041E\u0431\u044A\u044F\u0432\u043B\u044F\
    \u0435\u0442\u0441\u044F \u0432\u0435\u043A\u0442\u043E\u0440, \u0440\u0430\u0437\
    \u043C\u0435\u0440\u0430 (n, m). \u041D\u0435\u0437\u0430\u0432\u0438\u0441\u0438\
    \u043C\u043E \u043E\u0442 \u0444\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\
    \u043B\u044C\u043D\u043E\u0441\u0442\u0438, \u043C\u044B \u0440\u0435\u0430\u043B\
    \u0438\u0437\u043E\u0432\u044B\u0432\u0430\u0435\u043C \u043F\u0435\u0440\u0435\
    \u043C\u0435\u0449\u0435\u043D\u0438\u0435 \u0432\u0435\u043A\u0442\u043E\u0440\
    \u0430.\n\n\n</text>\n<cell>", "\n    x <- as.integer(x)\n    y <- as.integer(y)\n\
    \    x <- x - 1\n    y <- y - 1\n    x <- x %/% 2 # integer division\n    if (x\
    \ > y) x <- x + 1\n    if (x == 0) return(-1) # no such number in the range\n\
    \    return(x) # the biggest number in the range\n}\n", "\n  if(x > y) return(-1)\n\
    \  if(x > y & x == y) return(x)\n  x <- x + 1\n  y <- y - 1\n  if(x > y) return(-1)\n\
    \  return(x - 1)\n}\n", "\n  if(y > x & y > x %% 2 == 0) {\n    return(y);\n \
    \ } else if(x > y & x > y %% 2 == 0) {\n    return(x);\n  } else {\n    return(-1);\n\
    \  }\n}\n", "\n    if(x>y) stop(\"x should be smaller than y\") \n    y <- y+1\n\
    \    i <- x\n    while(i <= y) {\n        i <- i+2\n        if(x %% i == 0) {\n\
    \            x <- x+1\n            if(y == x) return(y)\n        }\n    }\n  \
    \  return(-1)\n}\n\nchoose_num(12, 15) # 14\nchoose_num(13, 12) # -1\n", "\n \
    \ i <- 1\n  while(i <= y ) {\n    x <- x + i\n    i <- i + 1\n  }\n  return(x-1)\n\
    }\nchoose_num(25, 15)\n</code>\n<|/ a tags=algorithm,r,performance dscore=3 |>\n\
    <| a tags=algorithm,r,performance |>\nI suspect that this is very close to what\
    \ you are looking for. \n<code>\nchoose_num <- function(x, y) {\n  y <- y+1\n\
    \  n <- 0\n  m <- 0\n  repeat {\n    n <- n+1\n    m <- max(m, x+m)\n    if (y\
    \ > m) break\n  }\n  return(x-m)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI didn't\
    \ know about the `repeat` statement, that's really useful. Thanks!\n<|/ c |>\n\
    <| c |>\nThis doesn't actually work. Try running `choose_num(2, 8)`. You'll find\
    \ it returns `-1` when it should be returning `3`.\n<|/ c |>\n<| a tags=algorithm,r,performance\
    \ |>\nTry this:\n<code>\nchoose_num <- function(x, y) {\n  i <- 0\n  while(x <=\
    \ y) {\n    i <- i + 1\n    x <- x + i\n  }\n  return(x)\n}\n\nchoose_num(12,\
    \ 15)\n</code>\n<|/ a dscore=3 |>\n<| a tags=algorithm,r,performance dscore=3\
    \ |>\nI think this will be very slow, but you could do the following:\n<code>\n\
    choose_num <- function(x, y) {\n  n <- 0\n  m <- 0\n  while(x <= y) {\n    n <-\
    \ n + 1\n    m <- max(m, x + m)\n  }\n  return(x-m)\n}\n\nchoose_num(12, 15)\n\
    </code>\n<|/ a |>\n<| c |>\nThis is not very different to the other answers, but\
    \ you made me wonder what was the complexity of this.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThis is very slow but here is a solution I wrote:\n<code>\nchoose_num <-\
    \ function(x, y) {\n  while(x <= y) {\n    x <- x + 1\n  }\n  return(x)\n}\n\n\
    choose_num(25, 15)\n</code>\n<|/ a tags=algorithm,r,performance |>\n<| a dscore=2\
    \ |>\nYou can try this solution:\n<code>\nchoose_num <- function(x, y) {\n  x1\
    \ <- x + 1;\n  y <- y + 1;", "\n  return(\n    which.max(\n      Map(\n      \
    \  function(x){\n          return(\n            ifelse(\n              x > y,\n\
    \              x,\n              ifelse(\n                x < y,\n           \
    \     y,\n                x %% (y - 1) + y\n              )\n            )\n \
    \         )\n        },\n        x:y\n      )\n    )\n  )\n}\n</cell>\n<cell>",
  "\n  x <- as.integer(x)\n  y <- as.integer(y)\n  x <- ifelse(x >= y, x, y) # Make\
    \ sure x is less than or equal to y\n  y <- ifelse(x <= y, y, x) # Make sure y\
    \ is less than or equal to x\n  x <- as.integer(x)\n  y <- as.integer(y)\n  for(i\
    \ in 1:(x-y)){\n    if(y%%i == 0 && x%%i == 0){\n      if(y%%i == 0) y <- y+1\n\
    \      if(x %% i == 0) x <- x+1\n      if(y%%i == 0){\n        y <- y-1\n    \
    \    break\n      }\n      if(x %% i == 0){\n        x <- x-1\n        break\n\
    \      }\n    }\n  }\n  if(x > y){\n    x <- x+1\n  } else {\n    y <- y+1\n \
    \ }\n  if(x > y){\n    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x > y){\n\
    \    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x > y){\n    x <- x+1\n  }\
    \ else {\n    y <- y+1\n  }\n  if(x > y){\n    x <- x+1\n  } else {\n    y <-\
    \ y+1\n  }\n  if(x > y){\n    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x\
    \ > y){\n    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x > y){\n    x <- x+1\n\
    \  } else {\n    y <- y+1\n  }\n  if(x > y){\n    x <- x+1\n  } else {\n    y\
    \ <- y+1\n  }\n  if(x > y){\n    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x\
    \ > y){\n    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x > y){\n    x <- x+1\n\
    \  } else {\n    y <- y+1\n  }\n  if(x > y){\n    x <- x+1\n  } else {\n    y\
    \ <- y+1\n  }\n  if(x > y){\n    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x\
    \ > y){\n    x <- x+1\n  } else {\n    y <- y+1\n  }\n  if(x > y){\n    x <- x+1\n\
    \  } else {\n    y <- y+1\n  }\n  if(x > y){\n    x ", "\n  x <- ifelse(x >= y,\
    \ x, y)\n  y <- ifelse(x <= y, x, y)\n  ifelse(x > y, y - y, y - x)\n}\n</cell>\n\
    <text>\nTask 3\nAs a last task, we'll implement a function that calculates the\n\
    median of a vector of positive numbers.\n\n\n</text>\n<cell>", "\n  if(x < y &&\
    \ x > 0)\n    which.max(x + y)\n  else\n    return(-1)\n}\n", "\n  # Write your\
    \ code here\n  if (x < y && x >= x || y > x && y >= y) return -1\n  else if (x\
    \ < y && x >= y) x <- y\n  else if (y > x && y >= y) y <- x\n  else if (x > y\
    \ && x >= y) x <- y\n  else if (x > y && x >= y) y <- x\n  else x <- y\n  return(x)\n\
    }\n\nchoose_num(12,15)\nchoose_num(5,3)\n</cell>\n<text>\nPart II: Big O\n\n</text>\n\
    <text>\nAn important concept in computer science is the big O notation. Big O\
    \ notation tells us a few useful properties:\n\nIt tells us how quickly the program\
    \ will run, meaning that if we have a function with big O of $n$, we can expect\
    \ a time complexity of $O(n)$, meaning $n$ will always grow as the program runs.\n\
    We can\u2019t tell how big a program is going to run, so it\u2019s important that\
    \ each function have a big O to help us determine the worst case scenario.\n\n\
    For example, a program that has a linear runtime would be considered O(n), because\
    \ if its runtime is linear, then it will take time proportional to $n$, meaning\
    \ $n$ will always grow as the program runs. A program that has a $n^{2}$ runtime\
    \ would be O(n\xB2), because if its runtime is $n^{2}$, then it will take time\
    \ proportional to $n^{2}$, meaning $n$ will grow with $n^{2}$.\n\nBig O notation\
    \ is also important to note that we can tell how many elements the for loop is\
    \ going to iterate. If for loop is going to iterate over 100 elements, the running\
    \ time of the for loop would be $O(n) = 100$.\n\n\n</text>\n<text>\nIs a program\
    \ O(n) or not?\n\n</text>\n<cell>", "\n\tif(!is.numeric(x) || !is.numeric(y))\
    \ {\n\t\tstop(\"Arguments should be numeric.\")\n\t}\n\tif(x == y) { \n\t\tstop(\"\
    Both numbers must be positive.\")\n\t}\n\tif(x < y) {\n\t\tx <- y\n\t\ty <- x\n\
    \t}\n\tx <- floor(x / 2)\n\ty <- floor(y / 2)\n\twhile(x <= y) {\n\t\tif(x ==\
    \ y || y == x || x %% 2 != 0 | y %% 2 != 0) {\n\t\t\treturn(-1) # Return NA if\
    \ x and y are neither odd nor even\n\t\t}\n\t\tif(x %% 2 == 0) {\n\t\t\tx <- x\
    \ + 1\n\t\t} else {\n\t\t\ty <- y - 1\n\t\t}\n\t}\n\treturn(x + (y - x))\n}\n",
  "\n    result <- -1\n    while(x <= y && result == -1) {\n        result <- max(x,\
    \ y)\n        x <- x + 2\n    }\n    return(result)\n}\n</cell>\n<text>\nNow we\
    \ are ready to run the function to see what it returns.\n\n\n</text>\n<cell>\n\
    choose_num(12, 15)\n</cell>\n<text>\nNow let's try it out with some more examples.\n\
    \n\n</text>\n<cell>\nchoose_num(100, 200)\n</cell>\n<cell>\nchoose_num(12, 20)\n\
    </cell>\n<cell>\nchoose_num(12, 23)\n</cell>\n<cell>\nchoose_num(9, 10)\n</cell>\n\
    <text>\nIt should return -1 and give an error if we input numbers that are not\
    \ in the range.\n\n\n</text>\n<cell>\nchoose_num(19, 14)\n</cell>\n<text>\nA quick\
    \ check to see if our function is working:\n\n\n</text>\n<cell>\nchoose_num(20,\
    \ 15)\n</cell>\n<text>\nNow, let's implement a function that takes a string of\
    \ letters and returns the number of vowels in it.\n\n\n</text>\n<cell>\nvowel_count\
    \ <- function(word) {\n    num_vowels <- 0\n    for(letter in word) {\n      \
    \  if(letter == 'a' | letter == 'e' | letter == 'i' | letter == 'o' | letter ==\
    \ 'u') {\n            num_vowels <- num_vowels + 1\n        }\n    }\n    return(num_vowels)\n\
    }\n</cell>\n<cell>\nvowel_count(\"hello\")\n</cell>\n<cell>\nvowel_count(\"helloooooooooooooooooooooooooooo\"\
    )\n</cell>\n<text>\nNow we are ready to test our function.\n\n\n</text>\n<cell>\n\
    vowel_count(\"helloooooooooooooooooooooooooooo\")\n</cell>\n<text>\nNow we can\
    \ use it to test our choose_num function:\n\n\n</text>\n<cell>\nchoose_num(50,\
    \ 100)\n</cell>\n<cell>\nchoose_num(500, 1000)\n</cell>\n<cell>\nchoose_num(50000,\
    \ 100000)\n</cell>\n<cell>\nchoose_num(100000, 1000000)\n</cell>\n<cell>\nchoose_num(1000000,\
    \ 2000000)\n</cell>\n<cell>\nchoose_num(10000000, 100000000)\n</cell>\n<text>\n\
    Let's see what happens when we input something outside of the range of our choose_num\
    \ function.\n\n\n</text>\n<cell>\nchoose_num(200000, ", "\n  return(seq(from =\
    \ x[1], to = y[1], by = 1)[which.max(seq(from = x, to = y, by = 1))])\n}\n</cell>\n\
    <cell>", "\n  # Initialize your variables here\n  \n  x <- as.integer(x)\n  y\
    \ <- as.integer(y)\n  \n  if(x == y) {\n    x <- x + 1\n    y <- y-1\n  }\n  \n\
    \  if(x == 0)\n    x <- 1\n  \n  if(y == 0)\n    y <- 1\n  \n  while(x <= y) {\n\
    \    \n    if(x %% 2 == 0 & y %% 2 == 0) {\n      x <- x + 1\n      y <- y - 1\n\
    \    } else\n      if(x %% 2 != 0 & y %% 2 != 0) {\n        x <- x - 1\n     \
    \   y <- y - 1\n      } else {\n        x <- x + 1\n        y <- y - 1\n     \
    \ }\n  }\n  \n  return(y)\n}\n</cell>\n<cell>\nchoose_num(1, 3)\n</cell>\n<cell>",
  "\n  x <- as.integer(x)\n  y <- as.integer(y)\n  max(x > y & x + y > 0, y + x >\
    \ 0 & x + y > 0)\n}\n</cell>\n<code language=conda-root-py>\nchoose_num(17, 21)\n\
    </cell>\n<code language=conda-root-py>\nchoose_num(9, 20)\n</cell>\n<code language=conda-root-py>\n\
    choose_num(9, 21)\n</cell>\n<code language=conda-root-py>\nchoose_num(12, 14)\n\
    </cell>\n<text>\n3.1 K-Means Clustering\n\n</text>\n<text>\nIn the previous chapter,\
    \ we learned about k-means clustering for the purposes of identifying groups of\
    \ data points that are similar to each other based on a set of attributes. But\
    \ how can we use k-means clustering when the number of clusters is unknown?\n\n\
    There are three ways to solve this problem:\n\nChoose the number of clusters beforehand\n\
    Use a method that automatically determines the number of clusters\nUse a method\
    \ that performs k-means clustering\n\nIn this chapter, we\u2019ll look at three\
    \ methods of solving this problem: choosing the number of clusters beforehand,\
    \ using a method that automatically determines the number of clusters, and using\
    \ a method that performs k-means clustering.\n\n\n</text>\n<text>\n3.1.1 Choosing\
    \ the number of clusters\n\n</text>\n<text>\nThere are a couple of ways to determine\
    \ a suitable number of clusters:\n\nUse a method that automatically determines\
    \ the number of clusters\nChoose a number based on the results of experiments\n\
    \nThe first method is known as the \"elbow method\". The method uses the results\
    \ of an experiment and determines a suitable number of clusters.\n\n\n</text>\n\
    <text>\nTo determine which method to use, we\u2019ll use our data again and compare\
    \ the number of clusters we obtain from different algorithms. We\u2019ll start\
    \ by running our data through our existing code, and use the results to determine\
    \ the appropriate number of clusters. To do this, we\u2019ll use the k-means function\
    \ from the clustering package, along with our data.\n\n\n</text>\n<code language=conda-root-py>\n\
    kmeans_pred <- predict(kmeans, newdata = data)\n</cell>\n<text>\nWe can now compare\
    \ the number of clusters we have with the number of clusters we obtain from our\
    \ experiment.\n\n\n</text>\n<code language=conda-root-py>\ntable(factor(clusters$cluster),\
    \ factor(kmeans_pred))\n</cell>\n<text>\nThe table shows that we have 3 clusters\
    \ in our data, but only 2 clusters in the kmeans clustering. If we use the elbow\
    \ method, we should get a value of 3 clusters. From this we can see that we\u2019\
    ll need to determine a ", "\n  nums <- seq(from=x, to=y, by=2)\n  i <- 0\n  while\
    \ (i<length(nums)) \n  {\n    if (nums[i]%%2==0) \n    {\n      if (nums[i]>y)\
    \ \n      {\n        break\n      }\n      else \n      {\n        nums[i] <-\
    \ nums[i]-1\n      }\n    }\n    else \n    {\n      nums[i] <- nums[i]+1\n  \
    \  }\n    i <- i+1\n  }\n  if (i<length(nums)) \n  {\n    return(max(nums))\n\
    \  }\n  else \n  {\n    return(-1) \n  }\n}\n", "\n    \n    y <- y\n    if(y\
    \ > x) # check whether y is bigger than x\n        stop(\"y must be bigger than\
    \ x\")\n        \n    y <- y -1\n    x <- x -1\n    \n    out <- x # initialize\
    \ output\n    \n    while(x < y){\n        \n        if(y %% 2 == 0){\n      \
    \      \n            if(y %% 3 == 0){\n                \n                out <-\
    \ y + x\n            } else{\n                \n                if(y %% 5 == 0){\n\
    \                    \n                    out <- y + x\n                } else{\n\
    \                    \n                    if(y %% 7 == 0){\n                \
    \        \n                        out <- y + x\n                    }\n     \
    \           }\n            }\n        }\n        \n        y <- y - 1\n      \
    \  x <- x + 1\n    }\n    \n    if(out == y){\n        out <- -1\n    }\n    \n\
    \    out\n}\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n<text>\nTask 3: Sum\
    \ all the prime numbers from 1 to n\n\n\n</text>\n<cell>\nprime_numbers <- function(n)\
    \ {\n    \n    primes <- c()\n    \n    for(i in 2:n){\n        \n        for(j\
    \ in 1:(floor(sqrt(i))){\n            \n            if((i %% j) == 0){\n     \
    \           \n                primes <- c(primes, i)\n                break\n\
    \            }\n        }\n    }\n    \n    length(primes)\n}\n</cell>\n<cell>\n\
    prime_numbers(10)\n</cell>\n<text>\nTask 4: Return the sum of all the numbers\
    \ in the list in the range \n[1, n] inclusive. The first number in the range is\
    \ 1.\n\n\n</text>\n<cell>\nsum_of_nums <- function(n) {\n    \n    out <- 0\n\
    \    \n    for(i in 1:n){\n        \n        out <- out + i\n    }\n    \n   \
    \ out\n}\n</cell>\n<cell>\nsum_of_nums(10)\n</cell>\n<text>\nTask 5: Compute the\
    \ square of a number x by adding its digits, starting from right-to-left.\n\n\n\
    </text>\n<cell>\nsquare_digits_right <- function(x) {\n    \n    x <- as.integer(x)\n\
    \    \n    out <- 0\n    \n    for(i in 1:x){\n        \n        out <- out +\
    \ i %% 10\n    }\n    \n    out\n}\n</cell>\n<cell>\nsquare_digits_right(123)\n\
    </cell>\n<cell>", "\n  if (x < y && y < x && y <= 2 * x) {\n    return -1\n  }\
    \ else {\n    if (x <= y) {\n      return y\n    } else {\n      x <- x - y\n\
    \      y <- y + x\n      x <- x + y\n      y <- y - x\n      x <- x - y\n    \
    \  y <- y + x\n      x <- x - y\n      y <- y + x\n      x <- x + y\n      y <-\
    \ y - x\n      x <- x - y\n      y <- y - x\n    }\n  }\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| a |>\n<code>\nchoose(3,2)\n[1] 3\nchoose(3,3)\n[1] 5\n</code>\n<|/ a\
    \ dscore=5 tags=r,integer,random |>\n<| c |>\nHow does this answer differ  from\
    \ the other two?\n<|/ c |>\n<| c |>\nThis is really simple, yet it is the only\
    \ one I've found that answers the question exactly\n<|/ c |>\n<| c |>\nThis one\
    \ is simple, since it doesn't depend on the existence of any packages (so there's\
    \ no need to install anything) and is exactly the solution I needed.\n<|/ c |>\n\
    <| c |>\n, yes, this is simple, but it's not the answer the OP asked for, since\
    \ it only returns one of three answers (not all of them).\n<|/ c |>\n<| c |>\n\
    The other answers are all valid (though yours is also simple), but this answer\
    \ is the only one that does what is being asked for. It returns exactly one of\
    \ three possible answers. It's a good answer because it explains how to write\
    \ the function by hand, which is the only way to understand it.\n<|/ c |>\n<|\
    \ a |>\nThis is my solution:\n<code>\nchoose.int <- function(n, m){\n  z <- rbinom(n,1,m)\n\
    \  return(ifelse(z==1,n,m-z))\n}\n</code>\n<|/ a tags=r,integer,random dscore=5\
    \ |>\n<| c |>\nNice, but I don't think it returns all three possibilities of returning\
    \ the desired number\n<|/ c |>\n<| c |>\nThis is a great solution! I thought there\
    \ should be a base function that does it but I can't find it. I don't know if\
    \ it's my lack of knowledge of R because I haven't used R very much.\n<|/ c |>\n\
    <| c |>\nThis is the best answer for me (and the one that most closely matches\
    \ the question) as it returns the possible answers exactly as requested. Thanks!\n\
    <|/ c |>", "\n    r <- c(x, y)\n    i <- 1\n    while (i <= length(r)) {\n   \
    \     if (all(r %% 2 != 0)) {\n            i <- i + 1\n        } else {\n    \
    \        r <- r[!r %% 2]\n        }\n    }\n    return(r[1])\n}\n", "\n  x  <-\
    \ as.numeric(substitute(x))\n  y  <- as.numeric(substitute(y))\n  \n  x  <- ifelse(x\
    \ == y, x, x - y)\n  y  <- ifelse(x == y, x, x - y)\n  \n  x  <- as.integer(x)\n\
    \  y  <- as.integer(y)\n  \n  x  <- ifelse(x <= y || x > y || x %in% c(2, 0),\
    \ -1, x)\n  y  <- ifelse(x <= y || x > y || y %in% c(2, 0), -1, y)\n  \n  if(x\
    \ == y){\n    return(x)\n  }else{\n    return(ifelse(x == y, 1, -1))\n  }\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\n`ifelse` can be replaced by `if/else`.\n\
    <|/ c |>\n<| c |>\n: I didn't think of that! Thanks ! I changed the code accordingly\n\
    <|/ c |>\n<| c |>\nYour function is still wrong when x and/or y are negative.\n\
    <|/ c |>\n<| c |>\nThanks for the note. I forgot to check for negatives. I fixed\
    \ it\n<|/ c |>\n<| c |>\nIn your `choose_num` function, shouldn't `x` be `y`?\n\
    <|/ c |>\n<| a tags=r |>\n<code>", "\n  \n  # First check whether the given number\
    \ is in the range\n  if (x >= y || x <= 0)\n    stop(\"The given number is not\
    \ in the range [x, y].\")\n  \n  # Then determine the difference between x and\
    \ y\n  d <- abs(x - y)\n  \n  # If x and y are equal or less than d, then return\
    \ -1\n  if (d == 0)\n    stop(\"The given numbers are equal.\")\n  \n  # Otherwise\
    \ the largest even integer in the range [x, y] will be \n  # either x (if y is\
    \ even) or x + y (if y is odd). \n  res <- if (y %% 2 == 0) \n    x\n  else \n\
    \    x + y\n  \n  # Then return the result \n  res\n}\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function to check if an integer is a palindrome.\n\nA palindrome\
    \ is a word, number, phrase, or other sequence of characters which reads the same\
    \ backward as forward, i.e. forward and backward can be interchanged. For example,\
    \ the sequence\n\"racecar\", or \"race car\", or \"racecar\", or \"racecar\",\
    \ or \"racecar\", or \"racecar\" is the same as \"racecar\" or \"race car\", so\
    \ these two sequences are considered palindromes. Write a function that checks\
    \ if an integer is a palindrome.\n\n\n</text>\n<cell>", "\n    x <- abs(x)\n \
    \   y <- abs(y)\n    x <- min(x, y)\n    y <- max(x, y)\n    if(y <= (x/2)) {\n\
    \        return -1\n    }\n    i <- 1\n    while(x <= y) {\n        i <- i + 1\n\
    \        x <- x + y\n    }\n    return(i)\n}\n</code>\n<|/ a tags=r dscore=0 |>\n\
    <| c |>\nI ran the code you gave but it did not work. Does your answer have to\
    \ do with using the package 'randomForest' or is it just an issue with the code?\n\
    <|/ c |>\n<| c |>\nHi, I used this package to simulate your data. The function\
    \ does not work for the random generated data, because there are numbers in the\
    \ range (-2,3). I edited the answer and added a function that returns random numbers\
    \ in the range (0,4). Hope it helps!\n<|/ c |>\n<| c |>\nOkay, I ran it again\
    \ and it still returns -1. Perhaps there's something wrong with my R installation\
    \ because when I run the code you gave it comes up with an error saying 'Error\
    \ in choose_num(12, 15) : could not find function \"choose_num\". Also, is there\
    \ a way to do this without using 'randomForest'?\n<|/ c |>\n<| c |>\nThe code\
    \ I posted was a solution for the question you asked. Did you run it with the\
    \ function you provided? How did you test it? Did you include this `choose_num\
    \ <- function(x, y) {...}` function in the code? If yes, what is the error message?\n\
    <|/ c |>\n<| c |>\nYes I ran it with the function you provided. And yes I included\
    \ the 'choose_num <- function(x, y) {...}' function in the code. Error message\
    \ was \"Error in choose_num(12, 15) : could not find function \"choose_num\".\
    \ Also, is there a way to do this without using 'randomForest'?\n<|/ c |>\n<|\
    \ a tags=r dscore=0 |>\nThis seems to work\n<code>\nfind2 <- function(lower, upper)\
    \ {\n  lower2 <- lower\n  upper2 <- upper\n  lower2 <- lower2 - 1\n  lower2 <-\
    \ max(lower2, -1)\n  upper2 <- upper2 + 1\n  upper2 <- min(upper2, 5)\n  x <-\
    \ lower2\n  y <- upper2\n  while(x < y & !(x > y)) {\n    x <- x + y\n    y <-\
    \ x + y\n  }\n  while(y > x & !(x < ", "\n    x <- min(x, y)\n    y <- max(x,\
    \ y)\n    out <- -1\n    for(i in seq(x, y)) {\n        out <- i if (i %% 2 !=\
    \ 0)\n    }\n    out\n}\n</cell>\n<text>\n3.1.2 Question 3.2\nWrite a function\
    \ named sum2 which takes two numbers as parameters and returns the sum of the\
    \ two numbers.\n\nExample\nGiven the vector:\n$ A = [4, -2, -3]$\n\nThe function\
    \ should return $ 3 + 4 - 2 - 3 = 0$\n\n</text>\n<cell>", "\n  ifelse(\n    x\
    \ > y || (x <- y) ,\n    -1,\n    max(x + 2*(y - x), abs(x - y) + 1))\n}\n", "\n\
    \    x <- abs(x)\n    y <- abs(y)\n    if(x == 0 | y == 0) {\n        return(-1)\n\
    \    }\n    if(x < y) {\n        m <- min(x, y)\n        while(m < y) {\n    \
    \        m <- m * 2\n        }\n        return(m)\n    }\n    m <- min(y, x)\n\
    \    while(m > x) {\n        m <- m * 2\n    }\n    return(m)\n}\n", "\n  x <-\
    \ as.numeric(x)\n  y <- as.numeric(y)\n  y <- max(y, x-1)\n  y <- min(y, x+1)\
    \ \n  x <- max(x, y-1)\n  x <- min(x, y+1) \n  return(y)\n}\n</code>\n<|/ a tags=integer,r\
    \ dscore=1 |>\n<| c |>\nThis code is not correct at all. Look at the examples\
    \ for `choose_num(9, 20)` for example. There are 4 numbers between 9 and 19 that\
    \ are even and both 9 and 19 are even.\n<|/ c |>\n<| a tags=integer,r dscore=1\
    \ |>\nYou can do this with R's %in% operator to test whether each element in num\
    \ is included in [x, y]. If it is, then num is even:\n<code>\nchoose_num <- function(num1,\
    \ num2) {\n  x <- as.numeric(num1)\n  y <- as.numeric(num2)\n  x <- max(x, y-1)\n\
    \  y <- min(x, y+1) \n  y <- min(y, x-1)\n  y <- max(y, x+1) \n  if (y %in% num)\
    \ y <- -1\n  return(y)\n}\n</code>\nNote that I've modified your function so that\
    \ the lowest and highest numbers are chosen to be inclusive in the range of numbers,\
    \ and the lowest number chosen to be exclusive in the range of numbers. That way\
    \ the function returns -1 when the first number is less than the second number,\
    \ and otherwise it returns the second number that isn't in the range of numbers.\n\
    <|/ a |>\n<| c |>\n`as.numeric` is unnecessary. `y` is an integer.\n<|/ c |>\n\
    <| c |>\n- it won't work like that as `num` is not a numeric vector. Try `choose_num(9,\
    \ 20)`.\n<|/ c |>\n<| c |>\nYes, I tested it. `choose_num(9,20)` returns `-1`.\
    \ But I believe it shouldn't. Try `choose_num(9,21)`.\n<|/ c |>\n<| c |>\nAh,\
    \ yes. My code wasn't clear that `num` would be a vector. I'll edit it out.\n\
    <|/ c |>\n<| c |>\nYour code works, but the answer is wrong. Try it with `choose_num(9,\
    \ 20)`. And why do you use `y` twice in the `if`?\n<|/ c |>\n<| a dscore=1 |>\n\
    Here's another option, with some simplification.\n<code>\nchoose_num <- function(num1,\
    \ num2) {\n    x <- as.numeric", "\n  y <- y\n  x <- x\n  while(x<y) {\n    x\
    \ <- x+y\n  }\n  x <- x-y\n  if(x%%2==0) {\n    return(x)\n  } else {\n    return(-1)\
    \ # no such number\n  }\n}\n", "\n  if (x < y & x > 0) {\n    stop(\"The biggest\
    \ even number must be greater or equal to that of the lower bound\")\n  } else\
    \ if (x > y & x < 0) {\n    stop(\"The biggest even number must be greater or\
    \ equal to that of the upper bound\")\n  } else if (x == y) {\n    return(x -\
    \ 1)\n  } else if (x == y - 1) {\n    return(-1)\n  } else {\n    i <- 0\n   \
    \ x <- 0\n    y <- 0\n    result <- 0\n    \n    while (x < y & x < y) {\n   \
    \   x <- x + 1\n      if (x %% 2 == 0) {\n        i <- i + 1\n      }\n    }\n\
    \    \n    if (i == 0) {\n      return(-1)\n    } else {\n      result <- x -\
    \ 1\n    }\n    \n    return(result)\n  }\n}\n", "\n  if (x < y & !(x%2)) return(-1)\
    \ # if y is even but x is less than y\n  if (x > y & !(x%2)) return(-1) # if y\
    \ is odd but x is greater than y\n  for (i in seq(x, y)) {\n    if (i %% 2 ==\
    \ 0) return(i) # if i is even\n  }\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r dscore=1\
    \ |>\nTo get the largest integer from a given range (inclusive), I used the following\
    \ code:\n<code>\n largest.integer <- function(x,y){\n   for(val in seq(x,y+1))\
    \ {\n     if(val%%2==0) return (val)\n   }\n }\n</code>\n<|/ a |>\n<| a |>\nJust\
    \ in case anyone wants a base R solution without loops here is one:\n<code>\n\
    max.even <- function(x,y) unname(sapply(seq(x),function(x) x%%2==0))\n</code>\n\
    <|/ a tags=r dscore=1 |>\n<| c |>\nVery nice. +1. However, this fails when the\
    \ first number is odd. See my answer for an amended version that handles that\
    \ case.\n<|/ c |>\n<| c |>\nAlso fails if the first number is 0. See my answer\
    \ for an amended version that handles that case as well and another version that\
    \ doesn't require that assumption.\n<|/ c |>\n<| c |>\ngood point, I didn't consider\
    \ that case\n<|/ c |>\n<| a tags=r |>\n<code>\nmax.even <- function(x,y) if(length(x)\
    \ > length(y)) which.max(x%%2==0) else -1\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for sharing your code! Could you please [edit] your answer to explain how\
    \ it works? That will help readers understand your code, and help you get better\
    \ answers in the future. Thanks!\n<|/ c |>\n<| c |>\nThanks for your comment!\
    \ I am glad to help. This should explain my code.\n<|/ c |>\n<| a tags=r dscore=1\
    \ |>\nIf you're looking for a base R solution, here is a version that does not\
    \ assume that there are any even numbers in the first argument:\n<code>\nmax.even\
    \ <- function(x,y){\n  if( length(x) > length(y)){\n    x <- x[-length(x)]\n \
    \ }\n  which.max(x%%2==0)\n}\n</code>\n<|/ a |>\n<| c |>\n+1 This ", "\n  if(x\
    \ > y) {\n    stop(\"'x' should be less than 'y'\");\n  }\n\n  if(x <= 0) {\n\
    \    return -1;\n  }\n\n  if(y <= 0) {\n    return -1;\n  }\n\n  if(x %2 == 0\
    \ && y %2 == 0) {\n    return -1;\n  }\n\n  if(x %2 == 1) {\n    y <- y - 1;\n\
    \  }\n\n  while(y != 0) {\n    if(x == y) {\n      y <- y - 1;\n    }\n    if(y\
    \ % 2 == 0) {\n      x <- x - 1;\n    }\n    else {\n      y <- y - 1;\n    }\n\
    \  }\n\n  if(x == 0) {\n    return(-1);\n  }\n\n  return(x);\n}\n</cell>\n<text>\n\
    Next we write a function to find the largest even number between 2 numbers.\n\n\
    \n</text>\n<cell>\nlibrary(plyr)", "\n  # Your code here\n  return(ifelse(x >=\
    \ y & x <= x, x, y))\n}\n</code>\n<|/ a tags=r,return,if-statement,function,for-loop\
    \ |>\n<| c |>\nYep. I knew it was a simple mistake. I can't believe I missed that.\n\
    <|/ c |>\n<| a tags=r,return,if-statement,function,for-loop |>\nAs noted before,\
    \ you need to return your ifelse statement, otherwise it will return nothing.\n\
    <code>\nchoose_num <- function(x,y){\n  for(i in x:y){\n    ifelse(i %% 2 == 0,\
    \ i, -1)\n  }\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,return,if-statement,function,for-loop\
    \ |>\nAnother option is to use a vectorized approach with pmax:\n<code>\nchoose_num\
    \ <- function(x, y){\n  return(ifelse(x == y, x, y))\n}\n\nx <- 10:20\ny <- 20:10\n\
    \n> choose_num(x, y)\n[1] 10 20 10 20 10 20 10 20\n\n> y <- 20:10\n> choose_num(x,\
    \ y)\n[1] 10 20 10 20 10 20 10\n</code>\nOr use ifelse:\n<code>\nifelse(x == y,\
    \ x, y)\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,return,if-statement,function,for-loop\
    \ |>\nHere is another option:\n<code>\nx <- 10:20\ny <- 20:10\n\nchoose_num <-\
    \ function(x, y){\n  if(x >= y) x else y\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ |>\nYour code did not return anything because it did not return ifelse\nYou\
    \ can do like this\n<code>\nchoose_num <- function(x,y){\n  for(i in x:y){\n \
    \   ifelse(i %% 2 == 0, i, -1)\n  }\n}\nchoose_num(12,15)\n[1] 14\n</code>\n<|/\
    \ a dscore=0 tags=r,return,if-statement,function,for-loop |>\n<| a dscore=0 |>\n\
    Your code only returns \"i\" if i is even. Because you only return i when the\
    \ test is TRUE. \nThis code might help:\n<code>\nchoose_num <- function(x,y){\n\
    \  y <- y[1]\n  for(i in x:y){\n    ifelse(i %% 2 == 0, i, y)\n  }\n}\nchoose_num(12,15)\n\
    [1] 14\n</code>\n<|/ a tag", "\n    ans <- -1 # Initialize the answer with the\
    \ first argument\n    i <- 1 # Initialize variable i\n    while (i <= y && ans\
    \ < x) {\n        if (x %% i == 0) {\n            ans <- x # Record the answer\n\
    \        }\n        i <- i + 1\n    }\n    ans\n}\n</code>\nHere's the whole program\
    \ in R:\n<code>\nchoose_num <- function(x, y) {\n    ans <- -1 # Initialize the\
    \ answer with the first argument\n    i <- 1 # Initialize variable i\n    while\
    \ (i <= y && ans < x) {\n        if (x %% i == 0) {\n            ans <- x # Record\
    \ the answer\n        }\n        i <- i + 1\n    }\n    ans\n}\n", "\n  if(x ==\
    \ y) return -1\n  if(x %% 2 == 0) return(y)\n  if(y %% 2 == 0) return(x)\n  if(x\
    \ > y) return(choose_num(x, y-1))\n  if(x < y) return(choose_num(x-1, y))\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\n`if(x == y) return` should be `if(x < y)\
    \ return` and likewise for the other cases.\n<|/ c |>\n<| a |>\nIf you're using\
    \ S4, a more succinct and efficient version is as follows:\n<code>\nlibrary(S4)\n\
    \nchoose_num <- function(x, y){\n  if(x > y) return(x - 1)\n  if(x < y) return(x\
    \ + 1)\n  if(y == 0) return(-1)\n  if(y %% 2 == 0) return(y)\n  return(x)\n}\n\
    \nchoose_num(11,12) # 14\n</code>\n<|/ a dscore=4 tags=functional-programming,r\
    \ |>\n<| a dscore=2 tags=functional-programming,r |>\nI'm adding my contribution\
    \ since I got here from another forum (maybe someone will find it helpful):\n\
    <code>\nchoose_num <- function(x,y){\n  if(y<x) return(-1) #If y is smaller than\
    \ x, y can be any integer. \n  if(y==0) return(x+1)  #If y is zero, return x+1.\n\
    \  if(y%%2==0) return(y) #If y is even, return y.\n  return(x-1) #If y is odd,\
    \ return x-1.\n}\n</code>\nThe main idea is that you can \"play\" with your arguments\
    \ and see what happens. Here is a small example I made:\n<code>\n> choose_num(1,2)\n\
    [1] 2\n> choose_num(1,3)\n[1] 2\n> choose_num(1,4)\n[1] 1\n> choose_num(3,4)\n\
    [1] 3\n> choose_num(3,6)\n[1] 2\n> choose_num(3,7)\n[1] 2\n> choose_num(5,6)\n\
    [1] 4\n> choose_num(5,7)\n[1] 4\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere's another\
    \ function that works with integers even when y is a negative number, and also\
    \ with negative numbers.\n<code>\nchoose_num <- function(x, y) {\n  if (y < x)\
    \ return(-1L) # if y is smaller than x, y can be any integer. \n  if (y == 0)\
    \ return(x+1L)  # If y is zero, return x+1.\n  if (y %% 2 == 0) return", "\n\t\
    x <- as.integer(x)\n\ty <- as.integer(y)\n\tx <- ifelse(x > y, y, x)\n\ty <- ifelse(x\
    \ < y, y, x)\n\ty <- ifelse(y > Inf, y, Inf)\n\tx <- ifelse(x < Inf, x, Inf)\n\
    \tx <- ifelse(x > y, y, x)\n\tx <- ifelse(x < Inf, x, Inf)\n\ty <- ifelse(x >\
    \ Inf, y, Inf)\n\ty <- ifelse(x < y, y, x)\n\ty <- ifelse(y > Inf, y, Inf)\n\t\
    return(y)\n}\n\n", "\n  if(x < y && x > 1) {\n    for(k in seq(x, y)) {\n    \
    \  if(!(k %% 2 == 0)) {\n      return(k)\n      }\n    }\n    return(-1) \n  }\n\
    }\n</code>\nI realize that there's an error in the function above. Since choose_num(11,\
    \ 14) should return 12, it actually returns 11. That's not the case with this\
    \ code. I think the problem lies in the fact that the for loop should iterate\
    \ from x to y, but my code is iterating from 1 to x. That's where the problem\
    \ is. I think a for loop is overkill for this problem.\n<|/ a dscore=2 |>\n<|\
    \ c |>\nYeah, I think that's what OP wanted to do, but OP's code doesn't do it,\
    \ and I don't think OP wants to change his code\n<|/ c |>\n<| a dscore=1 tags=r\
    \ |>\nThe function works now. Thank you so much to all of you.\n<code>\nchoose_num\
    \ <- function(x, y) {\n    if(x < y && x > 1){\n        for(k in seq(x, y)) {\n\
    \            if(!(k %% 2 == 0)) {\n                return(k)\n            }\n\
    \        }\n        return(-1) \n    }\n}\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post.\n<|/ c |>\n<| c |>\nOP provided\
    \ a working function so I provided an answer. There is no need for clarification.\
    \ OP can accept either of them as an answer if they want. OP can also leave a\
    \ comment to my answer if he wants to clarify something. Either way, my answer\
    \ still answers the question.\n<|/ c |>\n<| c |>\nSo you provided your own answer\
    \ which I guess is fine, but you say *\"This does not provide an answer to the\
    \ question.\"* ... and that is your answer which you said. Is that not an answer\
    \ to the question? Please see [How to write a good answer](http://stackoverflow.com/help/how-to-answer).\n\
    <|/ c |>\n<| c |>\nI said \"This does not provide an answer to the question\"\
    \ because the OP accepted an answer which he didn't say was wrong, instead he\
    \ said his code was wrong and he posted his own answer, I didn't post an answer\
    \ to the question because my answer was wrong.\n<|/ c |>\n<| c |>\nOK - I see\
    \ now. But I think OP doesn't want to change the OP's code - I think that was\
    \ his point.\n<|/ c |>\n", "\n  if(x > y) {\n    stop(\"x must be smaller than\
    \ y\")\n  }\n  if(y > floor(x)) {\n    stop(\"y must be smaller than or equal\
    \ to x\")\n  }\n  if(y == floor(x) & x < y) {\n    x\n  } else {\n    -1\n  }\n\
    }\n", "\n    x <- to_integer(x)\n    y <- to_integer(y)\n    \n    if (x < y)\
    \ {\n        x <- y\n        y <- x\n    }\n    \n    x <- abs(x - y)\n    while\
    \ (y %% 2 != 0) {\n        y <- y / 2\n    }\n    \n    y <- y / 2\n    \n   \
    \ y <- max(x, y)\n    \n    if (x >= y) return(-1)\n    else if (x < y) return(y\
    \ - 1)\n    else if (x == y) return(x)\n    else return(y - 1)\n}\n</code>\n<|/\
    \ a tags=r,algorithm,c++,math,function |>\n<| c |>\nThanks for your answer! However,\
    \ I find it really hard to follow... can you please explain what is going on?\n\
    <|/ c |>\n<| a |>\nThis can be done by checking every pair of numbers in sorted\
    \ order. If the first number is smaller than the second number, then the second\
    \ number is the larger number, so you have to check if the last even number of\
    \ the pair is smaller than the second number, and if yes then it's the larger\
    \ number, so you have to check if the second number is also a even number or smaller\
    \ number. If so, you found your number. \nI wrote a Python code which does the\
    \ job for you:\n<code>\ndef choose_num(a, b):\n    if a > b:\n        a, b = b,\
    \ a\n    pairs = range(2, min(a, b + 1) + 1, 2)\n    for p in pairs:\n       \
    \ if p % 2 == 0 and p < a:\n            if b > p:\n                return p\n\
    \            else:\n                b = p\n        elif p % 2 == 0 and p > a:\n\
    \            if b < p:\n                return p\n            else:\n        \
    \        b = p\n    return -1\n\nprint(choose_num(12, 15))\nprint(choose_num(13,\
    \ 12))\nprint(choose_num(14, 11))\nprint(choose_num(15, 12))\n</code>\n<|/ a tags=r,algorithm,c++,math,function\
    \ dscore=0 |>\n<| a dscore=0 |>\nI solved this in O(logn) time using the following\
    \ method. \n<code>\nint choose_num(int a, int b)\n{\n  if ( a > b )\n  {\n   \
    \ swap(a, b);\n  }\n\n  int c = 1;\n  int d = 1;\n\n  while ( d <= b )\n  {\n\
    \    if ( d % 2 == 0 )\n    {\n      if ( a % 2 == 0 )\n      {\n        swap(a,b);\n\
    \        b = a;\n        break;\n      }\n      else if ( a < c )\n      {\n \
    \       c = a;\n      }\n      else if ( a < c )\n      {\n        d = d;\n  \
    \    }\n    }\n    else\n    {", "\n    x <- as.integer(x)\n    y <- as.integer(y)\n\
    \    if (x >= y) return(-1) # if the range is empty or all values equal \n   \
    \ \n    i <- 1\n    while(x <= y) {\n        x <- x + 1 # next x is x + 1\n  \
    \      i <- i + 1\n    }\n    return(i) # returns biggest odd number in range\n\
    }\n", "\n    \n    x <- as.integer(x)\n    y <- as.integer(y)\n    \n    # check\
    \ if y > x\n    if(x < y) {\n        y <- x\n    }\n    \n    # check whether\
    \ y>=1 and x>=1\n    if(y >= 1) {\n        if(x >= 1) {\n            while (x\
    \ > 0) {\n                x <- x - 1\n                y <- y - 1\n           \
    \     if(y == 0) {\n                    x <- x + 1\n                    break\n\
    \                }\n            }\n            if(y == 0) {\n                x\
    \ <- x + 1\n                break\n            }\n        }\n        if(x < 1)\
    \ {\n            x <- x - 1\n            y <- y - 1\n            if(y == 0) {\n\
    \                x <- x + 1\n                break\n            }\n        }\n\
    \    }\n    return(x)\n}\n", "\n    i <- 0\n    flag <- 1\n    while (i <= x)\
    \ {\n        if (i %% 2 == 0) {\n            if (y > i) {\n                y <-\
    \ i\n            }\n            i <- i + 1\n        }\n        else {\n      \
    \      if (i <= y) {\n                flag <- flag - 1\n            }\n      \
    \      else {\n                i <- i + 1\n            }\n        }\n    }\n \
    \   if (flag == 1) {\n        return(y)\n    }\n    else {\n        return(-1)\n\
    \    }\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r |>\nUsing R's \"rolling sum\"\
    \ approach, we could write\n<code>\nchoose_num <- function(x, y) {\n  rs <- seq(y[1],\
    \ length(x), by = -1)\n  r <- sum((rs[-1:-2] + rs[-1]) == x)\n  if(r > 0) r else\
    \ -1\n}\n</code>\nHere, seq(y[1], length(x), by = -1) creates the vector rs that\
    \ has all possible rolling sums from y to the length(x) of the vector (ignoring\
    \ the last value), and rs[-1:-2] selects the even values from these rolling sums.\
    \ Thus, rs[-1:-2] + rs[-1] gives us the sum of the even rolling sums, which we\
    \ then sum.\nHowever, this will fail for vectors with negative numbers, since\
    \ the rolling sum with even length (-1) is a valid sum.\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\nI believe that my solution is cleaner and more efficient. \n\
    <code>\nchoose_num <- function(x, y) {\n  x_pos <- x - 1\n  x_neg <- x - 2\n \
    \ y_pos <- y - 1\n  y_neg <- y - 2\n  pos_x <- x_pos - y_pos\n  pos_y <- x_neg\
    \ - y_neg\n\n  if(pos_x == 0 | pos_y == 0 | pos_x <= 0 | pos_y <= 0 | y_neg <\
    \ 0 | y_pos < 0 | x_neg < 0 | x_pos < 0) {\n    -1 \n  } else {\n    if(y_neg\
    \ > x_neg) {\n      y_neg <- x_neg\n    }\n    y_pos <- x_pos\n    x_neg <- y_neg\n\
    \    x_pos <- y_pos\n    pos_x <- x_pos - y_pos\n    pos_y <- x_neg - y_neg\n\
    \    max(y_neg, x_neg, x_pos, y_pos, y_neg)\n  }\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis answer will also return -1 for `choose_num(100,0)`, which I think\
    \ it should be -1.\n<|/ ", "\n  if(x > y) return(-1)\n  if(x < y) return(-1)\n\
    \  for(i in seq(x)) {\n    if(x %% i == 0) {\n      if(y %% i == 0) return(i)\n\
    \      if(x %% i == 0 && y %% i == 0) return(i + y)\n    }\n  }\n  return(-1)\n\
    }\nchoose_num(100, 15)\n</cell>\n<cell>", "\n  tmp <- x\n  while (tmp < y) {\n\
    \    if (tmp %% 2 == 0) tmp <- tmp + 1\n    else tmp <- tmp - 1;\n  }\n  return(tmp)\n\
    }\n</cell>\n<cell>\nchoose_num(19, 19)\n</cell>\n<text>\nNow let's implement the\
    \ algorithm that goes through the list one by one, adding its elements to tmp\
    \ and comparing tmp to the final number:\n\n\n</text>\n<cell>\nchoose_num <- function(x,\
    \ y) {\n  tmp <- x\n  \n  while (tmp < y) {\n    if (tmp %% 2 == 0) tmp <- tmp\
    \ + 1\n    else tmp <- tmp - 1;\n  }\n  return(tmp)\n}\n</cell>\n<text>\nLet's\
    \ test it on the first 20 numbers:\n\n\n</text>\n<cell>\ntmp <- 0\nfor (i in 1:20)\
    \ {\n  print(choose_num(i, 20))\n  tmp <- tmp + 1\n}\n</cell>\n<text>\nAnd now\
    \ for the entire list. Let's create another list of length 100 containing the\
    \ first 20 numbers from 1 to 19. We need to subtract 19 from the first number,\
    \ so that it becomes 0 at the start, and then multiply each number in the list\
    \ by i:\n\n\n</text>\n<cell>", "\n  if(x > y) {\n    y <- x\n  }\n  x <- x + 1\n\
    \  y <- x + 1\n  while(x < y) {\n    if(x == y) {\n      break\n    }\n    if((x\
    \ %% 2) == 0 && (y %% 2) == 0) {\n      x <- x + 2\n    }\n    if((x %% 2) ==\
    \ 0 && (y %% 2) == 0) {\n      y <- y + 2\n    }\n    if(x %% 2 != 0 && (y %%\
    \ 2 != 0)) {\n      x <- x + 1\n    }\n    if(x %% 2 != 0 && (y %% 2 != 0)) {\n\
    \      y <- y + 1\n    }\n  }\n  if(x %% 2 == 0 && y %% 2 == 0) {\n    x <- x\
    \ + 1\n    y <- y + 1\n  }\n  if(x %% 2 == 0 && y %% 2 != 0) {\n    x <- x + 1\n\
    \  }\n  if(x %% 2 != 0 && y %% 2 == 0) {\n    y <- y + 1\n  }\n  return(ifelse(x\
    \ > y, y, x))\n}\n</cell>\n<text>\nTest your code\nRun the cell below to test\
    \ your code. On SageMath you can test your functions using test_your_code.\n\n\
    \n</text>\n<cell>", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n\n  if (x ==\
    \ y) # If they're equal then return x\n    x <- x + 1 # otherwise add 1 to x to\
    \ ensure x > y\n  \n  if (x > y) \n    y <- y - 1 #reverse the order to ensure\
    \ x > y\n\n  while (x < y) { # while x is less than y, do the following\n    if\
    \ (x %% 2 == 0) # if x is even\n      x <- x + 2 # then increment x by 2\n   \
    \ else if (x %% 2 != 0) # if x is odd\n      x <- x - 2 # then decrement x by\
    \ 2\n  }\n  return(x)\n}\n\nchoose_num(12, 15)", "\n  i <- 1\n  j <- 1\n  while(i\
    \ <= x & j <= y) {\n    if(x %% i == 0) {\n      if(y %% j == 0) {\n        break\n\
    \      }\n      j <- j+1\n    }\n    i <- i+1\n  }\n  if(i == x & j == y) {\n\
    \    i <- i+1\n  }\n  if(i <= x & j <= y) {\n    return(i)\n  } else {\n    return(-1L)\n\
    \  }\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=0 |>\nThis is an answer that is\
    \ very similar to but much faster than the original post. My post is just to show\
    \ that there is an answer. \nI used a while loop instead (I used this for loop\
    \ as a means of getting it started):\n<code>", "\n  i <- 0\n  while(i <= y) {\n\
    \    if(x %% 2 != 0 && y %% 2 != 0) {\n      return(which.max(c(as.numeric(x %%\
    \ 2), as.numeric(y %% 2))))\n    }\n    i <- i + 2\n  }\n  return(-1)\n}\n</code>\n\
    The function above only takes two positive numbers as an input. The while loop\
    \ runs from 0 to y inclusive. In the while loop i <- i + 2 increases i by 2. So\
    \ i takes the values 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 and so on, until the\
    \ while loop ends and which.max() returns the biggest even number among the values\
    \ of i starting from 0 to y inclusive.\n<|/ a |>\n<| c |>\nThanks. I forgot about\
    \ 'which.max'.\n<|/ c |>\n<| c |>\nI added a faster alternative\n<|/ c |>\n<|\
    \ c |>\n, thanks for the alternate method but when I used it I got the following\
    \ error message. `Error in choose_num(12, 15) : object 'choose_num' not found`\n\
    <|/ c |>\n<| c |>\nYou just copied my function and it didn't work because I forgot\
    \ to include an assignment `choose_num <- function(x, y)`. I've added it\n<|/\
    \ c |>\n<| c |>\nThanks. It's working now. `choose_num <- function(x, y) {\n \
    \ i <- 0\n  while(i <= y) {\n    if(x %% 2 != 0 && y %% 2 != 0) {\n      return(which.max(c(as.numeric(x\
    \ %% 2), as.numeric(y %% 2))))\n    }\n    i <- i + 2\n  }\n  return(-1)\n}`\n\
    <|/ c |>\n<| a |>\nAn efficient way to find all the even numbers in a vector is\
    \ to use the fact that when you take every second value of a vector you get every\
    \ second element in the original vector:\n<code>\nvec <- c(1,2,3,4,5,6,7,8,9,10)\n\
    vec[c(TRUE, FALSE, TRUE)]\n</code>\nThis will return c(2, 4). \nTo find out if\
    \ all even numbers in a vector are present, you do this:\n<code>\nall(vec[c(TRUE,\
    \ FALSE, TRUE)] == 0)\n</code>\nThis returns TRUE. \nAnd for even numbers greater\
    \ than a number you can do:\n<code>\nall(vec[c(TRUE, FALSE, TRUE)] > 5)\n</code>\n\
    <|/ a tags=r dscore=3 |>\n<| c |>\nThis is the best answer.  It's so much more\
    \ elegant ", "\n  if(x < y) {\n    stop(\"y must be greater than x\");\n  }\n\
    \  x <- as.integer(x); y <- as.integer(y); # cast to integer\n  if(x > y) {\n\
    \    x <- y; y <- x; x <- y; y <- x;\n  }\n  x <- sort(x);\n  y <- sort(y);\n\
    \  \n  # Find smallest integer y >= x.\n  i <- which.min(x-y);\n  \n  # Calculate\
    \ remainder\n  r <- x-y[i];\n  \n  # Calculate largest even number that fits in\
    \ range.\n  if(r > 1) {\n    n <- 1;\n    i <- i+1;\n  } else {\n    n <- y;\n\
    \    i <- i+1;\n  }\n  \n  n[i] # return the largest even number\n}\n", "\n  \n\
    \  # Define the range that x and y can go in\n  x_range <- seq(from=x, to=y, length.out\
    \ = 100)\n  y_range <- seq(from=y, to=x, length.out = 100)\n  \n  # Return an\
    \ index from the x_range that gives us the biggest number in the y_range\n  x_index\
    \ <- which.max(x_range %% y_range == 0)\n  \n  # Return the number at the index\
    \ from the x_range that gives us the biggest number in the y_range\n  return(x_range[x_index])\n\
    }\n</cell>\n<cell>", "\n    \n    choose_num <- function(x, y) {\n        \n \
    \       if ((x <= y & y >= x)) {\n            return (x+y)/2\n        }\n    \
    \    else if ((x > y & y <= x)) {\n            return (y-x)/2\n        }\n   \
    \     else if ((x == y & y > x)) {\n            return (y-x+1)/2\n        }\n\
    \        else if (x == y & y == x) {\n            return -1\n        }\n     \
    \   else {\n            return -1\n        }\n    }\n    \n    choose_num(12,\
    \ 15)\n    \n}\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n<cell>\nchoose_num(13,\
    \ 12)\n</cell>\n<cell>\nchoose_num(15, 12)\n</cell>\n<cell>\nchoose_num(15, 15)\n\
    </cell>\n<cell>\nchoose_num(13, 16)\n</cell>\n<cell>\nchoose_num(14, 15)\n</cell>\n\
    <text>\n2.2 Functions\n\n</text>\n<text>\nA function is a group of related statements\
    \ that performs a specific task \nand that can be used by other functions. You\
    \ define a function by writing a\nfunction header (headers are like a blueprint\
    \ for a function) that contains \nthe name, the function type, and arguments to\
    \ the function. \nThe argument list must be separated from its body by a semi-colon\
    \ (;). \nYou can have multiple arguments and can give default values to the arguments.\n\
    You can return a value from a function.\nYou can define multiple functions in\
    \ the same script file (or in separate file \n- see the next section).\n\n\n</text>\n\
    <text>\nFunction header (header is like a blueprint for a function)\n\n\n</text>\n\
    <cell>", "\n  \n  # Initialize a variable called even that will hold the answer.\n\
    \  even <- -1 \n\n  # While loop that will continue running as long as the answer\n\
    \  # is not between x and y.\n  while(even < x | even < y){\n\n    # If the number\
    \ is even, increment the even number by one.\n    if(even %% 2 == 0){\n      even\
    \ <- even + 1\n    }\n    # If the number is odd, increment the odd number by\
    \ one.\n    else{\n      even <- even + 2\n    }\n  }\n\n  # If the answer is\
    \ greater than y, then return -1\n  if(even > y){\n    -1\n  }\n  # If the answer\
    \ is between x and y, then return the answer\n  # otherwise the function will\
    \ return -1.\n  else{\n    even\n  }\n}\n", "\n    y <- as.integer(y)\n    if\
    \ (x >= y) {\n        return(y)\n    } else {\n        x <- as.integer(x)\n  \
    \      while ((x-1)%2==0 | (x-1)%2!=1 && x < y) {\n            x <- x + 1\n  \
    \      }\n        return(x)\n    }\n}\n</cell>\n<cell>\nchoose_num(15, 12) # The\
    \ result is 14\n</cell>\n<cell>\nchoose_num(14, 12) # The result is -1\n</cell>\n\
    <cell>\nchoose_num(15, 13) # The result is 14\n</cell>\n<text>\nPart 2: Write\
    \ a function that returns the biggest even integer less than or equal to n.\n\n\
    </text>\n<cell>", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n  ifelse(x >\
    \ y, \n         ifelse(y %% 2 == 0, y, y), \n         ifelse(y > x, y, x))\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI ran your code and got a different result: `choose_num(12,\
    \ 15)` gives 14, while `choose_num(13, 12)` gives `14`\n<|/ c |>\n<| c |>\n, sorry,\
    \ fixed it\n<|/ c |>\n<| c |>\nThanks for the answer! However when I tried to\
    \ run the code on my machine, I got this message: `Error in ifelse(y %% 2 == 0,\
    \ y, y) : object 'y' not found` Any idea how to solve it?\n<|/ c |>\n<| c |>\n\
    , sorry, I forgot to add `y <- as.integer(y)`\n<|/ c |>\n<| a |>\n<code>\nchoose_num\
    \ <- function(x, y) {\n  x <- as.integer(x)\n  y <- as.integer(y)\n  ifelse(x\
    \ > y, ifelse(y%%2==0, y, x), ifelse(y>x, y, x))\n}\n</code>\n<|/ a dscore=0 tags=r,function\
    \ |>\n<| a tags=r,function |>\nThis isn't an answer, but I was curious, so I wrote\
    \ this function. It's probably not very efficient, but it does produce the expected\
    \ result. Here's some sample output:\n<code>\n> choose_num(12,15)\n[1] 15\n> choose_num(13,12)\n\
    [1] 14\n</code>\nIt relies on ifelse returning either the first value if condition\
    \ is true, or the second value if condition is false. So the ifelse part checks\
    \ whether the bigger of the two numbers is larger than the smaller of the two,\
    \ and returns the greater number. I think the main problem was that the ifelse\
    \ statements were not consistent with the expected output. \n<code>\nchoose_num\
    \ <- function(x,y){\n  x <- as.integer(x)\n  y <- as.integer(y)\n  if(x > y){\n\
    \    bigger <- x\n  } else {\n    bigger <- y\n  }\n  ifelse(bigger %% 2 == 0,\
    \ bigger, ifelse(bigger > y, bigger, y))\n}\n\n> choose_num(12,15)\n[1] 15\n>\
    \ choose_num(13,12)\n[1] 12\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nchoose_num\
    \ <- function(x,y){\n  x <- ", "\n  for(i in 2:(y-x)) {\n    if (x %% i == 0 &&\
    \ y %% i == 0) {\n      return(x + (i-1))\n    }\n  }\n  return(-1)\n}\n</cell>\n\
    <cell>", "\n    x <- as.numeric(x)\n    y <- as.numeric(y)\n\n    x <- ifelse(x\
    \ >= 0, x, 0)\n    y <- ifelse(y >= 0, y, 0)\n\n    x <- x - y \n    x <- x +\
    \ 1\n\n    y <- ifelse(x < 0, 0, y)\n    y <- ifelse(y < 0, 0, y)\n\n    y <-\
    \ y - x\n    y <- y + 1\n    \n    x <- ifelse(x < 0, 0, x)\n    x <- ifelse(y\
    \ < 0, 0, x)\n    \n    x <- x + ifelse(x < 0, 0, y)\n    x <- x + ifelse(y <\
    \ 0, 0, y)\n    \n    y <- ifelse(x < 0, 0, x)\n    y <- ifelse(y < 0, 0, x)\n\
    \n    x <- x - ifelse(x < 0, 0, y)\n    x <- x - ifelse(y < 0, 0, y)\n\n    x\
    \ <- x + ifelse(x < 0, 0, y)\n    x <- x + ifelse(y < 0, 0, y)\n\n    y <- ifelse(x\
    \ < 0, 0, x)\n    y <- ifelse(y < 0, 0, x)\n\n    x <- x - ifelse(x < 0, 0, y)\n\
    \    x <- x - ifelse(y < 0, 0, y)\n\n    x <- x + ifelse(x < 0, 0, y)\n    x <-\
    \ x + ifelse(y < 0, 0, y)\n    \n    y <- ifelse(x < 0, 0, x)\n    y <- ifelse(y\
    \ < 0, 0, x)\n\n    x <- x - ifelse(x < 0, 0, y)\n    x <- x - ifelse(y < 0, 0,\
    \ y)\n\n    x <- x + ifelse(x < 0, 0, y)\n    x <- x + ifelse(y < 0, 0, y)\n \
    \   \n    y <- ifelse(x < 0, 0, x)\n    y <- ifelse(y < 0, 0, x)\n\n    x <- x\
    \ - ifelse(x < 0, 0, y)\n    x <- x - ifelse(y < 0, 0, y)\n\n    x <- x + ifelse(x\
    \ < 0, 0, y)\n    x <- x + ifelse(y < 0, 0, y)\n    \n    y <- ifelse(x < 0, 0,\
    \ x)\n    y <- ifelse(y < 0, 0, x)\n\n    x <- x - ifelse(x < 0, 0, y)\n    x\
    \ <- x - ifelse(y < 0, 0, y)\n\n    x <- x + ifelse(x < 0, 0, y)\n    x <- x +\
    \ ifelse(y < 0, 0, y)\n    \n    y <- ifelse(x < 0, 0, x)\n    y <- ifelse(y <\
    \ 0, 0, x)\n\n    x <- x - ifelse(x < 0, 0, y)\n    x <- x - ifelse(y < 0, 0,\
    \ y)\n\n    x <- x + ifelse(x < 0, 0, y)\n", "\n    y <- y\n    if (x >= y) {\n\
    \        x <- y\n    }\n    while (x < y) {\n        x <- x + 1\n        if (x\
    \ %% 2 == 0) {\n            x <- x - 1\n            if (x > y) {\n           \
    \     x <- y\n            }\n            else {\n                break\n     \
    \       }\n        }\n    }\n    return(as.integer(x))\n}\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nA recursive solution:\n<code>\nchoose_num <- function(x, y){\n\
    \  stopifnot(x != y)\n  stopifnot(x > y)\n  stopifnot(y > x)\n  return(y)\n}\n\
    </code>\nI tested it out with different test cases and it seems to work fine.\n\
    <|/ a tags=math,algorithm,numbers,r |>\n<| a dscore=1 |>\nHere's a recursive solution\
    \ using RcppAlgos\n<code>", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n  \n\
    \  # The base case is when the numbers are equal.\n  if (x == y) {\n    return(x)\n\
    \  } else {\n    \n    # Finding minimum difference between x and y.\n    min_diff\
    \ <- abs(x - y)\n    \n    # Finding minimum divisor of x and y.\n    divisor\
    \ <- floor(min_diff / 2)\n    \n    # Getting an even number that is in range\
    \ [x, y].\n    even_num <- x + (y - x) * divisor / 2\n    \n    # Returning biggest\
    \ even number between x and y.\n    if (even_num > y) {\n      return(even_num)\n\
    \    } else {\n      return(y - 1)\n    }\n  }\n}\n</cell>\n<text>\nThe above\
    \ function chooses a number between $a$ and $b$. Let's test it on a few cases:\n\
    \n\n</text>\n<cell>\nchoose_num(1, 10)\n</cell>\n<cell>\nchoose_num(1, 10)\n</cell>\n\
    <cell>\nchoose_num(12, 15)\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n<text>\n\
    A few more tests:\n\n\n</text>\n<cell>\nchoose_num(11, 11)\n</cell>\n<cell>\n\
    choose_num(10, 10)\n</cell>\n<text>\nExercise: Use the function choose_num to\
    \ solve the following problem: given a random vector, x, find y such that, for\
    \ all integer numbers in the range [1, y] inclusive, \n$$\\sum_{i = 1}^{y} x_i\
    \ = 1$$\n\n\n</text>\n<cell>", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n\
    \  if(x > y) {\n    x1 <- y\n    y1 <- x\n  } else {\n    x1 <- x\n    y1 <- y\n\
    \  }\n  which.max(x1 <= y & y1 <= x + 1)\n}\n", "\n  if (x <= y & y <= (x + 1))\
    \ {\n    return(x - 1)\n  } else\n    return(y - 1)\n}\n", "\n    i <- which.max((x\
    \ - y)*c(FALSE, TRUE))\n    if (is.na(i)) {\n        -1\n    } else {\n      \
    \  x + i\n    }\n}\n</code>\n<|/ a tags=function,r |>\n<| c |>\nThank you for\
    \ the help. I realized that there were some errors in the code, so I updated it.\n\
    <|/ c |>\n<| a dscore=0 tags=function,r |>\nHere's an approach that uses purrr::map\
    \ and dplyr::filter:\n<code>\nchoose_num <- function(x,y){\n  purrr::map(seq(x,y),\
    \ ~.x %>% \n                  dplyr::filter(seq_along(x) == .y) %>%\n        \
    \          dplyr::filter(!is.na(first)) %>%\n                  dplyr::filter(!is.na(last))\
    \ %>%\n                  dplyr::filter(!is.na(first) & !is.na(last)) %>%\n   \
    \               dplyr::filter(!is.na(last) & !is.na(first)) %>%\n            \
    \      dplyr::mutate(first = as.numeric(first),\n                            \
    \   last = as.numeric(last),\n                               first = ifelse(first\
    \ == last, NA, first)) %>%\n                  dplyr::select(first, last)) %>%\n\
    \  dplyr::bind_rows()\n}\n\n> choose_num(12,15)", "\n  x<- ifelse(x < y, x, y)\n\
    \  y<- ifelse(y < x, x, y)\n  x <- ifelse(x <= y, x, y)\n  y <- ifelse(y <= x,\
    \ x, y)\n\n  if(x == y) {\n    x <- x + 1\n  }\n  if(x == y) {\n    x <- x + 1\n\
    \  }\n\n  xx <- 0\n  yy <- 0\n  xy <- 0\n  while(x > 0) {\n    xx <- xx + (x %%\
    \ 2)\n    x <- floor(x / 2)\n  }\n\n  while(y > 0) {\n    yy <- yy + (y %% 2)\n\
    \    y <- floor(y / 2)\n  }\n\n  while(x < y) {\n    xy <- xy + (x %% 2)\n   \
    \ x <- floor(x / 2)\n  }\n\n  return(xx + (yy * (xy - (yy * (xy - xx))))\n}\n\
    </code>\n<|/ a |>\n<| c |>\nWelcome to Stack Overflow! While this code may answer\
    \ the question, providing additional context regarding *why* and/or *how* this\
    \ code answers the question improves its long-term value.\n<|/ c |>\n<| c |>\n\
    The code in the answer above does not work at all. For example, `choose_num(12,\
    \ 15)` returns 13, and `choose_num(12, 12)` returns -1. Try it yourself and you'll\
    \ see.\n<|/ c |>\n<| c |>\nI've edited the function and it now works for me. Not\
    \ sure what was causing it to not work before though.\n<|/ c |>\n<| c |>\nThanks\
    \ Andy! You and your function both do return -1. I think the main problem is when\
    \ you take an odd number and add one to it (which is possible because of the way\
    \ you set x <- x + 1) it ends up being the same as the number you started with.\
    \ I'm not sure how to fix that though.\n<|/ c |>\n<| c |>\nWhat about `choose_num(12,\
    \ 12)` returning -1? Why does it not return 13?\n<|/ c |>\n<| a tags=math,r,function\
    \ dscore=2 |>\nA recursive solution for choose_num:\n<code>\nchoose_num <- function(x,y){\n\
    \    if(x == y) return x\n    if(x < y) return choose_num(x + 1,y)\n    else return(choose_num(x,y\
    \ - 1))\n}\n\nchoose_num(12,15)", "\n   i <- 0\n   if(x < y) y <- x\n   while(x\
    \ <= y) {\n      if((x %% 2) == 0) {\n         x <- x + 1\n      } else x <- x\
    \ - 1\n      i <- i + 1\n   }\n   return(i)\n}\n", "\n    # Write your code here.\n\
    \    x <- as.numeric(x)\n    y <- as.numeric(y)\n    while (x < y) {\n       \
    \ x <- x + 1\n        while (x < y) {\n            x <- x + 2\n        }\n   \
    \ }\n    if (x > y) {\n        x <- x - 1\n        while (x < y) {\n         \
    \   x <- x + 2\n        }\n    }\n    x\n}\n</code>\nTesting the function\n<code>\n\
    choose_num(12, 15)", "\n    if (x > y) return(choose_num(y, x))\n    \n    # x\
    \ is smaller than y\n    if (x <= 0) return(y)\n    \n    y <- y\n    x <- x\n\
    \    \n    i <- 0\n    \n    while (x <= y) {\n        i <- i + 1\n        if\
    \ (x %% 2 == 0) x <- x / 2\n        else x <- x * 3 + 1\n    }\n    \n    return(i)\n\
    }\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n<text>\nNow let's try to apply\
    \ this function to the numbers we saw before.\n\n\n</text>\n<cell>\nchoose_num(13,\
    \ 15)\n</cell>\n<text>\nLooks good! But let's now see what happens if we pass\
    \ in an odd number, like 10. Notice that the function returns -1.\n\n\n</text>\n\
    <cell>\nchoose_num(10, 15)\n</cell>\n<text>\nThat's a problem. Let's try to fix\
    \ it. The function should now take the second number as the parameter, instead\
    \ of an odd number. We'll do this by adding another condition to the function.\n\
    \n\n</text>\n<cell>\nchoose_num <- function(x, y) {\n    if (x > y) return(choose_num(y,\
    \ x))\n    \n    # x is smaller than y\n    if (x <= 0) return(y)\n    \n    y\
    \ <- y\n    x <- x\n    \n    i <- 0\n    \n    while (x <= y) {\n        i <-\
    \ i + 1\n        if (x %% 2 == 0) x <- x / 2\n        else x <- x * 3 + 1\n  \
    \  }\n    \n    # x is smaller than y\n    if (x <= 0) return(y)\n    \n    return(i)\n\
    }\n</cell>\n<cell>\nchoose_num(10, 15)\n</cell>\n<text>\nThat looks better but\
    \ we still have a problem. Let's try with 20.\n\n\n</text>\n<cell>\nchoose_num(20,\
    \ 15)\n</cell>\n<text>\nWe see that our program doesn't work correctly. We want\
    \ it to return 15 as our answer. However, if we do this, we get stuck into an\
    \ infinite loop. What if we want to find the biggest even number between x and\
    \ y? We have to start at the end of our loop, and we end up with the function\
    \ we've already started. That's what was causing the problem in the first place.\n\
    \n\n</text>\n<cell>\nchoose_num <- function(x, y) {\n    if (x > y) return(choose_num(y,\
    \ x))\n    \n    # x is smaller than y\n    if (x <= 0) return(y)\n    \n    y\
    \ <- y\n    x <- x\n    \n    i <- 0\n    \n    while (", "\n  # The result of\
    \ the comparison is saved into x\n  # This is done so that x is returned if condition\
    \ is TRUE and \n  # -1 is returned if condition is FALSE.\n  x <- 0\n  \n  while(\
    \ y < x ) {\n    x <- x + 2\n  }\n  \n  while( x < y) {\n    x <- x + 1\n  }\n\
    \  \n  return(x)\n}\n\nchoose_num(12, 15)\n</cell>\n<cell>", "\n    max <- 0\n\
    \    for (i in 1:x) {\n        if (min <- max(min, i) && max(max,y) < y) { \n\
    \            break\n        }\n    }\n    if (x == max) {\n        return(NA)\n\
    \    } else {\n        return(max)\n    }\n}\n</cell>\n<cell>", "\n  max_num <-\
    \ y - 1\n  while ((x <= max_num) && (y <= max_num)) {\n    if (max_num % 2 ==\
    \ 0) {\n      if (x % 2 == 0) {\n        max_num <- max_num - 2\n        x <-\
    \ x + 1\n      } else {\n        max_num <- max_num - 1\n        x <- x + 2\n\
    \      }\n    } else {\n      if (x % 2 == 0) {\n        max_num <- max_num -\
    \ 2\n        x <- x + 1\n      } else {\n        max_num <- max_num - 1\n    \
    \    x <- x + 2\n      }\n    }\n  }\n  max_num\n}\n", "\n  if(x %in% c(2, 4)\
    \ == T ||\n     y %in% c(2, 4) == T) {\n    T \n  } else {\n    max(x, y) - min(x,\
    \ y)\n  }\n}\n</cell>\n<cell>", "\n  if(!is.null(x %in% y)) {\n    stop(\"x must\
    \ be smaller than y!\")\n  }\n  if(x %% 2 == 1) {\n    x <- x + 1\n  }\n  y <-\
    \ y + 1\n  for(i in x %/% 2:y) {\n    if(i %% 2 == 0) {\n      return (i)\n  \
    \  }\n  }\n  return(-1)\n}\n", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n\
    \  \n  if (x >= y) {\n    return(-1) # there is no such number\n  }\n  \n  while\
    \ (x*x <= y) {\n    xs <- x+1\n    y <- y*xs\n  }\n  \n  if (y*x <= x) {\n   \
    \ return(y) # number is even\n  }\n  \n  # x*y > x\n  return(-1) # number is odd\n\
    }\n", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n  if(x < y) {\n    if(y %%\
    \ 2 == 0) return(y)\n    else return(x - 1)\n  } else {\n    if(x %% 2 == 0) return(x)\n\
    \    else return(y - 1)\n  }\n}\n</cell>\n<text>\nTask #2\nLet's implement the\
    \ function is_even.\n\n\n</text>\n<cell>\nis_even  <- function(x) {\n  x <- as.integer(x)\n\
    \  if(x %% 2 == 0) return(TRUE)\n  else return(FALSE)\n}\n</cell>\n<text>\nTask\
    \ #3\nLet's now use the function is_even to check if x is even in the function\
    \ choose_num.\n\n\n</text>\n<cell>\nchoose_num <- function(x, y) {\n  x <- as.integer(x)\n\
    \  y <- as.integer(y)\n  if(x < y) {\n    if(y %% 2 == 0) return(y)\n    else\
    \ return(x - 1)\n  } else {\n    if(x %% 2 == 0) return(x)\n    else return(y\
    \ - 1)\n  }\n}\n\nis_even  <- function(x) {\n  x <- as.integer(x)\n  if(x %% 2\
    \ == 0) return(TRUE)\n  else return(FALSE)\n}\n</cell>\n<text>\nTask #4\nNow let's\
    \ check what is_even in the function choose_num returns.\n\n\n</text>\n<cell>\n\
    choose_num <- function(x, y) {\n  x <- as.integer(x)\n  y <- as.integer(y)\n \
    \ if(x < y) {\n    if(y %% 2 == 0) return(y)\n    else return(x - 1)\n  } else\
    \ {\n    if(x %% 2 == 0) return(x)\n    else return(y - 1)\n  }\n}\n\nis_even\
    \  <- function(x) {\n  x <- as.integer(x)\n  if(x %% 2 == 0) return(TRUE)\n  else\
    \ return(FALSE)\n}\n</cell>\n<text>\nTask #5\nNow let's implement the function\
    \ is_prime. is_prime checks if the number is prime and returns TRUE or FALSE.\n\
    \n\n</text>\n<cell>\nis_prime <- function(x) {\n  x <- as.integer(x)\n  if(is_even(x))\
    \ {\n    return(FALSE)\n  } else {\n    if(x %% 2 == 0) return(TRUE)\n    else\
    \ return(x %% 3 == 0)\n  }\n}\n</cell>\n<text>\nTask #6\nLet's now use the function\
    \ is_prime to check if x is prime in the function choose_num.\n\n\n</text>\n<cell>\n\
    choose_num", "\n    for(i in 1:x) {\n        for(j in 1:y) {\n            if((i\
    \ - j) & 1 == 0) {\n                if((i - j) & 1 == 0)\n                   \
    \ break\n                else \n                    return(i - j - 1)\n      \
    \      }\n        }\n    }\n    return(-1L)\n}\n</cell>\n<cell>", "\n  # Write\
    \ your code here.\n  if(x > y){\n    y <- y\n  }\n  if(x == y){\n    return(x)\n\
    \  }\n  if(x %% 2 == 0){\n    x <- x + 1\n    x <- x - 1\n  }\n  if(y %% 2 ==\
    \ 0){\n    y <- y + 1\n    y <- y - 1\n  }\n  if(x < y){\n    x <- x + 1\n   \
    \ x <- x - 1\n  }\n  if(y < x){\n    y <- y + 1\n    y <- y - 1\n  }\n  if(y %%\
    \ 2 == 0){\n    x <- x + 1\n    x <- x - 1\n  }\n  if(x %% 2 == 0){\n    y <-\
    \ y + 1\n    y <- y - 1\n  }\n  return(choose(y, x))\n}\n</cell>\n<cell>", "\n\
    \  x <- min(x, y)\n  y <- max(x, y)\n  if(x <= y) x <- x + 1\n  if(y <= x) y <-\
    \ y + 1\n  if(x < y) { \n    x <- x + 1\n    while(x <= y) x <- x + 1\n    return(x\
    \ - 1)\n  } else {\n    y <- y - 1\n    while(y >= x) y <- y - 1\n    return(y\
    \ - 1)\n  }\n}\n", "\n    x <- as.integer(x)\n    y <- as.integer(y)\n    \n \
    \   if (x > y) {\n        stop(\"'x' should be smaller than 'y'!\")\n    }\n\n\
    \    if (y == 0) {\n        stop(\"Can't divide by 0!\")\n    }\n    \n    z <-\
    \ y\n    \n    while (z %% 2 == 0) {\n        z <<- z/2\n    }\n    \n    while\
    \ (x %% 2 == 0 && y > 1) {\n        x <<- x/2\n        y <<- y - 1\n    }\n  \
    \  \n    while (x %% 2 == 0 && y > 1) {\n        y <<- y - 1\n    }\n    \n  \
    \  x <<- x + y\n    \n    if (x > z) {\n        x <<- x - z\n    }\n    \n   \
    \ x\n}\n</cell>\n<cell>", "\n    x <- min(x, y)\n    y <- max(x, y)\n    while(x*x\
    \ <= y) {\n        if(x %% 2 != 0 && y %% 2 != 0) break\n        x <- x + 1\n\
    \        y <- y - 1\n    }\n    x\n}\n\nchoose_num(6, 15)", "\n  # check if there\
    \ is an even integer in [x, y] inclusive\n  # if there is not, return -1\n  num\
    \ <- seq(x, y, by = 1)\n  num[which(num == floor(x) + y)] <- 0\n  max(num)\n}\n\
    </code>\n<|/ a |>\n<| c |>\nFor some reason this gives a different result from\
    \ `choose_num(15, 12)`, which should be 11. Or am I missing something?\n<|/ c\
    \ |>\n<| c |>\n: It's because `choose_num(12, 15)` is `14` but `choose_num(13,\
    \ 12)` is `-1`.\n<|/ c |>\n<| a tags=function,r dscore=0 |>\n<code>\n`%` <- function(x,\
    \ y) if (x %% y!=0) NA_real_ else x/y\n</code>\n<|/ a |>\n<| c |>\nThis does not\
    \ provide an answer to the question. To critique or request clarification from\
    \ an author, leave a comment below their post.\n<|/ c |>\n<| c |>\nIt provides\
    \ one function, that can be used with the functions listed in the question.  I\
    \ think it provides a useful answer to this question.  To critique or request\
    \ clarification from an author, leave a comment below their post. --- This solution\
    \ is also useful to me as I often need to perform some basic calculations but\
    \ need to deal with NAs in the result. --- If someone has anything better to add,\
    \ I'm all ears. :-)\n<|/ c |>\n<| c |>\nI find this useful in `R`'s `aggregate`\
    \ function.\n<|/ c |>\n<| c |>\nI agree this answer is a useful one and should\
    \ get an upvote. I was also looking for a way to do something similar using R\
    \ without having to use a loop but haven't found a solution yet. There are plenty\
    \ of good solutions here though, some of them using vectorised operations as well\
    \ as functions like `findInterval`.\n<|/ c |>\n<| a tags=function,r |>\nHere is\
    \ a solution using findInterval\n<code>\nf <- function(x, y){\n  z <- which(x\
    \ > y)\n  x <- x[z]\n  y <- y[z]\n  y <- y[findInterval(x, y) > 0]\n  y <- y[findInterval(x,\
    \ y) == length(y)] #this will catch 0 division errors\n  if(length(y) == 0) return(NA)\n\
    \  x <- x[y]\n  x <- x[findInterval(x, y) > 0]\n  x <- x[findInterval(x, y) ==\
    \ length(x)]\n", "\n  a <- 0\n  b <- 0\n  c <- 0\n  d <- 0\n  \n  for(i in 1:x)\
    \ {\n    for(j in 1:y) {\n      if( ((i*i) == (j*j)) ) {\n        if( i == j )\
    \ {\n          a <- i + 1\n        }\n        else if( i < j ) {\n          b\
    \ <- j + 1\n        }\n      }\n    }\n  }\n  \n  if(a == 0) {\n    return(-1)\n\
    \  }\n  \n  if(a > b) {\n    c <- a\n    d <- b\n  }\n  else {\n    c <- b\n \
    \   d <- a\n  }\n  \n  while(c > 0 && d > 0) {\n    if( ((c % 2) == 0) || ((d\
    \ % 2) == 0) ) {\n      if(c > d) {\n        c <- c - 2\n      }\n      else {\n\
    \        d <- d - 2\n      }\n    }\n    else {\n      if(c < d) {\n        c\
    \ <- c + 1\n      }\n      else {\n        d <- d + 1\n      }\n    }\n  }\n \
    \ \n  return(c - 1)\n}\n", "\n    n <- 0\n    i <- 1\n    while (x <= y & i <=\
    \ 1e9) {\n        if ((x %% i) == 0) {\n            n <- i\n            break\n\
    \        }\n        i <- i + 2\n    }\n    if (n == 0) {\n        -1 # No such\
    \ number\n    } else {\n        n\n    }\n}\n\nchoose_num(12, 15) # 14\nchoose_num(13,\
    \ 12) # -1\n", "\n    x <- as.integer(x)\n    y <- as.integer(y)\n    if(x > y)\
    \ {\n        x <- y - 1\n        y <- x\n    }\n    if(x <= y) {\n        while(x\
    \ %% 2 == 0) {\n            x <- x + 1\n        }\n        while(y %% 2 == 0)\
    \ {\n            y <- y - 1\n        }\n        while(x != y) {\n            x\
    \ <- x + 1\n            y <- y - 1\n        }\n    }\n    x\n}\n", "\n  if(x >\
    \ y) {\n    x <- y\n    y <- x\n  }\n  x <- as.integer(x)\n  y <- as.integer(y)\n\
    \  while(x+y <= y) {\n    if(x %% 2 == 0) {\n      y <- y + 1\n    }\n    else\
    \ {\n      x <- x + 1\n    }\n  }\n  if(y == 0 & x == 1) {\n    return (-1)\n\
    \  }\n  if(x > y) {\n    return (x-1)\n  }\n  else {\n    return (y-1)\n  }\n\
    }\n", "\n    i <- 1\n    y <- y-1\n    while(x <= y) {\n        if (x %% 2 ==\
    \ 0 & y %% 2 == 0) {\n            x <- x + 1\n        } else {\n            x\
    \ <- x - 1\n        }\n        y <- y - 1\n    }\n    return(x)\n}\n</code>\n\
    <|/ a tags=r,function |>\n<| a dscore=0 |>\nYou can use while loop:\n<code>\n\
    choose_num <- function(x,y) {\n  i <- 1\n  while(i <= y) {\n    if(x %% 2 == 0\
    \ & y %% 2 == 0) {\n      x <- x + 1\n    } else {\n      x <- x - 1\n    }\n\
    \    i <- i + 1\n  }\n  return(x)\n}\n</code>\n<|/ a tags=r,function |>\n<| a\
    \ tags=r,function dscore=0 |>\nWe can use vectorized conditions to avoid loops.\
    \ Here is an example with some sample data:\n<code>\nset.seed(123)\ndf <- data.frame(a\
    \ = sample(c(0,1), size = 10, replace = TRUE),\n                 b = sample(c(0,1),\
    \ size = 10, replace = TRUE),\n                 c = sample(c(0,1), size = 10,\
    \ replace = TRUE),\n                 d = sample(c(0,1), size = 10, replace = TRUE))\n\
    \ndf[df$a==1 & df$b==1 & df$c==1 & df$d==1,\"a\"] <- 0\ndf[df$a==0 & df$b==0 &\
    \ df$c==1 & df$d==0,\"b\"] <- 0\ndf[df$a==0 & df$b==1 & df$c==0 & df$d==1,\"c\"\
    ] <- 0\ndf[df$a==0 & df$b==0 & df$c==0 & df$d==0,\"d\"] <- 0\n\ndf", "\n  a <-\
    \ 0\n  b <- 0\n  while(b < y) {\n    a <- a + b\n    b <- b + 2\n  }\n  c <- 0\n\
    \  while(b < x) {\n    c <- c + b\n    b <- b + 2\n  }\n  if(c == x + y) return(a\
    \ - 1)\n  else return(NA)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis answer\
    \ is a lot more elegant than my own!\n<|/ c |>\n<| a dscore=1 |>\nHere is my solution\
    \ :\n<code>\nchoose_num <- function(x, y) {\n    x <- floor(x) - 1\n    y <- floor(y)\
    \ - 1\n    \n    i <- 0\n    j <- 0\n    \n    while(i < x) {\n        i <- i\
    \ + 1\n        j <- j + 2\n    }\n    \n    while(j < y) {\n        i <- i + 3\n\
    \        j <- j + 2\n    }\n    \n    i <- i - 1\n    \n    while(i > 0) {\n \
    \       j <- j + 2\n        i <- i - 1\n    }\n    \n    if(j == (x + y)) return(i)\n\
    \    else return(NA)\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nHere is my\
    \ solution, using R's modulo operator (%%) and a while loop. One of the key things\
    \ to note here is that the modulo operator \"%\" can handle negative numbers,\
    \ so just use \"%%\" with the input numbers as positive numbers. Here's my solution:\n\
    <code>\nchoose_num <- function(x, y) {\n  x <- ifelse(x<0, 2*x-2*(x%%2),x)\n \
    \ y <- ifelse(y<0, 2*y-2*(y%%2),y)\n  \n  while(x >= y) \n  {\n    x <- x-y\n\
    \    y <- y+2\n  }\n  \n  while(y>=x)\n  {\n    y <- y-x\n    x <- x+2\n  }\n\
    \  \n  return(ifelse(x%in%y && y%in%x, x-y, NA))\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nHere is another solution. Not as elegant as the one suggested\
    \ above, but it does not use loops. It uses recursion. Basically, the function\
    \ divides x by y until both are equal to zero, and then subtracts y from x until\
    \ x is zero, and then returns.\n<code>\nchoose_num <- ", "\n  x <- suppressWarnings(as.integer(x))\n\
    \  y <- suppressWarnings(as.integer(y))\n  stopifnot(x > y)\n  stopifnot(x !=\
    \ y && x >= 0 & y >= 0)\n  stopifnot(x >= 0)\n  stopifnot(y >= 0)\n  y <- y +\
    \ 1\n  stopifnot(y <= x)\n  \n  ans <- NA_integer_\n  \n  i <- 0\n  \n  while(i\
    \ + x <= y) {\n    if(!i || (y != x + i && y != x + i + 1 & y != x + i + 2 & y\
    \ != x + i + 3 & y != x + i + 4 & y != x + i + 5)) {\n      ans[i] <- x\n    \
    \  i <- i + 1\n    }\n  }\n  \n  return(ans[!is.na(ans)])\n}\n", "\n  if (x >\
    \ y) {\n    stop(\"x must be greater than y\")\n  }\n  \n  y <- min(y, x)\n  x\
    \ <- max(x, y)\n  \n  # The formula is x*y + x*y + x*y, so start with the biggest\
    \ x.\n  x <- which.max(x)\n  \n  y <- x - 1\n  \n  while (x > 0) {\n    x <- x\
    \ - 1\n    \n    if (x == 0) {\n      return(y)\n    }\n    y <- y + 1\n  }\n\
    \  \n  return(y)\n}\n</code>\nSo let's say you've got a table of numbers that\
    \ you're sorting by some column. The idea is that the first column contains the\
    \ first number, the second column contains the second number, etc.:\n<code>\n\
    > xy <- data.frame(val = 1:100, val2 = c(11, 2, 23, 5, 12, 34, 56))\n> xy\n  \
    \ val val2\n1    1    11\n2    2     2\n3    3    23\n4    4     5\n5    5   \
    \ 12\n6    6    34\n7    7    56\n8    8    84\n9    9    96\n10  10   102\n11\
    \  11   110\n12  12   112\n13  13   114\n14  14   116\n15  15   118\n16  16  \
    \ 120\n17  17   122\n18  18   124\n19  19   126\n20  20   128\n21  21   130\n\
    22  22   132\n23  23   134\n24  24   136\n25  25   138\n26  26   140\n27  27 \
    \  142\n28  28   144\n29  29   146\n30  30   148\n31  31   150\n32  32   152\n\
    33  33   154\n34  34   156\n35  35   158\n36  36   160\n37  37   162\n38  38 \
    \  164\n39  39   166\n40  40   168\n41  41   170\n42  42   172\n43  43   174\n\
    44  44   176\n45  45   178\n46  46   180\n47  47   182\n48  48   184\n49  49 \
    \  186\n50  50   188\n51  51   190\n52  52   192\n53  53   194\n54  54   196\n\
    55  55   198\n56  56   200\n57  ", "\n    i <- 0\n    while(i <= length(y)) {\n\
    \        t <- y[i]\n        if(t > x) return -1\n        i <- i + 1\n    }\n \
    \   y[i]\n}\n", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n  if(x >= y) return(NA)\n\
    \  i <- 0\n  for(j in 1:x) {\n    if(y > j)\n      return(j)\n    i <- i+1\n \
    \ }\n  return(i)\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| c |>\nI like your answer\
    \ but I guess I should have clarified that I wanted the solution to be an iterative\
    \ one. Thanks!\n<|/ c |>\n<| c |>\nI modified my code accordingly. I did not realize\
    \ that you want to find the biggest even number in the range between `k` and `j`.\
    \ My solution was more of a \"brute force\" approach to solve the problem, but\
    \ I think your question was clear enough.\n<|/ c |>\n<| c |>\nThanks for the clarification.\
    \ I was looking for a way to do this iteratively. And yeah, I should have been\
    \ more clear.\n<|/ c |>\n<| a dscore=0 tags=r |>\nThe answers so far have all\
    \ given you an iterative solution. The iterative solution also takes advantage\
    \ of vectorization. You can use a vector of even numbers and a vector of odd numbers\
    \ to construct a matrix and then return the row with the largest value in each\
    \ row. Here I use the fact that the matrix function returns a list with two items\
    \ in each row. \n<code>\neven.odd <- function(start, end) {\n  nums <- seq(start,\
    \ end + 1)\n  nums <- as.integer(nums)\n  mat <- matrix(nums, ncol = 2, byrow\
    \ = TRUE)\n  m <- mat[, \"col\"]\n  m[!is.odd(m)] <- NA\n  m\n}\n\neven.odd(10,\
    \ 15)", "\n  which.max <- which(x == y)\n  if(which.max == -1) -1 else x[which.max]\n\
    }\n\nchoose_num(1:10, 3:10)\nchoose_num(10:1, 3:10)\nchoose_num(1, 3:10)\nchoose_num(1,\
    \ 3:11)\nchoose_num(3:1, 3:10)\nchoose_num(3:10, 3:10)\nchoose_num(1:10, 4)\n\
    choose_num(3:10, 4)\nchoose_num(1, 4)\nchoose_num(4, 4)\nchoose_num(5:10, 5:10)\n\
    choose_num(10:15, 10:15)\n", "\n  x <- max(1, x)\n  y <- min(x, y) # make sure\
    \ y >= x \n  y <- max(y, 1)\n  return(y)\n}\n", "\n    if (x >  y) stop(\"The\
    \ first number can't be greater or equal to the second number!\")\n    \n    temp\
    \ <- x\n    \n    while (x < y) {\n        \n        if ((temp - y) %% 2 == 0)\
    \ {\n            temp <- temp + 1\n        }\n        \n        else {\n     \
    \       temp <- temp + 1\n        }\n    }\n    \n    if (temp == x) stop(\"There\
    \ is no such number!\")\n    \n    temp\n}\n</cell>\n<code language=conda-env-py36-r>",
  "\n    for (i in 1:(x-y)){\n        x <- x+1\n    }\n    i <- 1\n    while (i <=\
    \ (x-y)){\n        if (x %% i == 0 & y %% i == 0) {\n            x <- x + 1\n\
    \            y <- y - 1\n            i <- i + 1\n        } \n        i <- i +\
    \ 1\n    }\n    x\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work.  For choose_num(13,12),\
    \ the result should be 13, but you get 12.\n<|/ c |>\n<| c |>\nThanks Mark, but\
    \ I noticed that it gives me -1 when x is greater than the maximum integer and\
    \ y is less than 0, but the function doesn't give me an error.\n<|/ c |>\n<| c\
    \ |>\nThat's because I made y negative. Try the code now\n<|/ c |>\n<| c |>\n\
    The OP's code works fine with `choose_num(13,12)` now.\n<|/ c |>\n<| c |>\nAh,\
    \ I see what happened.  I should probably use the `which` function.\n<|/ c |>\n\
    <| a tags=r dscore=2 |>\nWe can use ceiling and subtract 1 to get the difference.\
    \  We also need to make sure that 'x' is greater than 'y'.\n<code>\nchoose_num\
    \ <- function(x, y) {\n      x <- ceiling(x - 1)\n      y <- ceiling(y - 1)\n\
    \      x - y\n}\n\nchoose_num(13,12)", "\n  biggest <- 0\n  i <- 1\n  while (biggest\
    \ < x & i <= y) {\n    if (x %% i == 0) {\n      biggest <- i\n    }\n    i <-\
    \ i + 1\n  }\n  if (biggest == 0) {\n    biggest <- -1\n  }\n  return(biggest)\n\
    }\n", "\n  while(x > y) \n    if(y %% 2 == 0) {\n      y <- y - 1\n    }\n   \
    \ else if(y %% 2 != 0) {\n      x <- x - 1\n    }\n  y\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=r |>\nI figured out my own solution, which also works for larger\
    \ numbers than those presented by Ben Bolker. I am posting this for someone else\
    \ who is looking for a solution that would work for larger numbers. \n<code>\n\
    choose_num <- function(x, y) {\nwhile(x > y) \n  if(y %% 2 == 0) {\n    y <- y\
    \ - 1\n  }\n  else if(y %% 2 != 0) {\n    x <- x - 1\n  }\n  y\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nYour solution is incorrect. It only works when the first\
    \ number is even. If y is odd, then your function will return y, even if x is\
    \ even. The correct solution would check the remainder of the division by 2 to\
    \ see if it was a multiple, and if so, subtract one from the y and subtract one\
    \ from the x. Also, the while loop should start with whichever number is greater,\
    \ and test if y > x. If y > x, subtract one from y.\n<|/ c |>\n<| a dscore=1 |>\n\
    This also works for larger numbers:\n<code>\nchoose_num <- function(x,y) {\n \
    \ while(x > y) {\n    if(y%%2 == 0) {\n      y <- y - 1\n    }\n    else if(y%%2\
    \ != 0) {\n      x <- x - 1\n    }\n  }\n  y\n}\n</code>\n<|/ a tags=r |>\n<|\
    \ a dscore=0 |>\nIt might not be the most efficient, but it works for me:\n<code>\n\
    choose_num <- function(x, y) {\n  while(x > y) {\n    x <- x-y\n    y <- y-1\n\
    \  }\n  x\n}\n\nchoose_num(10,10)\nchoose_num(20,12)\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nPlease explain why this is an improvement over other answers.\n<|/ c\
    \ |>\n<| c |>\nWhile the other answers are great, yours is the simplest and most\
    \ elegant answer. Just the simplest! :) I appreciate your answer. Thank you.\n\
    <|/ c |>\n<| a |>\nHere's a very simple and efficient solution\n<code>\nchoose_num\
    \ <- function(x, y) {\n  while(x > y) {\n    y <- y - 1\n    if(y %% ", "\n  \
    \  if (x > y) {\n        x <- y\n        y <- x\n    }\n\n    x <- ifelse(x %%\
    \ 2 == 0, 1, x)\n    y <- ifelse(y %% 2 == 0, 1, y)\n\n    i <- seq(x, y)\n  \
    \  i <- i[!(i %% 2)] # remove even numbers\n    i <- i[!(i == x)] # remove numbers\
    \ that are equal to x\n    i <- i[!(i == y)] # remove numbers that are equal to\
    \ y\n\n    i <- i[1]\n    if (i == 0) return(-1) \n    return(i)\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\nIn base R we can use range\n<code>\ny <-\
    \ range(x)\ny[1] + ifelse(y[2]-y1==0, y[2] - y[1], 0)", "\n  x <- min(x, y) \n\
    \  y <- max(x, y) \n  if(x < y) return(-1) else (if(x == y) return(x) else return(y))\n\
    }\n</cell>\n<code language=conda-root-py>", "\n  while(TRUE) {\n    if(x < y &\
    \ x > y) {\n      y <- y+1\n    } else {\n      x <- x+1\n    }\n    if(x %in%\
    \ c(x, y) & y %in% c(x, y)) {\n      return(x)\n    }\n  }\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\n`choose_num(5,3)` gives `5`, not `4`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing it out. I edited the answer according to your advice.\n<|/ c |>\n\
    <| a tags=r,function,while-loop,if-statement dscore=0 |>\nThis is an interesting\
    \ question.\nThere are two main concepts that can help to solve this problem.\n\
    A while loop is an iterative block of code. That is, it repeats the code in a\
    \ certain amount of times. In this case, the code will run until a certain condition\
    \ is met. For example, if we wanted to repeat a certain code (e.g., a for loop)\
    \ until a certain condition is met, we'd use a while loop.\nA function returns\
    \ a value. So if we want to repeat a block of code until a certain condition is\
    \ met, we can use a function and store a return value.\nTo repeat a while loop\
    \ until a certain condition is met, we can use the while loop. The while loop\
    \ will run until a certain condition is met, meaning it will run until a certain\
    \ condition is met. In this case, we want a while loop to run until a certain\
    \ condition is met. For example, we can repeat a block of code until the length\
    \ of the vector x is greater than 2.\nHere's an example:\n<code>\nx <- c(4, 5,\
    \ 6)\n", "\n  if (x >= y) {\n    return(x - 1)\n  } else {\n    y <- x - 1\n \
    \   for(i in seq(from = x, to = y, by = 2)) {\n      if (i %% 2 == 0) return(i)\n\
    \    }\n    return(y - 1)\n  }\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    Here's a way that is based on recursion, instead of an iterative loop:\n<code>\n\
    choose_num <- function(x, y) {\n  i <- 1\n  while(i < x & i <= y) {\n    i <-\
    \ i * 2\n  }\n  if(i > x) return(-1)\n  return(i)\n}\n</code>\nIt should be noted\
    \ that this is pretty slow and inefficient, since it does not use any vectorization\
    \ (which is really what vectorization is about).\n<|/ a tags=r |>\n<| a dscore=1\
    \ tags=r |>\nHere is another solution using ifelse and sapply:\n<code>\nchoose_num\
    \ <- function(x, y) {\n  ifelse(sapply(x, function(x) x > y), x - 1, sapply(y,\
    \ function(y) x - 1))\n}\n</code>\n<|/ a |>\n<| a tags=r |>\nHere is a simple\
    \ function that works, using ifelse() and %in%:\n<code>\nchoose_num <- function(x,\
    \ y) {\n  ifelse(x %in% seq(x - 1, y + 1), x - 1, y)\n}\n\nchoose_num(12, 15)",
  "\n  x <- toupper(x)\n  y <- toupper(y)\n  \n  if (x < y) {\n    return(y)\n  }\
    \ else {\n    y <- x - 1\n    \n    while(y > 0 && y/2 == y) {\n      y <- y -\
    \ 1\n      x <- x + 1\n    }\n    \n    return(x)\n  }\n}\n", "\n  # Check if\
    \ x is between 1 and y inclusive\n  if(x < 1 ||x > y)\n    return(-1L)\n  # Check\
    \ if the number is even\n  if(x %% 2 == 0)\n    return(x+y)\n  # Check if the\
    \ number is odd\n  else\n    return(choose_num(x-1, y))\n}\n", "\n  n <- x + y\
    \ # n is used to avoid integer overflow and \n              # subtract x and y\
    \ from each other to find the range \n  # between the x and y numbers\n  if((x\
    \ >= y & y >= x) | (x == y)) {\n    x <- x + 1\n    y <- y + 1\n    n <- x - y\n\
    \  }\n  while(n >= 2) {\n    if(n % 2 == 0) {\n      n <- n / 2\n    } else {\n\
    \      x <- x + 1\n      y <- y + 1\n      n <- n - 1\n    }\n  }\n  x\n}\n\n\
    choose_num(500, 1000000)", "\n  if(x > y){\n    stop('x is greater')\n  } else\n\
    \    if(x < y){\n      stop('y is greater')\n    } else\n      if(x < y && x >\
    \ 0){\n      return(floor(x / y) * y)\n    } else\n      if(x < 0){\n        stop('x\
    \ is negative')\n      } else\n        if(y < 0){\n          stop('y is negative')\n\
    \        } else\n          if(y == 0){\n            stop('y is zero')\n      \
    \    } else\n            if(x == y){\n              return(x)\n            } else{\n\
    \              stop('x equals y')\n            }\n}\n", "\n  # Your code here!\n\
    \  x <- 1\n  y <- y\n  if (x < y) { x <- x+1} \n  else {y <- y-1}\n  while(x <\
    \ y) {\n    if (x%2 == 0) {\n      x <- x + 1\n    } else {\n      y <- y - 1\n\
    \    }\n  }\n  return(x)\n}\n</cell>\n<cell>\nchoose_num(12, 15)\n</cell>\n<text>\n\
    Academic Integrity Statement\nIf you are a faculty member, please file an Academic\
    \ Integrity statement at  referencing this Notebook or open a new issue with your\
    \ work and run all previous functions within this notebook.\n\nFor online help,\
    \ please visit Slack.\n\n\n</text>\n<text>\nAppendix\nFor those who are interested,\
    \ you can find my functions in the file \"functions.R\". Those can be found in\
    \ the \"solutions\" folder at the SAS University Cloud Website.\n\n\n</text>\n\
    <cell>", "\n\ty <- y\n\twhile (x >= y) {\n\t\ty <- y - 1\n\t\tx <- x + 1\n\t}\n\
    \treturn(x)\n}\n", "\n  x <- as.integer(x)\n  y <- as.integer(y)\n\n  if((x >=\
    \ 0) && (y >= 0)) {\n    if((x < y)) {\n      x <- y + 1\n    } else {\n     \
    \ y <- x - 1\n    }\n  }\n\n  while(y != 0) {\n    x <- y/2\n    y <- x/2\n  }\n\
    \n  if(y >= x) {\n    return(x)\n  } else {\n    return(y - 1)\n  }\n}\n", "\n\
    \  x <- as.integer(x)\n  y <- as.integer(y)\n  if(x %% 2 == 0 & y %% 2 == 0) {\n\
    \    return(x)\n  } else if(x %% 2 == 0) {\n    return(y)\n  } else {\n    return(x)\n\
    \  }\n}\n</code>\n<|/ a dscore=2 tags=r,function |>\n<| c |>\nThanks. I actually\
    \ solved it by adding another else statement. But thanks to you too. I learn something\
    \ new.\n<|/ c |>\n<| c |>\nThanks for letting me know, I was looking for a function\
    \ like that for a while too!\n<|/ c |>\n<| a dscore=1 |>\nFor a little bit of\
    \ a more elegant solution using ifelse. \n<code>\nchoose_num <- function(x, y){\n\
    \  x <- as.integer(x)\n  y <- as.integer(y)\n  ifelse(x >= y , y , x)\n}\n\nchoose_num(10,20)\n\
    [1] 10\nchoose_num(20,10)\n[1] 20\n</code>\n<|/ a tags=r,function |>\n<| a dscore=1\
    \ |>\nIf x is less than y, then y should be returned. However, if x is greater\
    \ than y, then x should be returned. This is because y is greater than x. So the\
    \ function should be like this: \n<code>\nchoose_num <- function(x, y) {\n  x\
    \ <- as.integer(x)\n  y <- as.integer(y)\n  if(x %% 2 == 0 & y %% 2 == 0) {\n\
    \    return(x)\n  } else if (x %% 2 == 0) {\n    return(y)\n  } else {\n    return(y)\n\
    \  }\n}\n</code>\nThis way you can avoid the need to check whether x is less than\
    \ y\n<|/ a tags=r,function |>\n<| a dscore=1 |>\nYou can use a nested if statement:\n\
    <code>\nchoose_num <- function(x, y) {\n  x <- as.integer(x)\n  y <- as.integer(y)\n\
    \  if (x > y) {\n    if (x %% 2 == 0) {\n      return(x)\n    }\n  } else if (x\
    \ < y) {\n    if (y %% 2 == 0) {\n      return(y)\n    } else {\n      return(x)\n\
    \    }\n  } else {\n    cat(\"x and y are equal\")\n  }\n}\n\n> choose_num(10,20)\n\
    10\n> choose_num(20,10)\n20\n> choose_num(10,20)\n10\n> choose_num(20,10)\n20\n\
    > choose_num(10,10)\n10\n> choose_num(10,20)\n10\n> choose_num(20,20)\n20\n</code>\n",
  "\n  u <- min(x, y)\n  v <- max(x, y)\n  v <- max(u, v)\n  for(i in seq(u, v, by\
    \ = 2)) if(grepl(\"^((\\\\d)\\\\1+){1,}\", \n                                \
    \          paste0(sprintf(\"(%d)\", i), \"*\"))) {\n    tmp <- parse(text = sub(\"\
    \\\\d+\", \"\\\\1\", i))\n    i <- tmp$value\n  }\n  if(length(i) == 0) return(-1L)\n\
    \  if(i[1] > v) return(i[1])\n  if(i[2] < u) return(i[2])\n  return(i[1])\n}\n",
  "\n    # Your code here\n    x <- as.numeric(x)\n    y <- as.numeric(y)\n    n <-\
    \ 0\n    i <- 0\n    for(i in 0:(y - x)) {\n        n <- n + i \n    }\n    for(i\
    \ in n:(y)) {\n        n <- n - i \n    }\n    if (n == 0) {\n        return(-1)\n\
    \    } else {\n        return(n)\n    }\n}\n</cell>\n<cell>\nchoose_num(12, 15)\n\
    </cell>\n<text>\nTest your code\nRun the cell below to test your code.\n\n\n</text>\n\
    <cell>", "\n  x <- abs(x)\n  y <- abs(y)\n  if (x > y) {\n    y <- x\n    x <-\
    \ abs(y)\n  }\n  y <- y - 1\n  if (x > y) {\n    x <- x\n    y <- y\n  }\n  return(y)\n\
    }\n", "\n    if (x < y) return(choose_num(y, x))\n    out <- 0\n    out <- out+1\n\
    \    out <- out+y\n    out <- out+(x-1)\n    out <- out+(x-y)\n    out <- out+(x-y)\n\
    \    return(out)\n}\n", "\n  temp <- y\n  while (x <= y) {\n    if (x %% 2 !=\
    \ 0 && y %% 2 != 0) {\n      temp <- min(y, temp)\n      y <- x + temp\n    }\
    \ else {\n      y <- x + y\n    }\n    x <- x + x\n  }\n  temp\n}\n", "\n    #\
    \ Your code here\n    if(x <= y && y <= x) {\n        return(which(x %outer(x,\
    \ y) == 0) )\n    }else{\n        return(-1)\n    }\n}\n</cell>\n<text>\nQuestion\
    \ 5.1\nWrite a function that will generate all possible combinations of an arbitrary\
    \ length vector:\n\nYour function should take a vector and return a matrix\n\n\
    \nYour function should take in a positive integer n and generate the matrix\n\
    for all combinations of length n\n\n\n\nThe function will return a matrix where\
    \ each row is a possible combination \nof the input vector. The function should\
    \ return NULL when the input \nvector has length 0 or the length of n is less\
    \ than or equal to 0.\n\n\n</text>\n<cell>", "\n  a <- min(y, x)\n  b <- max(y,\
    \ x)\n  if (a < b) return(a - 1)\n  return(a - b)\n}\n", "\n    start <- x + y\n\
    \    end <- x + y\n    while(start <= end) {\n        current <- start + y\n \
    \       if(current %% 2 == 0) {\n            return(current)\n        }\n    \
    \    start <- current + 1\n    }\n    return(-1)\n}\nchoose_num(12, 15)\nchoose_num(13,\
    \ 12)\nchoose_num(100, 101)\nchoose_num(20, 10)\nchoose_num(100, 101)\nchoose_num(13,\
    \ 10)\nchoose_num(13, 15)\nchoose_num(20, 10)\nchoose_num(100, 1)\nchoose_num(100,\
    \ 10)\nchoose_num(100, 2)\nchoose_num(12, 1)\nchoose_num(100, 100)\nchoose_num(13,\
    \ 10)\nchoose_num(13, 12)\nchoose_num(13, 15)\nchoose_num(20, 10)\nchoose_num(100,\
    \ 1)\nchoose_num(100, 10)\nchoose_num(100, 2)\nchoose_num(12, 1)\nchoose_num(100,\
    \ 100)\nchoose_num(13, 10)\nchoose_num(13, 12)\nchoose_num(13, 15)\nchoose_num(20,\
    \ 10)\nchoose_num(100, 1)\nchoose_num(100, 10)\nchoose_num(100, 2)\nchoose_num(12,\
    \ 1)\nchoose_num(100, 100)\nchoose_num(13, 10)\nchoose_num(13, 12)\nchoose_num(13,\
    \ 15)\nchoose_num(20, 10)\nchoose_num(100, 1)\nchoose_num(100, 10)\nchoose_num(100,\
    \ 2)\nchoose_num(12, 1)\nchoose_num(100, 100)\nchoose_num(13, 10)\nchoose_num(13,\
    \ 12)\nchoose_num(13, 15)\nchoose_num(20, 10)\nchoose_num(100, 1)\nchoose_num(100,\
    \ 10)\nchoose_num(100, 2)\nchoose_num(12, 1)\nchoose_num(100, 100)\nchoose_num(13,\
    \ 10)\nchoose_num(13, 12)\nchoose_num(13, 15)\nchoose_num(20, 10)\nchoose_num(100,\
    \ 1)\nchoose_num(100, 10)\nchoose_num(100, 2)\nchoose_num(12, 1)\nchoose_num(100,\
    \ 100)\nchoose_num(13, 10)\nchoose_num(13, 12)\nchoose_num(13, 15)\nchoose_num(20,\
    \ 10)\nchoose_num(100, 1)\nchoose_num(100, 10)\nchoose_num(100, 2)\nchoose_num",
  "\n  if (x <= y) {\n    while (x %% 2 != 0) {\n      x <- x - 1\n    }\n  } else\
    \ {\n    while (y %% 2 != 0) {\n      y <- y - 1\n    }\n  }\n  return(y)\n}\n",
  "\n  if (x > y) {\n    return(choose_num(y, x))\n  }\n  \n  z <- 0\n  \n  # Initialize\
    \ variables\n  while ((z < x) && (z < y)) {\n    if (z * z == x * x + y * y) {\n\
    \      z <- z + 1\n    }\n  }\n  \n  if (z == x && z < y) {\n    return(z)\n \
    \ }\n  \n  if (z == y) {\n    return(choose_num(y, x))\n  }\n}\n</cell>\n<cell>\n\
    choose_num(12, 15)\n</cell>\n<cell>\nchoose_num(13, 12)\n</cell>\n<cell>\nchoose_num(15,\
    \ 12)\n</cell>\n<cell>\nchoose_num(12, 11)\n</cell>\n<cell>\nchoose_num(13, 10)\n\
    </cell>\n<cell>\nchoose_num(15, 10)\n</cell>\n<cell>\nchoose_num(7, 7)\n</cell>\n\
    <text>\nThe next function takes three numbers a b c and returns the product of\
    \ a and b and the product of b and c. \nFor instance, if a = 2 and b = 3 and c\
    \ = 5, then a * b = 2 and b * c = 5.\n\n\n</text>\n<cell>", "\n  # Your code here\n\
    \  # if (x > y) return(-1);\n  # if (x <= y) return(1);\n  # return(x+y);\n}\n\
    choose_num(12, 15) # returns 14\nchoose_num(13, 12) # returns -1\nchoose_num(29,\
    \ 19) # returns 19\nchoose_num(20, 20) # returns -1\nchoose_num(42, 18) # returns\
    \ 19\nchoose_num(42, 24) # returns 18\nchoose_num(42, 44) # returns 24\nchoose_num(42,\
    \ 60) # returns 44\nchoose_num(42, 120) # returns 60\nchoose_num(42, 300) # returns\
    \ 120\nchoose_num(42, 1000) # returns 3000\nchoose_num(42, 1000000) # returns\
    \ -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000)\
    \ # returns -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42,\
    \ 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000) # returns\
    \ -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000)\
    \ # returns -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42,\
    \ 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000) # returns\
    \ -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000)\
    \ # returns -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42,\
    \ 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000) # returns\
    \ -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000)\
    \ # returns -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42,\
    \ 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000) # returns\
    \ -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000)\
    \ # returns -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42,\
    \ 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000) # returns\
    \ -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000)\
    \ # returns -1\nchoose_num(42, 10000000000000000) # returns -1\nchoose_num(42,\
    \ 10000000000000000) # returns -1\nchoose_num(42, 10000000000000000) # returns\
    \ -1\ncho", "\n  tmp <- NULL\n  for(i in seq(x, y, by = 2)) {\n    if(!is.na(tmp))\
    \ {\n      tmp <- tmp + i\n    }\n  }\n  if(!is.na(tmp)) {\n    tmp\n  } else\
    \ {\n    -1\n  }\n}\n", "\n\tif(x == y) return -1\n\ta = x\n\twhile(a <= y) {\n\
    \t\tif(a %% 2 == 0) {\n\t\t\ta = a + 1\n\t\t\tif((a > y) && (a==y)) break\n\t\t\
    }\n\t\ta = a + 1\n\t}\n\ta\n}\n", "\n    \n    # Check that x is between y and\
    \ y.\n    x <- min(y, x)\n    y <- max(y, x)\n\n    # Initialize an empty vector\
    \ to store result\n    out <- c(x, y)\n\n    # For each element of vector out,\
    \ find the greatest integer \n    # which is less than or equal to x\n    for\
    \ (i in 1:length(out)) {\n        index <- which.max(out[i] <= x)\n        if\
    \ (index != 1)\n            out[i] <- out[index] + 1 \n        else\n        \
    \    out[i] <- x\n    }\n    \n    # Return the greatest number in vector out\n\
    \    out[length(out)]\n}\n</code>\n<|/ a tags=r,numeric,ceiling |>\n<| c |>\n\
    This won't work correctly if `x` is larger than `y`\n<|/ c |>\n<| c |>\nYes you\
    \ are right. I will update the answer accordingly.\n<|/ c |>\n<| c |>\nThis would\
    \ be a much more efficient answer, but is very difficult to read and to understand\
    \ for someone who is still learning R. Also it wouldn't solve the problem presented\
    \ in the OP example. `choose_num(14,15)` returns `14`, whereas the OP's example\
    \ returns `-1`.\n<|/ c |>\n<| a |>\nHere is another solution in base R:\n<code>\n\
    x <- 20\ny <- 10\nceiling(x + y - floor(y))\n</code>\n<|/ a tags=r,numeric,ceiling\
    \ dscore=5 |>\n<| c |>\nThis is actually more readable than the top answer. Thanks!\n\
    <|/ c |>\n<| c |>\nThis solution doesn't work for `choose_num(12,15)` which should\
    \ return 14 instead of 15.\n<|/ c |>\n<| c |>\nI think it is meant to return `12`.\
    \ Or am I missing something here?\n<|/ c |>\n<| c |>\nIt doesn't work for choose_num(12,15)\
    \ which should return 14 instead of 15\n<|/ c |>\n<| c |>\nThis solution works\
    \ for me. choose_num(12,15) returns 14.\n<|/ c |>\n<| a |>\nHere is a solution\
    \ in base R that avoids the for loop and gives you the greatest number greater\
    \ than or equal to x:\n<code>\nx <- 10\ny <- 20\nmax(outer(x, y, `+`))\n</code>\n\
    Edit:\nHere is another approach that I think may be more efficient than using\
    \ outer.  It assumes that x is less than or equal to y.  It also assumes that\
    \ the greatest number that is larger than x is x.  So ", "\n  # Check if the first\
    \ number is in the range [x, y] inclusive.\n  if(x >= y || x <= 0) {\n    return(-1)\n\
    \  }\n  \n  # Check if there's an even number between x and y.\n  if(x %% 2 ==\
    \ 0 && y %% 2 == 0) {\n    return(x + (y-x) / 2)\n  }\n  \n  # Otherwise, just\
    \ return the first number that's in the range.\n  return(y)\n}\n</cell>\n<cell>\n\
    choose_num(15, 12)\n</cell>\n<text>\nExercise: Write a function called dice_to_face\
    \ that takes a positive integer n and returns n if it is an even number or a number\
    \ between 1 and 6 if n is not an even number.\n\n</text>\n<cell>", "\n  x <- x\
    \ - 1\n  y <- y - 1\n  while(x <= y & x %% 2 == 0) {\n    x <- x + 1\n  }\n  if(x\
    \ > y) {\n    return(x)\n  } else {\n    return(y)\n  }\n}\n", "\n  x <- as.integer(x)\n\
    \  y <- as.integer(y)\n  if (x < y) {\n    x <- y\n    y <- x\n  }\n  x <- y\n\
    \  y <- x\n  while(x+y > y) {\n    x <- x+y\n    y <- y-2\n  }\n  if (x <= y)\n\
    \    return(x)\n  else \n    return(-1) \n}\n</cell>\n<text>\nLet's check the\
    \ result of the first function we wrote:\n\n\n</text>\n<cell>\nchoose_num(1, 5)\n\
    </cell>\n<text>\nThe result is the expected 14. We can check the result of the\
    \ second function we wrote:\n\n\n</text>\n<cell>\nchoose_num(7, 3)\n</cell>\n\
    <text>\nThe result is -1, because there are no even numbers in [7, 3]. We can\
    \ check the result of the third function we wrote:\n\n\n</text>\n<cell>\nchoose_num(7,\
    \ 7)\n</cell>\n<text>\nThe result is -1.\n\n\n</text>\n<text>\nWrite a function\
    \ called choose_evens that takes a vector a of integers and returns an integer\
    \ vector of even integers.\nThe function should return -1 if any integer in the\
    \ vector is odd and otherwise return an integer vector of the even integers.\n\
    For example, choose_evens(c(2, 4, 6, 8, 10)) should return the vector c(2, 4,\
    \ 6, 8).\n\n\n</text>\n<cell>\nchoose_evens <- function(x) {\n  x <- as.integer(x)\n\
    \  x <- sort(x)\n  x <- x[x %% 2 == 0]\n  if (length(x) == 0) {\n    return(-1)\n\
    \  } else {\n    return(x)\n  }\n}\n</cell>\n<cell>\nchoose_evens(c(2, 4, 6, 8,\
    \ 10))\n</cell>\n<text>\nLet's check the result of the first function we wrote:\n\
    \n\n</text>\n<cell>\nchoose_evens(c(2, 4, 6, 8, 10))\n</cell>\n<text>\nThe result\
    \ is the expected c(2, 4, 6, 8). We can check the result of the second function\
    \ we wrote:\n\n\n</text>\n<cell>\nchoose_evens(c(2, 4, 6, 8, 10, 12))\n</cell>\n\
    <text>\nThe result is -1, because there are no even numbers in c(2, 4, 6, 8, 10,\
    \ 12).\n\n\n</text>\n<text>\nWrite a function called choose_odds that takes a\
    \ vector a of integers and returns an integer vector of odd integers.\nThe function\
    \ should return -1 if any integer in the vector is even and otherwise return an\
    \ integer vector of the odd integers.\nFor example, choose_odds(c(2, 4, 6, 8,\
    \ 10)) should return the vector c(2, 4, 6, 10).\n\n\n</text>\n<cell>\nchoose_",
  "\n  if (x < y) {\n    return(choose_num(x, y))\n  } else if (y == 1) {\n    return(x-1)\n\
    \  } else if (y == 2) {\n    return(x+2)\n  } else if (y > 1) {\n    i <- 0\n\
    \    while(i <= y) {\n      i <- i + 2\n      if (i % 2 == 0) {\n        return(x)\n\
    \      }\n    }\n    return(-1)\n  }\n}\n", "\n  \n  for(i in seq_len(x - 1))\
    \ {\n    if(isTRUE(x %in% seq(i, y))) {\n      if(isTRUE(y %in% seq(i, x))) {\n\
    \        return(i)\n      }\n      else {\n        break\n      }\n    }\n  }\n\
    \  return(-1)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYes, the function is O(n),\
    \ but it's pretty unwieldy.\n<|/ c |>\n<| c |>\nI agree, the code above is quite\
    \ unwieldy and also the code is hard to understand for most people including myself.\n\
    <|/ c |>\n<| a tags=r,loops,algorithm |>\nThis is a recursive solution that I\
    \ wrote in R. \n<code>\nchoose = function(x,y) {\n  if(is.na(x) || is.na(y)) {\n\
    \    return(-1)\n  }\n  if(is.na(x)) {\n    return(y)\n  }\n  if(is.na(y)) {\n\
    \    return(x)\n  }\n\n  if(x < y) {\n    return(choose(y-x,x))\n  } else {\n\
    \    return(choose(x,y-x))\n  }\n}\n\nchoose(3,9)", "\n    x <- as.integer(x)\n\
    \    y <- as.integer(y)\n    while (x <= y) {\n        if (x %% 2 == 0) {\n  \
    \          if (y %% 2 == 0) {\n                x <- x + 1\n                y <-\
    \ y - 1\n            } else {\n                x <- x + 1\n                y <-\
    \ y\n            }\n        } else {\n            if (y %% 2 == 0) {\n       \
    \         x <- x + 1\n                y <- y - 1\n            } else {\n     \
    \           x <- x\n                y <- y - 1\n            }\n        }\n   \
    \ }\n    if (x == y) {\n        x\n    } else {\n        -1\n    }\n}\n\nchoose_num\
    \ <- function(x, y) {\n    x <- as.integer(x)\n    y <- as.integer(y)\n    while\
    \ (x <= y) {\n        if (x %% 2 == 0) {\n            if (y %% 2 == 0) {\n   \
    \             x <- x + 1\n                y <- y - 1\n            } else {\n \
    \               x <- x + 1\n                y <- y\n            }\n        } else\
    \ {\n            if (y %% 2 == 0) {\n                x <- x + 1\n            \
    \    y <- y - 1\n            } else {\n                x <- x\n              \
    \  y <- y - 1\n            }\n        }\n    }\n    if (x == y) {\n        x\n\
    \    } else {\n        -1\n    }\n}\n</code>\nBenchmark tests\n<code>", "\n  #\
    \ if x is larger than y, return -1\n  if (x > y) return -1\n\n  # get rid of negative\
    \ numbers\n  x <- abs(x)\n  y <- abs(y)\n\n  # if x is equal to or larger than\
    \ y, return x\n  if (x == y) return x\n\n  # initialize biggest_even_number\n\
    \  biggest_even_number <- x\n\n  # for biggest_even_number in range [x, y] inclusive\n\
    \  for (i in 2:y) {\n    # if the current number is not even, continue to the\
    \ next number\n    if (x %% i != 0) next\n\n    # if the current number is even,\
    \ compare it to the biggest_even_number\n    if (x %% i == 0) {\n      if (biggest_even_number\
    \ < x) biggest_even_number <- x\n    }\n  }\n  return(biggest_even_number)\n}\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nHi, thanks for your solution. I know that my\
    \ question was badly stated and I apologize. I will edit my question so it is\
    \ clearer what I am looking for. \n\nWhat I really want to do is find the biggest\
    \ even number that is not larger than a given number, which I believe this solution\
    \ provides.\n<|/ c |>\n<| c |>\nOk, I edited my solution to do just that. I had\
    \ misunderstood what you were looking for. Let me know if this works for you\n\
    <|/ c |>\n<| c |>\nAwesome! Thanks so much!\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    choose_num <- function(x, y) {\n  if (x > y) return -1\n  x <- abs(x)\n  y <-\
    \ abs(y)\n  if (x == y) return x\n  for (i in 1:y) {\n    if (x %% i == 0) {\n\
    \      res <- x\n      x <- x - (x %% i)\n      x <- x + (y - (i %% x))\n    \
    \  if (x > y) break\n      x <- y - (x %% i)\n      x <- x + (y - (i %% x))\n\
    \      if (x > y) break\n      if (x < res) res <- x\n    }\n  }\n  return(res)\n\
    }\n</code>\n<|/ a tags=r |>\n<| a dscore=0 |>\nHere's a similar answer using only\
    \ base R, using RcppAlgos::maxElement function.\n<code>\nchoose_num <- function(x,\
    \ y) {\n  x <- abs(x)\n  y <- abs(y)\n  if (x == y) return x\n  res <- maxElement(x:y)\n\
    \  return(res)\n}\n\nchoose_num(12, 15)"]
stop_tokens:
- "\n#"
- "\n```"
