name: HumanEval_2_truncate_number
language: r
prompt: "# Given a positive floating point number, it can be decomposed into\n# and\
  \ integer part (largest integer smaller than given number) and decimals\n# (leftover\
  \ part always smaller than 1).\n# Return the decimal part of the number.\n# >>>\
  \ truncate_number(3.5)\n# 0.5\ntruncate_number <- function(number) {"
tests: "test_humaneval <- function() {\ncandidate <- truncate_number\n    if(!identical(candidate(3.5),\
  \ 0.5)){quit('no', 1)}\n    if(!identical(candidate(1.25), 0.25)){quit('no', 1)}\n\
  \    if(!identical(candidate(123.0), 0.0)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  ns <- gsub(\"^([-]\\\\d+)\\\\.?\\\\d+$\", \"\\\\1\", number)\n\
    \  ns <- as.numeric(as.character(ns)) - 1\n  fraction <- number - ns * as.numeric(as.character(ns))\n\
    \  return(fraction)\n}\n", "\n  \n  # If number is a single digit\n  # then return\
    \ the number\n  if (is.numeric(number)) {\n    number <- as.integer(number)\n\
    \  }\n  \n  # Get number after decimal point\n  # (decimal part always smaller\
    \ than 1)\n  number <- trunc(number, 0)\n  \n  # If number is zero then return\
    \ the number itself\n  if (number == 0) {\n    number\n  }\n  \n  # Get number\
    \ before decimal point\n  # (integer part always smaller than number)\n  number\
    \ <- floor(number)\n  \n  # If number is zero then return zero\n  # (otherwise\
    \ we may end up with 0.xxx)\n  if (number == 0) {\n    0\n  }\n  \n  \n  # If\
    \ number is a fraction\n  # then return the number with decimal part\n  else {\n\
    \    \n    # Number of decimal digits\n    # (the part after decimal point is\
    \ always smaller than 1)\n    decimal_digits <- decimal_length(number)\n    \n\
    \    # Construct the return number\n    trunc(number, decimal_digits)\n  }\n}\n\
    \n", "\n  decimal_part <- as.numeric(formatC(number, digits=-2, flag='0'))\n \
    \ integer_part <- as.integer(number - decimal_part)\n  return(decimal_part * 10^-integer_part)\n\
    }\n", "\n  number_part <- number %/% 1\n  decimal_part <- number %% 1\n  return(decimal_part)\n\
    }\n", "\n  integer <- ceiling(number - trunc(number, floor=TRUE))\n  decimals\
    \ <- number - integer\n  return(if (is.finite(integer)) integer else integer(0))\n\
    }\n", "\n  return(number - trunc(number))\n}\n", "\n  number <- as.numeric(number)\n\
    \  \n  # First we find out how many decimals are in this number\n  # This will\
    \ be used to split the number into integer and decimal\n  # part\n  decimals <-\
    \ max(floor(log10(abs(number))), 1)\n  \n  # We keep an integer part and remove\
    \ the decimal part\n  integer_part <- trunc(number)\n  number <- number - integer_part\n\
    \  \n  # Return the float number\n  number <- number * 10^(-decimals)\n  \n  return(list(integer_part=integer_part,\
    \ decimals=decimals, number=number))\n}\n</cell>\n<text>\nWe are now ready to\
    \ define the function that returns the factorial of a number\n\n\n</text>\n<cell>\n\
    factorial <- function(n) {\n  \n  # This function checks if the given integer\
    \ is a prime number\n  # It also checks if the given integer is a factor of the\
    \ given number\n  # If the given integer is a prime number, then this function\
    \ returns one\n  # If the given integer is a factor of the given number, then\
    \ the function\n  # returns this number's factorial\n  \n  # If n is negative,\
    \ then return 0\n  if(n < 0) return(0)\n  \n  # If a number is 2, then it returns\
    \ 1\n  if(n %in% c(2,3)) return(1)\n  \n  # If the given number is 1, then return\
    \ 1\n  if(n == 1) return(1)\n  \n  # If n is not a prime number, then return its\
    \ factorial\n  if(!(n % 2)) return(n * factorial(n - 1))\n  \n  # We only have\
    \ to deal with odd numbers, therefore we only have to check\n  # for numbers divisible\
    \ by 3\n  # For example, if n is 11, then number 11 is not divisible by 3, so\
    \ we skip\n  # it\n  if(!((n %% 3) %% 1)) return(n * factorial(n - 1))\n  \n \
    \ # If n is not a factor of the given number, then return its factorial\n  return(factorial(n\
    \ - 1) * n)\n}\n</cell>\n<text>\nWe can now test the function\n\n\n</text>\n<cell>\n\
    factorial(8)\n</cell>\n<text>\nWe can now use our truncate function to test our\
    \ function\n\n\n</text>\n<cell>\ntruncate_number(3)\n</cell>\n<text>\nWe can now\
    \ define a new function that calculates the sum of a vector\n\n\n</text>\n<cell>",
  "\n  decimal_part <- floor(log10(number))\n  integer <- trunc(number)\n  decimal_part\
    \ - integer(log10(number))\n}\n</cell>\n<cell>\ntruncate_number(2.5)\n</cell>\n\
    <cell>\ntruncate_number(3.5)\n</cell>\n<cell>\ntruncate_number(4.5)\n</cell>\n\
    <cell>\ntruncate_number(4.55)\n</cell>\n<cell>\ntruncate_number(4.56)\n</cell>\n\
    <text>\nNow the task is to find the number which is close to $x$ with given precision:\n\
    \n\n</text>\n<cell>", "\n  if (is.numeric(number)) {\n    n <- as.numeric(number)\n\
    \    r <- n + 1\n    if (r %% 1 > 0) {\n      r <- r %% 1\n    }\n    return(r)\n\
    \  } else {\n    stop(\"Argument needs to be numeric!\")\n  }\n}\n", "\n  # Taken\
    \ from http://stackoverflow.com/a/5654167/2416332\n  number <- as.double(number)\n\
    \  x <- floor(number)\n  y <- x - number\n  ifelse(is.na(y), 0, y)\n}\n", "\n\
    \    if (number <= floor (number)) {\n        return floor (number)\n    }\n \
    \   if (number < ceiling (number)) {\n        return ceiling (number)\n    }\n\
    \    else {\n        decimal_number <- truncate (number - floor (number))\n  \
    \      return (decimal_number * 10)\n    }\n}\n", "\n  return(number - (number\
    \ %% 1))\n}\n", "\n  decimals <- as.integer(as.double(number) * 10^(max(floor(log10(number))-1,0)))\n\
    \  integer <- trunc(number)\n  return(integer + (decimals/10^(max(floor(log10(number))-1,0))))\n\
    }\n</code>\nThe above is based on this answer to a similar question\n<|/ a dscore=2\
    \ |>\n<| c |>\nYour answer works for positive numbers only, I needed it for negative\
    \ numbers. I modified your function and added a second answer, that works for\
    \ negative numbers also.\n<|/ c |>\n<| a |>\nHere is a more general solution that\
    \ works for positive and negative numbers, it also works for numbers with more\
    \ than 2 decimals. \n<code>\ntruncate <- function(x,digits=0){\n  x_trunc <- trunc(x)\n\
    \  x_decimals <- as.integer(round(x*10^(digits-max(floor(log10(x))),0)))\n  x_res\
    \ -(x_trunc + x_decimals/10^(digits-max(floor(log10(x)))))\n}\n</code>\n<|/ a\
    \ tags=truncation,r dscore=2 |>\n<| a tags=truncation,r |>\nBased on the answer\
    \ from, I have adapted it so that it works for negative numbers as well:\n<code>\n\
    truncate_neg <- function(x, digits) {\n  x_trunc <- trunc(x)\n  x_decimals <-\
    \ as.integer(round(x * 10^(digits- max(floor(log10(x))), 0)))\n  x_res -(x_trunc\
    \ + x_decimals/10^(digits- max(floor(log10(x)))))\n}\n</code>\nAnd then we can\
    \ test it with the following example:\n<code>\ntest <- c(2.5,3,4.5,8.5,12.5,15)\n\
    truncate_neg(test,0)\ntruncate_neg(test,2)\ntruncate_neg(test,5)\ntruncate_neg(test,8)\n\
    truncate_neg(test,10)\n</code>\nWhich gives the following result:\n<code>\n[1]\
    \ 2.5 3 4.5 8.5 12.5 15\n[1] 2 3 4.5 8 12 15\n[1] 2 3 4 8 12 15\n[1] 2 3 4 8 12\
    \ 15\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthis one worked for me perfectly. thank\
    \ you :)\n<|/ c |>\n<| a dscore=2 |>\nI found the accepted answer to be incorrect\
    \ for negative numbers. Here is a slightly modified function which seems to do\
    \ the job.\n<code>\ntruncate_negative <- function(x, digits) {\n  x_trunc <- trunc(x)\n\
    \  x_decimals <- as.integer(round(x", "\n  number <- as.integer(number)\n  decimal\
    \ <- number - as.integer(number)\n  return(as.numeric(round(number / 10^decimal)))\n\
    }\n", "\n    if(is.numeric(number) && is.finite(number)) {\n        as.numeric(format(number,\
    \ nsmall = 0))\n    } else {\n        NaN\n    }\n}\n", "\n  ifelse(number <=\
    \ 1, 1, number - trunc(number))\n}\n", "\n  stopifnot(is.numeric(number))\n  if(number\
    \ < 1) return(NULL)\n  result <- floor(nchar(as.character(number)) - 1)\n  return(result)\n\
    }\n", "\n  return(number - trunc(number))\n}\n", "\n  return(number - as.integer(number))\n\
    }\n", "\n\tfloor_number(number) - number %% 1\n}\n\n", "\n    number <- roundUp(number,\
    \ 0)\n    number <- trunc(number)\n    number <- number - trunc(number)\n    number\n\
    }\n", "\n  # Truncate\n  n <- trunc(number)\n  # Check if we have integer part\
    \ and decimal.\n  if (n > 1) {\n    # Return integer\n    return(n)\n  }\n  #\
    \ Return decimal\n  return(number - trunc(number))\n}\n", "\n  # Make sure to\
    \ take in account the sign of the number\n  sign <- number[1]\n  number <- number[-1]\n\
    \  # Decompose the number into a decimal part and a integer part\n  integer <-\
    \ floor(nzchar(gsub(\"\\\\D\", \"\", number)))\n  decimal <- nchar(number)\n \
    \ decimal <- gsub(\"^0\", \"\", decimal)\n  decimal <- gsub(\"^\\\\.0*\", \"\"\
    , decimal)\n  # Return floating point numbers\n  return(list(number = number,\
    \ sign = sign, decimal = decimal, integer = integer))\n}\n", "\n    x <- as.integer(number)\n\
    \    y <- as.integer(x - trunc(x))\n    trunc(number)\n}\n</code>\n<|/ a tags=r,rounding,floating-point\
    \ dscore=3 |>\n<| c |>\nYour solution works but is slower than the solutions above:\
    \ ```R> microbenchmark(truncate_number(3.5), truncate_number(3.5), truncate_number(3.5))```",
  "\n  number <- as.integer(number)\n  if(number < 1) return(number)\n  integer <-\
    \ trunc(number)\n  number <- number - integer\n  number <- round(number, digits\
    \ = 1)\n  return(number)\n}\n", "\n  number <- as.character(number)\n  truncated\
    \ <- strsplit(number, \".\")[[1]]\n  truncated <- truncated[-length(truncated)]\n\
    \  truncated <- paste0(truncated, \"0\")\n  integer <- truncated[1]\n  decimal\
    \ <- truncated[-length(truncated)]\n  return(as.numeric(integer) + as.numeric(decimal)/10^length(decimal))\n\
    }\n", "\n    ceiling(number + 0.5)\n}\n", "\n  number <- as.character(number)\n\
    \  number <- number[number %in% c(as.character(0:9), as.character(10), '.')]\n\
    \  number <- as.numeric(number)\n  number <- trunc(number)\n  number <- number\
    \ - trunc(number)\n  number <- number / 10\n  return(number)\n}\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nThis approach is nice, but it won't work for numbers represented\
    \ with more than 1 decimal place. E.g. 3.14159265359 is truncated to 3.14 and\
    \ 0.0000000000000001 remains. I believe a better approach is to truncate to integers\
    \ and round down (or up) after truncation. The rounding down method will give\
    \ a number with the same number of digits as input (e.g 3.14159265359), but it\
    \ will always round down, so the difference will always be zero.\n<|/ c |>\n<|\
    \ a |>\nAnother answer is the following function that converts the number to character\
    \ and removes the decimal places:\n<code>\ntrunc_number <- function(number) {\n\
    \  number <- as.character(number)\n  number <- number[number %in% c(as.character(0:9),\
    \ as.character(10), '.')]\n  number <- as.numeric(number)\n  return(round(number))\n\
    }\n\ntrunc_number(3.14159265359)", "\n    number <- round(number)\n    if (number\
    \ %% 1 == 0) {\n        number <- number + 1\n    }\n    return(number - trunc(number))\n\
    }\n", "\n  number <- as.numeric(number)\n  x <- floor(number)\n  y <- number -\
    \ x\n  ifelse(y > 0, trunc(y) + trunc(x), trunc(y))\n}\n", "\n\tnumber <- as.integer(number)\n\
    \tnumber <- round(number * 10^(-floor(log10(number))),1)\n\treturn(number)\n}\n",
  "\n  round_number <- round(number, digits=-1)\n  ndigits <- nchar(number)\n  decimal_part\
    \ <- round_number - trunc(round_number)\n  integer_part <- round_number - trunc(round_number)\n\
    \  decimal_part\n}\n</cell>\n<text>\nNow let's run it on the first three examples\
    \ of our dataset:\n\n\n</text>\n<cell>\ntruncate_number(df$x)\ntruncate_number(df$y)\n\
    truncate_number(df$z)\n</cell>\n<text>\nIt works pretty well!\n\n\n</text>\n<cell>",
  "\n  truncated <- trunc(number)\n  integer <- truncated - truncated%%1\n  decimal\
    \ <- truncated - integer\n  result <- list(integer=integer, decimal=decimal)\n\
    \  return(result)\n}\n</cell>\n<cell>\ntruncate_number(3.5)\n</cell>\n<text>\n\
    The same function can be used to find common divisors of the product of two numbers.\n\
    \n\n</text>\n<cell>\ncommon_divisors <- function(x,y) {\n  result <- rep(0,length(x)+length(y))\n\
    \  result[[1]] <- x\n  result[[2]] <- y\n  for(i in 1:length(x)) {\n    result[length(x)+i]\
    \ <- result[length(x)+i-1]*(y[length(y)]/(x[i]))\n  }\n  result <- result[1:(length(x)+length(y))]\n\
    \  return(result)\n}\n</cell>\n<cell>\ncommon_divisors(1,2)\n</cell>\n<cell>\n\
    common_divisors(1,3)\n</cell>\n<cell>\ncommon_divisors(2,4)\n</cell>\n<cell>\n\
    common_divisors(2,9)\n</cell>\n<cell>\ncommon_divisors(5,10)\n</cell>\n<text>\n\
    The prime factorization of a number is a vector composed of prime numbers (in\
    \ increasing order) and their multiplicities (which must be relatively prime to\
    \ each other).\n\nThe function below returns a vector containing the prime numbers\
    \ and their multiplicities.\n\n\n</text>\n<cell>\nprime_factorizations <- function(number)\
    \ {\n  number_primes <- function(n) { \n    prime <- rep(1,n)\n    prime[1] <-\
    \ FALSE\n    for(i in 2:n) {\n      if(prime[i] == TRUE) {\n        for(j in i:n)\
    \ {\n          if(prime[j] == FALSE) {\n            prime[j] <- FALSE\n      \
    \      break\n          }\n        }\n      }\n    }\n    return(prime)\n  }\n\
    \  is_prime <- function(x) {\n    result <- rep(0,length(x))\n    result[1] <-\
    \ TRUE\n    for(i in 2:length(x)) {\n      if(result[i] == TRUE) {\n        result[i]\
    \ <- x[i] %% x[i-1] == 0\n      }\n    }\n    return(result)\n  }\n  n <- ceiling(sqrt(number))\n\
    \  prime <- number_primes(n)\n  primes <- rep(0,n)\n  for(i in 1:n) {\n    if(prime[i]\
    \ == TRUE) {\n      for(j in i:n) {\n        if(prime[j] == FALSE) {\n       \
    \   primes[j] <- j\n          break\n        }\n      }\n", "\n  n <- number\n\
    \  integer <- floor(n)\n  decimal <- n - integer\n  if (decimal < 1) {\n    return(integer)\n\
    \  }\n  return(integer + (decimal - 1))\n}\n</code>\n<|/ a |>\n<| c |>\nThis approach\
    \ doesn't work for negative numbers.\n<|/ c |>\n<| c |>\nI thought this was a\
    \ requirement, as I understood \"the decimal part of the number\".  I have fixed\
    \ the answer.\n<|/ c |>\n<| a tags=r,regex |>\nYou could use this simple regex:\n\
    <code>\n\\b[0-9]+(?:\\.[0-9]+)?\\b\n</code>\nWorking demo\n<code>\nstring <- \"\
    My number is 0.45 and my other number is 0.1\"\nsub(\"\\\\b[0-9]+(?:\\\\.[0-9]+)?\\\
    \\b\", \"\", string, perl=TRUE)", "\n  decimal_part <- floor((number - trunc(number))\
    \ * 10^(-1L - digits(number)))\n  number - trunc(number) * 10^(-1L - digits(number))\
    \ * decimal_part\n}\n", "\n  return(floor(number))\n}\n", "\n    # Extract decimal\
    \ part\n    decimal_part <- number %% 1\n    # Extract integer part\n    integer_part\
    \ <- number / 1\n    # Return integer part\n    integer_part\n}\n", "\n  number\
    \ <- as.integer(number)\n  result <- number - floor(0.1 * number)\n  return(result)\n\
    }\n", "\n  if (number < 1) {\n    stop('cannot truncate numbers')\n  }\n  number\
    \ %/% 1\n}\n", "\n  x <- as.numeric(number)\n  as.numeric(formatC(x, width=15,\
    \ format=\"f\", flag=\"0\"))\n}\n", "\n  if (number < 1) {\n    return(0)\n  }\n\
    \  x = floor(number)\n  y = round(number - x)\n  return((y-1)/x)\n}\n", "\n  return(floor(number))\n\
    }\n", "\n  if(is.numeric(number)) {\n    number <- round(number, 0)\n    if(number\
    \ %% 1 == 0) {\n      number <- number - floor((number - 1) / 1)\n    }\n  }\n\
    \  return(number)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNice! This answer is\
    \ great for me. \nWhat if I have `2.12` and not `2.119999999999998`? \n`ceiling`\
    \ returns `2.13`\n<|/ c |>\n<| c |>\nIt doesn't work for `1.99` returns `2`\n\
    <|/ c |>\n<| c |>\nYou probably want to add `library(RCurl)` to your `head` call.\n\
    <|/ c |>\n<| c |>\nThis is by far the best answer. It's also the simplest, most\
    \ compact and most readable answer. Thank you!\n<|/ c |>\n<| a |>\nHere's my version\
    \ using a simple function that returns the ceiling of the fractional portion.\n\
    <code>\nceiling_fraction <- function(x) {\n  y <- floor(x)\n  if(x %% 1){\n  \
    \  y <- y + 1\n  }\n  y\n}\n\nceiling_fraction(3.5) ## 4\nceiling_fraction(3.4)\
    \ ## 4\nceiling_fraction(3.3) ## 3\nceiling_fraction(3.2) ## 4\nceiling_fraction(3.1)\
    \ ## 3\nceiling_fraction(3.0) ## 3\nceiling_fraction(2.9) ## 3\nceiling_fraction(2.8)\
    \ ## 3\nceiling_fraction(2.7) ## 2\nceiling_fraction(2.6) ## 3\nceiling_fraction(2.5)\
    \ ## 3\nceiling_fraction(2.4) ## 3\nceiling_fraction(2.3) ## 2\nceiling_fraction(2.2)\
    \ ## 2\nceiling_fraction(2.1) ## 3\nceiling_fraction(2.0) ## 3\nceiling_fraction(1.9)\
    \ ## 3\nceiling_fraction(1.8) ## 2\nceiling_fraction(1.7) ## 2\nceiling_fraction(1.6)\
    \ ## 3\nceiling_fraction(1.5) ## 3\nceiling_fraction(1.4) ## 2\nceiling_fraction(1.3)\
    \ ## 2\nceiling_fraction(1.2) ## 3\nceiling_fraction(1.1) ## 3\nceiling_fraction(1.0)\
    \ ## 3\nceiling_fraction(0.9) ## 3\nceiling_fraction(0.8) ## 2\nceiling_fraction(0.7)\
    \ ## 2\nceiling_fraction(0.6) ## 3\nceiling_fraction(0.5) ## 3\nceiling_fraction(0.4)\
    \ ## ", "\n  floor(number - floor(number) + 1)\n}\n</cell>\n<cell>\ntruncate_number(3.5)\
    \ # Truncate to integer\ntruncate_number(3.14) # Truncate to decimal\ntruncate_number(0.34)\
    \ # Truncate to zero\n</cell>\n<text>\nExercise: Truncate numbers in vector\n\
    Your task is to find numbers that are within 0.1% of the mean and within 1% of\
    \ the standard deviation of the vector.\n\n\n</text>\n<cell>", "\n  stopifnot(is.numeric(number))\n\
    \  number <- round(number)\n  if (number < 1) {\n    stop(\"number must be greater\
    \ than 0\")\n  }\n  decimal <- trunc(number)\n  integer <- integer(decimal)\n\
    \  if (integer < 1) {\n    stop(\"number must be greater than 0\")\n  }\n  number\
    \ <- decimal - integer\n  return(number)\n}\n", "\n    if(number == 0) return(number)\n\
    \    number <- abs(number)\n    exponent <- log2(number)\n    decimal <- number\
    \ - 2^exponent\n    truncate <- trunc(decimal)\n    return(truncate / 2^exponent)\n\
    }\n", "\n  number <- tolower(number)\n  if(grepl(\"^-?\\\\d+$\", number)) \n \
    \   return(number)\n  else if(grepl(\"^-?\\\\d*\\\\.\\\\d+$\", number))\n    return(truncate_number(gsub(\"\
    (\\\\d+\\\\.)\", \"\", number)))\n  else if(grepl(\"^-?\\\\d*$\", number))\n \
    \   return(gsub(\"(\\\\d+$)\", \"\", number))\n  else if(grepl(\"^-?\\\\d*\\\\\
    .?\\\\d+$\", number))\n    return(gsub(\"(\\\\d*\\\\.?\\\\d+)$\", \"\\\\1\", number))\n\
    \  else\n    return(number)\n}\n", "\n  decimal_part <- floor((number - floor(0.1*number))*10^(floor(log10(number)+1)))\
    \ / 10^(floor(log10(number)+1))\n  int_part <- floor(number*10^(floor(log10(number)+1)))\
    \ / 10^(floor(log10(number)+1))\n  if(decimal_part < 0) int_part <- int_part -\
    \ decimal_part + 1\n  return(int_part)\n}\n</code>\n<|/ a |>\n<| a tags=r |>\n\
    You cannot use ceiling or floor because those functions work with whole numbers.\
    \ \nceiling takes whole numbers as its arguments. If you have a number like \"\
    10.5\", ceiling will return \"11\" because 10 is not a whole number. floor works\
    \ the same way. If you want to round to the nearest integer, you could use round\
    \ with a little trickery. \n<code>\nceiling_or_nearest <- function(x) {\n  abs(x)\
    \ <= .Machine$double.eps * (1-.Machine$double.eps)\n  ceiling(x) + ifelse(x <\
    \ 0, -x, 0)\n}\n</code>\n(The reason to use absolute comparison is to avoid rounding\
    \ up for numbers like 10.5)\nIf you're willing to use package dplyr, this can\
    \ be done with\n<code>\nceiling_or_nearest <- function(x) {\n  ceiling(round(x,\
    \ 0))\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you, I didn't know that ceiling\
    \ and floor work on whole numbers. I edited my question to specify that I want\
    \ to round up in some cases. If x is 10.5 and I round it to 10.5 or 10.3, I want\
    \ the result to be 10.5 or 10.4.\n<|/ c |>\n<| c |>\n: I updated my answer with\
    \ an explanation of why you're not going to get `10.5` or `10.4`\n<|/ c |>\n<|\
    \ a |>\nHere's an approach with just R:\n<code>\n> round(10.5)\n[1] 10.5\n> round(10.3)\n\
    [1] 10.4\n> round(10.7)\n[1] 10.7\n> round(10.8)\n[1] 10.8\n</code>\n<|/ a tags=r\
    \ dscore=0 |>\n<| c |>\nPlease edit your answer and explain why this works, not\
    \ just post code.\n<|/ c |>\n<| c |>\nOh I missed that he was rounding to the\
    \ nearest integer. I had tried using truncate and ceiling before, but it rounds\
    \ to the nearest whole. He could use round, with the round-up argument set to\
    \ TRUE, to round it up for single digits, like 10.3. This works because ", "\n\
    \  number <- gsub(\"^-$\", \"\", number)\n  number <- gsub(\"^.+\", \"\", number)\n\
    \  number <- gsub(\"^0\", \"\", number)\n  number <- gsub(\"-\", \"\", number)\n\
    \  number <- gsub(\"^-?0*([0-9]+).*$\", \"\\\\1\", number)\n  number <- gsub(\"\
    ^0*([0-9]+).*$\", \"\\\\1\", number)\n  number <- gsub(\"^-?([0-9]+).*$\", \"\\\
    \\1\", number)\n  number <- gsub(\"^([0-9]+).*$\", \"\\\\1\", number)\n  number\
    \ <- as.numeric(number)\n  if (is.na(number)) {\n    return(NA)\n  } else {\n\
    \    return(number - 1)\n  }\n}\n", "\n  return(floor(number))\n}\ntruncate_number()\n",
  "\n\tdigits <- str_split(as.character(number), \"\")[[1]]\n\tdigits <- digits[order(as.numeric(digits))]\n\
    \tifelse(length(digits) > 1, paste0(digits[-length(digits)], \"0\"), digits[length(digits)])\n\
    }\n</cell>\n<text>\nNow, we can write our function that takes as input a number\
    \ as string and returns True if and only if the number is within the limits of\
    \ its decimal representation. In the example, the first three numbers in the input\
    \ list are outside the limits of their decimal representation (i.e. 3.4 and 3.3999999999999999),\
    \ hence the result of the function will be False.\n\nNote: we could have also\
    \ used round() to obtain the decimal representation of the number and then use\
    \ the truncate_number() function as above, but this approach will lead to an error\
    \ in the case of rounding up, for which we would want to return True.\n\n\n</text>\n\
    <cell>", "\n  return(floor(number))\n}\n", "\n  number <- as.numeric(number)\n\
    \  if (number > 1)\n    return(number - trunc(number))\n  else\n    return(number)\n\
    }\n", "\n  \n  number <- number * 100\n  \n  if(number < 1) {\n    return(0)\n\
    \  }\n  \n  integer <- floor(number)\n  \n  decimals <- number - integer\n  \n\
    \  return(integer + decimals)\n  \n}\n</cell>\n<code language=conda-env-stats-py>\n\
    truncate_number(1.5)\n</cell>\n<code language=conda-env-stats-py>\ntruncate_number(3.5)\n\
    </cell>\n<code language=conda-env-stats-py>\ntruncate_number(7.5)\n</cell>\n<code\
    \ language=conda-env-stats-py>\ntruncate_number(3.5)\n</cell>\n<code language=conda-env-stats-py>\n\
    truncate_number(1.5)\n</cell>\n<code language=conda-env-stats-py>\ntruncate_number(3.5)\n\
    </cell>\n<code language=conda-env-stats-py>\ntruncate_number(7.5)\n</cell>\n<code\
    \ language=conda-env-stats-py>\ntruncate_number(8.5)\n</cell>\n<code language=conda-env-stats-py>\n\
    truncate_number(10)\n</cell>\n<code language=conda-env-stats-py>\ntruncate_number(1.5)\n\
    </cell>\n<code language=conda-env-stats-py>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=conda-env-stats-py>\ntruncate_number(7.5)\n</cell>\n<code language=conda-env-stats-py>\n\
    truncate_number(8.5)\n</cell>\n<code language=conda-env-stats-py>\ntruncate_number(10)\n\
    </cell>\n<code language=conda-env-stats-py>\ntruncate_number(1.5)\n</cell>\n<code\
    \ language=conda-env-stats-py>\ntruncate_number(3.5)\n</cell>\n<code language=conda-env-stats-py>\n\
    truncate_number(7.5)\n</cell>\n<code language=conda-env-stats-py>\ntruncate_number(8.5)\n\
    </cell>\n<code language=conda-env-stats-py>\ntruncate_number(10)\n</cell>\n<text>\n\
    Exercise\nCompute truncated number of days between two dates\n\n</text>\n<code\
    \ language=conda-env-stats-py>", "\n  number <- round(number, 0)\n  ceiling(number)\n\
    }\n", "\n  # make sure decimal part is smaller than 1\n  tol <- 1e-15\n  res <-\
    \ trunc(number*100)\n  decimal_part <- floor(number*100)/100\n  # check whether\
    \ number is an integer or decimal\n  if(number < 1) {\n    decimal_part <- decimal_part\
    \ + 1\n  }\n  decimal_part[decimal_part > 1] <- decimal_part[decimal_part > 1]\
    \ - 1\n  if((number - decimal_part) < tol) {\n    if(number %% 1 == 0) res <-\
    \ res - 0.5\n    res else res\n  } else {\n    res\n  }\n}\ntruncate_number(0.3)\n\
    truncate_number(0.37)\ntruncate_number(0.371)\ntruncate_number(0.3711)\ntruncate_number(0.371110)\n\
    truncate_number(0.3711100000000001)\ntruncate_number(0.37111000000000011)\ntruncate_number(0.3711100000000001110)\n\
    truncate_number(0.37111000000000011100000000001)\ntruncate_number(0.371110000000000111000000000011)\n\
    truncate_number(0.37111000000000011100000000001110)\n</code>\n<|/ a tags=math,r,truncation\
    \ dscore=3 |>\n<| c |>\nThis is neat.  Thank you.  I added some explanation of\
    \ why this works here.\n<|/ c |>\n<| a tags=math,r,truncation |>\nFor positive\
    \ numbers, the solution given by is perfect and simple.\nThe only thing I had\
    \ to add to it to get it to work in R (version 4.0.2 (2020-06-22)) is the ceiling\
    \ function:\n<code>\ntruncate_number <- function(number) {\n  tol <- 1e-15\n \
    \ res <- trunc(number*100)\n  decimal_part <- floor(number*100)/100\n  # check\
    \ whether number is an integer or decimal\n  if(number < 1) {\n    decimal_part\
    \ <- decimal_part + 1\n  }\n  decimal_part[decimal_part > 1] <- decimal_part[decimal_part\
    \ > 1] - 1\n  if((number - decimal_part) < tol) {\n    if(number %% 1 == 0) res\
    \ <- res - 0.5\n    res else res\n  } else {\n    res\n  }\n}\n\ntruncate_number(0.3)\n\
    truncate_number(0.37)\ntruncate_number(0.371)\ntruncate_number(0.3711)\ntruncate_number(0.371110)\n\
    truncate_number(0.3711100000000001)\ntruncate_number(0.37111000000000011)\ntruncate_number(0.3711100000000001110)\n\
    truncate_number(0.37111000000000011100000000001)\ntruncate_", "\n  n <- as.numeric(number)\n\
    \  if(n == floor(number)) number <- n\n  if(n%%1 > 0) return(ceiling(number))\n\
    \  if(n%%1 < 0) return(floor(number))\n  return(number)\n}\n</cell>\n<cell>",
  "\n  number <- gsub(\"(\\\\.\\\\d+)$\", \"\", number) # remove trailing decimals\n\
    \  \n  integer <- as.numeric(substr(number, 1, 1))\n  \n  number <- gsub(\"^0*\"\
    , \"\", number) \n  \n  ifelse(number == \"\", \n         integer = integer, \n\
    \         integer = trunc(integer)*10^(nchar(as.numeric(substr(number, 2, nchar(number)))\
    \ - nchar(number))+2)\n  )\n}\n", "\n  ifelse(number %% 1 > 0, number, number\
    \ - floor(number))\n}\n", "\n  truncated <- floor(number)\n  decimals <- number\
    \ - truncated\n  return(truncated)\n}\n", "\n  number <- as.numeric(number)\n\
    \  x <- floor(number)\n  ifelse(number - x > 0.000000001, x, number - x)\n}\n",
  "\n  ndigits <- nchar(as.character(number))\n  decimal_part <- number - trunc(number)\n\
    \  integer <- trunc(number)\n  integer %% 1 != 0 &\n    stop(\"Number too small\
    \ for truncating.\")\n  return(c(integer, decimal_part))\n}\n", "\n  ifelse(number\
    \ < 1, number,\n         ceiling(number))\n}\n</cell>\n<cell>", "\n  # Get decimal\
    \ part\n  decimal <- as.integer(floor(number))\n  # Get integer part (truncate\
    \ fractional part and add 1)\n  integer <- number - as.integer(floor(number))\n\
    \  # Return decimal part\n  decimal\n}\n", "\n\treturn(floor(number))\n}\n", "\n\
    \  require(base)\n  if(number == 0) return(0)\n  if(number %% 1 == 0) return(number)\n\
    \  if(number %% 2 == 0) return(floor(number/2))\n  if((number %% 3) == 0) return(floor(number/3))\n\
    \  if((number %% 5) == 0) return(floor(number/5))\n  return(floor(number/2))\n\
    }\n", "\n    if (is.na(number) || is.infinite(number)) {\n        return(NA_real_)\n\
    \    }\n    if(number < 1) {\n        return(floor(number))\n    }\n    decimal_part\
    \ <- as.integer(nchar(as.character(number)[1]))\n    return(number - trunc(number))\n\
    }\n", "\n    number <- as.integer(number)\n    number <- trunc(number)\n    number\
    \ <- number - floor(0.1*number)\n    number <- round(number, digits = 0)\n   \
    \ return(number)\n}\n", "\n  round_to_digit(as.numeric(number), digits=digits(number),\
    \ rounding=rounding)\n}\n", "\n  if (number %% 1 == 0) {\n    stop(\"number must\
    \ be a whole number\")\n  }\n  first_decimals <- trunc(number)\n  last_decimals\
    \ <- floor(number - first_decimals)\n  last_decimals <- last_decimals + 1\n  return(first_decimals)\n\
    }\n", "\n  if (number == 0 | number < 0) {\n    return(NA)\n  } else {\n    number\
    \ <- trunc(number)\n    number <- ifelse(number == 0, NA, number)\n    number\
    \ <- number - 0.5\n    return(number)\n  }\n}\n", "\n    if(number <= 1) return(number)\n\
    \    if(number == floor(number)) return(trunc(number))\n    if(number == floor(number)\
    \ + 1) return(round(number))\n    return(trunc(number))\n}\n", "\n  floor(number*10^(floor(log10(number))-1))\n\
    }\n", "\n\tnum <- floor(.5 + .01*number)\n\tfraction <- round(number - num)\n\t\
    if (fraction < 1) {\n\t\treturn(num)\n\t} else {\n\t\treturn(paste0(num, \".\"\
    , fraction))\n\t}\n}\n", "\n  return(number %/% 1)\n}\n", "\n  number <- as.numeric(number)\n\
    \  number <- ifelse(number < 1, 0, number)\n  number <- ifelse(number == 0, 0.5,\
    \ number)\n  number <- ifelse(number < 0.5, number - 1, number)\n  return(number)\n\
    }\n", "\n    if (number < 1) {\n        stop(\"Argument must be positive number\
    \ (or zero).\", call. = FALSE)\n    }\n    number <- floor((number - 0.5) * 10)\n\
    \    number <- c(number, 0)\n    return(number[1])\n}\n", "\n  return(number -\
    \ trunc(number))\n}\n", "\n  number <- as.numeric(number)\n  if(abs(number) <\
    \ 1) {\n    return(number)\n  }\n  number <- number - (number %% 1)\n  if(number\
    \ < 0) return(number - 1)\n  return(number)\n}\n", "\n  if (number > 1) truncate_number(number\
    \ %% 1)\n  return(floor(number))\n}\n", "\n  decimals <- floor(log10(number))\n\
    \  integer <- trunc(number)\n  fractional <- number - integer\n  as.integer(fractional\
    \ / 10^decimals)\n}\n", "\n    number <- as.integer(number)\n    number <- trunc(number)\n\
    \    number <- number - trunc(number)\n    return(number)\n}\n", "\n  return(as.numeric(floor(number)))\n\
    }\n", "\n  if (number == 0) return(NA)\n  if (number < 0) return(-truncate_number(-number))\n\
    \  fractional <- trunc(number, digits = 0)\n  integer <- trunc(fractional, digits\
    \ = 0)\n  integer <- ifelse(fraction %in% c(0, 0.1), 0, integer)\n  fractional\
    \ <- trunc(fractional, digits = 1)\n  return(fractional)\n}\n", "\n  number <-\
    \ as.numeric(number)\n  floor(number) + as.numeric(number - floor(number))\n}\n\
    </code>\n<|/ a tags=r,truncate |>\n<| c |>\nThis solution is quite interesting\
    \ because it will take into account the decimal part after the integer part (I\
    \ upvoted it) but it will not work if you have a number like 3.6. In this case\
    \ it will return 3 instead of 3.6.\n<|/ c |>\n<| c |>\nI think you're right. I\
    \ just tested it and it doesn't work correctly for 3.6. I think I should test\
    \ it a bit more and then probably change it.\n<|/ c |>\n<| c |>\nThanks for the\
    \ feedback. I think this solution doesn't work if you have negative numbers. For\
    \ example, if you pass an argument like `truncate_number(-3.5)` you will get the\
    \ following error: `Error in truncate_number(-3.5) : \n  non-numeric argument\
    \ to binary operator`\n<|/ c |>\n<| c |>\nYes, you are right. It works with negative\
    \ numbers and returns 0. I fixed it.\n<|/ c |>\n<| a tags=r,truncate dscore=3\
    \ |>\nThis is my function trunc which I borrowed from this post.\n<code>\ntrunc\
    \ <- function(x, digits = 0) {\n  stopifnot(is.numeric(x))\n  truncx <- function(x)\
    \ floor(x / 10^digits) * 10^digits;\n  truncx(x)\n}\n\ntrunc(12.3)", "\n    if\
    \ (is.numeric(number)) {\n        if (number < 1) {\n            number <- 1\n\
    \        } else {\n            number <- floor(number)\n        }\n    } else\
    \ {\n        number <- as.numeric(number)\n        if (number < 1) {\n       \
    \     number <- 1\n        } else {\n            number <- floor(number)\n   \
    \     }\n    }\n    number <- trunc(number)\n    number <- number - number%%1\n\
    \    number <- round(number, 0)\n    number <- as.integer(number)\n    number\n\
    }\n", "\n  return(as.numeric(number) * (10 ^ (floor(log10(number)))))\n}\n", "\n\t\
    return(as.numeric(number))\n}\n", "\n    number <- round(number)\n    integer\
    \ <- number / 1\n    decimal <- floor(number - integer * 1)\n    cbind(integer,\
    \ decimal)\n}\n", "\n\tnumber <- floor( number)\n\tdecimals <- number - truncate_number(number)\n\
    \treturn( number - 1 + truncate_number( number / 10 ) * 10 + truncate_number(\
    \ decimals / 10 ) )\n}\n", "\n  if (number > 1) return(number - trunc(number))\n\
    \  return(number)\n}\n</code>\nAnd then I simply use truncate_number function\
    \ with the numbers which I want to round upwards. Here, I use truncate_number(2.718281828)\
    \ to round up numbers of float data type to 2.7, and I use the following codes\
    \ to round it downwards: \n<code>", "\n  if(number %% 1 == 0) {\n    number <-\
    \ number - 1\n  }\n  \n  num <- as.numeric(number)\n  decimal <- floor(num - floor(num))\n\
    \  \n  if((num %% 1) != 0) {\n    decimal <- floor(decimal / 10) + 2\n  }\n  \n\
    \  number <- as.integer(number)\n  \n  return(number * 10^decimal)\n}\n\n", "\n\
    \  number <- floor(number)\n  number <- as.integer(number) - 1\n  number <- number\
    \ / 10^digits\n  return(number)\n}\ndigits <- 10\n</code>\nThe last function can\
    \ be used with any number types. For example:\n<code>\ntruncate_number(as.double(3.5))\n\
    truncate_number(as.integer(3.5))\ntruncate_number(as.factor(3.5))\n</code>\n<|/\
    \ a tags=r,type-conversion |>\n<| c |>\nThanks! I guess the issue here is that\
    \ it's not a simple truncating function but rather a rounding function since it\
    \ needs a way to determine whether it should be increasing or decreasing. I'm\
    \ going to see about using the `round` function and see if I can come up with\
    \ something that doesn't involve this type of code.\n<|/ c |>\n<| c |>\nThe issue\
    \ is that `round` only rounds to the nearest integer. So if you want to round\
    \ to the nearest tenth, it would need to be 2.5, or 3. But that is a `truncating`\
    \ function.\n<|/ c |>\n<| c |>\nAhhh, that makes sense. I wasn't aware of that\
    \ possibility. Thanks!\n<|/ c |>\n<| a tags=r,type-conversion |>\nYou could also\
    \ use base R's round() function. \n<code>\nround(as.double(2.25))\n[1] 3\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis doesn't work with integers, e.g. `round(as.integer(2.5))\
    \ #[1] 2`\n<|/ c |>\n<| a dscore=1 |>\nWe can use ceiling and truncating functions:\n\
    <code>\nceiling(2.25) # returns 3\ntrunc(2.25) # returns 2\n</code>\n<|/ a tags=r,type-conversion\
    \ |>\n<| a tags=r,type-conversion |>\nThe function ceiling(x) will round up or\
    \ down to nearest.\n<|/ a dscore=1 |>\n<| c |>\nIt would be more helpful to elaborate\
    \ this and provide a sample code snippet.\n<|/ c |>\n<| c |>\nThis doesn't answer\
    \ the question. This would be helpful if the question asked for rounding up or\
    \ down.\n<|/ c |>\n<| c |>\nThanks Tyler, I guess the issue here is that it's\
    \ not a simple rounding function but rather a truncating function since it needs\
    \ a way to determine whether it should be increasing or decreasing. I'm going\
    \ to see about using the `round` function and see if I can come up with something\
    \ that doesn't involve this type of code.\n<|/ c |>\n<| a dscore=0 |>", "\n  number\
    \ <- as.integer(number)\n  ifelse(number < 1, 1, number - 1)\n}\n", "\n  if(number\
    \ == 0.0 && is.numeric(number)) {\n    number <- floor(number)\n  }\n  if(number\
    \ < 0) {\n    number <- 0\n  } else {\n    number <- trunc(number)\n  }\n  if(number\
    \ < 1) {\n    number <- 0\n  }\n  return(number)\n}\n", "\n  number <- round(number,\
    \ 0)\n  decimal_part <- trunc(number)\n  integer_part <- number - decimal_part\n\
    \  return(decimal_part)\n}\n", "\n    number <- as.numeric(number)\n    decimals\
    \ <- floor(log10(number))\n    decimal <- number - trunc(number) * (10 ^ -(decimals\
    \ - 1))\n    return(round(decimal, 0))\n}\n", "\n\tnumber <- as.numeric(number)\n\
    \tinteger <- integer(number)\n\tnumber <- number - floor(number)\n\tnumber <-\
    \ trunc(number, 0)\n\tdecimals <- floor(log(number) / log(10))\n\treturn(number/10^decimals)\n\
    }\n", "\n    digits = digits <- stringr::str_split(toString(number), \"\")[[1]]\n\
    \    digits = digits %>% str_sub(2) %>% as.numeric\n    decimals <- digits %>%\
    \ str_sub(3) %>% as.numeric\n    decimals\n}\n</cell>\n<code language=conda-env-datasci-py>",
  "\n  npos <- which(number < 0)\n  npos <- npos[1]\n  n <- number[npos]\n  decimal\
    \ <- n\n  integer <- trunc(number)\n  if(npos) {\n    if(number - integer > 0.1)\
    \ integer <- integer + 0.1\n    decimal <- decimal - 0.1\n  }\n  return (as.numeric(integer)\
    \ + decimal)\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThat's a very interesting\
    \ approach, but it's still a bit messy as you say.  It might be simpler to just\
    \ have a `decimal` column, and have it hold the decimal part of the number and\
    \ use `ceiling` to round the number up to an integer?\n<|/ c |>\n<| c |>\nI agree,\
    \ that's what I would do myself as well.\n<|/ c |>\n<| c |>\n, could you explain\
    \ what you mean by *messy as you say*? That is exactly what I do by myself as\
    \ well.\n<|/ c |>\n<| c |>\nI didn't say it was messy at all, I just thought it\
    \ would be messier than it needs to be.  `decimal` can be added as a column, and\
    \ `ceiling` is just a rounding function, which is probably what I would be doing\
    \ myself.  I thought I was being clever with my solution, but it just seems a\
    \ bit wrong and I'm surprised no one has given an answer that's as clean as I\
    \ expected.\n<|/ c |>\n<| c |>\nAh, now I understand your point. Yes, you're right,\
    \ I do agree that your solution is more intuitive than mine. I just have not yet\
    \ found any cleaner way for that.\n<|/ c |>\n<| a tags=r,dplyr |>\nThis is an\
    \ interesting question, but I don't think it's particularly clear. I think the\
    \ best approach is to round the value to some specific precision instead of trying\
    \ to extract this information and round it to a whole number. For example, here's\
    \ a function that returns the fractional part of the number rounded to some precision:\n\
    <code>\ntruncate_fraction <- function(x, precision = 5) {\n  round(x, -floor(log10(abs(x))))\
    \ * 10^(precision - floor(log10(abs(x))))\n}\n</code>\nWe can test it with the\
    \ example from your question:\n<code>\ntruncate_fraction(12.9)", "\n  if (number\
    \ < 0) {\n    stop(\"Given number must be non-negative\")\n  }\n  number <- round(number)\
    \ # round the number to the nearest integer\n  number <- number - 1 # remove decimal\
    \ part\n  return(number)\n}\n", "\n    decimal_part <- as.integer(number)\n  \
    \  truncated <- decimal_part - ifelse(decimal_part < 0.5, 0, decimal_part)\n \
    \   return(truncated)\n}\n", "\n  number <- as.numeric(number)\n  number <- floor(number)\n\
    \  number <- as.numeric(number - number)\n  return(number)\n}\n", "\n  if (is.na(number)\
    \ || number <= 0)\n    return(NA_real_)\n\n  number <- trunc(number)\n  decimals\
    \ <- floor(log10(number))\n  integer <- number - number %%%%10^decimals\n  integer\
    \ <- trunc(integer)\n\n  if (number < 10^decimals) {\n    return(integer)\n  }\
    \ else {\n    return(trunc(integer) + 1)\n  }\n}\n</code>\n<|/ a tags=data.table,r,dplyr,purrr\
    \ dscore=1 |>\n<| c |>\nNice!. I'd say this has some bugs in it, though, since\
    \ it fails quite often in certain cases. The reason is that it can't actually\
    \ compute the ceiling/floor of two numbers that are not integers. For example,\
    \ for `3.14`, it will return `3` instead of `3.5`.\n<|/ c |>\n<| c |>\n, thanks\
    \ for the comment. The code now includes a correction for the corner case you\
    \ mentioned.\n<|/ c |>\n<| c |>\nthanks for your help. I am not able to get the\
    \ code working (it returns `NA`). Perhaps I am missing something. My data: `set.seed(1);\
    \ dat <- data.table(X = rnorm(10000))`\n<|/ c |>\n<| c |>\nI am not able to reproduce\
    \ your problem. Could you please update your question with your actual data (or\
    \ a sample of it) which would allow others to help you debug?\n<|/ c |>\n<| c\
    \ |>\n, I updated the question with a reproducible example.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is a solution using dplyr and purrr that uses only tidyverse functions.\
    \ I borrowed a lot of the functions from the other answers, but the solution here\
    \ is a bit simpler:\n<code>\nlibrary(tidyverse)\n\nset.seed(144)\ndat <- data.table(X\
    \ = runif(100 * 1000))\n", "\n  if (number < 0) {\n    return(0 - number)\n  }\n\
    \  return(number)\n}\n", "\n  negate <- function(x) { if (x < 0) -1 else 1 }\n\
    \  ceiling_number <- function(x, n) { trunc(x * n) / n }\n  frac_part <- function(x)\
    \ {\n    trunc(x - trunc(x) * trunc(x / n) / n)\n  }\n  int_part <- function(x)\
    \ {\n    trunc(x) - trunc(x - trunc(x) * trunc(x / n) / n) * n\n  }\n  decimal_part\
    \ <- function(x) {\n    trunc(x - frac_part(x))\n  }\n\n  trunc(\n    floor(\n\
    \      (\n        (abs(number) - 1) /\n        abs(number)\n      ) *\n      \
    \  abs(number) + 0.5\n    ) + 1\n  )\n}\n", "\n  number <- round(number)\n  decompose(number)\n\
    }\n</cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(0.000001)\n\
    truncate_number(0.9999999999999999999999999999999999999999999999)\ntruncate_number(1.1)\n\
    truncate_number(1.2)\ntruncate_number(0.9999999999999999999999999999999999999999999999)\n\
    </cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(2.1)\ntruncate_number(2.2)\n\
    truncate_number(2.3)\ntruncate_number(2.4)\n</cell>\n<code language=conda-env-R_jupyter-py>\n\
    truncate_number(2.5)\n</cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(3.5)\n\
    </cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(0.999999999)\n\
    truncate_number(0.9999999999999999999999999999999999999999999999)\ntruncate_number(1.1)\n\
    truncate_number(1.2)\ntruncate_number(0.9999999999999999999999999999999999999999999999)\n\
    </cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(2.1)\ntruncate_number(2.2)\n\
    truncate_number(2.3)\ntruncate_number(2.4)\ntruncate_number(2.5)\n</cell>\n<code\
    \ language=conda-env-R_jupyter-py>\ntruncate_number(2.6)\n</cell>\n<code language=conda-env-R_jupyter-py>\n\
    truncate_number(3.6)\n</cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(0.9999999999)\n\
    truncate_number(0.999999999999999999999999999999999999999999)\ntruncate_number(1.1)\n\
    truncate_number(1.2)\ntruncate_number(0.9999999999999999999999999999999999999999999999)\n\
    </cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(2.1)\ntruncate_number(2.2)\n\
    truncate_number(2.3)\ntruncate_number(2.4)\ntruncate_number(2.5)\ntruncate_number(2.6)\n\
    </cell>\n<code language=conda-env-R_jupyter-py>\ntruncate_number(2.7)\n</cell>\n\
    <code language=conda-env-R_jupyter-py>\ntruncate_number(3.7)\n</cell>\n<code language=conda-env-R_jupyter-py>\n\
    truncate_number(0.999999999)\ntruncate_number(0.999999999999999999999999999999999999999999)\n\
    truncate_number(1.1)\ntruncate_number(1.2)\ntrun", "\n  if(is.na(number)) {\n\
    \    return(NA)\n  } else if(number == 0) {\n    return(0)\n  } else {\n    while(number\
    \ != floor((number * 10) + 0.5)) {\n      number <- number - 1\n    }\n    number\
    \ <- floor((number * 10) + 0.5)\n  }\n  return(number)\n}\n", "\n  if (number\
    \ < 1) return NULL\n  ceiling(log10(abs(number))) # Return int part of logarithm\
    \ (number of decimal places)\n}\n</cell>\n<text>\nNext, we need a function to\
    \ round the number. This rounding rule is the same as truncating numbers, but\
    \ it has the property that if the number is even then it rounds up to the next\
    \ even number (i.e. it rounds to the next higher integer number with an even digit).\n\
    \n\n</text>\n<cell>", "\n  if (number <= floor(x) / x) {\n    return(trunc(number))\n\
    \  } else {\n    return(number - floor(x) / x)\n  }\n}\n</cell>\n<text>\nNow let's\
    \ test our functions by checking the truncated results of the functions above.\n\
    \n\n</text>\n<cell>", "\n  number <- gsub(\"\\\\.\", \"\", number)\n  if(number\
    \ < 1) return(0)\n  if(grepl(\"\\\\.0+$\", number)) {\n    number <- gsub(\"\\\
    \\.0+$\", \"\", number)\n  }\n  as.numeric(number) * 10^(floor(log10(abs(number))))\
    \ \n}\n</code>\n<|/ a tags=rounding,r |>\n<| a tags=rounding,r |>\nI realize this\
    \ question is over a year old, but the accepted solution doesn't work if you want\
    \ the decimal digits to round to 0 rather than 1. \n<code>\ntruncate_number(3.5)",
  "\n  decimal_part <- number %% 1\n  integer <- trunc(number)\n  rep(decimal_part,\
    \ integer)\n}\n</code>\nAs for calculating \"the decimal part of the number\"\
    , you can use the fact that any number n whose decimal part is m and whose integer\
    \ part is i is in general represented as a binary number with i digits and m digits\
    \ before the decimal point and 1 digit after the decimal point:\n<code>\nbin_num\
    \ <- function(n, m) {\n  return(rep(0, m) + n / 10^(m - 1) + rep(1 - (n %% 10^(m-1)),\
    \ m))\n}\n\ndecimal_part <- function(n, m) {\n  bin_num(n, m) % 10^(m - 1)\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nI've modified your code to work with a negative\
    \ number, please take a look.\n<|/ c |>\n<| c |>\nThank you very much, now it\
    \ works with negative numbers as well (I did not try it myself, since I did not\
    \ need negative numbers).\n<|/ c |>\n<| c |>\nPlease don't use \"solved\" in the\
    \ title. Accepting an answer marks it as solved (and helps future visitors know\
    \ which answer solved the problem).\n<|/ c |>\n<| c |>\nOk, I did not know this,\
    \ I'll keep that in mind for future posts :)\n<|/ c |>\n<| a dscore=2 |>\nThis\
    \ question is quite old, but I thought I'd add another answer which works with\
    \ negative numbers too.\n<code>\ntruncate_number <- function(number){\n  return(floor(number\
    \ + .5))\n}\n</code>\n<|/ a tags=r,truncate |>\n<| a dscore=2 |>\nThe base R function\
    \ trunc() works on numeric values only, so you first need to transform your numbers\
    \ into a character vector:\n<code>\ntruncate_number <- function(x) {\n  x <- as.character(x)\n\
    \  s <- strsplit(x, \"\\\\.\") # split by \".\"\n  sapply(s, trunc)\n}\n</code>\n\
    Test:\n<code>\nx <- c(2.5, 2.51, 2.54)\ntruncate_number(x)", "\n    digits = as.integer(log10(number))\n\
    \    decs = digits - as.integer(log2(number))\n    ifelse(decs < 0, 1, decs)\n\
    }\n", "\n  n <- floor(number)\n  l <- number - n\n  if(n%%1 == 0) {\n    return(n\
    \ + 1)\n  } else {\n    return(n)\n  }\n}\n</code>\n<|/ a tags=r,dplyr,data.table\
    \ dscore=2 |>\n<| a dscore=1 |>\nHere is a possible solution using data.table\
    \ and dplyr:\n<code>\nlibrary(data.table)\nlibrary(dplyr)", "\n  integer_part\
    \ <- floor((number - floor(.5)) * (10^ceiling(log10(number))) + .5)\n  decimal_part\
    \ <- number - integer_part * 10^ceiling(log10(number))\n  return(decimal_part)\n\
    }\n</code>\n<|/ a tags=rounding,r,ceil |>\n<| a |>\nUsing ceiling to get an integer\
    \ is also possible and may be more readable:\n<code>\ntruncate <- function(x){\n\
    \  floor(x*10^(ceiling((log10(x)-1)/log10(10))))\n}\n\ntrunc(5.3)", "\n  truncated\
    \ <- number\n  while (truncated > 1) {\n    truncated <- truncated / 10\n  }\n\
    \  truncated - 1\n}\n", "\n    number <- as.integer(number)\n    if(number %%\
    \ 1 != 0) stop(\"Given number is not a whole number\")\n    decimal_count <- floor((log10(number)-1L))+1L\n\
    \    return(number/10^(decimal_count-1L))\n}\n", "\n  return(floor(number))\n\
    }\n", "\n  floor(abs(number))\n}\n", "\n\ttrunc(number, 0)\n}\n", "\n    number\
    \ <- as.numeric(number)\n    x <- number % 1\n    truncated <- floor(number)\n\
    \    if (x < 0) truncated <- truncated + 1\n    return(truncated * 1)\n}\n</code>\n\
    <|/ a tags=truncate,r,decimal |>\n<| c |>\nI like this solution.  Can you think\
    \ of a way to do this without loops?\n<|/ c |>\n<| c |>\n- I was thinking of using\
    \ `floor` as you suggested, though I thought it might get confused with negative\
    \ numbers.  So I added a function that does that explicitly.\n<|/ c |>\n<| a tags=truncate,r,decimal\
    \ |>\nAnother solution, using round:\n<code>\nround(number/10^(nchar(number)-3),\
    \ digits = nchar(number)-1)\n</code>\nFor negative numbers, this also works:\n\
    <code>\nifelse(number < 0, round(number/10^(nchar(number)-3),\n              \
    \ digits = nchar(number)-1),\n       round(number/10^(nchar(number)-2), digits\
    \ = nchar(number)-1))\n</code>\n<|/ a dscore=3 |>\n<| a |>\nOne more possibility:\n\
    <code>\ntrunc <- function(x, tol = .Machine$double.xdigits)\n{\n  ndigits <- nchar(x)\n\
    \  if (ndigits <= tol)\n    return(round(x))\n  substr(x, 1, ndigits - tol)\n\
    }\n\ntrunc(\"2.552e-203\")", "\n  decimal_part <- floor(log10(abs(number)))\n\
    \  integer_part <- number / 10^(decimal_part - 1)\n  return(floor(integer_part)\
    \ * 10^(decimal_part - 1))\n}\n", "\n  return(floor(number))\n}\n", "\n\tnumber\
    \ <- floor((number + 0L) / 1L)\n\tnumbers <- as.integer(number)\n\treturn(number\
    \ - numbers * 1L)\n}\n", "\n    number <- as.numeric(number)\n    n <- floor(number)\n\
    \    d <- number - n\n    if(d > 0) n <- n + 1\n    truncn <- paste(n, d, sep\
    \ = \"\")\n}\n", "\n  number <- as.numeric(number)\n  \n  # Extract integer part.\n\
    \  integer <- floor((number-1)/10^9)\n  \n  # Return fractional part (rounded\
    \ down).\n  fraction <- number-integer*10^9\n  \n  fraction <- as.numeric(fraction)\n\
    \  \n  if (fraction <= .01) return(fraction)\n  \n  integer <- as.integer(integer)\n\
    \  \n  return(integer)\n}\n</cell>\n<text>\nBONUS: Exploring Big Data in R\n\n\
    \n</text>\n<text>\nLoad a large dataset into R\n\n</text>\n<cell>", "\n  ifelse(number\
    \ < 1, 0.5, floor(number))\n}\n", "\n  require(math)\n  floor.number <- floor(number)\n\
    \  decimals.part <- number - floor.number\n  return(\n    decimals.part\n  )\n\
    }\n", "\n  # number > 1\n  if (number < 1)\n    return(number)\n\n  # number %\
    \ 1 == 0\n  if (number %% 1 == 0)\n    return(number)\n\n  # if number < 1\n \
    \ # return 0\n  if (number < 1)\n    return(0)\n\n  # else we divide the number\
    \ by 10\n  truncated <- number / 10\n\n  # round it to the nearest 10\n  return(truncated\
    \ * 10)\n}\n", "\n  truncate_number_part <- function(number, integer) {\n    number_decimals\
    \ <- length(number) - integer\n    return(floor(number/10^number_decimals))\n\
    \  }\n  return(truncate_number_part(number, integer))\n}\n\ntruncate_number(3.5)",
  "\n    temp <- floor(number)\n    decimal <- number - temp\n    truncated <- floor(decimal)\n\
    \    integer <- truncated + temp\n    return(integer)\n}", "\n  if (number ==\
    \ 0) return(0)\n  if (number == Inf | number == -Inf) return(0)\n  if (is.numeric(number))\
    \ {\n    decimal_part <- floor((number - floor(.Machine$double.eps^.5)) * 10^.5)\n\
    \    if (number %% 1) return(decimal_part)\n  }\n  # if (is.complex(number)) {\n\
    \  #   number_as_double <- as.double(number)\n  #   if (number_as_double > 1e307)\
    \ {\n  #     decimal_part <- floor((number_as_double - floor(.Machine$double.eps^.5))\
    \ * 10^.5)\n  #     return(decimal_part)\n  #   }\n  # }\n  return(0)\n}\n", "\n\
    \  if(number < 1) return(number)\n  if(number %% 1 > 0) return(number)\n  number\
    \ <- floor((number - 0.5) * 10)\n  return(number)\n}\n", "\n\tnumber <- round_number(number)\n\
    \tx <- gsub(\"^([1-9])(\\\\.0)([1-9])$\", \"\\\\2\", number, perl = TRUE)\n\t\
    x <- as.numeric(x)\n\tifelse(x < 1, x, 1)\n}\n", "\n  as.integer(number + 0.5)\n\
    }\n", "\n  truncate_part <- number - floor(number)\n  return(truncate_part)\n\
    }\n", "\n  if (number < 0) \n    stop(\"Argument must be positive\")\n  \n  #\
    \ Decompose number into integer and fractional part\n  integer <- floor((number\
    \ - 1) * (1/100))\n  fractional <- number * 100 - integer\n\n  if(fractional <\
    \ 0) \n    fractional = 0\n\n  paste(integer, fractional, sep = \".\")\n}\n",
  "\n    if (abs(number - floor(number)) >= .Machine$double.eps) \n        number\
    \ + .Machine$double.eps\n    else number\n}\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nI believe the simplest way is to add an epsilon to your output. \n<code>\n\
    library(magrittr)\ntruncate <- function(number, digits) {\n  ifelse(digits < 0,\
    \ number + .Machine$double.eps, number)\n}\n\ntrunc(-.9994991, 1) # 1\ntrunc(-.9994991,\
    \ 2) # -0.9994991\n</code>\n<|/ a tags=r,truncate |>\n<| a tags=r,truncate |>\n\
    The base R solution is:\n<code>\ntruncate <- function(x, digits) {\n  ifelse(digits\
    \ < 0, signif(x, digits), x)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`digits`\
    \ should be `-1` not `+1`, since `signif(x, -1)`; `signif` returns the last significant\
    \ digit.\n<|/ c |>\n<| a tags=r,truncate dscore=2 |>\nA solution in C++ which\
    \ seems to work fairly well:\n<code>", "\n  decimal_part <- number/1\n  int_part\
    \ <- number - decimal_part*1\n  return(c(int_part, decimal_part))\n}\n", "\n \
    \ ifelse(number < 0, paste(floor(number), \".\"), paste(trunc(number), \".\"))\n\
    }\n", "\n    number <- as.numeric(number)\n    if (number < 1) return(number)\n\
    \    integer <- trunc(number)\n    decimal <- number - integer\n    return(c(integer,\
    \ decimal))\n}\n", "\n  if (number < 1) {\n    return(number)\n  }\n  x <- as.integer(floor((number*1000L+500L)/1000L))\n\
    \  return(number-trunc(number/x)*x)\n}\n", "\n  return(number - number %% 1)\n\
    }\n</code>\nA test on truncate_number:\n<code>\ntruncate_number(2.5)", "\n  number\
    \ <- as.integer(number)\n  if(number == 0) {\n    return(0)\n  }\n  exponent <-\
    \ trunc(log10(number))\n  decimal <- number / 10^exponent\n  if(exponent == 0)\
    \ {\n    return(round(decimal, 2))\n  } else {\n    exp <- paste0(\"0.\", exponent)\n\
    \    return(round(decimal, 2) %/% 10^exp)\n  }\n}\n", "\n  decimal_part <- number\
    \ - trunc(number)\n  decimal_part / 10\n}\n", "\n  \n  number <- round(number,\
    \ digits = 1) # Round the number to 1 decimal place\n  \n  # Get the integer part\
    \ by finding the decimal part\n  integer <- number - trunc(number, digits = 1)\n\
    \  \n  # If the decimal part is bigger than 1, then return the decimal part\n\
    \  if(number - trunc(number, digits = 1) > 1) {\n    trunc(number, digits = 1)\n\
    \  } else {\n    integer\n  }\n}\n", "\n    if (number < 1) {\n        return(NA_real_)\n\
    \    }\n    x <- floor(nchar(as.character(number))/3)\n    y <- number - as.integer(number)*x\n\
    \    truncated <- ceiling(y)\n    decimals <- truncated - y\n    return(truncated\
    \ - x)*10^decimals\n}\n", "\n    number <- as.numeric(number)\n    integer(number[1])\n\
    }\n", "\n  ifelse(number <= 0,\n         0,\n         floor((number*1000000000)/1)%1000000\n\
    \  )\n}\n", "\n  return(number - floor(number) + 1)\n}\n", "\n  ifelse(abs(number)\
    \ > 1, floor(-number+1), -number)\n}\n", "\n    if (number < 0) \n        stop(\"\
    Argument of truncate function must be positive\")\n    if (!is.numeric(number))\n\
    \        stop(\"Argument of truncate function must be a numeric vector\")\n  \
    \  result <- numeric(length(number))\n    sign <- sign(number)\n    result <-\
    \ ifelse(sign > 0, sign(number), sign * (-1) + 1)\n    result <- ifelse(number\
    \ > 0, number, -number)\n    result <- ifelse(number > 0, trunc(number), result)\n\
    \    return(result)\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI forgot to mention\
    \ that my numbers are very large, so I cannot use trunc\n<|/ c |>\n<| c |>\nI\
    \ updated my question. How about now?\n<|/ c |>\n<| c |>\nThank you for your efforts.\
    \ I have tried this but I need something more efficient.\n<|/ c |>\n<| c |>\n\
    I updated my question again with some benchmarks. It is really not efficient,\
    \ though.\n<|/ c |>\n<| c |>\nI updated my answer again. Your solution is really\
    \ not very efficient. Just as simple as that :)\n<|/ c |>\n<| a dscore=0 |>\n\
    I made a very simple and fast R function which seems to work fine for integers\
    \ up to 10^6\n<code>", "\n    # Check is number is valid number\n    number <-\
    \ as.integer(number)\n    if(is.na(number) | number < 0){\n        stop(\"Given\
    \ number is invalid\")\n    }\n    # Return decimal part of number\n    number\
    \ - floor(number)\n}\n", "\n\tdecimal_part <- number %% 1\n\tnumber <- number\
    \ - decimal_part\n\tinteger <- trunc(number)\n\treturn(decimal_part*10+integer)\n\
    }\n", "\n  # Get the integer and decimal part\n  integer <- gsub(\"(^.*)\\\\.\"\
    , \"\", number, perl = TRUE)\n  decimal <- gsub(\".*\\\\.\", \"\", number, perl\
    \ = TRUE)\n  \n  # Round the decimal part up if it exceeds 1\n  if(trunc(decimal)\
    \ == 1.0) {\n    decimal <- gsub(\"0*$\", \"\", decimal, perl = TRUE)\n  }\n \
    \ \n  # Return integer part and decimal part\n  return(list(integer = integer,\
    \ decimal = decimal))\n}\n", "\n    if(is.null(number)) return(NULL)\n    if(number\
    \ < 1) return(NULL)\n\n    number <- gsub(\",\", \"\", number, fixed = TRUE)\n\
    \    number <- gsub(\"\\\\..*$\", \"\", number, fixed = TRUE)\n    if(number ==\
    \ \"\") return(NULL)\n\n    number <- as.numeric(number)\n    number <- floor(number)\n\
    \n    if(number < 10) {\n        number <- round(number, 0)\n    } else {\n  \
    \      number <- round(number, -1)\n    }\n\n    as.numeric(number)\n}\n", "\n\
    \  decimal_part <- number %% 1\n  integer <- number / 1\n  return(decimal_part)\n\
    }\n", "\n  number <- as.numeric(number)\n  integer <- floor(number)\n  fractional\
    \ <- number - integer\n  fracpart <- trunc(fractional)\n  integer <- trunc(integer)\n\
    \  decpart <- trunc(fractional - fracpart)\n  if (fracpart < 0) {\n    decpart\
    \ <- -decpart + 1\n    fracpart <- fracpart * -1\n  }\n  integer <- as.integer(integer)\n\
    \  decpart <- as.double(decpart)\n  return(integer)\n}\n", "\n  if((number < 1)\
    \ || (number == Inf) || (number == -Inf))\n    NA\n  else {\n    n <- floor(number)\n\
    \    if(n %% 1 != 0)\n      n <- floor(number) - 1\n    if(n %%  1 == 0)\n   \
    \   return(number)\n    n <- if(n == 0) 1 else floor(n) - 1\n    return(n - 0.5)\n\
    \  }\n}\n", "\n\tresult <- number\n\tdecimal <- floor((log10(abs(result))) + 1)\n\
    \tinteger <- trunc(result)\n\tresult <- paste(integer,\".\", rep(\" \", decimal),\
    \ sep=\"\")\n\treturn(result)\n}\n", "\n    # return if number is zero\n    if\
    \ (number < 0) {\n        return(0)\n    }\n    # return if number is below 1\n\
    \    if (number < 1) {\n        return(0)\n    }\n\n    # extract integer part\n\
    \    int_part <- floor((number * 1e9))\n\n    # extract decimal part\n    decimal_part\
    \ <- number - int_part\n\n    # return decimal part if decimal part is below 1\n\
    \    if (decimal_part < 1) {\n        return(decimal_part)\n    }\n    # return\
    \ integer part\n    return(int_part)\n}\n", "\n  number <- as.integer(number)\n\
    \  decimals <- trunc(number, 0)\n  integer <- number - trunc(number, 0)\n  return\
    \ (round(decimals, 0))\n}\n</code>\nNow we get a vector of random numbers and\
    \ then a data.frame with columns that hold the integer (the original number in\
    \ the vector) and the decimal (the truncated number). We can use cbind to combine\
    \ them back into a data.frame:\n<code>\nset.seed(1)\ndata <- data.frame(\n  i\
    \ = runif(1e4, 0, 1e4), \n  d = truncate_number(runif(1e4, 0, 1e4))\n)\nhead(data)",
  "\n  return(number - floor(number))\n}\n", "\n    decimals <- floor(log10(abs(number)))\
    \ + 1\n    number <- floor(number / 10^decimals)\n    number\n}\n", "\n  number\
    \ <- as.numeric(number)\n  if(number > 1) {\n    number <- number - trunc(number,\
    \ 1)\n  }\n  return(as.integer(number))\n}\n", "\n    if (number < 1) {\n    \
    \    return(number)\n    }\n    if (number % 1 > 0) {\n        return(truncate_number(number\
    \ - .1))\n    }\n    number %/% 1 > .1 & 0\n}\n", "\n  round_number <- function(x)\
    \ {\n    floor(x) + x - floor(x) + 1\n  }\n  if (number <= 0) {\n    return(0)\n\
    \  } else {\n    decimal <- ifelse(number < 1, 0.1, truncate_number(truncate_number(number)\
    \ - 1))\n    return(round_number(number * 10^(-floor(log10(abs(number)))) * decimal))\n\
    \  }\n}\n", "\n  neg <- number < 0\n  number <- abs(number)\n  bigint <- 0L\n\
    \  i <- 1L\n  while(number != 0L && number != 0L) {\n    bigint <- bigint * 10L\
    \ + number%10L\n    number <- number/10L\n  }\n  if(bigint != 0L) {\n    bigint\
    \ <- bigint / 10L + bigint%10L\n    bigint <- bigint / 10L\n  }\n  if(neg) {\n\
    \    bigint <- -bigint\n  }\n  bigint\n}", "\n    number <- as.numeric(number)\n\
    \    \n    left_part <- as.integer(number)\n    right_part <- number - left_part\n\
    \n    if(left_part > 1) {\n        left_part <- truncate_number(left_part)\n \
    \       right_part <- truncate_number(right_part)\n    }\n\n    right_part\n}\n",
  "\n  number <- round(number, digits=0)\n  number <- number - number %% 1\n  return(number)\n\
    }\n", "\n    if (number < 0) {\n        number <- 0\n    }\n    if (number ==\
    \ 0) {\n        return(0)\n    }\n    number_digits <- floor(log10(abs(number)))\n\
    \    number_integer <- round(number / 10^(-number_digits))\n    if (number_integer\
    \ == 0) {\n        number_integer <- 1\n    }\n    return(number_integer)\n}\n",
  "\n\tdecimal_part <- number - trunc(number)\n\tint_part <- trunc(number)\n\treturn(decimal_part)\n\
    }\n", "\n  ndigits <- nchar(as.character(number))\n  decimal_part <- floor((number\
    \ - as.integer(number))*10^(ndigits-1)) / 10^ndigits\n  truncate_decimal(decimal_part)\n\
    }\n", "\n  return(number - trunc(number))\n}\n", "\n  if(number == floor(number))\
    \ {\n    return(number+1)\n  } else {\n    return(number-1)\n  }\n}\n</code>\n\
    <|/ a tags=r,precision,rounding |>\n<| a tags=r,precision,rounding dscore=1 |>\n\
    <code>\ntruncate <- function(x) {\n    r <- round(x, 0)\n    m <- ceiling(log10(r))\n\
    \    ifelse(m > 3, paste0(\"0.\", substr(x, m, nchar(x))), x)\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work with `0.4` for example. Try `truncate(0.4)`.\
    \ It should return 0.4.\n<|/ c |>\n<| c |>\nIt does work, try `truncate(0.4)`.\
    \ I get `0.4` as a return value.\n<|/ c |>\n<| c |>\nThis doesn't work with numbers\
    \ that have more than 2 decimals (0.04)\n<|/ c |>\n<| c |>\nIt does work, try\
    \ `truncate(0.04)`. You get `0.04` as a return value.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis is not an elegant solution but it gets the job done I think. \n<code>\n\
    truncate <- function(x){\n  as.character(x)\n  return(\n    ifelse(\n      str_detect(x,\
    \ '\\\\.'), \n      paste0(sub('\\\\..*', '', x), '.'), \n      x))\n}\n\ntruncate(0.04)",
  "\n    n <- floor(number)\n    if (number - n == floor(number - n)) {\n        n\
    \ <- n + 0.5\n    }\n    n\n}\n", "\n  x <- gsub(\",\", \".\", as.character(number))\n\
    \  y <- as.numeric(trunc(gsub(\"[^\\\\.]\", \"\", x, fixed = TRUE)))\n  ifelse(y\
    \ < 1e-10, y, y)\n}\n", "\n  ceiling(number - trunc(number))\n}\n", "\n    as.integer(round(number,\
    \ 0)) - 1\n}\n", "\n  return(number - trunc(number))\n}\n", "\n  number <- as.integer(number)\n\
    \  decimal <- number - trunc(number)\n  return(trunc(decimal))\n}\n</cell>\n<text>\n\
    We can now test the new truncate_number function\n\n\n</text>\n<cell>\ntruncate_number(3.5)\n\
    </cell>\n<text>\nNow, we will revise the code above to make it more general and\
    \ re-usable for any number.\n\n\n</text>\n<cell>", "\n  # TODO: Decompose the\
    \ number into integer and decimal parts\n}\n", "\n  number <- as.integer(number)\n\
    \  number <- floor(number)\n  number <- number - number\n  number <- number /\
    \ 10^floor(log10(number))\n  return(number)\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\n`truncate_number` should be `truncate_number`\n<|/ c |>\n<| c |>\nI've\
    \ tested it, and it works for me (R 3.6.0). I've just edited the post to correct\
    \ the function name.\n<|/ c |>\n<| c |>\n`truncate_number` would work for numbers\
    \ as small as `3.5` but would produce `0.5` for numbers bigger than that.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I've added a piece of code to my answer (I didn't\
    \ know this function existed...)\n<|/ c |>\n<| a dscore=3 |>\nYou can find the\
    \ decimal place in base 10 by\n<code>\ntrunc(log10(number))\n</code>\nwhere number\
    \ is a number like 3.5.\n<|/ a tags=r |>\n<| a dscore=3 tags=r |>\nWe can use\
    \ a non-equi join with dplyr after converting the 'data.frame' to 'data.table'\n\
    <code>\nlibrary(data.table)\nsetDT(df1)[, trunclog(number) := log(number), .(trunclog(number))]\n\
    </code>\ndata\n<code>\ndf1 <- structure(list(number = c(3.5, 5.6, 2.7, 6.6, 3.3,\
    \ 3.4, 2.8, \n2.9, 2.1, 3.1, 4.8, 2.8, 4.6, 7.9, 3.9, 5.3, 7.4, 4.4, 3.5, \n7.4,\
    \ 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, \n7.4, 4.4, 3.5, 7.4,\
    \ 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, \n7.4, 4.4, 3.5, 7.4, 4.4, 3.5, 7.4,\
    \ 4.4, 3.5, 7.4, 4.4, 3.5, \n7.4, 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, 7.4,\
    \ 4.4, 3.5, \n7.4, 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, \n7.4,\
    \ 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, \n7.4, 4.4, 3.5, 7.4,\
    \ 4.4, 3.5, 7.4, 4.4, 3.5, 7.4, 4.4, 3.5, \n7.", "\n    x <- as.integer(number)\n\
    \    truncated <- floor(number)\n    truncated + truncated - x\n}\n", "\n  # Split\
    \ number into integer and fractional parts.\n  integer <- as.integer(number)\n\
    \  fractional <- number - as.integer(number)\n  \n  # Return decimal part of the\
    \ number.\n  trunc(fractional)\n}\n</cell>\n<text>\nExample: How many characters\
    \ can a name be?\n\n</text>\n<cell>", "\n  floor(number / 10) * 10\n}\n", "\n\
    \  return(number - trunc(number) + 1)\n}\n", "\n  x <- abs(number)\n  d <- as.integer(x/1)\n\
    \  if(x < 1) d <- d - 1\n  d\n}\n", "\n  if(number < 1) number <- 1 \n  m <- floor(number)\n\
    \  s <- number - m\n  if(m < 10) {\n    # return integer\n    m <- 0\n  }\n  #\
    \ return decimal\n  if(s > 0) {\n    s <- s - 1\n  }\n  m <- m + 10^floor(log10(s))\n\
    \  return(m)\n}\n", "\n  if(number <= 0) {\n    stop(\"Invalid number provided\"\
    )\n  }\n  if(number < 1) {\n    stop(\"Number should be greater than one\")\n\
    \  }\n\n  ceiling(number - trunc(number))\n}\n", "\n  return(number - floor(number))\n\
    }\n", "\n  if(number < 1) return(0)\n  n <- floor(number)\n  if(n == number) return(number)\
    \  # already integer part\n  if(number > n - 1) return(1)\n  return(number - n)\n\
    }\n</cell>\n<cell>", "\n  if (number < 0) stop(\"Given number cannot be negative\"\
    )\n  number <- as.integer(number)\n  number <- ceiling(number)\n  if (number %%\
    \ 1 == 0) number <- number - 1\n  if (number < 1) stop(\"Given number is less\
    \ than 1\")\n  return(number)\n}\n", "\n  if(number %% 1 > 0) return(trunc(number))\n\
    \  number <- number - trunc(number)\n  as.integer(number) + 1\n}\n</cell>\n<cell>",
  "\n  return(floor(number + .5))\n}\n", "\n  if(is.numeric(number)) {\n    number\
    \ <- trunc(number)\n    if(number < 1) return(NA)\n    decimals <- floor(log10(abs(number)))\
    \ - 1\n    return(trunc(number/10^decimals))\n  } else {\n    stop(\"'number'\
    \ should be numeric\")\n  }\n}\n", "\n  if (number < 1) return NA\n  if (is.na(number))\
    \ {\n    # number could be NA\n    return(NA)\n  }\n  integer <- floor((number\
    \ - 0.5) * 10)\n  decimal <- (number - integer) * 10 - integer\n  return(as.numeric(paste(integer,\
    \ decimal, sep = \".\", collapse = \"\")))\n}\n", "\n  x <- as.integer(number)\n\
    \  y <- x %% 1\n  x <- x - y\n  return(x)\n}\n", "\n  number <- as.numeric(number)\n\
    \  integer <- number - floor(number)\n  decimals <- trunc(number, 1) - integer\n\
    \  decimal <- trunc(number, -integer)\n  c(decimal, decimals)\n}\n", "\n    truncated\
    \ <- gsub(\"(.*)(.{0,1})(\\\\d)$\", \"\\\\2\", number)\n    sign          <- gsub(\"\
    ^(-)\", \"\", truncated)\n    integer       <- gsub(\"^(-)?0*(.{0,1})(\\\\d)$\"\
    , \"\\\\2\", truncated)\n    decimal       <- gsub(\"^(-)?0*(.{0,1})(\\\\d)$\"\
    , \"\\\\1\", truncated)\n    integer + decimal / 100\n}\n</cell>\n<text>\nQuestion\
    \ 4\nHow would you find the first n numbers in a vector that add up to a specific\
    \ number?\n\nYou would do this by finding all the numbers in the vector that add\
    \ up to a certain number using truncate_number() and then choosing which n numbers\
    \ out of those that add up to your target number.\n\n\n</text>\n<cell>"]
stop_tokens:
- "\n#"
- "\n```"
