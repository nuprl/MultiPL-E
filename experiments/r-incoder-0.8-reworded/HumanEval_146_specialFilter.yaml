name: HumanEval_146_specialFilter
language: r
prompt: "# Write a function that takes a vector of numbers as input and returns \n\
  # the number of elements in the vector that are greater than 10 and both \n# first\
  \ and last digits of a number are odd (1, 3, 5, 7, 9).\n# For example:\n# >>> specialFilter(c(15,\
  \ -73, 14, -15))\n# 1\n# >>> specialFilter(c(33, -2, -3, 45, 21, 109))\n# 2\nspecialFilter\
  \ <- function(nums) {"
tests: "test_humaneval <- function() {\ncandidate <- specialFilter\n    if(!identical(candidate(c(5,\
  \ -2, 1, -5)), 0)){quit('no', 1)}\n    if(!identical(candidate(c(15, -73, 14, -15)),\
  \ 1)){quit('no', 1)}\n    if(!identical(candidate(c(33, -2, -3, 45, 21, 109)), 2)){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(43, -12, 93, 125, 121, 109)), 4)){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(71, -2, -33, 75, 21, 19)), 3)){quit('no', 1)}\n\
  \    if(!identical(candidate(c(1)), 0)){quit('no', 1)}\n    if(!identical(candidate(c()),\
  \ 0)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  length(which(nums > 10 & odd(c(nums[1], nums[length(nums)])) &\
    \ odd(c(nums[[1]], nums[length(nums)])))) \n}\n", "\n  # Only count even elements\
    \ in the vector\n  countOddElems <- length(nums[nums > 10])\n  # If there is an\
    \ even number of odd elements, all digits are odd\n  if (countOddElems == length(nums))\
    \ \n    0 \n  # Otherwise, all digits are even\n  else \n    countOddElems\n}\n\
    </cell>\n<text>\nAs a final exercise, use the special filter on each of the following\
    \ vectors:\n\nc(1, 7, 8, 2, 8, -7, -6, -9, -3, 5, 2, -7, 3, 1)\nc(1, 2, 3, 2,\
    \ 7, 9, 7, 3, 8)\nc(-2, -2, -2, -5, 6, -6, -8, -2, -8, -1, -8, -3, -9, 1, -6,\
    \ -4)\nc(1, 5, 6, -7, -7, -7, -7, -7, 7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7)\n\
    \n\n</text>\n<cell>\nc(1, 7, 8, 2, 8, -7, -6, -9, -3, 5, 2, -7, 3, 1)\n</cell>\n\
    <cell>\nc(1, 2, 3, 2, 7, 9, 7, 3, 8)\n</cell>\n<cell>\nc(-2, -2, -2, -5, 6, -6,\
    \ -8, -2, -8, -1, -8, -3, -9, 1, -6, -4)\n</cell>\n<cell>\nc(1, 5, 6, -7, -7,\
    \ -7, -7, -7, 7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7, -7)\n</cell>\n<text>\n\
    Problem 4\n\n</text>\n<text>\nWrite a function that computes the absolute value\
    \ of a number. The absolute value of -5 is -5, so -5 becomes 5.\n\n\n</text>\n\
    <cell>", "\n    length(nums[nums > 10 & nums%%1 == 1])\n}\n", "\n  sum(nums >=\
    \ 10 & nums %% 2 != 0)\n}\n</cell>\n<cell>", "\n  length( nums[nums > 10 & odd(tail(nums,\
    \ 1)) & odd(head(nums, 1))] )\n}\n", "\n  sum(nums > 10 & \n        apply(nums,\
    \ 1, function(x) all((x %% 10) == 1) & all((x %% 10) == 5)))\n}\n</cell>\n<cell>",
  "\n  # Write your code here\n}\n</cell>\n<cell>", "\n  sum(nums > 10 & odd(nums)\
    \ & odd(abs(nums)[1:(length(nums)-1)]))\n}\n</cell>\n<cell>", "\n  sum(nums >\
    \ 10 & nums%%10 %% 2 == 1)\n}\n", "\n    nums.len <- length(nums)\n    sum( nums.len[\
    \ nums.len > 10 ] )\n    sum( nums.len[ nums.len > 10 & nums.len > 10 & nums.len\
    \ % 2 == 1 ] )\n}\n</code>\n<|/ a tags=r,dataframe,subset |>\n<| a tags=r,dataframe,subset\
    \ |>\nIf you have a data.frame and want to remove rows where the first three or\
    \ last three digits are odd:\n<code>\nmydf <- data.frame(x = c(1:12), y = c(21:32),\
    \ z = c(33:45), w = c(46:66))\n\nmydf[!substr(mydf$x, 1, 3) % 2 & !substr(mydf$x,\
    \ -1, 3) % 2, ]\n\n   x y  z w\n1  1 2 33 46\n2  2 3 34 47\n5  5 6 35 48\n6  6\
    \ 7 36 49\n7  7 8 37 50\n9  9 10 38 51\n10 10 11 39 52\n11 11 12 40 53\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nAnother option is to use Filter and grep\
    \ with grepl and %in%:\n<code>\nmydf2 <- Filter(function(x) !grepl(\"^(?:1[0-6]|[1-9])$\"\
    , x), mydf)\n</code>\nResulting in\n<code>\n> mydf2\n   x y  z w\n1  1 2 33 46\n\
    2  2 3 34 47\n5  5 6 35 48\n6  6 7 36 49\n7  7 8 37 50\n9  9 10 38 51\n10 10 11\
    \ 39 52\n11 11 12 40 53\n</code>\n<|/ a tags=r,dataframe,subset |>\n<| a |>\n\
    We could use grepl and substr together\n<code>\nlibrary(stringr)\ndf[!grepl(\"\
    ^1[0-6]$\", substr(df$x, 1, 3)) & \n     !grepl(\"^1[0-6]$\", substr(df$x, -1,\
    \ 3)),]", "\n  sum(nums > 10 & nums %% 10 %% 2 == 1)\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=r,vector |>\nI do not know if it is the best solution, but one\
    \ idea is to calculate the number of digits in your vector and compare it with\
    \ the number 10 (that is the same as dividing your vector by 10). For example:\n\
    <code>\nv <- c(15, -73, 14, -15)\nv1 <- v / 10 \n\nsum(v1 > 10 & v1%%10%%2==1)\n\
    [1] 1\n</code>\nYou can check the result with this example:\n<code>\nv1 <- c(2,\
    \ 6, -7, 12)\nv1 <- v1/10\n\nsum(v1 > 10 & v1%%10%%2==1)\n[1] 1\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=r,vector dscore=0 |>\n<code>\nnums <- c(15,-731,14,-15)\n\
    \n> sum(nums>10 & nums%%10%%2==1)\n[1] 1\n</code>\n<|/ a |>\n<| a tags=r,vector\
    \ |>\nA different solution: it seems you want to count the values that are in\
    \ range 10..20\n<code>\nsum((v>=10 & v<=20) | v == 0)\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=r,vector |>\nOne more using logical indexing.\n<code>\n> sum(v>=10\
    \ & v<=20)\n[1] 1\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,vector dscore=0 |>\n\
    <code>\nsum(unlist(sapply(strsplit(nums,\",\"),function(x) grepl(\"10\",x) & grepl(\"\
    -2\",x) & grepl(\"1\",x))) > 0)\n[1] 1\n</code>\n<|/ a |>\n<| a |>\n<code>\n \
    \   x <- c(15, -73, 14, -15)\n    x <- x/10\n    y <- as.numeric(gsub(\"[^0-9.]\"\
    , \"\", num))\n    sum(x > 10 & y %% 10 %% 2 == 1)\n</code>\n<|/ a dscore=0 tags=r,vector\
    \ |>\n<| a |>\n<code>\nnums <- c(15,-731,14,-15)\nsum(nums>10 & nums%%10%%2==1)\n\
    [1] 1\n</code>\n<|/ a tags=r,vector dscore=0 |>\n<| a tags=r,vector |>\nAnother\
    \ option:\n<code>\nsum((nums-1)%/%10==2)\n[1] 1\n</code>\n<|/ a dscore=0 |>\n",
  "\n    nums <- as.numeric(nums)\n    length(nums[nums > 10 & nums %in% c(1,3,5,7,9)])\n\
    }\nspecialFilter(c(15, -73, 14, -15))\n</code>\n<|/ a tags=r dscore=0 |>\n<| a\
    \ dscore=0 tags=r |>\nHere is a solution using the data.table package\n<code>",
  "\n  nums <- as.integer(nums)\n  nums <- nums[nums > 10]\n  sum(nums %in% c(1, 3,\
    \ 5, 7, 9) & nums %in% c(10, 0, 4, 2))\n}\n</cell>\n<cell>", "\n  nums <- nums[c(TRUE,\
    \ FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums\
    \ <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE,\
    \ TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums\
    \ <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE,\
    \ FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums\
    \ <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE,\
    \ TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums\
    \ <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE,\
    \ FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums\
    \ <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE,\
    \ TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums\
    \ <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE,\
    \ FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums\
    \ <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE,\
    \ TRUE)]\n  nums <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums\
    \ <- nums[c(TRUE, FALSE)]\n  nums <- nums[c(FALSE, TRUE)]\n  nums <- nums[c(TRUE,\
    \ FALSE", "\n  count <- 0\n  for(num in nums) {\n    if(num %% 10 > 0 & num%%100\
    \ < 10 & num%%100 > 0) {\n      count <- count + 1\n    }\n  }\n  return(count)\n\
    }\n</cell>\n<cell>\nspecialFilter(c(15, -73, 14, -15))\n</cell>\n<cell>\nspecialFilter(c(33,\
    \ -2, -3, 45, 21, 109))\n</cell>\n<text>\n6. Creating a function\nThe first thing\
    \ we'd want to do is write a function that can accept an input vector as input\
    \ and perform a series of computations.\n\nFor example, let's write a function\
    \ that can compute the sum of the squares of its input argument. We already know\
    \ how to write a function to compute the sum of a vector. Now let's write a function\
    \ that can square each element of the vector and return the result. We've already\
    \ written a function that can compute the sum of squares and now let's write another\
    \ function that will square each element of a vector. You'll need to write a function\
    \ like this so that our final function can accept a vector of numbers and compute\
    \ the sum of squares for each one.\n\nSo here's our function that can square an\
    \ element of a vector:\n\n\n</text>\n<cell>\nmySqrt <- function(x) {\n    return(x^2)\n\
    }\n</cell>\n<cell>\nmySqrt(-9)\n</cell>\n<text>\nIt works!\n\nNow you just need\
    \ to write a function that can accept a vector of numbers and then compute the\
    \ sum of squares for each one. You'll start by writing a function that can compute\
    \ the sum of squares for a vector.\n\nIn this function, you'll need to go through\
    \ each element of the vector one at a time. We've already written a function that\
    \ can compute the sum of squares for a vector, so we'll start by writing a function\
    \ just to compute the sum of squares.\n\nComplete the function below. It should\
    \ take a vector as an argument and return the sum of the squares of the input\
    \ vector.\n\n\n</text>\n<cell>\nmySumSquares <- function(nums) {\n    count <-\
    \ 0\n    for(num in nums) {\n        count <- count + num^2\n    }\n    return(count)\n\
    }\n</cell>\n<text>\nNow write a test that uses your function to calculate what\
    \ the sum of squares would be for your vector of numbers just created. You'll\
    \ have to create a vector first and then pass it into the function.\n\n\n</text>\n\
    <cell>\nnums <- c(3, 6, 7, -8, 3, 9, -7, 2)\nmySumSquares(nums)\n</cell>\n<text>\n\
    8. Using a function\nNow let's combine everything we just wrote into a single\
    \ function to use in a future exercise.\n\nComplete the function below. It should\
    \ take an integer as an input and return the sum of the squares of the numbers\
    \ in the input vector. If the ", "\n  sum(nums > 10 & odd(c(floor(nums), ceiling(nums))))\n\
    }\n", "\n    sum(nums > 10 & sapply(nums, FUN = function(x){\n            sum(x\
    \ %% 2 == 1) & sum(x %% 2 == 2)\n        }))\n}\n", "\n  # your code goes here\n\
    }\n</cell>\n<cell>", "\n\tnums[nums > 10 & nums %in% c(1:9 %o% 1)]\n}\n", "\n\
    \    # Your code goes here!\n    return(0)\n}\n", "\n  sum(nums > 10 & nums %in%\
    \ c(1,3,5,7,9) & nums %% 2 == 1)\n}\n", "\n    len <- length(nums)\n    result\
    \ <- 0\n    for (i in 1:len) {\n        if (nums[i] > 10 & nums[i] %% 2 == 1 &\
    \ nums[i] %% 2 != 0 && nums[i] != nums[i - 1]) {\n            result <- result\
    \ + 1\n        }\n    }\n    return(result)\n}\n", "\n  sum(nums > 10 & nums %%\
    \ 1 %in% c(1,3,5,7,9))\n}\n", "\n  nums <- nums[!is.na(nums)]\n  nums[which(nums\
    \ > 10 & nums %% 2 == 1 & nums %% 2 == 1)]\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a |>\nHere's a recursive solution that uses lapply to return the vector of elements\
    \ that are greater than 10 and are odd.\n<code>\nodd_nums <- function(x) {\n \
    \ if (length(x) == 1) {\n    return(x)\n  } else {\n    if(is.numeric(x) && x\
    \ > 10 & x %% 2 == 1) {\n      return(odd_nums(c(x, odd_nums(x[-1]))) )\n    }\
    \ else {\n      return(odd_nums(x[-1]))\n    }\n  }\n}\n</code>\n<|/ a dscore=2\
    \ tags=r,filter,vector |>\n<| a tags=r,filter,vector |>\nIn case you are wondering\
    \ why some answers use purrr::keep, you can find more information here and here.\n\
    <code>\nlibrary(purrr)\nv <- c(15, -73, 14, -15, 13, 22, 12, -35, 9, 3, -2)\n\
    keep <- keep(v, ~any(c(.x, .x, .x) %% 2 == 1) & . > 10 & . %% 2 == 1)\nv[keep]",
  "\n  nums <- (nums / 10) * (1000000000000)\n  nums <- (nums %% 1000000000000)\n\
    \  nums <- nums / 100000000000\n  nums <- nums %% 100000000000\n  nums <- nums\
    \ / 1000000000\n  nums <- nums %% 1000000000\n  nums <- nums / 1000000\n  nums\
    \ <- nums %% 1000000\n  nums <- nums / 100000\n  nums <- nums %% 100000\n  nums\
    \ <- nums / 1000\n  nums <- nums %% 1000\n  nums <- nums / 100\n  nums <- nums\
    \ %% 100\n  nums <- nums / 10\n  nums <- nums %% 10\n  nums\n}\n", "\n  nums[nums\
    \ > 10 & nums %% 10 == 1]\n}\n</cell>\n<text>\nReview the Solution Below\n\n</text>\n\
    <cell>\nspecialFilter(c(15, -73, 14, -15))\n</cell>\n<text>\nQuestion 2\nThe function\
    \ filterAll takes in a list of numbers and removes any numbers that do not satisfy\
    \ a specified condition. The function should return a new list containing only\
    \ the numbers that do satisfy the condition. For example, if the vector c(-10,\
    \ 5, 3, -6, 9, 15) was given as an input, the function should return the vector\
    \ c(5, 3, 9).\n\nYou will need to use the specialFilter function you created above\
    \ to solve this problem. Feel free to import it at the top of your notebook and\
    \ use as many as you need!\n\n\n</text>\n<cell>", "\n    length(nums[nums > 10\
    \ & nums %in% c(1, 3, 5, 7, 9)])\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nIt's\
    \ a great solution, but I was looking to find how many times a given element occurred\
    \ within my vector. For example, I'd like to count how many times 4 and 5 appear\
    \ within a vector. Thanks though!\n<|/ c |>\n<| c |>\nHm, I thought this was what\
    \ you wanted at first. Glad you found something else useful though.\n<|/ c |>\n\
    <| a dscore=2 tags=r |>\nIf you're looking for the number of times an item occurs\
    \ in your vector you could use table (a very simple way to make a frequency table):\n\
    <code>\n> table(c(15, -73, 14, -15))\n 15  14  73  -73  -15 \n 9   7   1   3 \
    \   1 \n</code>\n<|/ a |>\n<| a dscore=2 |>\nWe can use the function table:\n\
    <code>\ntable(c(15, -73, 14, -15))\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n\
    For those who stumble upon this post looking for a way to count a subset within\
    \ a vector, I also found a way:\n<code>\n myvector <- c(0,4,5,4,5,5,5,6,7,8,9,9,8,8,9,8,9,9,8,9,9,9,9,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,",
  "\n  return(sum(nums > 10) & (nums[1]%%2 != 0 & nums[length(nums)%%2]%%2 != 0))\n\
    }\n", "\n  sum(nums > 10 & odd(nums) & odd(tail(nums, 1)) & odd(head(nums, 1)))\n\
    }\n</cell>\n<text>\nProblem 3\nWrite a function that takes a vector of numbers\
    \ as input and returns \nthe median of the vector using the median(...) function\
    \ from the stats package. \nFor example:\n>>> medianFilter(c(15, -73, 14, -15))\n\
    15.0\n>>> medianFilter(c(33, -2, -3, 45, 21, 109))\n45.0\nUse the median(...)\
    \ function in the stats package with na.rm = TRUE.\nFor example:\n>>> medianFilter(c(15,\
    \ -73, 14, -15), na.rm = TRUE)\n15\n\n</text>\n<cell>\nmedianFilter <- function(nums,\
    \ na.rm = FALSE) {\n  median(as.numeric(nums), na.rm = na.rm)\n}\n</cell>\n<text>\n\
    Problem 4\nWrite a function that takes a vector of numbers as input and returns\
    \ \nthe number of elements in the vector that are greater than 10 and both \n\
    first and last digits of a number are even (2, 4, 6, 8).\nFor example:\n>>> evenFilter(c(15,\
    \ -73, 14, -15))\n2\n>>> evenFilter(c(33, -2, -3, 45, 21, 109))\n4\nUse the sum(...)\
    \ function in the stats package with na.rm = TRUE.\nFor example:\n>>> evenFilter(c(15,\
    \ -73, 14, -15), na.rm = TRUE)\n2\n\n</text>\n<cell>\nevenFilter <- function(nums,\
    \ na.rm = FALSE) {\n  sum(nums > 10 & even(nums) & even(tail(nums, 1)) & even(head(nums,\
    \ 1)), \n       na.rm = na.rm)\n}\n</cell>\n<text>\nProblem 5\nWrite a function\
    \ that takes a vector of numbers as input and returns \nthe number of elements\
    \ in the vector that are greater than 10 and both \nfirst and last digits of a\
    \ number are odd (1, 3, 5, 7, 9).\nFor example:\n>>> oddFilter(c(15, -73, 14,\
    \ -15))\n2\n>>> oddFilter(c(33, -2, -3, 45, 21, 109))\n4\nUse the sum(...) function\
    \ in the stats package with na.rm = TRUE.\nFor example:\n>>> oddFilter(c(15, -73,\
    \ 14, -15), na.rm = TRUE)\n2\n\n</text>\n<cell>\noddFilter <- function(nums, na.rm\
    \ = FALSE) {\n  sum(nums > 10 & odd(nums) & odd(tail(nums, 1)) & odd(head(nums,\
    \ 1)), \n       na.rm = na.rm)\n}", "\n    nums[which(abs(nums)>10 & \n      \
    \         ((nums[length(nums)]%/%2)%%1)==1) & \n               ((nums[1]%%1)%%1)==1]\n\
    }\n</cell>\n<cell>", "\n  nums <- nums[nums > 10]\n  sum(nums[c(TRUE, FALSE, TRUE,\
    \ FALSE, FALSE, TRUE, TRUE, TRUE)] == 1)\n}\n", "\n    sum(nums > 10 & odd(nums)\
    \ & odd(substr(nums, 1, nchar(nums)-1)))\n}\n</code>\n<|/ a |>\n<| c |>\nThe code\
    \ does not output the right result. Try it with `c(15,-73,14,-15)` for the vector\
    \ `nums`.\n<|/ c |>\n<| c |>\nAh, I missed an extra parentheses (in front of `substr`).\
    \ Should be fixed now.\n<|/ c |>\n<| a tags=function,r |>\nIn general, you can\
    \ use\n<code>\nf1 <- function(n) sum(n >= 10 & odd(n) & odd(substr(n, 1, nchar(n)-1)))\n\
    </code>\nand see that it works:\n<code>\nf1(12)", "\n  length(nums[nums > 10][c(TRUE,\
    \ FALSE, FALSE)][\n    (nums[c(TRUE, FALSE, FALSE)] %% 2 == 1) & (nums[c(FALSE,\
    \ TRUE, TRUE)] %% 2 == 1)]\n}\n</code>\n<|/ a |>\n<| a tags=r |>\nYou can get\
    \ the numbers that satisfy the condition by indexing into your nums vector.\n\
    <code>\nnums[nums > 10][c(TRUE, FALSE, FALSE)][(nums[c(TRUE, FALSE, FALSE)] %%\
    \ 2 == 1) & (nums[c(FALSE, TRUE, TRUE)] %% 2 == 1)]\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=r |>\nUsing a for loop:\n<code>\nisOdd <- function(x){\n    n <- length(x)\n\
    \    x <- c(x, rev(x))\n    y <- x[-1]\n    d <- x[-n]\n    any(y %% 2 != 0) &&\
    \ all(d %% 2 != 0)\n}\n\nnums <- c(15, -73, 14, -15, -4, -1, 33, 21, 109, -2)\n\
    \nfor (i in 1:length(nums)){\n  if(isOdd(nums[i])){\n    print(i)\n  }\n}\n\n\
    [1] 1\n</code>\nOr using sapply:\n<code>\nnums[sapply(nums, function(x) all(x\
    \ %% 2 != 0))]\n</code>\nOr using lapply:\n<code>\nnums[unlist(lapply(nums, function(x)\
    \ all(x %% 2 != 0)))]\n</code>\nOr using purrr:\n<code>\nlibrary(purrr)\nnums[purrr::keep(nums,\
    \ ~ .x %% 2 != 0)]\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\n<code>", "\n \
    \ x <- nums[[1]]\n  i <- 1\n  while (i + 1 < length(x)) {\n    if (x[i] + x[i\
    \ + 1] % 2 == 1) {\n      i <- i + 2\n    } else {\n      i <- i + 1\n    }\n\
    \  }\n  return(length(x) - i - 1)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nHi Nick,\
    \ thank you for your answer. Can you explain a bit more about your solution? Thanks!\n\
    <|/ c |>\n<| c |>\nHi Nick, I have tried to explain a bit more about my solution.\
    \ The idea is to use a function that iterates over the vector. For example, `c(1,\
    \ 2, 3, 4, 5, 6, 7)` would output `3` because there are 3 elements that are both\
    \ odd and first and last digits are odd. You could also use something like `c(0,\
    \ 2, 4, 6, 8)` to output `5` because there are 5 elements that are both odd and\
    \ first and last digits are even.\n<|/ c |>\n<| c |>\nThe function `specialFilter`\
    \ above is a little more involved than it sounds. I won't explain it in a comment\
    \ because it's a little too long. I will add an explanation to my answer. Let\
    \ me know if you have any questions.\n<|/ c |>\n<| c |>\nHi Nick, thank you for\
    \ the explanation. Your solution works great but I am having trouble trying to\
    \ get it to work in my case. I am trying to apply it to a list of dataframes.\
    \ `> mylist[[1]]\n [1] 62 42 72 12 17 28 40 52 72 84 92 124 148 173 202 229 266\
    \ 310 332 361 399 440 493 531 583 616 646 691 744 791 839 904 951 1027 1091 1151\
    \ 1227 1321 1376 1437 1499 1566 1619 1670 1724 1784 1838 1901 1955 1987 2034 2069\
    \ 2112 2152 2192 2232 2265 2303 2354 2393 2436 2474 2517 2557 2597 2647 2698 2748\
    \ 2788 2834 2869 2923 2968 3021 3065 3113 3147 3168 3216 3264 3304 3347 3388 3433\
    \ 3468 3511 3553 3595 3626 3659 3691 3733 3772 3813 3855 ", "\n  num <- nums[[1]]\n\
    \  if (num < 10) {\n    return(0)\n  }\n  return(sum(nums[-2] %% 2 != 1 & nums[-1]\
    \ %% 2 != 1))\n}\n</code>\nIt might seem strange that I am writing these tests,\
    \ but they are actually being run by R to ensure the functions are as expected.\
    \  For example, you can see that calling specialFilter(c(15, -73, 14, -15)) returns\
    \ the expected output of 1:\n<code>\n> specialFilter(c(15, -73, 14, -15))\n[1]\
    \ 1\n</code>\n<|/ a dscore=2 |>\n<| a tags=r dscore=1 |>\nYou can do the following.\
    \ No packages are required.\n<code>", "\n  nums %>%\n    length() %>%\n    filter(between(nums,\
    \ 10, 100)) %>%\n    filter(odd(.) & odd(.[1]) & odd(.[n()]) %>%\n    sum()\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nJust a quick question: what is the purpose\
    \ of %>%?\n<|/ c |>\n<| c |>\nIt's a function that pipes its input into the next\
    \ function without modifying the object. In this case it is used to add up all\
    \ the lengths of the filtered vectors.\n<|/ c |>\n<| a |>\nAnother dplyr solution:\n\
    <code>\nnums %>% \n  filter(between(nums, 10, 100)) %>% \n  filter(odd(.) & odd(.[1])\
    \ & odd(.[n()]) %>%\n  summarise(count = sum(1))\n</code>\nOr using an inline\
    \ function and avoiding dplyr:\n<code>\nnums %>% \n  filter(between(nums, 10,\
    \ 100)) %>% \n  filter(oddInc(.) & oddInc(.[1]) & oddInc(.[n()]) %>%\n  summarise(count\
    \ = sum(1))\n", "\n  nums <- as.numeric(nums)\n  sum(nums > 10 & odd(nums[1])\
    \ & odd(nums[length(nums)])) \n}\n", "\n\tnums.1 <- nums[lengths(nums) > 0]\n\t\
    sum(nums.1 > 10 & nums.1 %% 2 == 1)\n}\n</cell>\n<cell>", "\n  nums <- sort(nums)\n\
    \  sum(nums > 10 & nums %% 1 == 1 & nums %% 3 == 1)\n}\n", "\n  result <- 0\n\
    \  for (i in seq_along(nums)) {\n    if (nums[i] > 10) {\n      if (i %% 2 ==\
    \ 1) {\n        if (nums[i] %% 2 != 0) {\n          if (nums[i] %% 3 == 0) {\n\
    \            if (nums[i] %% 5 == 0) {\n              result <- result + 1\n  \
    \          }\n          }\n        }\n      }\n    }\n  }\n  return(result)\n\
    }\n", "\n  nums <- as.numeric(nums)\n  length(which(nums > 10 & nums %% %% 2 !=\
    \ 0))\n}\n</cell>\n<cell>", "\n    sum(nums > 10 & sapply(nums, `%%`) == 1)\n\
    }\n", "\n    n <- length(nums)\n    x <- nums\n    result <- 0\n    for (i in\
    \ 1:n) {\n        if (nums[[i]] > 10 & firstDigitNums[[i]] %% 2 == 1 & \n    \
    \        lastDigitNums[[i]] %% 2 == 1) {\n        result <- result + 1\n     \
    \   }\n    }\n    return(result)\n}\n</code>\nAnd then compare the speed of various\
    \ functions with:\n<code>\nmicrobenchmark(\n    specialFilter(c(15, -73, 14, -15)),\n\
    \    specialFilter(c(33, -2, -3, 45, 21, 109)),\n    specialFilter(c(-14, -13,\
    \ -17, -81, -56, -42, -13)),\n    times=10)\n</code>\n<|/ a dscore=2 tags=r |>\n\
    <| a dscore=1 |>\n<code>\n> n <- c(15, -73, 14, -15)\n> n %>% sapply(is.numeric)\
    \ %>% as.numeric() %>% filter(!is.na(firstDigitNums %>% sapply(is.numeric) %>%\
    \ as.numeric() %>% filter(!is.na(lastDigitNums %>% sapply(is.numeric) %>% as.numeric()\
    \ %>% filter(!is.na(firstDigitNums) %>% sapply(is.numeric) %>% as.numeric() %>%\
    \ filter(!is.na(lastDigitNums)))))))\n[1] 1\n</code>\n<|/ a tags=r |>\n<| a dscore=1\
    \ |>\nUsing base R\n<code>\nspecialFilter <- function(nums) {\n  x <- nums\n \
    \ result <- 0\n  for(i in 1:length(x)){\n    if(x[i] > 10 & !is.na(firstDigitNums[i])){\n\
    \      if(x[i] %% 2 == 1 & !is.na(lastDigitNums[i])){\n        result <- result\
    \ + 1\n      }\n    }\n  }\n  return(result)\n}\n</code>\n<|/ a tags=r |>\n<|\
    \ a dscore=1 |>\n<code>", "\n    require(data.table)\n    require(bit64)\n   \
    \ \n    unique(\n        c(\n            which(\n                nums > 10 &\n\
    \                as.integer(bit64::int_as_str(nums)) > 10 &\n                as.integer(bit64::int_as_str(nums))\
    \ < 100\n            ), \n            length(nums))\n    )\n}\n", "\n  return(length(nums[nums\
    \ > 10]))\n}\nspecialFilter(c(15, -73, 14, -15))\n</cell>\n<text>\nQuestion 5\n\
    Write a function which takes the number of numbers from the vector in argument\
    \ \nnums and returns the sum of the numbers in nums multiplied by 3. The \nfunction\
    \ should only take one argument. For example:\n>>> doubleSum(c(15, -73, 14, -15))\n\
    -45\n\n</text>\n<cell>", "\n    # Your code here\n    x <- nums\n    x <- x[which(x>10)]\n\
    \    x <- x[which(x%%2==1)]\n    x <- x[1:(length(x)-1)]\n    x <- which(x%%2==1)\n\
    \    x <- x[length(x)]\n    return(x)\n}\n</code>\nI do not really like your solution,\
    \ it is too complex to read and inefficient - I suggest to re-write it in a way\
    \ that requires less memory and less time.\n<|/ a tags=r |>\n<| a tags=r |>\n\
    The function below will return the length of the first and last number of the\
    \ vector that meets these two conditions:\n<code>\nlibrary(data.table)\n", "\n\
    \  nums %>% \n    filter(. > 10) %>% \n    filter(. %% %% 2 == 1) %>% \n    length()\n\
    }\n", "\n    ns <- nums\n    ns[length(ns)] <- ns[length(ns)]/2\n    sum(ns[(ns\
    \ > 10) & (ns %in% c(1,3,5,7))])\n}\n", "\n  return(length(nums[nums > 10 & nums\
    \ %in% c(1, 3, 5, 7, 9)])) \n}\n</cell>\n<cell>", "\n  nums2 <- nums[nums > 10]\
    \ & nums[nums > 10] %% 2 != 0\n  if(nums2 == TRUE) sum(nums2) else 0\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you so much! I ended up writing my own solution\
    \ but this looks much cleaner and more straightforward. I'm wondering if you could\
    \ help me understand why my code doesn't work? I've seen so many other questions\
    \ that ask about the length of a vector, but my code doesn't seem to have any\
    \ issues with length. Could you please help me understand what went wrong here?\n\
    <|/ c |>\n<| c |>\nThe `length` function returns the number of elements in a vector.\
    \  You were attempting to find the number of elements greater than 10 and also\
    \ the first and last digits of a number are odd.  To do that you need to use the\
    \ `%%` operator in the `apply` function.  `%%` is the modulus operator which will\
    \ return the remainder of a division operation\n<|/ c |>\n<| c |>\nThanks. I understand\
    \ that `%%` will return the remainder after division, but I didn't understand\
    \ why my code wasn't working. I tried running the code on another set of test\
    \ cases and I realized that my code was returning a count of 4 instead of 3 when\
    \ I ran it on some examples. Do you know why that might be?\n<|/ c |>\n<| c |>\n\
    Yes, `length` returns the number of elements in a vector.  Since you were trying\
    \ to find elements that are greater than 10 and also the first and last digits\
    \ of a number are odd `nums[nums > 10] & nums[nums > 10] %% 2 != 0` will return\
    \ a vector of `FALSE`s and a `TRUE` for each number that meets those conditions.\
    \  When you use an `&` like that in R the `&` takes precedence over that `%%`\
    \ so the result is a vector of `TRUE`s only\n<|/ c |>\n<| a tags=vector,r dscore=1\
    \ |>\nA simple way would be to use ifelse with %/%:\n<code>\nx <- c(15, -73, 14,\
    \ -15)\nifelse(x>10 & x%/% 2 != 1, 1, 0)\n[1] 1 0 1 0\n</code>\n<|/ a |>\n<| c\
    \ |>\nI didn't even think to use `%/%` but I was about to do something similar.\
    \ Thanks!\n<|/ c |>\n<| c |>\nYou don't need `ifelse` here.  You can use `+` instead\
    \ of `ifelse` if you like\n<|/ c |>\n<| a |>\n", "\n  nums <- nums[nums > 10]\
    \ # Filter out the numbers less than ten.\n  sum(nums > 10 & nums %% 2 == 1)\n\
    }\n</code>\n<|/ a tags=r |>\n<| a dscore=1 |>\nIf you need to solve such problems\
    \ multiple times, you can create a function and assign it to the special operator\
    \ <<-. In the function body you can write the logical expressions and use those\
    \ to subset the vector. You can then call the function with multiple logical expressions\
    \ and assign the result to a new variable. Here is an example:\n<code>", "\n \
    \ nums[nums > 10 & nums %% 10 %% 2 == 1]\n}\n\nprint(specialFilter(c(15, -73,\
    \ 14, -15)))\nprint(specialFilter(c(33, -2, -3, 45, 21, 109)))\n", "\n  nums <-\
    \ sort(nums)\n  nums[which(nums > 10 & odd(nums) & odd(tail(nums, 2))), ]\n}\n",
  "\n  count <- 0\n  \n  for(i in 1:length(nums)) {\n    if(nums[i] > 10 & all(substr(nums[i],\
    \ 1, 1) == \"1\" | substr(nums[i], 1, 1) == \"3\" | substr(nums[i], 1, 1) == \"\
    5\" | substr(nums[i], 1, 1) == \"7\" | substr(nums[i], 1, 1) == \"9\")) {\n  \
    \    count <- count + 1\n    }\n  }\n  \n  return(count)\n}\n", "\n  sum(nums\
    \ > 10 & substr(nums, 1, 1) == \"3\" & substr(nums, 1, 2) == \"7\" & substr(nums,\
    \ 1, 3) == \"5\")\n}\n", "\n  length(c(which(nums > 10, arr.ind = TRUE)[, \"i1\"\
    ][1], which(\n    nums <= 10, arr.ind = TRUE)[, \"i1\"][1])) \n}\n", "\n  nums\
    \ <- unlist(nums)\n  sum(nums > 10 & odd(substr(nums, 1, 1)) & odd(substr(nums,\
    \ 2, 1)))\n}\n", "\n  nums <- as.vector(nums)\n  nums[nums > 10] <- NA\n  nums[(floor(nums)\
    \ / 100) %% 2 > 1] <- NA\n  nums[(nums[length(nums)] == floor(nums[length(nums)])\
    \ & \n           nums[length(nums)]%%2 != 1) | nums[length(nums)] == \n    round(nums[length(nums)])]\
    \ <- NA\n  return(nums[!is.na(nums)])\n}\n", "\n  nums <- nums[!is.na(nums)]\n\
    \  nums <- nums[nums > 10]\n  nums[grepl(\"^[13579]$\", nums)] <- 1\n  nums[grepl(\"\
    ^[1-5]$\", nums)] <- 1\n  sum(nums)\n}\n", "\n  length(nums[nums > 10 & nums[1]%%2\
    \ != 0 & nums[2]%%2 != 0])\n}\n</cell>\n<cell>", "\n  return(length(nums[nums\
    \ > 10 & \n                 nums[, 1] %% 2 == 1 &\n                 nums[, 1]\
    \ %% 2 == 0]))\n}\n", "\n  nums <- nums[nums > 10] \n  sum(nums == 10) == length(nums)\
    \ & \n  sum(nums %% 2 == 1) == 1\n}\n</cell>\n<text>\nExercise\nWrite a function\
    \ that takes an integer as an input and returns the sum of the digits\nof its\
    \ binary representation. For example:\n>>> binarySum(c(12, 6, 0, 1))\n9\nTo get\
    \ just the sum, use sum (instead of sum(c(...))).\n\nBonus questions\nWrite a\
    \ function that takes an integer as a parameter and returns the number of\ntimes\
    \ that integer appears consecutively in a vector.\n>>> countOccurrences(c(9, 2,\
    \ 11, 3, 4, 9))\n3\nWrite a function that takes an integer as a parameter and\
    \ returns whether that integer\nis prime or not. For example:\n>>> isPrime(8)\n\
    False\n>>> isPrime(20)\nTrue\nWrite a function that takes an integer as an input\
    \ and returns the factorial of it.\n>>> factorial(10)\n3628800\nWrite a function\
    \ that takes an integer as an input and returns the sum of its digits \n(without\
    \ using any loops).\n>>> sumDigits(c(12, 6, 0, 1))\n5\nWrite a function that takes\
    \ an integer as a parameter and returns its factorial (without\nusing any loops).\n\
    >>> factorial2(10)\n3628800\nWrite a function that takes an integer as an input\
    \ and returns the sum of its digits \n(without using any loops). Also, write another\
    \ function that takes two integers as \ninput (a and b) and returns the sum of\
    \ their digits.\n>>> sumDigits_2(c(12, 6, 0, 1))\n5\n>>> sumDigits_2(c(12, 6,\
    \ 0, 1), c(8, 0, 1))\n5\nWrite a function that takes an integer as an input and\
    \ returns the sum of the squared digits \n(without using any loops).\n>>> sumSquaresDigits(c(12,\
    \ 6, 0, 1))\n14\nWrite a function that takes an integer as a parameter and returns\
    \ its factorial (without\nusing any loops).\n>>> factorial3(10)\n3628800\nWrite\
    \ a function that takes an integer as a parameter and returns the sum of the squared\
    \ digits \n(without using any loops). Also, write another function that takes\
    \ two integers as \ninput (a and b) and returns the sum of their digits.\n>>>\
    \ sumSquaresDigits_2(c(12, 6, 0, 1))\n14\n>>> sumSquaresDigits_2(c(12, 6, 0, 1),\
    \ c(8, 0, 1))\n14\nWrite a function that takes an integer as an input and returns\
    \ the sum of its digits \n(without using any loops).\n>>> sumDigits_3(c(12, 6,\
    \ 0, 1))\n5\nWrite a function that take", "\n  numsLen <- length(nums)\n  evenNums\
    \ <- nums[numsLen %% 2 == 0]\n  oddNums <- nums[numsLen %% 2 != 0]\n  if(numsLen\
    \ > 1) {\n    counts <- c()\n    for(i in 1:numsLen) {\n      if(nums[i] > 10\
    \ & even(oddNums[i]) & odd(evenNums[i])) counts[i] <- counts[i] + 1\n    }\n \
    \   max(counts)\n  }\n  else {\n    0\n  }\n}\n", "\n  nums[nums > 10 & nums[-c(1,length(nums))\
    \ & nums[-1L] %% 2L == 1L] \n      & nums[-1L] %% 2L == 0L]\n}\n</code>\nWe now\
    \ have a function that can be used on vectors of numbers to count the number of\
    \ elements that are greater than 10 and where the last two digits are odd:\n<code>\n\
    specialFilter(c(15, -73, 14, -15))", "\n  return(sum(nums[nums > 10 & \n     \
    \             nums %% 10 == 0 &\n                  nums %% 100 != 0] > 10 & \n\
    \              (nums %% 10 == 1 & nums %% 100 != 1)))\n}\n", "\n  sum(nums > 10\
    \ & odd(head(nums, -1)) & odd(tail(nums, -1)))\n}\n", "\n  nums[nums > 10] <-\
    \ 10\n  nums[nums %% 2 == 1] <- 0\n  length(nums[nums > 10])\n}\n</cell>\n<cell>",
  "\n  nums <- nums[which(nums > 10 & nums %% 1 == 1)]\n  nums[which(nums == 10 &\
    \ nums %% 1 == 0)]\n}\n</cell>\n<text>\nProblem 9: Filter a vector with any elements\
    \ that are greater than 10, \nboth first and last digits are odd.\nFor example,\
    \ a vector c(12, 3, -20, 71, 34, -10) would return a vector \nof only -7 and -10.\n\
    \n\n</text>\n<cell>", "\n  \n  # Your code here\n  \n  return(length(nums[nums\
    \ > 10 & nums[,1]%%2 != 0 & nums[,2]%%2 != 0]))\n  \n}", "\n  # Write your code\
    \ here.\n}\n</cell>\n<text>\n6. Write a function that takes a vector of numbers\
    \ as input and\nreturns true if the first and last digits are odd, false otherwise.\n\
    \n</text>\n<cell>", "\n  # code goes here\n}\n</cell>\n<cell>", "\n  sum(nums\
    \ > 10 & odd(tail(nums, 1)) & odd(head(nums, 1)))\n}\n</cell>\n<cell>\nspecialFilter(c(15,\
    \ -73, 14, -15))\n</cell>\n<text>\nThe second function you wrote was odd\nWrite\
    \ a function that takes a vector of numbers as input and returns \nTRUE if the\
    \ vector is all odd numbers and FALSE if not. For example,\nif c(1, 5, 7) is a\
    \ vector the function should return TRUE.\n\n</text>\n<cell>", "\n  nums %>% \n\
    \    length() %>% \n    which(. > 10) %>% \n    which(. %% 2 == 1) %>% \n    sum()\
    \ \n}\n</cell>\n<text>\nTask 2: Calculate pi\nCalculate the value of $\\pi$ using\
    \ the formula:\n\\begin{align}\n    \\mathrm{pi} &= \\sqrt{\\frac{\\mathrm{d}\
    \ x^{2}}{\\mathrm{d} y^{2}}}\n\\end{align}\nwhere $x$ and $y$ are the input numbers.\n\
    \nHINT: you can use the function length to get the length of a vector.\n\n\n</text>\n\
    <cell>", "\n  return(length(nums[nums > 10&nums[[1]%%2%%2==1] & nums[length(nums)]%%2%%2==1]))\n\
    }\n</cell>\n<text>\nNow run your newly created function on three different vectors\
    \ of numbers. We'll use the ones we generated in the previous exercise to generate\
    \ vectors you can use for comparison.\n\n\n</text>\n<cell>\nresult <- specialFilter(c(15,\
    \ -73, 14, -15))\nresult\n</cell>\n<cell>\nresult <- specialFilter(c(33, -2, -3,\
    \ 45, 21, 109))\nresult\n</cell>\n<cell>\nresult <- specialFilter(c(-7, -3, 4,\
    \ -5, -6, 9, -9, 23, -23))\nresult\n</cell>\n<text>\nThe results are the same\
    \ in each case, so the function works as expected. Next, write a function similar\
    \ to the previous one to filter out all odd numbers in a vector of strings (see\
    \ ?substring). The function should take a single vector of strings as input.\n\
    \n\n</text>\n<cell>", "\n  \n  result <- 0\n\n  for (i in 1:length(nums)) {\n\
    \    if (nums[i] > 10) {\n      if (nums[i] %% 2 != 0 && nums[i] %% 1 != 0) {\n\
    \        result <- result + 1\n      }\n    }\n  }\n  \n  return(result)\n}\n",
  "\n  \n}\n</cell>\n<text>\nUsing R to create plots (optional)\nR provides a wide\
    \ range of plotting functions, some of which are useful in this class.\n\nBelow,\
    \ we will use one specific function from the ggplot2 package: the ggplot function.\
    \ We will use this to create some plots of our own.\n\nTo learn more about ggplot,\
    \ see this nice tutorial. There are also many other useful packages in R which\
    \ support plotting, including:\n\nggplot2: used to create default plots\nviridis:\
    \ used to create a custom colour palette\nggrepel: used to increase the size of\
    \ a plot (to show more detail)\n\nIn this example, we will use two of the most\
    \ common packages, and combine them together to create our own plot.\n\nTo learn\
    \ more about using R with Python, visit this guide.\n\nFirst, let's create our\
    \ data and store it in an R data frame, which we will then pass to our plots.\n\
    \n\n</text>\n<cell>", "\n    \n    # 1. Your code here\n    \n}\n\n</cell>\n<cell>",
  "\n  nums <- sort(nums)\n  sum(nums > 10 & nums > 10^floor(log10(nums)) & nums %%\
    \ 10 %% 2 ==1)\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nYes, this is my question.\
    \ Thanks, that helps.\n<|/ c |>\n<| a dscore=4 tags=r,numerical-analysis |>\n\
    As a more general approach to the problem of detecting if all elements in numeric\
    \ vector are integers (and not numbers that can have fractional components) you\
    \ can try using the following function:\n<code>\nall_integers <- function(x) {\n\
    \  sapply(x, function(x) all(typeof(x) == \"integer\"))\n}\n</code>\nIt takes\
    \ advantage of the fact that an R vector can hold a mixture of integer and numeric\
    \ values:\n<code>\n> all_integers(c(12, 23, 12.5, 0.5))\n[1] TRUE\n</code>\nIn\
    \ case you have mixed types you can use sapply on the numeric components:\n<code>\n\
    all_integers <- function(x) {\n  sapply(x, function(x) all(typeof(x) == \"integer\"\
    \ & !is.na(x)))\n}\n</code>\n<|/ a |>\n<| a |>\nIn a comment to another answer,\
    \ you asked about using dplyr::filter to filter your data frame with only those\
    \ rows that satisfy the conditions.\nThis can be done in several ways. One way\
    \ is to do it in one line using dplyr::filter like this:\n<code>\nlibrary(dplyr)\n\
    \nset.seed(1)\ndf <- data.frame(x1 = sample(c(-5:5), 100, replace = TRUE),\n \
    \                x2 = sample(c(-5:5), 100, replace = TRUE),\n                \
    \ x3 = sample(c(-5:5), 100, replace = TRUE),\n                 x4 = sample(c(-5:5),\
    \ 100, replace = TRUE),\n                 x5 = sample(c(-5:5), 100, replace =\
    \ TRUE),\n                 x6 = sample(c(-5:5), 100, replace = TRUE),\n      \
    \           x7 = sample(c(-5:5), 100, replace = TRUE),\n                 x8 =\
    \ sample(c(-5:5), 100, replace = TRUE),\n                 x9 = sample(c(-5:5),\
    \ 100, replace = TRUE),\n                 x10 = sample(c(-5:5), 100, replace =\
    \ TRUE))\n\ndf %>%\n  filter(\n    x1 <= 10 & x1 <= 10 & x1 <= 10 & x1 <= 10 &\
    \ x1 <= 10 & x1 <= 10 &\n    x1 <= 10 & x1 <= 10 & x1 <= 10 & x1 <= 10 & x1 <=\
    \ 10 & x1 <= 10 &\n    x1 <= 10 & x1 <= 10 & x1 <= 10 ", "\n  nums <- as.numeric(nums)\n\
    \  sum( nums > 10 & nums %% 2 != 0 )\n}\n</code>\nAnd now we can take advantage\
    \ of vectorization:\n<code>\n> specialFilter(c(15, -73, 14, -15))\n[1] 1\n> specialFilter(c(33,\
    \ -2, -3, 45, 21, 109))\n[1] 2\n</code>\n<|/ a |>\n<| c |>\nI agree, `sapply`\
    \ can be avoided with `ifelse`\n<|/ c |>\n<| a |>\n<code>\nx <- c(15, -73, 14,\
    \ -15)\nlength( which( x > 10 & x %% 2 != 0 ) )\n</code>\n<|/ a dscore=2 tags=r\
    \ |>\n<| a dscore=1 tags=r |>\nYou could also do:\n<code>\nnums <- c(15, -73,\
    \ 14, -15)\n\nlength(which(floor(nums)%2!=0))\n</code>\n<|/ a |>\n<| a tags=r\
    \ |>\nAnother option is using grepl to search for \"[\" and \"]\" in the vector\
    \ and count the numbers between them.\n<code>\nnums <- c(15, -73, 14, -15)\n\n\
    length(grep('[',nums)) - length(grep(']',nums))", "\n  n <- length(nums)\n  sum(nums\
    \ > 10 & nums %% 1 == 0 & nums %% 3 == 0)\n}\n</cell>\n<cell>", "\n  length(which(grepl(\"\
    ^[-]?\\\\d{0,2}$\", nums) & \n            grepl(\"^[-]?\\\\d{0,2}$\",\n      \
    \             substr(nums, 1, nchar(nums) - 1))) & \n            grepl(\"^[-]?\\\
    \\d{0,2}$\",\n                   substr(nums, 1, nchar(nums) - 1)) %*% c(TRUE,\
    \ FALSE))\n}\n", "\n    length(c(which(nums > 10 & nums[[1]] %% 2 != 0, which(nums\
    \ > 10 & nums[[1]] %% 2 != 0)))) \n}\n", "\n    nums <- as.numeric(nums)\n   \
    \ sum(nums > 10 & nums %% 10 %in% c(1, 3, 5)) == 1\n}\n</code>\nThis returns 1\
    \ for the numbers that satisfy the condition and 2 for the numbers that do not.\
    \ If you want only the first or last condition to be satisfied, change the ==\
    \ 1 to == 2 for first and == 3 for last.\n<|/ a |>\n<| c |>\nThank you so much\
    \ for taking the time to explain this! I now have a better understanding of what\
    \ the code is doing now.\n<|/ c |>\n<| c |>\nNo problem. Glad to help!\n<|/ c\
    \ |>\n<| a |>\nThe short answer is\n<code>\nsum(nums == 100 | nums == -100)\n\
    </code>\nThis will return you the number of numbers you need.\n<|/ a dscore=1\
    \ tags=r,numbers |>\n<| c |>\nThank you so much for taking the time to explain\
    \ this!\n<|/ c |>\n<| a tags=r,numbers |>\nThere are several ways to solve the\
    \ problem. The first one, which seems easiest, is to take both numbers that are\
    \ less than 0 and 0 and check if they add up to 100:\n<code>\nsum(nums <= 0 &\
    \ nums == 0) # 1\nsum(nums <= 0 & nums != 0) # 0\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis solution doesn't take into account the fact that OP said that he\
    \ only wants numbers that are both positive and negative.\n<|/ c |>\n<| c |>\n\
    Thank you so much for taking the time to explain this!\n<|/ c |>\n<| c |>\nI did\
    \ not realize it because of the other solutions here.\n<|/ c |>\n<| a |>\nYou\
    \ can use %in% to check if a vector contains another vector:\n<code>\nspecialFilter\
    \ <- function(nums) {\n  any(nums %in% c(100, -100))\n}\n</code>\n<|/ a tags=r,numbers\
    \ dscore=0 |>\n<| c |>\nThank you so much for taking the time to explain this!\n\
    <|/ c |>\n<| a dscore=0 |>\nWe can also use rowSums\n<code>\nrowSums(nums == c(100,\
    \ -100))", "\n  nums <- sort(nums)\n  nums <- nums[which(nums > 10 & nums %in%\
    \ c(1,3,5,7,9))[1]]\n  nums\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\n\
    specialFilter <- function(nums) {\n  nums <- sort(nums)\n  nums <- nums[which(nums\
    \ > 10 & nums %in% c(1,3,5,7,9))[1]]\n  nums\n}\n</code>\n<|/ a tags=r |>\n<|\
    \ a dscore=0 |>\nAs many have said, sort is the best approach.\nHowever, if you\
    \ are working with large datasets then you can use the data.table package in R\
    \ as it has a faster sort that uses radix sorting. \n<code>\n> specialFilter(c(15,\
    \ -73, 14, -15))\n[1] 1\n\n> specialFilter(c(33, -2, -3, 45, 21, 109))\n[1] 2\n\
    </code>\nThe code to install and load this package is quite simple:\n<code>\n\
    library(devtools)\ninstall_github(\"Rdatatable/data.table\")\nlibrary(data.table)\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nHow does this work when there are repeated\
    \ numbers in the vector? Or when the numbers are not unique?\n<|/ c |>\n<| c |>\n\
    The data.table package automatically sorts the data. The sort is implemented by\
    \ an R package called RcppBDT. https://cran.r-project.org/web/packages/RcppBDT.\n\
    <|/ c |>\n<| a tags=r |>\nAnother option is to apply the function to a vector\
    \ of numbers, rather than a vector of factors. \n<code>\nspecialFilter <- function(nums)\
    \ {\n  nums <- sort(nums)\n  nums <- nums[which(nums > 10 & nums %in% c(1,3,5,7,9))[1]]\n\
    \  nums\n}\n\nspecialFilter(nums = c(15, -73, 14, -15))\n[1] 1\n\nspecialFilter(nums\
    \ = c(33, -2, -3, 45, 21, 109))\n[1] 2\n</code>\n<|/ a dscore=0 |>\n<| a tags=r\
    \ |>\nWe can use Reduce\n<code>\nspecialFilter <- function(nums) {\n   nums <-\
    \ sort(nums)\n   nums <- nums[which(nums > 10 & nums %in% c(1,3,5,7,9))[1]]\n\
    \   nums\n}\n\nspecialFilter(nums = c(15, -73, 14, -15))", "\n  \n  # Count how\
    \ many numbers in the vector are greater than 10\n  # and both first and last\
    \ digits are odd\n  n <- lengths(nums)[nums[lengths(nums)] > 10 & nums[lengths(nums)]\
    \ %% 2 != 0]\n  \n  # Return the number of elements in the vector that are greater\
    \ than 10\n  # and both first and last digits are odd\n  n\n}\n</cell>\n<cell>",
  "\n    nums %>% \n        filter(n > 10 & lag(last, default = first) %% 2 == 1)\
    \ %>% \n        length()\n}\n</cell>\n<text>\n4.5 Exercise\nUsing the filtering\
    \ criteria from 4.1, write a function that returns the number of numbers in the\
    \ vector that satisfy the above condition.\n\n\n</text>\n<cell>", "\n  sum(nums\
    \ > 10 & oddFirst(nums) & oddLast(nums))\n}\n", "\n  nums <- as.integer(nums)\n\
    \  sum(nums > 10 & nums %/% 2 == 1)\n}\n\nspecialFilter(c(15, -73, 14, -15))",
  "\n  count <- 0\n  for (i in seq_along(nums)) {\n    if (nums[i] > 10 & nums[i]\
    \ %% 2 == 1 & nums[i] %% 2 == 1) {\n      count <- count + 1\n    }\n  }\n  return(count)\n\
    }\n", "\n  ns <- nums[lengths(nums) > 0]\n  ns[1] > 10 && ns[length(ns) - 1] %\
    \ 2 > 0 & ns[1] %% 2 == 1\n}\n</code>\n<|/ a tags=r,filtering |>\n<| c |>\nThanks\
    \ for the answer! It was really helpful and I learned new things from it. However,\
    \ my problem is that I cant figure out how to apply my function to the vector.\
    \ For example if I write\n    specialFilter(1:100)\nI get a vector with TRUE and\
    \ FALSE values. But if I write \n    specialFilter(1:100)[specialFilter(1:100)]\n\
    I get only FALSE. So how should I apply my function to the vector to get my desired\
    \ output?\n<|/ c |>\n<| c |>\nIt will help if you edit your question to show the\
    \ desired output for a particular example.\n<|/ c |>\n<| c |>\nSure, sorry for\
    \ that. I have edited my original question\n<|/ c |>\n<| a tags=r,filtering dscore=2\
    \ |>\nThere are some functions that are vectorized (and that is a big part of\
    \ what functional programming is). Here's an example from the help\n<code>\nx\
    \ <- c(1,2,3,4,5)\n</code>\nYou want to find the number of elements in x that\
    \ are less than 5:\n<code>\nlength(x)[x < 5]\n</code>\nThe vector length() will\
    \ return the length of a vector (the number of elements in the vector). Thus,\
    \ it can be used for filtering\n<code>\nlength(x)[x < 5]\n[1] 1\n</code>\nIn this\
    \ case, the function less than will return TRUE or FALSE depending on whether\
    \ x < 5 is true or not. We can use this in a filter\n<code>\nx <- c(1,2,3,4,5)\n\
    x %in% c(1,2,3,4,5)\n[1] TRUE TRUE TRUE TRUE TRUE\nx %in% c(4,5)\n[1] FALSE FALSE\n\
    </code>\nSo to answer your question:\n<code>\nspecialFilter <- function(x) {\n\
    \  length(x)[x < 5]\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe filter function\
    \ can be applied to both numeric vectors and vectors of strings.\nThe example\
    \ below uses the filter function on vectors of strings. In the first case it keeps\
    \ the non-matching elements and in the second case it keeps the matching elements.\
    \ The first example shows that it works with only a single variable and in the\
    \ second example it works also with several variables.\n<code>", "\n  sum(nums\
    \ > 10 & all(nums > 10 & nums %% 2 != 0))\n}\n", "\n  nums <- nums[nums != -Inf]\n\
    \  sum(nums > 10 & substr(nums, 1, 1) %% 2 == 1 & substr(nums, length(nums), 1)\
    \ %% 2 == 1)\n}\nspecialFilter(c(15, -73, 14, -15))\n</cell>\n<cell>", "\n   \
    \ sum(nums > 10 & nums %in% c(1,3,5,7,9) & nums %in% c(1,3)) \n}\n</code>\nThis\
    \ is not an efficient function though as it takes up three vector copies. I recommend\
    \ using R's built-in filter function or apply with MARGIN=1 or lapply:\n<code>\n\
    > lapply(nums, function(x) x > 10 & x %in% c(1,3,5,7,9) & x %in% c(1,3))", "\n\
    \    length(nums[nums > 10 & nums %in% c(1,3,5,7,9)])\n}\n</code>\n<|/ a |>\n\
    <| c |>\nWhat does the \"&\" mean? I thought it meant AND.\n<|/ c |>\n<| c |>\n\
    \"&\" means logical AND. Here's a nice link explaining it: http://statmethods.net/management/syntax.html\n\
    <|/ c |>\n<| c |>\nSo this function is not really working properly. I was able\
    \ to make it work by using \"c\" instead of \"&\". But the issue is the same with\
    \ mine. My function only works for positive numbers. I am looking for a function\
    \ that works with both positive and negative numbers. Any ideas?\n<|/ c |>\n<|\
    \ c |>\nThe code works fine with the example you provided. Try testing it by creating\
    \ an example where the output is not correct. You can use any test vector with\
    \ just positive and negative numbers.\n<|/ c |>\n<| c |>\nI tested it on the test\
    \ vector you provided. Here is the output I get: [1] 2\n[1] 2\n[1] 2\n[1] 1\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n\
    [1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2\n[1] 2", "\n  nums <- as.numeric(nums)\n\
    \  length(nums[nums > 10 & nums %% %% 2 == 1])\n}\n\nspecialFilter(c(15, -73,\
    \ 14, -15))", "\n  nums[nums > 10] <- 10\n  nums[nums > 10 & nums %in% c(1,3,5,7,9)]\
    \ <- 0\n  sum(nums)\n}\n</code>\n<|/ a dscore=0 tags=vector,r,conditional |>\n\
    <| a tags=vector,r,conditional |>\nUse \n<code>", "\n  num <- nums\n  length(which(num\
    \ > 10 & num %% 10 %% 1 %in% c(1, 3)) &\n        num %% 10 %% 3 %in% c(1, 5))\n\
    }\n</cell>\n<cell>", "\n\tsum <- 0\n\tfor(num in nums) {\n\t\tif(num > 10 & num%%1\
    \ > 0 & num%%5 == 1) {\n\t\t\tsum <- sum + 1\n\t\t}\n\t}\n\treturn(sum)\n}\n",
  "\n    sum(nums > 10 & nums %% 2 != 0)\n}\n</cell>\n<cell>", "\n  nums <- sort(nums)\n\
    \  sum(nums >= 10 & nums[[1]] %% 2 != 0 && nums[[n]] %% 2 != 0)\n}\n</code>\n\
    <|/ a tags=r,dataframe |>\n<| a tags=r,dataframe |>\nHere's a vectorized approach:\n\
    <code>\n> nums <- c(15, -73, 14, -15, 33, 2, -3, 45, 21, 109)\n> nums[nums > 10\
    \ & nums %in% c(1, 3, 5, 7, 9) & nums %in% c(1, 3, 5, 7, 9, 11)]\n[1] 1\n</code>\n\
    It takes all numbers that are > 10 and are odd and are either first or last digits.\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a way to get your result using base\
    \ R's grepl, grep, and regmatches.\n<code>\nnums <- c(15, -73, 14, -15, 33, 2,\
    \ -3, 45, 21, 109)\n</code>\nFirst, use grep to subset nums so that we get nums\
    \ that are greater than 10 and are odd.\n<code>\ngrep('(10|1[0-7]|3[0-8]|4[0-6]|5[0-5])',\
    \ nums)", "\n  return(length(nums[nums > 10 & nums %in% c(1, 3, 5)] & nums %%\
    \ 2 != 0))\n}\n", "\n  sum(nums > 10 & nums %% 2 != 0)\n}\n", "\n  sum(nums >\
    \ 10 & nums %in% c(1, 3, 5)) \n}\n", "\n  nums <- sort(nums)\n  sum(ivec(nums)[c(TRUE,\
    \ FALSE)] & c(FALSE, TRUE))\n}\n</cell>\n<text>\nProblem 3\n\n</text>\n<text>\n\
    Write a function that takes a vector of numbers as input and returns \nthe sum\
    \ of the absolute difference between the first and last elements of \nthe vector\
    \ that is greater than 10 but both first and last elements are \nodd (1, 3, 5,\
    \ 7, 9).\nFor example:\n>>> specialFilter(c(15, -73, 14, -15))\n9\n>>> specialFilter(c(33,\
    \ -2, -3, 45, 21, 109))\n18\n\n\n</text>\n<cell>", "\n  nums[nums > 10 & odd(nums[1])\
    \ & odd(nums[length(nums)])]\n}\n</code>\n<|/ a |>\n<| a |>\nThe answer is very\
    \ simple and yet so unexpected.\n<code>\n> length(which(x <- c(15, -73, 14, -15)\
    \ > (10*10^(1/2)), grepl(\"^[19]$\", x))) \n[1] 1\n</code>\n<|/ a dscore=0 tags=filter,r\
    \ |>\n<| a tags=filter,r dscore=0 |>\nI think it's better to separate numbers\
    \ in vector and apply the filter to numbers, rather than numbers in vector. If\
    \ I understood your question correctly, I think this one will work:\n<code>\n\
    x <- c(15, -73, 14, -15)\n", "\n  count1 <- 0\n  count2 <- 0\n  for(i in 1:length(nums))\
    \ {\n    if(nums[i] >= 10 & odd(nums[i])) {\n      if(odd(c(nums[i - 1], nums[i])))\
    \ {\n        count <- 1\n      }\n      if(odd(c(nums[i - 1], nums[i], nums[i\
    \ + 1]))) {\n        count <- 1\n      }\n      if(count > 1) {\n        count2\
    \ <- count2 + count\n      }\n    }\n  }\n  return(count2)\n}\n", "\n  sum(nums\
    \ > 10 & nums %% 10 != 0 & nums %% 10 %% 2 == 1)\n}\n</code>\n<|/ a tags=r,filter,vector\
    \ dscore=3 |>\n<| c |>\nThis is exactly what I needed! Thank you!\n<|/ c |>\n\
    <| c |>\nGlad to help. If this or any answer has solved your question please consider\
    \ [accepting it](https://meta.stackexchange.com/q/5234/179419) by clicking the\
    \ check-mark. This indicates to the wider community that you've found a solution\
    \ and gives some reputation to both the answerer and yourself. There is no obligation\
    \ to do this.\n<|/ c |>\n<| c |>\nThanks. I tried to accept the answer but because\
    \ I am a new user it told me that I do not have enough reputation to do so. Maybe\
    \ I will try to get it done next time.\n<|/ c |>\n<| c |>\nNo problem. Feel free\
    \ to accept the answer in the future if you think it helps. You can always do\
    \ so by clicking the checkmark (check mark) to the left of the answer. :)\n<|/\
    \ c |>\n<| a tags=r,filter,vector |>\nI believe this will work for you:\n<code>\n\
    myvec <- c(15, -73, 14, -15, 33, -2, -3, 45, 21, 109)\nmyvec[myvec > 10 & myvec\
    \ %% 10 %% 2 != 1]", "\n  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10]\
    \ %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums\
    \ > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums\
    \ > 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums\
    \ > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n\
    \  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > 10]\
    \ <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums >\
    \ 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums\
    \ > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n\
    \  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > 10]\
    \ <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums >\
    \ 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums\
    \ > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n\
    \  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > 10]\
    \ <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums >\
    \ 10] - nums[nums > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums\
    \ > 10] %% 10\n  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n\
    \  nums[nums > 10] <- nums[nums > 10] - nums[nums > 10] %% 10\n  nums[nums > ",
  "\n\tnums <- sort(nums, decreasing = TRUE)\n\tnums[nums > 10 & nums %in% c(1,3,5,7,9)\
    \ & all(nums %% 2 ==1)]\n}\n</cell>\n<text>\n3. Degree Distribution\nLet us now\
    \ look at what is the degree distribution of a given vector (of numbers).\n\n\n\
    </text>\n<cell>", "\n  nums <- nums[nums > 10] \n  nums[nums %in% c(11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)] \n}\n\nprint(specialFilter(c(15,\
    \ -73, 14, -15)))\nprint(specialFilter(c(33, -2, -3, 45, 21, 109)))\n</cell>\n\
    <text>\nGreat work! We've got it figured out. Now, we can use specialFilter to\
    \ clean our data!\n\n\n</text>\n<cell>\ndf <- read.csv('../../data/processed/filtered_data_no_IDs.csv')\n\
    </cell>\n<cell>\ndf %>% \n  dplyr::select(-c(V1, V2)) %>%\n  filter(specialFilter(V3)\
    \ == 1) %>%\n  mutate(outcome = if_else(specialFilter(V3) > 0, 'Y', 'N')) %>%\n\
    \  dplyr::select(-c(V3)) %>%\n  na.omit() %>%\n  mutate(outcome = if_else(outcome\
    \ == 'Y', TRUE, FALSE))\n\n</cell>\n<text>\nThis didn't work quite right. We might\
    \ want to check that our output makes sense before we move on. Let's take a look!\n\
    \n\n</text>\n<cell>\ndf %>% \n  dplyr::select(-c(V1, V2)) %>%\n  filter(specialFilter(V3)\
    \ == 1) %>%\n  mutate(outcome = if_else(specialFilter(V3) > 0, 'Y', 'N')) %>%\n\
    \  dplyr::select(-c(V3)) %>%\n  na.omit() %>%\n  mutate(outcome = if_else(outcome\
    \ == 'Y', TRUE, FALSE)) %>%\n  dplyr::select(outcome)\n\n</cell>\n<text>\nOk!\
    \ That worked! Let's make sure we're using the right data!\n\n\n</text>\n<cell>\n\
    df %>% \n  dplyr::select(-c(V1, V2)) %>%\n  filter(specialFilter(V3) == 1) %>%\n\
    \  mutate(outcome = if_else(specialFilter(V3) > 0, 'Y', 'N')) %>%\n  dplyr::select(-c(V3))\
    \ %>%\n  na.omit() %>%\n  mutate(outcome = if_else(outcome == 'Y', TRUE, FALSE))\
    \ %>%\n  dplyr::select(outcome) %>%\n  dplyr::select(outcome)\n</cell>\n<text>\n\
    Yep! That ", "\n  sum(nums > 10 & odd(nums[c(1,length(nums))]))\n}\n", "\n  sum(nums\
    \ > 10 & odd(nums) & odd(tail(nums, 2)))\n}\n", "\n  nums <-  nums[!is.na(nums)]\n\
    \  if (sum(nums==10) != length(nums) || (nums[1] %% 1 != 0) || nums[length(nums)]\
    \ %% 1 != 0) {\n    0 \n  } else {\n    length(nums[nums > 10 & nums[1]%%1 %in%\
    \ c(1, 3, 5) & nums[length(nums)] %%1 %in% c(1, 3, 5)])\n  }\n}\n", "\n  return(sum(nums\
    \ > 10 & odd(first(nums)) & odd(last(nums))))\n}\n\nprint(specialFilter(nums))",
  "\n    sum(nums > 10 & odd(head(tail(nums, -1), 1)) & odd(tail(nums, -1)))\n}\n",
  "\n    sum(nums > 10 & odd(c(floor(nums[1]), nums[length(nums)])))\n}\n", "\n  sum(nums\
    \ > 10 & nums %in% c(11, 13, 17, 19))\n}\n", "\n  nums <- sort(nums, decreasing\
    \ = T)\n  nums <- nums[lengths(nums) > 1]\n  return(length(nums[(odd & nums %in%\
    \ c(11, 5, 7, 9))]))\n}\n", "\n  length(nums[nums > 10 & nums%%1 != 0 & nums%%5\
    \ == 1])\n}\n\n</cell>\n<cell>", "\n  \n  sum <- 0\n  for(i in 1:length(nums))\
    \ {\n    if(nums[i] < 10) {\n      sum <- sum + 1\n    } else {\n      if(grepl('\\\
    \\w', nums[i], perl = TRUE) && grepl('\\\\w', nums[length(nums)], perl = TRUE))\
    \ {\n        sum <- sum + 1\n      }\n    }\n  }\n  \n  return(sum)\n  \n}\n",
  "\n  sum(nums > 10 & nums %% 10 == 2 & nums %% 10 == 1) \n}\n</cell>\n<cell>", "\n\
    \    nums <- nums[nums > 10] \n    nums <- nums[nums %% 2 == 1]\n    return(length(nums))\n\
    }\n</cell>\n<cell>", "\n\tnums <- as.numeric(nums)\n\treturn(length(nums[nums>10\
    \ & nums%%2 == 1]) + 1)\n}\n", "\n    n <- length(nums)\n    out <- 0\n    for\
    \ (i in 1:n) {\n        if (nums[i] > 10 & nums[i] %% 1 != 0 & nums[i] %% 2 ==\
    \ 1) {\n            out <- out + 1\n        }\n    }\n    out\n}\n", "\n  nums[nums\
    \ > 10 & odd(c(as.integer(nums)[1], as.integer(nums)[length(nums)]))]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI didn't think to `cbind` the two vectors before!\
    \ That's a much better way to do it! Thank you!\n<|/ c |>\n<| a dscore=1 tags=r,if-statement\
    \ |>\nYou could try using grep -\n<code>\nlength(grep(\"-[0-9][0-9]$\", num))",
  "\n  nums[nums > 10 & odd(nums[1]) & odd(nums[length(nums)])]\n}\n", "\n    x <-\
    \ nums[nums >= 10 & nums %% 10 %% 1 == 1]\n    return(length(x))\n}\n", "\n  \
    \  sum <- 0\n    for (i in nums) {\n        if ((i > 10 & modulus(i, 2) == 1)\
    \ & (i %% 2 != 0)) {\n            sum <- sum + 1\n        }\n    }\n    sum\n\
    }\n</code>\n<|/ a tags=r dscore=1 |>\n<| a |>\nWe can use Reduce to count the\
    \ number of numbers that match the criteria\n<code>\nn <- 10^4\nReduce(`+`, lapply(1:(n/2),\
    \ function(i) i %% 2 == 1) & (i %/% 2 == 1))", "\n  # Your code here\n}\n", "\n\
    \  nums <- as.integer(nums)\n  sum(nums > 10 & nums %% %% 2 != 0)\n}\n</code>\n\
    And now we can easily compare our original function with the new one:\n<code>\n\
    > identical(\n    specialFilter(c(15, -73, 14, -15)),\n    specialFilter(c(33,\
    \ -2, -3, 45, 21, 109))\n  )\n[1] TRUE\n> specialFilter(c(15, -73, 14, -15)) ==\
    \ specialFilter(c(33, -2, -3, 45, 21, 109))\n[1] TRUE\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=r,performance |>\nI think this is the fastest way:\n<code>\nspecialFilter\
    \ <- function(nums) {\n  nums <- as.integer(nums)\n  sum(nums > 10 & nums %% 2\
    \ != 0)\n}\n</code>\nThe speed is almost irrelevant, but this is clearly more\
    \ readable.\n<|/ a dscore=1 |>\n<| a |>\nThe fastest solution would be to use\
    \ bitwise operations to check the condition. \n<code>\nspecialFilter <- function(nums)\
    \ {\n  nums <- as.integer(nums)\n  sum(nums >> 11 & nums %% 2 != 0)\n}\n</code>\n\
    The idea is to first check if the last three digits of nums are odd and then check\
    \ if the first two digits of nums are odd or not. \n<code>\nnums >> 11\n</code>\n\
    checks whether a number is divisible by 11. \n<code>\nnums %% 2\n</code>\nchecks\
    \ the remainder, which will be 0 if nums is divisible by 11, 1 otherwise. \n<code>\n\
    & \n</code>\nchecks the condition for odd divisibility. \nThough this would give\
    \ the same result as \n<code>\nnums > 10 & nums %% 2 != 0\n</code>\nThe time complexity\
    \ would be the same, which is O(n). \nYou can check out my benchmark here.\n<|/\
    \ a tags=r,performance dscore=1 |>\n<| c |>\nThank you for the response. Could\
    \ you explain how `nums >> 11` checks for oddity? I'm not familiar with the `>>`\
    \ operator, and am not seeing how it checks for oddity. Is that operator checking\
    \ two numbers for divisibility? If so, why would you check for divisibility by\
    \ 11 if you already know the first two digits are oddity?\n<|/ c |>\n<| c |>\n\
    I added a link to my benchmark above. In my benchmark, your solution is actually\
    \ the fastest. I'm confused as to why your solution", "\n  nums[lengths(nums)\
    \ > 10 & odd(nums) & odd(tail(nums, 1)) & odd(head(nums, 1))]\n}\n</cell>\n<cell>\n\
    specialFilter(c(15, -73, 14, -15))\n</cell>\n<text>\nQuestion 5\nThe function\
    \ below creates a vector of length $n$ filled with random numbers from 1 to $m$.\
    \ Then, it applies a filter on the vector and returns the number of elements that\
    \ satisfy the conditions. For example, for $n = 10$ and $m = 2$:\n\nThe vector\
    \ is filled with random numbers ranging from 1 to $m$.\nThe filter filters out\
    \ all the odd numbers and returns a vector with length of 10.\nThe function then\
    \ returns the number of elements that satisfy the conditions.\n\n\n</text>\n<cell>",
  "\n  n1 <- length(nums)\n  nums[nums > 10 & nums %in% c(1, 3, 5)]\n}\n</cell>\n\
    <text>\nProblem 4: Filtering Data\nIn the previous problem, we filtered out numbers\
    \ that are not divisible by 3 and 5. We'll now filter out numbers divisible by\
    \ both 3 and 5.\n\nWrite a function that takes a vector of numbers as input and\
    \ returns the number of elements in the vector that are divisible by both 3 and\
    \ 5 (both first and last digits are even). For example:\n\n>>> specialFilter(nums)\n\
    1\n>>> specialFilter(nums)\n2\nYou may assume that the given vector is not empty.\n\
    \n\n</text>\n<cell>", "\n    sum(nums[nums > 10 & nums %in% c(11, 13)]) * 10\n\
    }\n</cell>\n<cell>", "\n  return(length(which(nums >= 10 & nums %% 10 %in% c(1,\
    \ 3, 5, 7, 9))) + 1)\n}\n", "\n  # Write code here\n  nums %>% \n    filter(nums\
    \ > 10) %>% \n    mutate(firstOdd = if_else(nums %% 1 == 1, TRUE, FALSE), \n \
    \          lastOdd = if_else(last(nums) < 10, TRUE, FALSE)) %>% \n    filter(firstOdd\
    \ & lastOdd)\n}\n\nspecialFilter(nums)\n</code>\nOutput:\n<code>\n> specialFilter(nums)",
  "\n  nums <- sort(nums)\n  return(sum(nums[nums > 10 & nums[nums %% 10 == 1]\n \
    \                  & nums[nums %% 10 == 3] & nums[nums %% 10 == 5]\n         \
    \          & nums[nums %% 10 == 7] & nums[nums %% 10 == 9]))\n}\n", "\n  sum(nums\
    \ > 10 & \n       floor(log10(nums)) == 1 & \n       substr(nums, 1, nchar(nums))\
    \ > 5)\n}\n", "\n  length(nums[nums > 10 & nums %% 1 == 1])\n}\n</cell>\n<text>\n\
    Problem 3: Filtering on a range of dates\nIn the first problem, we used a vector\
    \ of numbers to filter the data. This worked as expected, but now let's try filtering\
    \ on dates.\n\nWrite a function that, given an vector of dates (represented as\
    \ strings), returns the number of dates included in the vector that occurred on\
    \ or after July 3, 2015 and before July 4, 2015.\n\nFor example:\n\n\n</text>\n\
    <cell>", "\n  nums2 <- nums[!is.na(nums)]\n  nums2[is.na(nums2)] <- 0\n  sum(nums2\
    \ > 10 & nums2 %% %% 2 == 1)\n}\n</code>\n<|/ a |>\n<| c |>\nPlease note that\
    \ I've edited my question to clarify it (I hope I did not break anything).\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere's a base R solution that uses vectorized functions:\n\
    <code>", "\n  sum(nums > 10 & nums %% 1 == 0 & nums %% 2 == 1)\n}\n</code>\n<|/\
    \ a dscore=2 tags=r |>\n<| a |>\nA different approach to finding the number of\
    \ numbers that satisfy the conditions above is to use sum().  For example:\n<code>\n\
    sum(nums > 10 & nums %% 1 == 0 & nums %% 2 == 1)\n</code>\n<|/ a tags=r dscore=1\
    \ |>\n<| a dscore=1 tags=r |>\nHere's another approach:\n<code>\nnums <- c(15,\
    \ -73, 14, -15, 21, 109)\nany(c(TRUE, nums > 10 & nums %% 1 == 0 & nums %% 2 ==\
    \ 1))", "\n  # Write your code here\n  nums <- nums\n  nums[nums >= 10 & nums\
    \ %% 2 == 1 & nums %% 2 == 1]\n}\n", "\n  result <- 0\n  for (i in seq_along(nums))\
    \ {\n    x <- nums[i]\n    if (x > 10 & x %% 2 == 1) {\n      if (x %% 2 == 1)\
    \ {\n        if (x > 10 & x %% 2 == 1) {\n          result <- result + 1\n   \
    \     }\n      }\n    }\n  }\n  result\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks, this is extremely helpful! Is there a way to also include a for loop into\
    \ the function itself? So the final output would be the total number of numbers\
    \ below 10 that are both even and odd.\n<|/ c |>\n<| c |>\nSure! You just have\
    \ to replace the two \"if\" statements with a for-loop. I've edited my answer\
    \ with an example for you.\n<|/ c |>\n<| c |>\nNo problem! I hope my answer helped\
    \ you out! If you have any other questions feel free to ask and I can definitely\
    \ help!\n<|/ c |>\n<| c |>\nSorry it took me so long to respond. I've been busy\
    \ lately so I forgot about this question. I am really glad you helped me out with\
    \ this and your code is so much cleaner than mine. Thank you so much!\n<|/ c |>\n\
    <| a dscore=1 |>\nYou can use sapply and a nested ifelse statement to solve this\n\
    <code>\nif(sapply(nums,function(x) ifelse(x %% 2 != 0 & x > 10 & x %% 2 != 0,\
    \ sum(x %% 2 == 1),0)))\n{\n  print(\"The numbers are both even and odd.\")\n\
    }\nelse\n{\n  print(\"The numbers are both even and not odd.\")\n}\n</code>\n\
    You also have to use %in% instead of == for vector comparisons. And as pointed\
    \ out you cannot use if inside an sapply, so I rewrote it to only have one if\
    \ statement.\n<|/ a tags=r,for-loop,if-statement |>\n<| c |>\n`if(sapply(nums,\
    \ function(x) ifelse(x %% 2 != 0 & x > 10 & x %% 2 != 0, sum(x %% 2 == 1),0)))`\
    \ does not work. `if` has to be used inside `sapply`, but `ifelse` does not. Also,\
    \ `if` should be `ifelse`\n<|/ c |>\n<| c |>\nAh yes, you're right! I edited my\
    \ answer. Thanks!\n<|/ c |>\n<| a |>\nIn R we can use apply family functions to\
    \ do this very ", "\n  num_sum <- sum(nums > 10)\n  odd_sum <- sum(nums%%1 ==\
    \ 0)\n  if(num_sum > 10 & odd_sum > 1) length(nums[nums > 10])\n}\n", "\n  nums\
    \ <- nums[nums > 10]\n  length(nums[nums %% 10 %% 1 == 1]) \n}\n\nspecialFilter(1:10)",
  "\n  # Your code goes here\n  length(which(nums > 10 & first(nums) %% 1 == 1 & last(nums)\
    \ %% 1 == 1)) \n}\n</cell>\n<cell>\nspecialFilter(c(15, -73, 14, -15))\n</cell>\n\
    <text>\nChallenge\nCreate a function that finds all numbers that are a multiple\
    \ of 3 or 5 that are\ngreater than or equal to 10. For example:\n[3, 3, 5, 7,\
    \ 9, 12, 13, 15, 17, 18, 19, 21, 27, 33, 37, 45, 51, \n55, 61, 75, 81, 99, 109,\
    \ 121, 124, 126, 128, 131, 134, 137, 140, \n143, 146, 149, 152, 155, 158, 161,\
    \ 164, 167, 171, 174, 177, 180, \n183, 186, 189, 193, 196, 198, 201, 204, 207,\
    \ 211, 214, 217, 220]\n\n\n</text>\n<cell>", "\n    sum(nums > 10 & nums >= 10\
    \ & odd(c(trunc(nums), trunc(nums)[-1]))) # number of odd numbers >10 and first\
    \ and last digits are odd\n}\n</cell>\n<cell>\nspecialFilter(c(15, -73, 14, -15))\n\
    </cell>\n<cell>\nspecialFilter(c(33, -2, -3, 45, 21, 109))\n</cell>\n<text>\n\
    Using if/else\nif/else statements test conditions. We can use them to control\
    \ the flow of our program and write clearer and more readable code.\n\nLet's take\
    \ it apart and write out the if statement. Here's the test condition we're using:\n\
    \n\n</text>\n<cell>\nx > 10\n</cell>\n<text>\nNow, let's start our if statement.\
    \ We can use ifelse to write if statements in one line and get nice code like\
    \ so:\n\n\n</text>\n<cell>\nx <- ifelse(x > 10, x, 0)\n</cell>\n<cell>\nx\n</cell>\n\
    <text>\nWe could have also written the above if statement in a more explicit way:\n\
    \n\n</text>\n<cell>\nif (x > 10) x else 0\n</cell>\n<text>\nThe ifelse statement\
    \ also has the handy feature that, if you only have one argument it returns that\
    \ argument unaltered:\n\n\n</text>\n<cell>\nifelse(x > 10, x)\n</cell>\n<text>\n\
    We can also use it to perform logical comparisons and assignments:\n\n\n</text>\n\
    <cell>\nx <- ifelse(x == 2, 1, 0)\nx\n</cell>\n<text>\nIf we only have one argument\
    \ to ifelse, R will return that argument unaltered:\n\n\n</text>\n<cell>\nifelse(x)\n\
    </cell>\n<text>\nConditions\nWe can also use if statements with other types of\
    \ conditions such as logical comparisons and assignments. These conditions are\
    \ described by logical statements (&, |, ~, etc.) in the R language. Here is an\
    \ example of assigning the value of 5 to the variable x if the condition is met\
    \ or x if it is not.\n\nThe below example uses the ifelse function and uses this\
    \ condition x > 10. Let's assign the value of 2 to x if the condition is met and\
    \ assign x to 5 if the condition is not. Notice that we are using the assignment\
    \ operator <-. This is sometimes called assignment/reassignment and it is used\
    \ here to update the value of x. Otherwise, we could have used x = ifelse(x >\
    \ 10, 2, 5).\n\n\n</text>\n<cell>\nx <- ifelse(x > 10, 2, 5)\nx\n</cell>\n<text>",
  "\n  return(nrow(nums[nums > 10 & nums %in% c(1,3,5,7,9)] &\n    nums %in% c(1,3,5,7,9)\
    \ & nums %in% c(1,3,5,7,9)))\n}\n</code>\n<|/ a |>\n<| c |>\nThanks Ben.  I see\
    \ where you were going with this now, but I do not understand how to apply it\
    \ to a vector.  Would you mind showing me how you would apply this to a vector\
    \ (i.e. `c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)`)?\n<|/ c |>\n<| c |>\n\
    I edited my answer to show an example of what it might look like using a function\
    \ that takes a vector as an argument. Hope that helps!\n<|/ c |>\n<| c |>\nWow,\
    \ thanks Ben.  Very clear and easy to understand.  I really appreciate you taking\
    \ the time.\n<|/ c |>\n<| c |>\nI'm glad I could help. Don't forget to accept\
    \ an answer to mark your question as answered.\n<|/ c |>\n<| a tags=r |>\nHere's\
    \ a base R solution:\n<code>\n> ind <- which(\n    abs(c(1, 3, 5, 7, 9) - num)\
    \ <= (10 - 1) *\n      sign(10 - abs(c(1, 3, 5, 7, 9) - num))\n  )\n> length(ind[length(ind)\
    \ > 0])\n[1] 2\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work well with\
    \ vectors that have more than 9 elements.\n<|/ c |>\n<| c |>\n- I'm not sure I\
    \ follow. What's a vector, what does it look like, how do you expect it to behave,\
    \ and what did you expect it to do?\n<|/ c |>\n<| c |>\nI mean `which(abs(c(1,\
    \ 3, 5, 7, 9) - num) <= (10 - 1) * (sign(10 - abs(c(1, 3, 5, 7, 9) - num))))`\
    \ works for vectors of length 1, but `which(abs(c(1, 3, 5, 7, 9) - num) <= (10\
    \ - 1) * (sign(10 - abs(c(1, 3, 5, 7, 9, 11) - num)))))` returns `integer(0)`\n\
    <|/ c |>\n<| c |>\n- Yes, I just saw that `which` coerces the result to `integer`.\
    \ My bad. I've corrected it now.\n<|/ c |>\n<| a |>\nI'm no expert, but I would\
    \ think you would want to use a loop. \n<code>", "\n    length(nums[nums > 10\
    \ & nums %% 1 == 0])\n}\n</cell>\n<text>\n(7) Write a function that takes a vector\
    \ of numbers as input and returns ", "\n  nums %>% \n    filter( between(num,\
    \ 10, 11) & \n             lag(num, default = first(num)) %% 2 != 0 &\n      \
    \       lead(num, default = last(num)) %% 2 != 0 )\n}\n\nspecialFilter(nums)",
  "\n  n <- length(nums)\n  \n  sum(nums > 10 & odd(nums[1]) & odd(nums[(n-1)]))\n\
    }\n", "\n    nums <- nums[!is.na(nums)]\n    ifelse(length(nums)>1, sum(nums >\
    \ 10 & nums[1]%%2==1 & nums[length(nums)]%%2==1), NA)\n}\n", "\n  length(nums[nums\
    \ > 10 & nums %in% c(1, 3, 5, 7, 9)])\n}\n", "\n  return(length(nums[nums > 10\
    \ & nums %in% c(1,3,5,7,9)])/4)\n}\n\nspecialFilter(c(15, -73, 14, -15))", "\n\
    \  sum(nums > 10 & abs(floor(nums)%%2) != 0)\n}\n", "\n  sum(nums > 10 & odd(nums)\
    \ & odd(tail(nums, 1)) & odd(head(nums, 1)))\n}\n</cell>\n<cell>", "\n  length(nums[nums\
    \ > 10 & nums %in% c(1,3,5,7,9)])\n}\n\nspecialFilter(nums)\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nYes, this is true. My question was really more about the general\
    \ algorithm (without having to actually implement it for myself). My solution\
    \ would be to loop through the vector and check whether each element meets my\
    \ criteria and then use length() to return the number of elements that meet that\
    \ criteria.\n<|/ c |>\n<| a |>\nWe can use lengths (from base R) to count the\
    \ number of elements that satisfy a condition (here > 10 and first and last digits\
    \ are odd) in a vector:\n<code>\nlength(nums[nums > 10 & nums %in% c(1,3,5,7,9)])\n\
    </code>\n<|/ a tags=r dscore=1 |>\n<| a dscore=1 |>\n<code>\nspecialFilter <-\
    \ function(nums){\n  nums[(grepl(\"^\\\\d\",nums)) & ((as.numeric(substr(nums,nchar(nums)-2,nchar(nums)))\
    \ & odd) == 1)]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis fails if you pass\
    \ a vector with just one number (or character) into the function. It also fails\
    \ if you have `NA`s (try running `specialFilter(c(NA,NA))`.\n<|/ c |>\n<| c |>\n\
    Thanks, this is what I was looking for.\n<|/ c |>\n<| c |>\nGreat solution. I\
    \ think it would be better to have another condition `grepl(\"^\\\\d\",nums)`\
    \ so it only applies `substr` on whole numbers. Then you won't have to worry about\
    \ `nchar` - which I suspect is slower.\n<|/ c |>\n<| a tags=r |>\nHere's a slightly\
    \ different way of doing it.\n<code>\nspecialFilter <- function(nums){\n  any(grepl(\"\
    ^\\\\d\",nums)) & (as.numeric(substr(nums,nchar(nums)-2,nchar(nums))) & odd) ==\
    \ 1\n}\n</code>\nThe only difference is that the function returns TRUE or FALSE\
    \ as opposed to an integer. Since you probably don't want to change it to a boolean\
    \ you can use:\n<code>\nspecialFilter(nums)\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nI think you made a mistake in the condition for `grepl(\"^\\\\d\",nums)`.\
    \ It will return true on integers also. You could use `\"^-?\\\\d*\"` in your\
    \ regex. This will ", "\n  nums %>% \n    as.integer %>% \n    length(which(.\
    \ > 10 & lead(.) %% 2 != 0 & lag(.) %% 2 != 0))\n}\n\nspecialFilter(c(15, -73,\
    \ 14, -15, 0, -2, -3, 4, 5, 21, 109))", "\n  nums[nums > 10] <- 0\n  length(which((nums\
    \ %/% 2) == 1 & (nums %/% 1) == 1))\n}\n", "\n  nums[nums > 10 & odd(first(nums))\
    \ & odd(last(nums))]\n}\n", "\n    n1 <- length(nums)\n    n <- sum(nums>10)\n\
    \    n <- n+n1-n\n    if(n %% 2 == 0) {\n        return(1)\n    } else {\n   \
    \     return(0)\n    }\n}\n", "\n  nums<-nums\n  length(nums)\n  which(nums>10\
    \ & all(nums%%10%%2==1))\n}\n</code>\n<|/ a tags=r,data.table,dplyr |>\n<| a dscore=2\
    \ |>\nI think this can be done by first grouping your data, then applying a function\
    \ to each group and then ungrouping it.\n<code>\nlibrary(dplyr)\nset.seed(123)\n\
    df <- data.frame(\n  X = sample(1:100, 10, replace = TRUE)\n)\n</code>\nFunction\n\
    <code>\nf <- function(x){\n  out <- sum(x %% 10 == 1) >= 2 & all(x %% 10 %in%\
    \ c(1, 3, 5))\n  return(out)\n}\n</code>\nApply function\n<code>\ndf %>% \n  group_by(group\
    \ = gl(n(), 2, 2)) %>% \n  summarise(result = f(X))\n", "\n  sum(nums > 10 & odd(first(nums))\
    \ & odd(last(nums)))\n}\n", "\n  sum(nums > 10 & nums %% 10 == 1) &\n  sum(nums\
    \ > 10 & nums %% 10 == 1) & \n  sum(nums %% 10 == 1)\n}\n</cell>\n<cell>", "\n\
    \  res <- 0L\n  for (i in 1:length(nums))\n    if (nums[i] > 10 && abs(nums[i]\
    \ %% 1L) %% 2 == 1L && \n        nums[i] %% 1L != 0L)\n      res <- res + 1L\n\
    \  return(res)\n}\n\nset.seed(1)\nnums <- sample(1:1e7)\nmicrobenchmark(\n  specialFilter(nums),\n\
    \  length(which(nums > 10 & nums %% 1L %% 2 == 1L & nums %% 1L != 0L)),\n  times=1000\n\
    )\n", "\n    nums[nums > 10 & nums %% 10 %% 2 == 1]\n}\n", "\n  nums[nums > 10]\
    \ <- 10\n  nums[nums > 10 & nums %% 2 == 1] <- 0\n  sum(nums > 10 & nums %% 2\
    \ == 1)\n}\n\n</cell>\n<cell>\nspecialFilter(c(15, -73, 14, -15))", "\n  return(nrow(nums[nums\
    \ > 10 & nums %in% c(1, 3, 5, 7, 9)])) # count > 10 and first and last are odd\n\
    }\n", "\n  nums <- nums[nums > 10] \n  nums <- nums[nums %in% c(1,3,5,7,9)]\n\
    \  nums <- length(nums)\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\n<code>\n\
    specialFilter <- function(nums) {\n  nums <- nums[nums > 10] \n  nums <- nums[nums\
    \ %in% c(1,3,5,7,9)]\n  nums <- length(nums)\n}\n</code>\nThis also works:\n<code>\n\
    specialFilter <- function(nums) {\n  nums <- nums[nums > 10] \n  nums <- nums[!(nums\
    \ %in% c(1,3,5,7,9))]\n  nums <- length(nums)\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks. Could you provide more explanation of how this works? I believe\
    \ my code above will output 1 when it should output 2. I'm having trouble figuring\
    \ this out.\n<|/ c |>\n<| c |>\nThe trick is that you're applying the function\
    \ to a vector of integers. In your solution, you're returning the number of elements\
    \ in the vector that are greater than 10, but you're applying the function to\
    \ the whole vector and getting the output that you've posted in the question.\
    \ You need to apply the function to the subset of the vector you want.\n<|/ c\
    \ |>\n<| c |>\nSo if I apply it to c(15, -73, 14, -15) I should get 1 because\
    \ the first and last elements are odd. But if I apply it to c(33, -2, -3, 45,\
    \ 21, 109) I should get 2 because the first and last elements are odd. So my solution\
    \ gives me 2 when it should give me 1. I think I understand that my code was counting\
    \ the number of elements in the vector that are greater than 10 but not applying\
    \ it to the subset of the vector.\n<|/ c |>\n<| c |>\nYes, you're right. The issue\
    \ is that your function didn't do what you think it did. That was the key point\
    \ of the answer, so I figured I'd post it.\n<|/ c |>\n<| c |>\nYes, I thought\
    \ it applied the function to the subset of the vector.  I'm just not sure why\
    \ it wasn't working as I thought it would. Thanks.\n<|/ c |>\n<| a dscore=0 |>\n\
    Your code has two problems:\n\nIt only looks at the first element of nums.\nIt\
    \ doesn't look at the entire vector.\n\n<code>\nspecialFilter <- function(nums)\
    \ {\n  nums <- nums[nums > 10] \n  nums <- num", "\n  nums[nums > 10] <- NA\n\
    \  x <- nums[c(TRUE, FALSE)]\n  y <- nums[c(FALSE, TRUE)]\n  return(sum(x & y))\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is another variation on\
    \ akrun's answer, which I think is more efficient and concise:\n<code>\nspecialFilter\
    \ <- function(nums) {\n  nums[nums > 10] <- NA\n  x <- nums[c(TRUE, FALSE)]\n\
    \  y <- nums[c(FALSE, TRUE)]\n  return(sum(x & y))\n}\n</code>\n<|/ a tags=vector,r,sum,filter\
    \ |>\n<| a tags=vector,r,sum,filter |>\nHere's a base R option\n<code>\nspecialFilter\
    \ <- function(nums) {\n   nums[nums > 10] <- NA\n   x <- nums[c(TRUE, FALSE)]\n\
    \   y <- nums[c(FALSE, TRUE)]\n   return(sum(x & y))\n}\n\nspecialFilter(c(15,-73,14,-15))",
  "\n  nums2 <- nums[c(TRUE, FALSE)]\n  length(nums2[nums2 > 10  &\n             \
    \    nums2 %% 1 == 0 &\n                 nums2 %% 2 == 0])\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nI like this solution, but I wanted to avoid using an external\
    \ library and I wanted to be able to see it in action.  I did that myself using\
    \ just `c()` and `which()`\n<|/ c |>\n<| c |>\nYou can see the code I used here\
    \ if you're curious.  It's just `which()` without `c()` and I'm just passing the\
    \ `nums` vector into `which()`\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ your code.  I didn't use `which()`, but rather `c()` and `%in%`.  I then used\
    \ `length()` to count the number of elements of `nums` that are greater than 10\
    \ and both first and last digits are odd.\n<|/ c |>\n<| a tags=r dscore=0 |>\n\
    You can use the following code:\n<code>", "\n  nums <- nums\n  if (length(nums)\
    \ < 2) \n    stop(\"The vector has to be at least length 2.\")\n  \n  # Store\
    \ each element in a new vector\n  nums2 <- nums\n  \n  # Filter the first and\
    \ the last element\n  nums3 <- nums2[c(TRUE, FALSE)]\n  \n  # Check if all elements\
    \ are odd numbers. Return 0 if this is the case\n  length(unique(nums3)) \n  \
    \  \n  # Check if all elements are greater than 10 and at least one of them is\
    \ odd\n  length(which(nums3 > 10 & any(nums3 %% 1 != 0)))\n}\n", "\n  nums <-\
    \ nums[nums > 10]\n  nums <- nums[(floor(log(nums, 10)) %% 2) == 1]\n  nums <-\
    \ nums[nums >= 1]\n  length(nums)\n}\n</cell>\n<cell>", "\n  nums <- as.vector(nums)\n\
    \  \n  nums <- nums[nums > 10]\n  \n  nums <- nums[c(TRUE, nums[2] %% 2 == 1)]\n\
    \  nums <- nums[c(TRUE, nums[-1] %% 2 == 1)]\n  \n  return(length(nums))\n}\n",
  "\n  sum(nums > 10 & c(tail(nums, -1), first(nums)) %% 2)\n}\n</code>\n<|/ a tags=r,filter\
    \ dscore=0 |>\n<| c |>\nThis also works well, thanks. But I prefer the `filter`\
    \ solution in case I want to apply it to other scenarios as well.\n<|/ c |>\n\
    <| a tags=r,filter dscore=0 |>\n<code>\nx <- c(15, -73, 14, -15)\ngrepl(\"^[0-9]+$\"\
    ,x) && grepl(\"^[13579]+$\",x) ", "\n  nums <- as.integer(nums)\n  nums <- nums[nums\
    \ > 10]\n  nums <- nums[nums %in% c(1,3,5,7,9)]\n  sum(nums > 10 & nums %in% c(1,3,5,7,9))\n\
    }\n", "\n  # YOUR CODE HERE\n\n  sum(nums > 10 & nums %% %% 2 != 0)\n}\n\nspecialFilter(c(15,\
    \ -73, 14, -15))\n</code>\n<|/ a dscore=3 |>\n<| c |>\nNice! Thanks for sharing\
    \ your solution!\n<|/ c |>\n<| a dscore=2 |>\nThis one is a little different in\
    \ that we can use dplyr::filter\n<code>\nlibrary(dplyr)\ndf %>% filter(nums >\
    \ 10 & nums %% 2 != 0)\n</code>\nWe could also do \n<code>\ndf %>% filter(nums\
    \ > 10 & lead(nums, default = 0) %% 2 != 0)\n</code>\n<|/ a tags=r |>\n<| a tags=r\
    \ |>\nIf performance is not critical, here is one solution using base R:\n<code>\n\
    df[as.logical(ave(df$nums, df$nums > 10 & df$nums %% 2 != 0, FUN = function(x)\
    \ x)),]\n</code>\n<|/ a dscore=1 |>\n<| a |>\nTry this:\n<code>\ndf[df$nums >\
    \ 10 & substr(df$nums, 1,2) %% 2 != 0,]\n</code>\n<|/ a dscore=0 tags=r |>\n<|\
    \ c |>\nI get the following error:\n\nError in substr(df$nums, 1, 2) %% 2 != 0\
    \ : non-numeric argument for binary operator\n<|/ c |>\n<| c |>\nSorry, I misread\
    \ the question.  See the edit and let me know if that's what you want.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nHere is an option with dplyr\n<code>\nlibrary(dplyr)\n\
    df %>%\n    filter(nums > 10 & lead(nums, default = 0) %% 2 != 0)\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nThanks for sharing your solution!\n<|/ c |>\n<| c |>\n\
    This one isn't working for me, I get this error:\nError in eval(expr, envir, enclos)\
    \ : \n  unused argument (lead(nums, default = 0) %% 2 != 0)\n<|/ c |>\n<| c |>\n\
    I am not getting the error.  May be you have a different version of `dplyr`. \
    \ I am using `dplyr_0.4.2`\n<|/ c |>\n<| c |>\n`dplyr_0.4.3` gives me a different\
    \ error about `base::filter`\n<|/ c |>\n<| c |>\nIt gives `", "\n  numsFilter\
    \ <- Filter(function(n) {\n    n > 10 & \n      (substr(n, 1, 1) %% 2 != 0 | substr(n,\
    \ -1, 1) %% 2 != 0)\n  }, nums)\n  length(numsFilter)\n}\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nHere's a vectorized solution in base R that also uses regular\
    \ expressions to find the first and last digits:\n<code>\nfindNumbers <- function(n)\
    \ {\n  m <- gregexpr(\"\\\\d+\", n)\n  regmatches(n, m) %>% \n    lapply(function(x)\
    \ {\n      gregexpr(\"\\\\w+\", x) %>% \n        lapply(function(y) {\n      \
    \    x <- trimws(x)\n          y <- trimws(y)\n          return(ifelse(y[1] ==\
    \ \"-\" & y[2] == \"-\", \"0\", \"1\"))\n        }) %>% \n        Reduce(cbind,\
    \ .)\n    }) %>% \n    Reduce(cbind, .) %>% \n    as.data.frame %>% \n    colSums\n\
    }\n\nfindNumbers(c(15, -73, 14, -15))", "\n    sum(nums > 10 & odd(nums) & odd(c(nums[1],\
    \ nums[length(nums)]))) \n}\n", "\n  nums1 <- nums[which(nums > 10)]\n  return(length(nums1[which(is.odd(nums1))\
    \ & \n                      (as.numeric(nums1[which(as.logical(nums1))] == 1L))]))\n\
    }\n", "\n  sum(nums > 10 & odd(nums[c(1,length(nums))]) & odd(nums[c(1,length(nums)-1)]))\n\
    }\n", "\n  sum(nums > 10 & nums[2] %% 2 == 1)\n}\n", "\n  n <- length(nums)\n\
    \  n <- n[n > 0]\n  n <- n[nums > 10]\n  \n  n <- n[which(grepl(\"odd\", c(nums,\
    \ n[-n])))]\n  n <- n[which(grepl(\"odd\", c(nums[-n], nums[-n + 1])))]\n  \n\
    \  n\n}\n\nspecialFilter(c(15, -73, 14, -15))", "\n  length(which(nums > 10 &\
    \ odd(c(floor(nums/10^2), last(nums)))))\n}\n", "\n  nums <- nums[nums > 10 &\
    \ nums < 99 & nums %in% c(1, 3, 5, 7, 9)]\n  return(nums)\n}\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that takes as input a list of numbers, and returns\
    \ \nthe list with duplicated items removed:\n>>> duplicated(c(15, -73, 14, -15))\n\
    [1] FALSE  TRUE  TRUE FALSE\n\n</text>\n<cell>", "\n  return(length(nums)-sum(nums\
    \ > 10 & nums %in% c(1, 3, 5, 7, 9)))\n}\n", "\n  x <- nchar(nums)\n  if (x >\
    \ 10) {\n    if (x %% 2 == 1 && x %% 3 == 1) {\n      return(sum(nums > 10))\n\
    \    } else {\n      return(sum(nums > 10 & nums %% 2 != 0 & nums %% 3 != 0))\n\
    \    }\n  } else {\n    return(0)\n  }\n}\n</cell>\n<text>\nRewrite the previous\
    \ function using a single line, as we did in the lecture:\n\n\n</text>\n<cell>\n\
    specialFilter2 <- function(nums) {\n  x <- nchar(nums)\n  sum(x > 10 & x %% 2\
    \ != 0 & x %% 3 != 0)\n}\n</cell>\n<text>\nThe two functions produce the same\
    \ results, but the second one is easier to read. The first one is faster.\n\n\n\
    </text>\n<text>\nFiltering on a single element\nLet's say we want to select only\
    \ those numbers which are divisible by three. How can we do this?\n\n\n</text>\n\
    <cell>", "\n  nums[length(nums)] <- 0\n  nums[1] <- nums[1] + 2\n  nums[2] <-\
    \ nums[2] + 2\n  nums[length(nums) - 1] <- nums[length(nums) - 1] + 2\n  nums[length(nums)]\
    \ <- 0\n  return(sum(nums > 10 & odd(nums) & odd(nums) & odd(nums)))\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThe point is I don't want to have to type those numbers\
    \ by hand.\n<|/ c |>\n<| c |>\nAh I see. I added a solution based on your code\
    \ but using only a single vectorized function.\n<|/ c |>\n<| c |>\nWhat are you\
    \ talking about? I still have to type the numbers by hand in my code. Why do you\
    \ think my code requires me to type the numbers by hand?\n<|/ c |>\n<| c |>\n\
    Oh I see. You were suggesting that I add `c(15, -73, 14, -15)` to my code instead\
    \ of `c(1,2,3,4,5,6,7,8,9,10)`. That works but it is not what I was asking for.\
    \ I have edited my question and provided a better description of what I need.\n\
    <|/ c |>\n<| c |>\nYes you were right, my apologies. I'm going to try and find\
    \ a way to make that more efficient. Thanks for the feedback.\n<|/ c |>\n<| a\
    \ tags=r |>\nHere's an approach that only uses a single vectorized function. It\
    \ finds the index of the first element that is greater than 10, checks that its\
    \ first two digits are odd, and that its last two digits are odd, and returns\
    \ the number of odd digits in each number greater than 10 and odd in each of the\
    \ numbers before it.\n<code>\nspecialFilter <- function(nums) {\n  first_occurences\
    \ <- which(nums > 10)[1]\n  first_two <- nums[first_occurences] - 10\n  last_two\
    \ <- 10 - nums[length(nums) - first_occurences]\n  sum(first_two > 10 & odd(first_two)\
    \ & odd(first_two) & odd(last_two))\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r\
    \ |>\nYou don't really need to create a loop to find the first value greater than\
    \ 10 (nor do you need that value to store a temporary value).  It's just that\
    \ you want to know how many digits are odd in each number greater than 10.  So\
    \ just find that number:\n<code>\nspecialFilter <- function(nums) {\n  first_value\
    \ <- which(nums > 10)[1]\n", "\n  # Your code here!\n  n <- length(nums)\n  if(n\
    \ > 1) {\n    if(nums[1] > 10 & nums[-n] > 10 & nums[[1]] %% 2 == 1 & nums[-n]\
    \ %% 2 == 1)\n      return(1)\n  }\n  return(0)\n}\n\nspecialFilter(c(15, -73,\
    \ 14, -15))", "\n  nums <- nums[nums > 10]\n  nums[which(nums %in% c(1:9) & nums\
    \ %in% c(7:1))]\n}\n", "\n    nums <- sort(nums)\n    sum((nums >= 10) & (nums\
    \ %% 2 == 1)) - ((nums %% 2 == 0) & (nums <= 10)) \n}\n", "\n  sum(nums > 10 &\
    \ nums %% 1 != 0)\n}\n</code>\n<|/ a tags=filtering,r,dataframe dscore=2 |>\n\
    <| c |>\nThanks for your answer, but could you please explain how this works?\n\
    <|/ c |>\n<| c |>\nI added some comments. I hope that helps.\n<|/ c |>\n<| c |>\n\
    thanks! I do understand the first two lines of the code, but the `&` and `%in%`\
    \ parts seem to be a bit beyond me. Could you give a quick explanation how this\
    \ works and why it works please? Thanks! :)\n<|/ c |>\n<| c |>\n`%in%` means \"\
    is one of\". `&` means \"and\". It's like `and`, `&&`.\n<|/ c |>\n<| c |>\nThis\
    \ is really cool! But why use %in% instead of ==?\n<|/ c |>\n<| a |>\nThe first\
    \ thing you should do is read the answer to this question: How to use R to count\
    \ how many time a condition holds per group?\nThe code you want will look like\
    \ this:\n<code>", "\n  nums.filtered <- nums[nums > 10 & nums %in% c(1,3,5,7,9)]\n\
    \  return(length(nums.filtered))\n}\n", "\n  nums[sapply(nums, `>=`, 10) & \n\
    \        sapply(nums, `%%`, 1)%%2 &\n        !(floor(log10(min(nums))) & \n  \
    \        (floor(log10(max(nums))) & \n           (floor(log10(min(nums)) - floor(log10(max(nums))\
    \ + 1)) & \n           ((floor(log10(max(nums)) - floor(log10(min(nums)) + 1))\
    \ & \n            (floor(log10(max(nums)) - floor(log10(min(nums)) + 1)) & \n\
    \            (floor(log10(max(nums)) - floor(log10(min(nums)) + 1)) & \n     \
    \       (floor(log10(max(nums)) - floor(log10(min(nums)) + 1)) & \n          \
    \  (floor(log10(max(nums)) - floor(log10(min(nums)) + 1)) & \n            (floor(log10(max(nums))\
    \ - floor(log10(min(nums)) + 1)) & \n            (floor(log10(max(nums)) - floor(log10(min(nums))\
    \ + 1)) & \n            (floor(log10(max(nums)) - floor(log10(min(nums)) + 1))\
    \ & \n            (floor(log10(max(nums)) - floor(log10(min(nums)) + 1)) & \n\
    \            (floor(log10(max(nums)) - floor(log10(min(nums)) + 1))))))\n    ]\
    \ \n}\n</cell>\n<text>\nNow we can check that our function works correctly on\
    \ our sample data.\n\n\n</text>\n<cell>\nspecialFilter(c(15, -73, 14, -15))\n\
    </cell>\n<text>\nLooks good! Next, let's get the list of all prime numbers less\
    \ than 1000:\n\n\n</text>\n<cell>\nprime <- function(x) {\n  x <- floor(x)\n \
    \ x <- x[x %% 1 == 0 & \n           !(x %% 2 & x == 0 || x == 1) & \n        \
    \   !(x %% 3 & x == 0 || x == 1) & \n           !(x %% 5 & x == 0 || x == 1) &\
    \ \n           !(x %% 7 & x == 0 || x == 1) & \n           !(x %% 9 & x == 0 ||\
    \ x == 1) & \n           !(x %% 11 & x == 0 || x == 1) & \n           !(x %% 13\
    \ & x == 0 || x == 1) & \n           !(x %% 17 & x == 0 || x == 1) & \n      \
    \     !(x %% 19 & x == 0 || x == 1) & \n           !(x %% 23 & x == 0 || x ==\
    \ 1) & \n           !(x %% 29 & x == 0 || x == 1) & \n           !(x %% 31 & x\
    \ == 0 || x == 1) & \n           !(x %% 37 & x == 0 || x == 1) & \n          \
    \ !(x %% 43 & x == 0 || x == 1) & \n           !(x %% 53 & x == 0 || ", "\n  \
    \  nums[nums > 10 & odd(nums) & firstDigitOdd(nums) & lastDigitOdd(nums)]\n}\n\
    </cell>\n<text>\nAnd that's it! You're done!\nAs you can see, the filtering conditions\
    \ just consist of four functions and three boolean operations. In general, these\
    \ filter conditions can be broken down into smaller pieces to do more complicated\
    \ filtering, but to keep things simple, we'll just stick to basic filtering for\
    \ now.\n\n\n</text>\n<text>\nExploring data\nOne of the reasons you might want\
    \ to start exploring your data before doing any more computation is if you notice\
    \ any suspicious patterns. To explore your data a little further, let's first\
    \ write a function to extract the first and last numbers from a vector.\n\n\n\
    </text>\n<cell>", "\n    ns <- nums[sapply(nums, is.numeric)]\n    ns2 <- nums[sapply(nums,\
    \ is.numeric)]\n    ns2[sapply(ns2, function(x) (x < 10) & (x %% 1 != 0) & (x\
    \ %% 10 == 0))]\n    sum(ns2 > 10 & odd(ns2[[1]]) & odd(ns2[length(ns2)]))\n}\n",
  "\n    nr <- length(nums)\n    if(nr == 0) {\n        return(0)\n    }\n    m <-\
    \ cbind(nums[length((nums)) %% 2 != 0], nums[(length((nums)) %% 2)])\n    res\
    \ <- sum(m > 10 & m[1,1]%%2 == 1 & m[2,1]%%2 == 1)\n    return(res)\n}\n", "\n\
    \  require(plyr)\n  require(dplyr)\n  nums <- mutate(nums, \n                \
    \ firstOdd = (as.integer(floor(log10(as.numeric(nums))))%%2) == 1,\n         \
    \        lastOdd = (as.integer(floor(log10(as.numeric(nums))))%%2) == 1,\n   \
    \              firstLastOdd = firstOdd & lastOdd)\n  nums <- filter(nums, firstLastOdd\
    \ & !(firstOdd | lastOdd))\n  nums <- nrow(nums)\n  return(nums)\n}\n", "\n  sum(nums\
    \ > 10 & \n    round(nums, 1) %% 1 == 0 & \n    round(nums, 1) %% 2 == 1)\n}\n\
    </code>\nLet's test this function and see what we get:\n<code>\nspecialFilter(c(15,\
    \ -73, 14, -15))", "\n    sum(nums > 10 & odd(nums[1]) & odd(nums[length(nums)])\n\
    }\n</cell>\n<text>\nQuestion 7\nThe function below takes a vector of numbers as\
    \ an input and returns a vector of boolean values that indicate if the number\
    \ is prime or not. The rules for determining whether a number is prime are as\
    \ follows:\n\nIf any number is odd, return FALSE\nIf all numbers in the vector\
    \ are either 1 or 2, return TRUE\nFor all other numbers, check if they are all\
    \ primes up to and including sqrt of the number. If not, return FALSE\n\n\n</text>\n\
    <cell>\nprimeFilter <- function(nums) {\n    if(any(nums %in% c(1,2)))\n     \
    \   return(TRUE)\n    else \n        if(all(nums %in% seq(1,sqrt(nums),2)))\n\
    \            return(TRUE)\n        else\n            return(FALSE)\n}\n</cell>\n\
    <text>\nQuestion 8\nThe function below takes a vector of numbers as an input and\
    \ returns a vector of boolean values that indicate if the number is prime or not.\
    \ The rules for determining whether a number is prime are as follows:\n\nIf any\
    \ number is odd, return FALSE\nIf all numbers in the vector are either 1 or 2,\
    \ return TRUE\nFor all other numbers, check if they are all primes up to and including\
    \ sqrt of the number. If not, return FALSE\n\n\n</text>\n<cell>", "\n  nums <-\
    \ as.numeric(unlist(nums))\n  sum(nums > 10 & first(nums%%2) == 1 & last(nums%%2)\
    \ == 1)\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
