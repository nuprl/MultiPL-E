name: HumanEval_70_strange_sort_list
language: r
prompt: "# Given list of integers, return list in strange order.\n# Strange sorting,\
  \ is when you start with the minimum value,\n# then maximum of the remaining integers,\
  \ then minimum and so on.\n# Examples:\n# >>> strange_sort_list(c(1, 2, 3, 4))\n\
  # c(1, 4, 2, 3)\n# >>> strange_sort_list(c(5, 5, 5, 5))\n# c(5, 5, 5, 5)\n# >>>\
  \ strange_sort_list(c())\n# c()\nstrange_sort_list <- function(lst) {"
tests: "test_humaneval <- function() {\ncandidate <- strange_sort_list\n    if(!identical(candidate(c(1,\
  \ 2, 3, 4)), c(1, 4, 2, 3))){quit('no', 1)}\n    if(!identical(candidate(c(5, 6,\
  \ 7, 8, 9)), c(5, 9, 6, 8, 7))){quit('no', 1)}\n    if(!identical(candidate(c(1,\
  \ 2, 3, 4, 5)), c(1, 5, 2, 4, 3))){quit('no', 1)}\n    if(!identical(candidate(c(5,\
  \ 6, 7, 8, 9, 1)), c(1, 9, 5, 8, 6, 7))){quit('no', 1)}\n    if(!identical(candidate(c(5,\
  \ 5, 5, 5)), c(5, 5, 5, 5))){quit('no', 1)}\n    if(!identical(candidate(c()), c())){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(1, 2, 3, 4, 5, 6, 7, 8)), c(1, 8, 2, 7, 3,\
  \ 6, 4, 5))){quit('no', 1)}\n    if(!identical(candidate(c(0, 2, 2, 2, 5, 5, -5,\
  \ -5)), c(-5, 5, -5, 5, 0, 2, 2, 2))){quit('no', 1)}\n    if(!identical(candidate(c(111111)),\
  \ c(111111))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  l <- length(lst)\n  if(l == 0) return(c())\n  if(l == 1) return(c(lst))\n\
    \  if(l == 2) return(c(lst[1], lst[2]))\n  m <- msort(lst)\n  if(m[[1]] <= m[[2]])\
    \ return(c(m[[1]], m[[2]]))\n  if(m[[1]] >= m[[2]]) return(c(m[[2]], m[[1]]))\n\
    \  return(c(m[[1]], m[[2]]))\n}\n", "\n  for(i in seq_along(lst)){\n    lst[[i]]\
    \ <- lst[[i]] %>% paste(collapse = \"-\")\n  }\n  return(lst)\n}\n", "\n  return(lst[order(-lst)])\n\
    }\n", "\n  if (length(lst) == 0) return(c())\n  if (length(lst) == 1) return(c(lst))\n\
    \n  ret <- c(lst)\n  ret <- c(rev(ret), lst)\n\n  i <- 1\n  j <- 1\n  ret <- c(ret,\
    \ lst[[i]])\n  while((length(ret) > 1) & identical(ret[[1]], ret[[2]])) {\n  \
    \  j <- j + 1\n    ret[[i + 1]] <- ret[[i + j]]\n  }\n\n  ret <- c(rev(ret), lst[[i]])\n\
    \  return(ret)\n}\n", "\n  lst <- sort(lst)\n  lst <- sort(lst)\n  lst <- sort(lst)\n\
    \  return(lst)\n}\n", "\n  return(lst)\n}\n</code>\nA function that will sort\
    \ a list of integers using the strange sorting described above:\n<code>\nstrange_sort_list\
    \ <- function(lst) {\n  return(lst)\n}\n</code>\nTo get strange sorting on numeric\
    \ values, just replace the list(c(1, 2, 3, 4)) with list(c(1, 4, 2, 3)) to compare\
    \ the results for numeric values!\n<code>\nstrange_sort_list(c(1, 2, 3, 4)) #\
    \ c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1,\
    \ 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\n\
    strange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2,\
    \ 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1,\
    \ 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\n\
    strange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2,\
    \ 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1,\
    \ 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\n\
    strange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2,\
    \ 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1,\
    \ 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\n\
    strange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2,\
    \ 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1,\
    \ 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\n\
    strange_sort_list(c(1, 4, 2, 3)) # c(1, 4, 2, 3)\nstrange_sort_", "\n    l <-\
    \ length(lst)\n    if (l == 1) {\n        lst\n    } else {\n        if (l ==\
    \ 2) {\n            list(lst[1], lst[2])\n        } else {\n            if (l\
    \ == 3) {\n                list(lst[1], lst[2], lst[3])\n            } else {\n\
    \                if (l == 4) {\n                    list(lst[1], lst[2], lst[3],\
    \ lst[4])\n                } else {\n                    return(lst)\n       \
    \         }\n            }\n        }\n    }\n}\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nI created a function called strange_sort that takes an array of numbers\
    \ and returns a sorted version of that array of numbers. \n<code>\nstrange_sort\
    \ <- function(x) {\n  l <- length(x)\n  if(l > 1) {\n    if((l - 1) %in% c(1,\
    \ 4, 3, 2))\n      return(sort(x))\n    else if((l - 1) %in% c(1, 3, 2))\n   \
    \   return(sort(x[seq(1, l - 1)]))\n    else if((l - 1) %in% c(1, 2))\n      return(sort(x[seq(1,\
    \ l - 1)], decreasing = TRUE))\n    else if((l - 1) %in% c(1))\n      return(sort(x[seq(1,\
    \ l - 1)], decreasing = TRUE))\n    else if((l - 1) %in% c(0, 2))\n      return(sort(x,\
    \ decreasing = TRUE))\n  }\n  return(x)\n}\n</code>\n<|/ a tags=sorting,r |>\n\
    <| a |>\n<code>\n> x <- c(1,2,3,4)\n> x[order(x)]\n[1] 1 2 3 4\n</code>\n<|/ a\
    \ dscore=2 tags=sorting,r |>\n<| c |>\nThis would work, but unfortunately it doesn't\
    \ give the correct results. When you sort a vector of length 1, it returns the\
    \ vector unsorted. When you sort a vector of length 2, it sorts it in ascending\
    \ order, which is what OP wanted to do, but then when you sort a vector of length\
    \ 3, it sorts it in ascending order, then descending order, then ascending order,\
    \ and so on. That's why your code gives the wrong answer. See the example in the\
    \ OP's question.\n<|/ c |>\n<| a |>\n<code>\nx = c(2,1,3,4)\nx[order(x, decreasing\
    \ = TRUE)]", "\n  # Initialize a result with first element of lst\n  result <-\
    \ lst[1]\n\n  # Then go through the rest of lst and compare them to the result\n\
    \  for(i in 2:length(lst)) {\n    if(lst[i] > result) {\n      result <- lst[i]\n\
    \    }\n  }\n  return(result)\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI used\
    \ some sample data I got from a previous answer:\n<code>\nset.seed(69)\n\nmy_list\
    \ <- list(1:5, 1:6, 1:10, 1:15, 1:100)\n", "\n  lst <- as.list(lst)\n  lst <-\
    \ do.call(order, c(lst))\n  return(do.call(c, lst))\n}\n\nstrange_sort_list(c(1,\
    \ 2, 3, 4))\nstrange_sort_list(c(5, 5, 5, 5))\nstrange_sort_list(c())\n</code>\n\
    Output:\n<code>\nc(1, 4, 2, 3)\nc(5, 5, 5, 5)\nc()\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\n<code>\nstrange <- function(x) {\n  y <- sort(x)\n  paste(head(x,-1), tail(y,\
    \ -1*(length(x)-1)), sep=\"\")\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n\
    <code>\nstrange <- function(x) {\n  paste(head(x,-1), tail(sort(x), -1), sep=\"\
    \")\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nstrange <- function(x) {\n\
    \  paste(x[-c(1)], x[c(1)], sep=\"\")\n}\n</code>\n<|/ a tags=r dscore=2 |>\n\
    <| c |>\nPlease add some explanation to your answer.\n<|/ c |>\n<| a dscore=1\
    \ tags=r |>\nUsing's function I came up with this:\n<code>\nstrange <- function(x){\n\
    \  paste(sort(x[-length(x)]), x[length(x)], sep=\"\")\n}\n</code>\n<|/ a |>\n\
    <| a tags=r |>\nHere is another one using sort\n<code>\nstrange <- function(x)\
    \ {\n    paste(sort(x[-length(x)]), x[length(x)], sep=\"\")\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\n<code>\nstrange_sort_list <- function(lst){\n  lst <-\
    \ as.list(lst)\n  lst <- do.call(order, c(lst))\n  return(do.call(c, lst))\n}\n\
    \nstrange_sort_list(c(1, 2, 3, 4))\nstrange_sort_list(c(5, 5, 5, 5))\nstrange_sort_list(c())\n\
    </code>\nOutput:\n<code>\nc(1, 4, 2, 3)\nc(5, 5, 5, 5)\nc()\n</code>\n<|/ a dscore=1\
    \ tags=r |>\n<| a tags=r |>\n<code>\nstrange <- function(x) {\n  y <- sort(x)\n\
    \  paste(head(x,-1), tail(y, -1*(length(x)-1)), sep=\"\")\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=r |>\n<code>\n", "\n  lst.len <- length(lst)\n  if (lst.len <=\
    \ 1) { return(lst) }\n\n  min <- head(lst)\n  max <- tail(lst)\n  if (min == max)\
    \ {\n    return(lst + c(min))\n  }\n  \n  # Sort list ascending order\n  sorted\
    \ <- c(min, max)\n  \n  # Sort list by descending order\n  reverse.sorted <- c(reverse(min),\
    \ reverse(max))\n  \n  # Combine two lists\n  strange.sorted <- c(sorted, reverse.sorted)\n\
    \  \n  return(strange.sorted)\n}\n\nstrange_sort_list(c(1, 2, 3, 4))", "\n  lst\
    \ <- lst[!is.na(lst)]\n  nam <- names(lst)\n  return(names(lst)[c(1, order(-unlist(lst),\
    \ decreasing = TRUE), 1)])\n}\n\nstrange_sort_list <- function(lst) {\n  return(sort(names(lst)[c(1,\
    \ order(-unlist(lst), decreasing = TRUE), 1)]))\n}\n", "\n  sort_list <- function(x)\
    \ x[order(x)] \n  map_chr(lst,sort_list)\n}\n", "\n  stopifnot(is.list(lst))\n\
    \  \n  out <- lst[order(as.numeric(names(lst)))]\n  names(out) <- NULL\n  out\n\
    }\n", "\n  l <- c(lst[[1]], lst[length(lst)], lst[[1]], lst[length(lst)])\n  names(l)\
    \ <- NULL\n  l\n}\n", "\n  # Sort list by decreasing order.\n  result <- lst[order(-lst)]\n\
    \  # Return sorted list.\n  return(result)\n}\n</code>\n<|/ a dscore=1 tags=sorting,r\
    \ |>\n<| a |>\nBased on's answer, here's a functional version using lapply.  It\
    \ sorts numerically before alphabetically.\n<code>\nstrange_sort_list <- function(lst)\
    \ {\n    result <- lst[order(lapply(lst, as.numeric))][order(lapply(lst, as.character))]\n\
    \    return(result)\n}\n\nstrange_sort_list(c(7, 2, 9, 1, 3, 5, 8))", "\n  if\
    \ (length(lst) < 2) {\n    return(lst)\n  } else {\n    tmp_list <- lst[seq_len(length(lst))]\n\
    \    tmp_list1 <- lst[seq_len(length(lst)-1)]\n    tmp_list2 <- lst[seq_len(length(lst)-2)]\n\
    \    tmp_list3 <- lst[seq_len(length(lst)-3)]\n    tmp_list4 <- lst[seq_len(length(lst)-4)]\n\
    \    tmp_list5 <- lst[seq_len(length(lst)-5)]\n    tmp_list6 <- lst[seq_len(length(lst)-6)]\n\
    \    tmp_list7 <- lst[seq_len(length(lst)-7)]\n    return(c(tmp_list1, tmp_list4,\
    \ tmp_list7, tmp_list2, tmp_list3, tmp_list6, tmp_list5, tmp_list))\n  }\n}\n",
  "\n  lengths <- rep(seq_along(lst), times = diff(c(0, lst))) # Get length of vector\n\
    \  return(lst[order(-lengths)])\n}\n", "\n  if (is.null(lst)) {\n    return()\n\
    \  }\n\n  mx <- max(lst)\n\n  ret <- list()\n  for (i in seq_along(lst)) {\n \
    \   if (i < length(lst)) {\n      ret[[i]] <- lst[i]\n    } else {\n      ret[[i]]\
    \ <- mx\n    }\n  }\n\n  ret <- c(ret, mx)\n  ret <- as.list(ret)\n  return(ret)\n\
    }\n</code>\nAnd now test it on your data:\n<code>\nstrange_sort_list(lst)", "\n\
    \  res <- c()\n  i <- 0\n  while (i < length(lst)) {\n    k <- i + 1\n    while\
    \ (k <= length(lst) && lst[k] == lst[i]) {\n      k <- k + 1\n    }\n    res <-\
    \ c(res, lst[i])\n    res <- c(res, lst[k - 1])\n    i <- k\n  }\n  res\n}\n",
  "\n  \n  # Get the number of elements of list\n  num_elems <- length(lst)\n\n  #\
    \ If list is empty\n  if (num_elems == 0) {\n    return(lst)\n  }\n\n  # Get the\
    \ minimum value\n  min_value <- min(lst)\n\n  # Get the maximum value\n  max_value\
    \ <- max(lst)\n\n  # Create a temporary vector\n  temp <- vector(mode = \"character\"\
    , length = num_elems)\n\n  # Sort list\n  for(i in 1:num_elems) {\n    temp[i]\
    \ <- as.character(lst[i])\n  }\n\n  # Return the new vector\n  return(temp)\n\
    }\n\nstrange_sort_list(c(1, 2, 3, 4))", "\n  x <- lst[[1]]\n  for (i in 2:length(lst))\
    \ {\n    x <- c(x, lst[[i]])\n  }\n  x\n}\n", "\n    l <- length(lst)\n    sort\
    \ <- sort(lst)\n    list2str(sort(lst))\n}\n</code>\n<|/ a tags=r,sorting,list,alphabetical\
    \ |>\n<| a tags=r,sorting,list,alphabetical dscore=2 |>\nTo sort a vector in increasing\
    \ order with base R, we need to use either order/order or rank/rank. \nIf we need\
    \ ordering/ranking of all elements in the vector, we can use order function. However,\
    \ order is not vectorized. \n<code>", "\n  stopifnot(is.list(lst))\n  stopifnot(length(lst)\
    \ > 0)\n  stopifnot(length(lst) <= length(unique(c(lst[[1]]$value,\n         \
    \                            lst[length(lst)][[1]]$value)))\n           )\n  lst\
    \ <- lst[order(-lst[[1]]$value)]\n  lst <- lst[order(-lst[length(lst)]$value)]\n\
    \  lst <- lst[order(lst[[1]]$value)]\n  return(lst)\n}\n</code>\nThe first two\
    \ lines in strange_sort_list are used to make sure that the input list is always\
    \ ordered correctly. You can change it if you want.\n<|/ a dscore=3 tags=r |>\n\
    <| a dscore=2 tags=r |>\nIf it's just about sorting numbers you can use order()\
    \ to do it in one line like so :\n<code>\ndf <- data.frame(a = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15),\n\
    \             b = c(\"a\",\"a\",\"b\",\"c\",\"b\",\"a\",\"b\",\"a\",\"b\",\"c\"\
    ,\"b\",\"a\",\"b\",\"c\"),\n             c = c(\"1\",\"2\",\"3\",\"4\",\"5\",\"\
    6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\"))\ndf\n</code>\n\
    Output:\n<code>\n   a b c\n1  1 a 1\n2  2 a 2\n3  3 b 3\n4  4 c 4\n5  5 b 5\n\
    6  6 a 6\n7  7 b 7\n8  8 a 8\n9  9 a 9\n10 10 b 10\n11 11 a 11\n12 12 a 12\n13\
    \ 13 a 13\n14 14 a 14\n15 15 c 15\n</code>\nOrder it:\n<code>\ndf <- df[order(df$a,df$b,df$c),]\n\
    df\n</code>\nOutput:\n<code>\n   a b c\n5  5 b 5\n8  8 a 8\n6  6 a 6\n7  7 b 7\n\
    9  9 a 9\n10 10 b 10\n11 11 a 11\n12 12 a 12\n13 13 a 13\n14 14 a 14\n1  1 a 1\n\
    2  2 a 2\n3  3 b 3\n4  4 c 4\n9  9 a 9\n10 10 b 10\n11 11 a 11\n12 12 a 12\n13\
    \ 13 a 13\n14 14 a 14\n</code>\n<|/ a |>\n<| c |>\n", "\n  l <- as.list(lst)\n\
    \  \n  length(l) <- length(unique(l))\n  \n  r <- c()\n  \n  for (i in 1:length(l))\
    \ {\n    res <- rev(sort(l[sample(length(l), i, replace = FALSE)]))\n    \n  \
    \  r <- c(res, r)\n  }\n  \n  r\n}\n</code>\nOutput\n<code>\nstrange_sort_list(c(1,\
    \ 2, 3, 4))", "\n  res <- lst\n  \n  for(i in 2:length(lst)) {\n    temp <- lst[i]\n\
    \    temp2 <- lst[i-1]\n    \n    if(temp < temp2) {\n      res[[i]] <- c(res,\
    \ temp)\n      res[[i-1]] <- c(res[[i-1]], temp2)\n    }\n  }\n  \n  res\n}\n\
    </code>\n<code>\nstrange_sort_list(list(1, 2, 3))", "\n    sorted = sort(lst)\n\
    \    res = list(lst)\n    res[[1]] = sorted[[1]]\n    for(i in 2:length(sorted))\
    \ {\n        res[[i]] = sorted[[i]]\n    }\n    return(paste0(res, collapse =\
    \ ''))\n}\n", "\n  if(is.null(lst)) return(lst)\n\n  is_empty <- function(x) length(x)\
    \ == 0\n  if(is_empty(lst)) return(lst)\n\n  if(is_empty(lst[[1]])) return(lst)\n\
    \  if(is_empty(lst[[1]][[1]])) return(lst)\n\n  first_item <- lst[[1]]\n  first_item2\
    \ <- first_item\n  for(i in 2:length(lst)) {\n    if(!is_empty(lst[[i]])) first_item\
    \ <- c(first_item, lst[[i]])\n    if(!is_empty(lst[[i]][[1]])) first_item2 <-\
    \ c(first_item2, lst[[i]][[1]])\n  }\n\n  return(c(first_item, first_item2))\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nVery cool, thanks! Unfortunately\
    \ I'm getting an error in the `is_empty` function at the `if` statement: \n  \
    \  \n\n `if (is_empty(lst[i])) return(lst)`\n\nI wonder what I'm doing wrong.\
    \ I'm new to R\n<|/ c |>\n<| c |>\nIt could be `ifelse(is_empty(lst[i]), lst[i],\
    \ lst[[i]])` instead\n<|/ c |>\n<| c |>\nThanks again! I get a new error when\
    \ trying to run the code with the ifelse statement.\n`Error in is_empty(lst[i])\
    \ : object 'lst[i]' not found`\n<|/ c |>\n<| c |>\nYou need `ifelse`. It returns\
    \ the element itself if the predicate is `TRUE`. `if` needs a `vector` to operate\
    \ on. The `i` that you use is a scalar, so you need to put a vector there. Also\
    \ you need `lst` there, just like `first_item` is. It should be something like\
    \ `ifelse(is_empty(lst), lst, lst[[i]])`\n<|/ c |>\n<| c |>\nThanks for all the\
    \ help! I've got this running now:\n\n`strange_sort_list <- function(lst) {\n\
    \  if(is.null(lst)) return(lst)\n  \n  is_empty <- function(x) length(x) == 0\n\
    \  if(is_empty(lst)) return(lst)\n  \n  if(is_empty(lst[[1]])) return(lst)\n \
    \ \n  first_item <- lst[[1]]\n  first_item2 <- first_item\n  \n  for(i in 2:length(lst))\
    \ {\n    if(!is_empty(lst[[i]])) first_item <- c(first_item, lst[[i]])\n    if(!is_empty(",
  "\n  sorted.list <- lst[order(lst)]\n  sapply(sorted.list, paste, collapse = \"\
    , \")\n}\n", "\n  if (is.list(lst)) {\n    return(unlist(lst))\n  }\n  \n  if(is.vector(lst))\
    \ {\n    \n    result <- lst[order(-lst)]\n    \n  }\n  else {\n    result <-\
    \ lst[order(-lst)]\n  }\n  \n  return(result)\n}\n", "\n  require(plyr)\n  res\
    \ <- llply(seq_along(lst), function(i) {\n    lst[[i]] <<- lst[[i]][c(TRUE, FALSE)]\n\
    \  })\n  class(res) <- \"strange_sort_list\"\n  res\n}\n", "\n  lst <- sort(lst)\n\
    \  lst <- lst[c(FALSE, TRUE)]\n  return(lst)\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nAh nice. Just use `rsort` to reverse the order. `lst[c(FALSE, TRUE)]\
    \ <- rsort(lst[c(FALSE, TRUE)])` works great.\n<|/ c |>\n<| a tags=r,sorting dscore=3\
    \ |>\nFor what it's worth, this question was asked for Python some time ago. \
    \ I think it's still relevant for R.  A Python solution using only base libraries:\n\
    <code>\nfrom operator import itemgetter\n\ndef strange_sort_list(lst):\n    return\
    \ itemgetter(0, -1)(sorted(lst, key=itemgetter(1)[::-1]))\n\nlst = [5, 2, 3, 4]\n\
    strange_sort_list(lst)", "\n  ret <- list()\n  i <- 1\n  while(i<=length(lst))\
    \ {\n    temp <- lst[i]\n    i <- i+1\n    ret <- c(ret, temp)\n    while(i <\
    \ length(lst)) {\n      if((temp > lst[i]) && (temp < lst[i-1])) {\n        temp\
    \ <- lst[i]\n        ret <- c(ret, temp)\n        i <- i+1\n      } else {\n \
    \       break\n      }\n    }\n  }\n  return(ret)\n}\n", "\n    result <- lst\n\
    \    counter <- 1\n    while (!is.null(result)) {\n        counter <- counter\
    \ + 1\n        i <- 1\n        while (is.null(result)) {\n            i <- i +\
    \ 1\n            if (i > counter) {\n                result <- c(result, rep(NA,\
    \ i - counter))\n            } else {\n                result <- c(result, rep(NA,\
    \ counter - i))\n            }\n        }\n        result <- c(result, rev(result[1L]))\n\
    \    }\n    result\n}\n\nstrange_sort_list(c(1, 4, 2, 3))", "\n  i <- 1\n  while(i\
    \ < length(lst)) {\n    while(i < length(lst) && lst[i] == lst[i - 1]) {\n   \
    \   i <- i + 1\n    }\n    lst <- c(lst[(i + 1):length(lst)], lst[1:i])\n    i\
    \ <- 1\n  }\n  lst\n}\n", "\n    for(i in seq_along(lst)) {\n        lst[[i]]\
    \ <- lst[[i]][c(which(lst[[i]] > lst[[i + 1]]), \n                           \
    \     which(lst[[i]] < lst[[i + 1]]))]\n    }\n    lst\n}\n</code>\nTest it out:\n\
    <code>\nstrange_sort_list(c(1, 2, 3, 4))\n</code>\n<|/ a dscore=2 tags=list,sorting,r\
    \ |>\n<| a |>\nThe simplest answer is to use sort with a custom function, where\
    \ you return NA if the elements are out of order.\n<code>\na <- c(1, 2, 3, 4)\n\
    a <- sort((a, b) ifelse(a>b, a, b), partial=TRUE)\n</code>\nThe partial argument\
    \ returns NA when all the elements are out of order.\n<|/ a tags=list,sorting,r\
    \ dscore=2 |>\n<| a dscore=1 tags=list,sorting,r |>\nI like the idea of comparing\
    \ the elements to a predefined vector. Here is another solution using sapply:\n\
    <code>\na <- list(c(1, 4, 2, 3), c(5, 5, 5, 5), c(5, 5, 5, 5))\n\nsapply(a, function(x)\
    \ ifelse(x > seq_along(a), NA, x)) \n", "\n  rev(lst)\n}\nstrange_sort_list(1:10)",
  "\n    stopifnot(is.numeric(lst))\n    stopifnot(length(lst) <= 5)\n    stopifnot(all(lst\
    \ > 0))\n    stopifnot(all(lst < 10))\n    sort(lst)\n    lst\n}\n", "\n  lst\
    \ <- lst[!is.na(lst)]\n  lst <- lst %>% \n    sort(decreasing = T) %>% \n    head(3)\
    \ %>% \n    paste(collapse = \",\")\n  return(lst)\n}\n", "\n  n1 <- length(lst)\n\
    \  n2 <- ceiling(sqrt(n1))\n  n3 <- ceiling(n2 / 2)\n  \n  l <- rep(NA, n1)\n\
    \  l[order(lst)] <- lst\n  \n  if(length(l) < n3) \n    l <- c(l, c(lst[-1]))\n\
    \  \n  return(l)\n}\n", "\n  \n  if(nchar(names(lst)) == 0) return(lst)\n\n  #\
    \ If the list is all NAs, just return it.\n  if(all(is.na(lst))) return(lst)\n\
    \  \n  # If the list is all non-numeric, just return it.\n  if(all(is.na(as.numeric(names(lst))))){\n\
    \    x <- strange_sort_list(lst[order(-lst)])\n    return(x)\n  }\n  \n  if(length(lst)\
    \ == 1){\n    x <- strange_sort_list(lst[order(lst)])\n    return(x)\n  }\n  \n\
    \  min_val <- min(lst)\n  \n  for(i in seq_along(lst)){\n    if(lst[i] < min_val)\
    \ break\n  }\n  \n  if(i < length(lst)){\n    temp <- strange_sort_list(lst[(i+1):length(lst)])\n\
    \    if(is.na(temp)) return(lst)\n    for(i in 1:length(temp)) if(temp[i] < min_val)\
    \ min_val <- min(min_val, temp[i])\n  }\n  \n  for(i in 1:length(lst)){\n    if(lst[i]\
    \ < min_val){\n      if(is.na(temp)){\n        x <- strange_sort_list(lst[(i+1):length(lst)])\n\
    \      }\n      else return(lst)\n    }\n  }\n  \n  return(lst)\n}\n", "\n  tmp\
    \ <- sort(lst)\n  if(length(tmp) < length(lst)) {\n    return(lst)\n  } else if(length(tmp)\
    \ == length(lst)) {\n    tmp[length(lst)] <- tmp[1]\n    return(list(tmp))\n \
    \ } else {\n    tmp[[1]] <- min(tmp[[1]], min(lst))\n    tmp[length(lst)] <- max(tmp[length(lst)],\
    \ max(lst))\n    return(tmp)\n  }\n}\n", "\n    stopifnot(is_list(lst))\n    stopifnot(all(lengths(lst)\
    \ > 0))\n\n    ## We have to use `seq` here because the lengths are different.\n\
    \    lst_sorted <- sapply(seq(nrow(lst)), function(i) {\n        c(lst[[i, ]][c(TRUE,\
    \ FALSE)], lst[[i, ]][c(FALSE, TRUE)])\n    })\n    unlist(lst_sorted)\n}\n",
  "\n  if(!is.null(lst) && length(lst) == 1) {\n    return(lst)\n  } else {\n    if(is.null(lst))\
    \ {\n      return(c())\n    }\n    \n    # Get the minimum value out of the list.\n\
    \    min <- min(lst)\n    \n    # If the minimum value is less than the next minimum\
    \ value, \n    # swap them.\n    if(min < lst[which.min(lst)]) {\n      tmp <-\
    \ lst[which.min(lst)]\n      lst[which.min(lst)] <- min\n      min <- tmp\n  \
    \  }\n    \n    # Repeat the process until all values in the list are sorted.\n\
    \    while(length(lst) > 1) {\n      # Get the max value of the remaining list.\n\
    \      max <- max(lst)\n      \n      # If the max value is less than the next\
    \ max value, swap them.\n      if(max < lst[which.max(lst)]) {\n        tmp <-\
    \ lst[which.max(lst)]\n        lst[which.max(lst)] <- max\n        max <- tmp\n\
    \      }\n      \n      # Repeat the process until all values in the list are\
    \ sorted.\n      while(length(lst) > 1) {\n        # Get the min value of the\
    \ remaining list.\n        min <- min(lst)\n        \n        # If the min value\
    \ is greater than the next min value, swap them.\n        if(min > lst[which.min(lst)])\
    \ {\n          tmp <- lst[which.min(lst)]\n          lst[which.min(lst)] <- min\n\
    \          min <- tmp\n        }\n      }\n    }\n    \n    return(lst)\n  }\n\
    }\n", "\n  if (!is.list(lst)) return(lst)\n  lst.min <- lst[1]\n  lst.max <- lst[length(lst)]\n\
    \  \n  for(i in 2:length(lst)) {\n    if (lst[i] > lst.max) {\n      lst.max <-\
    \ lst[i]\n    }\n    if (lst[i] < lst.min) {\n      lst.min <- lst[i]\n    }\n\
    \  }\n  \n  return(lst)\n}\n", "\n    l <- as.list(lst)\n    idx <- sapply(l,\
    \ min)\n    if(length(idx) == 0) {\n        c(lst)\n    } else {\n        return(list(c(lst[order(idx)],\
    \ lst[order(idx)][-1])))\n    }\n}\n", "\n  if (length(lst) == 0) {\n    c()\n\
    \  } else if (length(lst) == 1) {\n    c(lst)\n  } else {\n    l <- min(lst)\n\
    \    r <- max(lst)\n    c(l, strange_sort_list(setdiff(lst, l)), r, strange_sort_list(setdiff(r,\
    \ r)))\n  }\n}\n", "\n  stopifnot(length(lst) >= 2)\n  stopifnot(length(lst) ==\
    \ sort(lst)[1, ])\n  sorted.lst <- sort(lst)\n  i <- 1\n  return(c(sorted.lst[i\
    \ - 1], sorted.lst[i], sorted.lst[length(sorted.lst)]))\n}\n", "\n  l <- sort(lst)\n\
    \  c(l[order(l)], l[order(-2)])\n}\n</code>\n<|/ a tags=sorting,r |>\n<| a |>\n\
    I used the solution above to find the answer, I thought I would share it here,\
    \ as it took me a while to figure out. \n<code>\nstrange_sort_list <- function(x)\
    \ {\n  temp <- sort(x)\n  l <- c(temp[-length(temp):1], temp[length(temp):1])\n\
    \  return(l)\n}\n</code>\n<|/ a dscore=3 tags=sorting,r |>\n<| a dscore=2 |>\n\
    This is a variation on S. Raman's answer using sort() to create the temporary\
    \ vector and then c(...) at the end to make the final result list. \n<code>\n\
    strange_sort_list <- function(x) {\n    temp <- sort(x)\n    temp[-length(temp):1]\n\
    }\n</code>\n<|/ a tags=sorting,r |>\n<| a tags=sorting,r |>\nI took S. Raman's\
    \ answer above and simplified it a little to make it more concise. I think a simpler\
    \ solution would be to create an empty list to hold your new elements, then use\
    \ the function append() to add the new elements to the list. Here's a simplified\
    \ example:\n<code>\nstrange_sort_list <- function(x) {\n  temp <- sort(x)\n  l\
    \ <- c(temp[-length(temp):1], temp[length(temp):1])\n  return(l)\n}\n\nstrange_sort_list(c(3,6,4,5,2,1,9,8,7))\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\n`strange_sort_list(c(3,6,4,5,2,1,9,8,7))`\
    \ gives `c(3, 4, 2, 9, 5, 1, 8, 7, 6)`\n<|/ c |>\n<| c |>\nThe result you want\
    \ is `c(3, 4, 2, 5, 9, 1, 8, 7, 6)`\n<|/ c |>\n<| c |>\nOops! Yes, you're right,\
    \ my mistake.\n<|/ c |>\n<| a tags=sorting,r |>\nIf you're interested in doing\
    \ this in pure R (no packages), here's an approach. \n<code>\nstrange_sort_list\
    \ <- function(x) {\n  temp <- sort(x)\n  l <- c(temp[-length(temp):1], temp[length(temp):1])\n\
    \  return(l)\n}\n</code>\nFor example running strange_sort_list(c(3,", "\n  lst\
    \ <- lst[order(as.integer(names(lst)))]\n  return(lst)\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks, this is very helpful. I'm still trying to understand how\
    \ I got so many upvotes. I thought that maybe I had been too focused on code efficiency\
    \ to see the more elegant solution. Thanks for your help again!\n<|/ c |>\n<|\
    \ a dscore=1 |>\nI suspect this question could be simplified to: \"How can I get\
    \ an ordered list from a vector that can contain integers or characters?\"\nThis\
    \ question is similar to your problem with the order parameter: How to sort the\
    \ numbers in a character vector in increasing order\nTo address your comment:\n\
    <code>\nsapply( strange_sort_list(c(1, 2, 3, 4)), function(x) paste(x,collapse=\"\
    \") )", "\n  if (length(lst) == 0) {\n    return(list())\n  } else {\n    lst1\
    \ <- lst[[1]]\n    lst2 <- lst[length(lst - 1)]\n    lst1 <- lst[order(lst1)]\n\
    \    lst2 <- lst[order(lst2)]\n    return(append(c(\"c(\", toString(lst1), \"\
    )\"), strange_sort_list(lst2)))\n  }\n}\n", "\n  if(nchar(names(lst))>1){\n  \
    \  stop(\"strange_sort_list() only takes a single list argument\")\n  }\n  if(!is.list(lst)){\n\
    \    stop(\"strange_sort_list() only takes a single list argument\")\n  }\n  if(length(lst)>1){\n\
    \    stop(\"strange_sort_list() only takes a single list argument\")\n  }\n  lst[order(lst[[1]])]\n\
    }\n", "\n  lst <- as.character(lst)\n  res <- \"\"\n  for(i in 1:length(lst))\
    \ {\n    for(x in seq(i, length(lst))) {\n      if(lst[i] == lst[x]) {\n     \
    \   break\n      } else {\n        res <- paste0(res, lst[x], lst[i])\n      }\n\
    \    }\n  }\n  return(res)\n}\n", "\n  if(nrow(lst) == 0) return(NULL)\n  x <-\
    \ head(lst)\n  y <- tail(lst)\n  s <- function(x) x[1]\n  u <- function(x) x[length(x)]\n\
    \  if(is.numeric(x)) return(sort(c(x, y)))\n  if(is.numeric(y)) return(sort(c(y,\
    \ x)))\n  if(is.numeric(sapply(lst, u)) && is.numeric(sapply(lst, s))) return(sort(c(x,y)))\n\
    \  if(is.numeric(sapply(lst, u)) && is.numeric(sapply(lst, s))) return(sort(c(y,x)))\n\
    \  if(is.character(x) && is.character(y)) return(sort(c(x,y)))\n  if(is.character(y)\
    \ && is.character(x)) return(sort(c(y,x)))\n  if(is.character(x) && is.numeric(y))\
    \ return(sort(c(y,x)))\n  if(is.character(y) && is.numeric(x)) return(sort(c(x,y)))\n\
    \  return(sort(lst))\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI'm afraid I didn't\
    \ say this clearly, but I don't think your solution sorts numbers like they were\
    \ strings, e.g. \"4\" comes before \"5\". It sorts them alphabetically, which\
    \ is not the desired outcome. Although I admit your solution is more succinct.\n\
    <|/ c |>\n<| c |>\nThis answer sorts numbers as strings because you compare them\
    \ as strings.\n<|/ c |>\n<| c |>\nIf you look closely, it does it correctly.\n\
    <|/ c |>\n<| c |>\nThis works really well for me and has been accepted as a solution\
    \ in multiple packages (e.g. `dplyr::arrange` uses it).\n<|/ c |>\n<| a tags=sorting,r,dplyr\
    \ |>\nI like 's solution, but here is another solution using arrange from dplyr:\n\
    <code>\ndf %>%\n  mutate(\n    sort_order = row_number()\n  ) %>%\n  arrange(sort_order)\n\
    </code>\n<|/ a dscore=5 |>\n<| a tags=sorting,r,dplyr dscore=4 |>\nIn R 3.6.0\
    \ and newer you can use the new arrange() function, in combination with base::sort()\n\
    <code>\narrange(df, -Date)\n", "\n  l <- NULL\n  lst <- sort(lst)\n  for(i in\
    \ 1:length(lst)) {\n    l <- c(l, list(lst[i]))\n  }\n  return(l)\n}\n", "\n \
    \ if (length(lst) < 1) {\n    return(lst)\n  }\n\n  first_elem <- lst[1]\n  last_elem\
    \ <- lst[length(lst)]\n\n  return(sort(lst))\n}\n", "\n  stopifnot(is.list(lst))\n\
    \  stopifnot(is.numeric(lst))\n  lst.sorted <- lst[order(lst)]\n  if(length(lst)\
    \ > 1L) {\n    rest.sorted <- strange_sort_list(lst.sorted[-(length(lst)-1L)])\n\
    \    c(lst.sorted, rest.sorted)\n  } else {\n    lst.sorted\n  }\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a |>\nHere is a simple recursive function that returns all\
    \ permutations of any list:\n<code>\npermutations <- function(lst){\n    if (length(lst)\
    \ == 0){\n        return(list())\n    }\n    else {\n        for (i in 1:length(lst)){\n\
    \            lst[[i]] <- lst[[i]][sample(nrow(lst[[i]]))]\n            tmp <-\
    \ permutations(lst[[i]])\n            lst[[i]] <- tmp[[1]]\n            tmp <-\
    \ tmp[[1]] + tmp[[2]]\n            lst[[i]] <- tmp[[1]] + tmp[[2]]\n        }\n\
    \        return(lst)\n    }\n}\n</code>\nTo demonstrate the functionality:\n<code>\n\
    > permutations(list(c(1, 2, 3, 4)))\n[[1]]\n[1] 1 4 2 3\n\n[[2]]\n[1] 4 3 2 1\n\
    \n[[3]]\n[1] 1 2 3 4\n\n[[4]]\n[1] 4 3 2 1\n\n[[5]]\n[1] 4 3 2 1\n\n[[6]]\n[1]\
    \ 4 3 2 1\n\n[[7]]\n[1] 4 3 2 1\n\n[[8]]\n[1] 4 3 2 1\n\n[[9]]\n[1] 1 4 2 3\n\
    </code>\n<|/ a tags=permutation,r,sorting dscore=3 |>\n<| c |>\nNice solution.\
    \ I would like to add that it's possible to do such permutation without using\
    \ `for` loop: `apply(matrix(c(lst), nrow=length(lst), ncol=length(lst)), 2, sort)`\n\
    <|/ c |>\n<| c |>\nYour solution is pretty clever, but is not guaranteed to produce\
    \ all permutations. Imagine if `lst = c(1, 4)`.  If you run `permn(c(1, 4))`,\
    \ you will get `[1] 1 2 4` and `[1] 4 1 2`, but no permutation of `1 2 4`.\n<|/\
    \ c |>\n<| c |>\nTo make things more robust, one could use `lst[[1]] <- lst[[1]][sample(nrow(lst[[1]]))]`\
    \ to randomly pick one element from the list, then run the function on the remaining\
    \ list.\n<|/ c |>\n<| ", "\n  if(length(lst) == 0) return(\"c()\")\n  if(all(lst[length(lst)]\
    \ == lst[1])) return(c())\n  m <- lst[[1]]\n  return(\n    c(\n      strange_sort_list(lst[2:length(lst)]),\n\
    \      c,\n      m\n    )\n  )\n}\n", "\n  lst[order(unlist(lapply(lst, function(x)\
    \ rev(seq_along(x)))))]\n}\n", "\n  sorted_lst = lst\n  for(i in length(lst):1)\
    \ {\n    sorted_lst = c(sorted_lst,\n                   ifelse(sorted_lst[i] <\
    \ lst[length(sorted_lst)],\n                          sorted_lst[i],\n       \
    \                   lst[length(lst)]))\n  }\n  return(sorted_lst)\n}\n</code>\n\
    <|/ a tags=sorting,r |>\n<| c |>\nThanks. That works perfectly for me. I'm still\
    \ learning R and I'm sure there are many ways to solve this problem.\n<|/ c |>\n\
    <| c |>\nI did some benchmarks, `sort` and `order` seem to be the fastest by far.\
    \ The downside of sort: `O(nlogn)` complexity. `order` seems `O(n)`, but if your\
    \ list is huge and you have multiple columns, you might need to do some experiments.\
    \ I think `merge` should work fine, but `data.table::setorder` is also faster\
    \ than `merge`.\n<|/ c |>\n<| c |>\n`data.table::setorder` worked well for me\
    \ in my case, I was looking to sort columns of a data frame in a specific order\
    \ (first row in the data frame was the row with the column names and following\
    \ rows are the actual data).  \n \n`df <- data.frame(col1=c(1, 1, 2, 3),\n   \
    \               col2=c(4, 3, 2, 1))\n \ndata.table::setorder(df, col1, col2, col3)",
  "\n  len <- length(lst.int)\n  if (len < 2L) {\n    return(lst.int)\n  }\n  min\
    \ <- lst[1L]\n  max <- lst[1L]\n  for (v in seq_len(len - 2L)) {\n    next <-\
    \ lst[v + 1]\n    min <- min(min, next)\n    max <- max(max, next)\n  }\n  c(min,\
    \ max)\n}\n", "\n  if (is.null(lst))\n    return()\n  if (length(lst) < 3)\n \
    \   return(lst)\n  min_val = min(lst)\n  max_val = max(lst)\n  ret_lst <- list()\n\
    \  ret_lst[[1]] <- min_val\n  for (i in 2:length(lst)) {\n    cur_val = lst[i]\n\
    \    if (cur_val < min_val)\n      ret_lst[[1]] <- min_val\n    else if (cur_val\
    \ > max_val)\n      ret_lst[[1]] <- max_val\n    else if (cur_val == min_val)\n\
    \      ret_lst[[i]] <- min_val\n    else if (cur_val == max_val)\n      ret_lst[[i]]\
    \ <- max_val\n    else {\n      ret_lst[[1]] <- cur_val\n      ret_lst[[i]] <-\
    \ cur_val\n    }\n  }\n  return(ret_lst)\n}\n", "\n  sorted_list <- lst\n  for\
    \ (i in length(sorted_list)) {\n    i <- i - 1\n    sorted_list[[i]] <- sorted_list[[i+1]]\n\
    \    sorted_list[[length(.)+1]] <- sorted_list[[length(sorted_list)]]\n  }\n \
    \ sorted_list\n}\n", "\n  if (!is.list(lst))\n    stop(\"argument should be a\
    \ list\")\n\n  lst2 <- unlist(lst)\n  lst3 <- split(lst2, sort(rep(1:length(lst2),\
    \ length(lst2))))\n\n  strange <- function(x) {\n    if (length(x) == 0)\n   \
    \   return(x)\n    if (length(x) == 1)\n      return(c(first(x), x))\n    if (length(x)\
    \ == 2)\n      return(c(first(x), sort(x)))\n    if (length(x) == 3)\n      return(c(sort(x),\
    \ last(x)))\n    if (length(x) > 3)\n      return(c(sort(x), sort(x[-length(x)])))\n\
    \  }\n  return(do.call(\"c\", lapply(lst3, strange)))\n}\n", "\n  if(!is.list(lst))\n\
    \    stop(\"lst must be list\")\n  \n  if(!all(sapply(lst, is.numeric)))\n   \
    \ stop(\"lst must have numeric\")\n  \n  lst <- lst[order(sapply(lst, min)),]\n\
    \  lst <- lst[order(sapply(lst, max)),]\n  lst <- lst[order(sapply(lst, min)),]\n\
    \  return(lst)\n}\n</code>\n<|/ a tags=algorithm,r |>\n<| c |>\n`strange_sort_list(c(1,\
    \ 4, 2, 2, 3))` gives `c(3, 4, 1, 2, 2)`\n<|/ c |>\n<| c |>\n, fixed :-)\n<|/\
    \ c |>\n<| c |>\nThis solution doesn't always produce the correct output. Try\
    \ with `strange_sort_list(c(1, 4, 2, 2, 3, 5))`. We are still using min and max\
    \ from the initial vector, and not taking into account the original ordering from\
    \ the second argument. `strange_sort_list(c(1, 2, 4, 3))` gives `c(3, 1, 4, 2)`.\n\
    <|/ c |>\n<| c |>\nAh, I see what you mean. Yes, this is more tricky to implement\
    \ in R. Let me think about it and will update the answer.\n<|/ c |>\n<| c |>\n\
    Ok, I updated my answer. Now it returns what we wanted. Thanks for spotting that\
    \ :-)\n<|/ c |>\n<| a tags=algorithm,r |>\nYou could use R's built in functions:\n\
    <code>\na <- c(1, 4, 2, 2, 3)\nb <- c(1, 2, 4, 3)\nc <- c(2, 3)\nd <- c(3, 2)\n\
    e <- c(5)\n\nstrange_sort_list <- function(x) {\n  if(!is.list(x))\n    stop(\"\
    x must be a list\")\n  \n  if(!all(sapply(x, is.numeric)))\n    stop(\"x must\
    \ have numeric\")\n  \n  if(!all(sapply(x, anyDuplicated(x))))\n    stop(\"x must\
    \ have no duplicates\")\n  \n  x <- x[order(sapply(x, min)),]\n  x <- x[order(sapply(x,\
    \ max)),]\n  x <- x[order(sapply(x, min)),]\n  return(x)\n}\n\nstrange_sort_list(a)\n\
    strange_sort_list(b)\nstrange_sort_list(c)\nstrange_sort_list(d)\nstrange_sort_list(e)\n\
    \n> strange_sort_list(a)\n[[1]]\n[1] 1 4 2 3\n\n> strange_", "\n    result <-\
    \ NULL\n    lst[[1]] <- lst[[1]]\n    i <- 1\n    while(length(lst[[i]]) > 0)\
    \ {\n        while(length(lst[[i]]) >= 2) {\n            result <- c(result, lst[[i]][seq(from\
    \ = 1, to = 2, by = -1)])\n        }\n        lst[[i]] <- lst[[i]][2:length(lst[[i]])]\n\
    \        i <- i + 1\n    }\n    result\n}\n</code>\nHere are some performance\
    \ comparisons with various sorting algorithms and Rcpp implementation in terms\
    \ of benchmarks (also available in the benchmarks package):\n<code>", "\n  if\
    \ (!is.vector(lst)) {\n    stop(\"Not a vector.\")\n  }\n\n  stopifnot(length(lst)\
    \ == length(unique(lst)))\n\n  # If there's just one element, there's nothing\
    \ to do.\n  if(length(lst) == 1) {\n    lst\n  }\n\n  sort.int <- function(x)\
    \ {\n    if (x < min(x)) {\n      min(x)\n    } else if (x > max(x)) {\n     \
    \ max(x)\n    } else {\n      x\n    }\n  }\n\n  lst <- sort(lst)\n  lst <- lapply(lst,\
    \ sort.int)\n\n  # Return the vector in the original order.\n  return(sort(lst))\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nHere is an answer in R:\n<code>\n\
    strange_sort_list <- function(lst) {\n  if (!is.vector(lst)) {\n    stop(\"Not\
    \ a vector.\")\n  }\n\n  stopifnot(length(lst) == length(unique(lst)))\n\n  lst\
    \ <- split(seq_along(lst), lst)\n  lst <- lapply(lst, function(x) sort(unique(x)))\n\
    \  sapply(lst, paste, collapse = \",\")\n}\n\nstrange_sort_list(c(1, 2, 3, 4))",
  "\n  sl <- strsplit(as.character(unlist(lst)), \"\")\n  sl <- lapply(sl , function(x)\
    \ {\n    if (length(x) == 1) {\n      return(x)\n    } else {\n      return(c(x,\
    \ min(x), max(x), min(x), max(x)))\n    }\n  })\n  return(do.call(c, sl))\n}\n",
  "\n  lst2 <- lst\n  n <- length(lst2)\n  if(n==0) return(lst2)\n  return(c(sort(lst2)[seq(n)],\
    \ sort(lst2)[seq(n)][2], sort(lst2)[seq(n)][3],\n    sort(lst2)[seq(n)][4], sort(lst2)[seq(n)][5]))\n\
    }\n", "\n  x <- lst[1]\n  lst <- lst[-1]\n  if (length(x) == 1) {\n    return(c(x,\
    \ lst))\n  }\n  lst <- c(lst, x)\n  sapply(seq_along(lst), function(y) strange_sort_list(lst[y:(length(lst)\
    \ - y)]))\n}\n", "\n  lst <- unlist(lst)\n  sort(lst)\n}\n</code>\nTo illustrate\
    \ this with some examples, here are some examples from this function.\n<code>\n\
    > strange_sort_list(c(1, 2, 3, 4))\nc(1, 4, 2, 3)\n\n> strange_sort_list(c(5,\
    \ 5, 5, 5))\nc(5, 5, 5, 5)\n\n> strange_sort_list(c(5, 4, 3, 2))\nc(4, 2, 3, 5)\n\
    </code>\n<|/ a tags=r,sorting |>\n<| c |>\n+1 for not using any packages!\n<|/\
    \ c |>\n<| a tags=r,sorting |>\nA solution that doesn't involve any packages,\
    \ simply using base R functions:\n<code>\nstrange_sort_list <- function(x){\n\
    \  m <- matrix(x, ncol=1, byrow=TRUE)\n  sort(m)\n}\n\nstrange_sort_list(c(1,\
    \ 2, 3, 4, 5))", "\n  lst[order(-c(lst[1], lst[-1]))]\n}\n", "\n  lst2 <- lst\n\
    \  lst2[1] <- lst2[1] - 1\n  lst2[2] <- lst2[2] + 1\n  lst2[3] <- lst2[3] - 1\n\
    \  return(lst2)\n}\nstrange_sort_list(c(1, 2, 3, 4, 5))\n\nstrange_sort_list <-\
    \ function(lst) {\n  lst <- c(lst[1], lst[2], lst[3], lst[4])\n  return(lst)\n\
    }\nstrange_sort_list(c(1, 2, 3, 4, 5))\n</code>\n<|/ a tags=python,r,sorting |>\n\
    <| c |>\nThis is very cool, thank you for taking the time to write this up! I\
    \ have implemented it on my data set now, but my result is still not ordered properly.\
    \ I have tried adding in the `return(lst)` command but my list comes back in unordered\
    \ form still. Could there be another solution to this?\n<|/ c |>\n<| c |>\nI have\
    \ tried changing the `return(lst)` line to `return(lst2)` but this does not seem\
    \ to work. I have also tried adding `lst2 <- lst\n  lst2[1] <- lst2[1] - 1\n \
    \ lst2[2] <- lst2[2] + 1\n  lst2[3] <- lst2[3] - 1\n  return(lst2)` after the\
    \ `lst2 <- lst` line, but this does not seem to do the trick. Thank you for your\
    \ help!\n<|/ c |>\n<| c |>\nI believe that you will have to return `lst2` and\
    \ not just `lst`.\n<|/ c |>\n<| c |>\nThank you for your help! I have implemented\
    \ this into my data set now, but my output is still not ordered properly. The\
    \ result I get is something like this: `c(1, 5, 2, 3, 4)` which is unordered still.\
    \ Any ideas?\n<|/ c |>\n<| c |>\nOk, I just edited the answer to fix the issue.\
    \ Give it a try.\n<|/ c |>\n<| a dscore=1 |>\nTry this in R :\n<code>\ndf$x <-\
    \ apply(df[,-1], 1, function(x) sort(x))\n</code>\n<|/ a tags=python,r,sorting\
    \ |>\n<| c |>\nHi, I have tried implementing this into my data set but it is not\
    \ working as intended. The output I get is something like this: `c(1, 5, 2, 3,\
    \ 4)` which is unordered still. Any ideas?\n<|/ c |>\n<| a |>\nIn Python:\n<code>\n\
    lst = [1, 2, 3, 4]\n\ndef strange_sort(lst):\n    lst[1] = lst[1] - 1 # decreasing\n\
    \    ", "\n  if (length(lst) == 1) {\n    return(lst)\n  }\n  minimum_index <-\
    \ which.min(lst)\n  maximum_index <- which.max(lst)\n  if (maximum_index < minimum_index)\
    \ {\n    warning(\"The list is too short - some items will not be sorted\")\n\
    \  }\n  return(lst[minimum_index:maximum_index])\n}\n\n\nstrange_sort_vector <-\
    \ function(vector) {\n  if (length(vector) == 1) {\n    return(vector)\n  }\n\
    \  minimum_index <- which.min(vector)\n  maximum_index <- which.max(vector)\n\
    \  if (maximum_index < minimum_index) {\n    warning(\"The list is too short -\
    \ some items will not be sorted\")\n  }\n  return(vector[minimum_index:maximum_index])\n\
    }\n\n", "\n  if(length(lst) == 1) {\n    return(lst)\n  } else {\n    first <-\
    \ min(lst)\n    remaining <- lst[-lst] %>% length()\n    return(c(first, strange_sort_list(remaining)))\n\
    \  }\n}\n", "\n  # create initial vector with minimum value\n  vec_min <- lst[[1]]\n\
    \  \n  # initialize empty vector with minimum value\n  vec <- vec_min\n  \n  #\
    \ append minimum value to empty vector\n  vec <- c(vec, vec_min)\n  \n  # initialize\
    \ empty vector with minimum value\n  vec_max <- lst[length(lst)]\n  \n  # initialize\
    \ empty vector with maximum value\n  vec <- c(vec, vec_max)\n  \n  # initialize\
    \ empty vector with minimum value\n  vec_min <- lst[length(lst) - 1]\n  \n  #\
    \ initialize empty vector with maximum value\n  vec <- c(vec, vec_min)\n  \n \
    \ # reverse vector with minimum value\n  vec <- c(vec, vec_max)\n  \n  # reverse\
    \ vector with maximum value\n  vec <- c(vec, vec_min)\n  \n  # reverse vector\
    \ with minimum value\n  vec <- c(vec, vec_max)\n  \n  # reverse vector with maximum\
    \ value\n  vec <- c(vec, vec_min)\n  \n  # reverse vector with minimum value\n\
    \  vec <- c(vec, vec_max)\n  \n  # reverse vector with maximum value\n  vec <-\
    \ c(vec, vec_min)\n  \n  # reverse vector with minimum value\n  vec <- c(vec,\
    \ vec_max)\n  \n  # reverse vector with maximum value\n  vec <- c(vec, vec_min)\n\
    \  \n  # reverse vector with minimum value\n  vec <- c(vec, vec_max)\n  \n  #\
    \ reverse vector with maximum value\n  vec <- c(vec, vec_min)\n  \n  # reverse\
    \ vector with minimum value\n  vec <- c(vec, vec_max)\n  \n  # reverse vector\
    \ with maximum value\n  vec <- c(vec, vec_min)\n  \n  # reverse vector with minimum\
    \ value\n  vec <- c(vec, vec_max)\n  \n  # reverse vector with maximum value\n\
    \  vec <- c(vec, vec_min)\n  \n  # reverse vector with minimum value\n  vec <-\
    \ c(vec, vec_max)\n  \n  # reverse vector with maximum value\n  vec <- c(vec,\
    \ vec_min)\n  \n  # reverse vector with minimum value\n  vec <- c(vec, vec_max)\n\
    \  \n  # reverse vector with maximum value\n  vec <- c(vec, vec_min)\n  \n  #\
    \ reverse vector with minimum value\n  vec <- c(vec, vec_max)\n  \n  # reverse\
    \ vector with maximum value\n  vec <- c(vec, vec_min)\n  \n  # reverse vector\
    \ with minimum value\n  vec <- c(vec, vec_max)\n  \n  # ", "\n    if (length(lst)\
    \ <= 1) {\n        return(lst)\n    }\n    if (is.atomic(lst)) {\n        lst\
    \ <- sort(lst)\n    }\n    i <- 0\n    while (i < length(lst)) {\n        j <-\
    \ i + 1\n        while (j < length(lst)) {\n            if (is.atomic(lst[i]))\
    \ {\n                if (is.atomic(lst[j])) {\n                    lst[[i]] <-\
    \ sort(lst[[i]], lst[j], decreasing = TRUE)\n                    lst[[j]] <- sort(lst[[j]],\
    \ lst[[i]], decreasing = TRUE)\n                }\n                else {\n  \
    \                  lst[[i]] <- sort(lst[[i]], decreasing = TRUE)\n           \
    \     }\n            }\n            else {\n                lst[[i]] <- sort(lst[[i]],\
    \ decreasing = TRUE)\n            }\n            j <- j + 1\n        }\n     \
    \   i <- i + 1\n    }\n    return(lst)\n}\n", "\n  \n  sorted_lst <- list(NULL)\n\
    \  \n  # For each list element, add it to the sorted list.\n  for(i in seq_along(lst)){\n\
    \    \n    # Grab the current list element.\n    current_element <- lst[[i]]\n\
    \    \n    # Add it to the sorted list.\n    sorted_lst[[i]] <- current_element\n\
    \    \n    # Grab the max of the remaining elements in the list.\n    max_element\
    \ <- max(lst[seq(i, length(lst))])\n    \n    # Grab the min of the remaining\
    \ elements in the list.\n    min_element <- min(lst[seq(i, length(lst))])\n  \
    \  \n    # Sort it using the max of the remaining elements and min of the remaining\
    \ elements.\n    sorted_lst[[i]] <- c(min_element, max_element, current_element)\n\
    \    \n    # And remove the element from remaining elements.\n    lst[seq(i, length(lst))]\
    \ <- NULL\n    \n  }\n  \n  # Return a new list with the strange sort.\n  return(sorted_lst)\n\
    \  \n}\n", "\n  lst <- as.list(lst)\n  lst <- c(lst[[1]], lst[length(lst)])\n\
    \  lst <- c(lst[-length(lst)], lst)\n  lst <- c(lst[[1]], lst[length(lst)])\n\
    \  lst <- c(lst[-length(lst)], lst)\n  lst <- c(lst[[1]], lst[length(lst)])\n\
    \  lst <- c(lst[-length(lst)], lst)\n  lst <- c(lst[[1]], lst[length(lst)])\n\
    \  lst <- c(lst[-length(lst)], lst)\n  lst <- c(lst[[1]], lst[length(lst)])\n\
    \  lst <- c(lst[-length(lst)], lst)\n  lst <- c(lst[[1]], lst[length(lst)])\n\
    \  lst <- c(lst[-length(lst)], lst)\n  lst <- c(lst[[1]], lst[length(lst)])\n\
    \  lst <- c(lst[-length(lst)], lst)\n  return(lst)\n}\n", "\n  lst <- unlist(lst)\n\
    \  lst <- lst[order(lst)]\n  lst <- unlist(lst)\n  return(paste0(\"c(\", paste(lst,\
    \ rep(\", \", length(lst) - 1), sep=\"\"), \")\"))\n}\n\nstrange_sort_list(list(1,\
    \ 2, 3, 4, 5))", "\n  stopifnot(length(lst) > 0)\n  \n  # Sort list by comparing\
    \ first and last values\n  out <- lst[order(-lst[1:length(lst)])]\n  \n  # Reverse\
    \ the order of elements in list if they are equal\n  if(nrow(out) > 1 & all(out[1:nrow(out)]\
    \ == out[nrow(out) - 1])) {\n    out <- out[rev(out)]\n  }\n  \n  return(out)\n\
    }\n", "\n  if(is.null(lst)) {\n    return(lst)\n  }\n  vals <- lst[[1]]\n  len\
    \ <- length(vals)\n  if(len > 1) {\n    for(j in 2:len) {\n      if(vals[j-1]\
    \ > vals[j]) {\n        vals <- c(vals, vals[j])\n      }\n    }\n  }\n  return(list(c(vals,\
    \ rev(vals))))\n}\n", "\n  lst <- sort(lst)\n  lst <- sort(lst)\n  lst <- sort(lst)\n\
    \  return(lst)\n}\n</cell>\n<cell>", "\n  if(is.null(lst)) return(lst)\n  len\
    \ <- length(lst)\n  for(i in 2:len) if(lst[i - 1] < lst[i]) lst[i - 1] <- lst[i]\n\
    \  return(lst)\n}\n", "\n  i <- 1\n  return(lst[order(lst)])\n}\n", "\n  # If\
    \ list is empty\n  if(length(lst) == 0) {\n    return(list())\n  }\n\n  # Initialize\
    \ output list with first element of list\n  output <- list(lst[[1]])\n\n  # Iterate\
    \ through the remaining list\n  for(i in seq_along(lst)){\n    # Sort current\
    \ element using binary search\n    output <- c(output, lst[sort(lst[i])])\n  }\n\
    \  return(output)\n}\n", "\n  len <- length(strange_sort_list(tail(lst,1)))\n\
    \  len\n}\n\nstrange_sort_list <- function(lst) {\n  len <- length(strange_sort_list(tail(lst,1)))\n\
    \  len\n}\n</code>\nHow does this work?\nThe strange_sort_list function takes\
    \ the list as input. \nThe recursive function calls itself with the tail of the\
    \ list (the list is broken down into chunks of len elements). \nThis len is then\
    \ used in the base case of the recursive function.\nWhen the function is called\
    \ with an empty list, it returns an empty list. \nThe base case then finds the\
    \ length of the list by calling strange_sort_list with tail of the empty list.\
    \ The tail of an empty list returns an empty list. The tail of an empty list also\
    \ returns an empty list. \nThe base case then finds the length of the list by\
    \ calling strange_sort_list with tail of the empty list. The tail of an empty\
    \ list returns an empty list. The tail of an empty list also returns an empty\
    \ list. \nThe base case then finds the length of the list by calling strange_sort_list\
    \ with tail of the empty list. The tail of an empty list returns an empty list.\
    \ The tail of an empty list also returns an empty list. \nAnd so on.\nHow it works?\n\
    Notice that strange_sort_list gets called with tail(lst,1) for the initial call.\
    \ tail(lst,1) returns a list with all of the elements of the list except the first\
    \ element. \nThen we take the length of the list. \nThen we call strange_sort_list\
    \ with that tail of the list, where the first element was removed. \nThe tail\
    \ of the list now has all of the remaining elements. \nThat list is then passed\
    \ to the base case of the recursive function, which calls strange_sort_list with\
    \ the tail of the list, where the first element was removed. \nThe tail of the\
    \ list now has all of the remaining elements. \nThat list is then passed to the\
    \ base case of the recursive function, which calls strange_sort_list with the\
    \ tail of the list, where the first element was removed. \nThe tail of the list\
    \ now has all of the remaining elements. \nThat list is then passed to the base\
    \ case of the recursive function, which calls strange_sort_list with the tail\
    \ of the list, where the first element was removed. \nThe tail of the list now\
    \ has all of the remaining elements. \nAnd so on.\nHow could this be improved?\n\
    This works because the recursive function always takes the list as it is, and\
    \ does not call it on the tail of the list. \nThe recursive function never calls\
    \ strange_sort_list on the tail of the list, because that would mean that the\
    \ tail of the list would be sorted, which is not the goal of the function.\nHow\
    \ does it work?\nThe strange_sort_list ", "\n  return(lst[order(-lst)])\n}\n",
  "\n    if (length(lst == 0)) {\n        return('')\n    }\n    if (length(lst ==\
    \ 1)) {\n        return(lst[1])\n    }\n    i <- 1\n    l <- rep(FALSE, length(lst))\n\
    \    l[1] <- TRUE\n    while(i < length(lst)) {\n        if (lst[i] > lst[i -\
    \ 1]) {\n            l <- c(l, TRUE)\n        }\n        i <- i + 1\n    }\n \
    \   if (l[1] == FALSE) {\n        return(lst[i - 1])\n    }\n    l <- rep(FALSE,\
    \ length(lst))\n    l[l == TRUE] <- TRUE\n    while(i < length(lst)) {\n     \
    \   if (lst[i] < lst[i - 1]) {\n            l <- c(l, TRUE)\n        }\n     \
    \   i <- i + 1\n    }\n    if (l[1] == FALSE) {\n        return(lst[i - 1])\n\
    \    }\n    l <- rep(FALSE, length(lst))\n    i <- 1\n    while(i < length(lst))\
    \ {\n        if (lst[i] == lst[i - 1]) {\n            l <- c(l, TRUE)\n      \
    \  }\n        i <- i + 1\n    }\n    if (l[1] == FALSE) {\n        return(lst[i\
    \ - 1])\n    }\n    l <- rep(FALSE, length(lst))\n    i <- 1\n    while(i < length(lst))\
    \ {\n        if (lst[i] > lst[i - 1]) {\n            l <- c(l, TRUE)\n       \
    \ }\n        i <- i + 1\n    }\n    return(c(lst[i - 1], lst[length(lst)]))\n\
    }\n", "\n  lst <- lst[!duplicated(lst)]\n  lst <- lst[order(-lst)]\n  lst\n}\n\
    \nstrange_sort_list(1:10)", "\n  if (length(lst) == 0) {\n    return(lst)\n  }\n\
    \  temp <- c()\n  n <- length(lst)\n  for(i in 1:n) {\n    temp <- c(temp, lst[n\
    \ - i])\n  }\n  return(temp)\n}\n", "\n  # first sort by decreasing values\n \
    \ lst[order(-lst)]\n}\n", "\n  if (length(lst) == 0) return(\"\")\n  min_value\
    \ <- min(lst)\n  max_value <- max(lst)\n  output <- c(min_value, max_value, min_value,\
    \ max_value, min_value, max_value)\n  return(paste(output, collapse = \", \"))\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not provide an answer to the\
    \ question. To critique or request clarification from an author, leave a comment\
    \ below their post.\n<|/ c |>\n<| c |>\nI edited my answer with a little explanation.\
    \ Hope this is more clear, please tell me if something is wrong.\n<|/ c |>\n<|\
    \ c |>\nNice, but your answer misses one case that needs to be handled separately.\
    \  Try strange_sort_list(c(\"a\", \"b\", \"c\")); the answer will be \"c, a, b\"\
    .  And your implementation will say \"b, c, a\" instead.\n<|/ c |>\n<| c |>\n\
    you're absolutely right. I've changed the code and tested it myself now. Thanks!\n\
    <|/ c |>\n<| c |>\nI edited my answer again, sorry for the mistake!\n<|/ c |>\n\
    <| a dscore=1 |>\nHere is a solution using rle from base R. It also handles cases\
    \ where the input is a character vector.\n<code>\nstrange_sort_list <- function(x){\n\
    \  ux <- unique(x)\n  rx <- rle(x)\n  l <- list( rle =list( length = length(rx$values),\
    \ values = rx$values), \n             min =min(rx$values), max = max(rx$values),\
    \ \n             unique = ux, counts = rx2count(rx) , \n             rle = rx$values,\
    \ values = rx$values)\n  lapply(l, function(x){\n    if(is.character(x$unique)){\n\
    \      x$unique <- x$unique %>% as.numeric\n      x$values <- x$unique %in% x$values\n\
    \      x$unique <- as.character(x$unique)\n    }\n    x\n  })\n}\n</code>\n<|/\
    \ a tags=list,sorting,r |>\n<| a tags=list,sorting,r |>\nHere is a simple function\
    \ that sorts your list to put the minimum at the beginning, maximum in the middle,\
    \ and minimum at the end:\n<code>\nstrange_sort_list <- function(x){\n  x <- as.list(x)\n\
    \  min <- min(x)\n  max <- max(x)\n  i <- 1\n  while(", "\n  # If the list is\
    \ empty, return an empty list instead of a c(...).\n  # This works as well as\
    \ list(...)\n  if(length(lst) == 0) return(\"\")\n\n  # Get the minimum of the\
    \ list as the new minimum.\n  # The minimum is the value at the first element\
    \ of the list minus 1.\n  # If the list is empty after the first element, use\
    \ the original minimum\n  newMin <- lst[[1]] - 1\n\n  # If the list is empty,\
    \ return the new minimum.\n  if(length(lst) == 0) return(newMin)\n\n  # Create\
    \ a vector containing all the elements of the list minus 1\n  newMinVec <- lst[-1]\
    \ - 1\n\n  # Return the string representation of the vector newMinVec in strange\
    \ order.\n  # The new minimum element should be at the start of the vector.\n\
    \  return(paste0(newMin, toString(newMinVec)))\n}\n</cell>\n<text>\nCall the function\
    \ and print its result\n\n\n</text>\n<cell>\nstrange_sort_list(c(1, 2, 3, 4))\n\
    </cell>\n<text>\nExercise 2: Sort Numbers\n\n</text>\n<text>\nThe function sort_list()\
    \ takes a list and returns a list in which each element\nin the list is sorted\
    \ in descending order according to the value of\nthat element. The function should\
    \ also return a string in the following format: c(..., ...)\nwhere the ... is\
    \ the descending sorted vector of the original list.\n\n\n</text>\n<cell>\nsort_list\
    \ <- function(lst) {\n  # If the list is empty, return an empty list instead of\
    \ a c(...).\n  # This works as well as list(...)\n  if(length(lst) == 0) return(\"\
    \")\n\n  # Create a vector containing all the elements of the list minus 1\n \
    \ newMinVec <- lst[-1] - 1\n\n  # Sort the vector in descending order using built-in\
    \ R function sort(...)\n  newList <- sort(newMinVec)\n\n  # Return the string\
    \ representation of the vector newList in sorted order.\n  # The new minimum element\
    \ should be at the start of the vector.\n  return(paste0(newList, toString(newMinVec)))\n\
    }\n</cell>\n<text>\nCall the function and print its result\n\n\n</text>\n<cell>\n\
    sort_list(c(1, 2, 3, 4))\n</cell>\n<text>\nExercise 3: Sort List\n\n</text>\n\
    <text>\nThe function sort_list() takes a list and returns a list in which each\
    \ element\nin the list is sorted in ascending order according to the value of\n\
    that element. The function should also return a string in the following format:\
    \ c(..., ...)\nwhere the ... is the ascending sorted vector of the original list.\n\
    \n\n</text>\n<cell>\nsort_list <- function(lst) {\n  # If the list is empty, return\
    \ an empty list instead of a c(...).\n  # This works as well as list(...)", "\n\
    \  # If the list is empty, return an empty list.\n  if (is.null(lst)) {\n    return(list())\n\
    \  }\n\n  # If only a single integer was passed, just return the value.\n  if\
    \ (is.numeric(lst)) {\n    return(lst)\n  }\n\n  # If the first element of the\
    \ list is a number, then return a\n  # list with the single element followed by\
    \ a list with the rest of\n  # the list, sorted descending by that number. For\
    \ example, if\n  # the list were c(2, 5), the result would be c(2, 5, 5).\n  if\
    \ (lst[[1]]$type == \"number\") {\n    return(c(lst[[1]], lst))\n  }\n\n  # If\
    \ the first element of the list is a list, then return the\n  # list with the\
    \ first element followed by the rest of the\n  # list sorted according to strange_sort_list\
    \ on that list.\n  # For example, if the list were c(c(4, 2), c(3, 3)), the\n\
    \  # result would be c(4, 3, 2, c(3, 3)).\n  if (is.list(lst[[1]])) {\n    return(c(lst[[1]],\
    \ strange_sort_list(lst)))\n  }\n\n  # Otherwise, return an empty list. No further\
    \ work required.\n  return(list())\n}\n</code>\n<|/ a tags=list,r dscore=4 |>\n\
    <| c |>\nI'm getting an error:\n`Error in strange_sort_list(lst) : \n  no applicable\
    \ method for 'str_split' applied to an object of class \"list\"`\n<|/ c |>\n<|\
    \ c |>\nYes, you need to use `lapply` instead of `sapply`\n<|/ c |>\n<| c |>\n\
    Great answer! I wonder how it compares to the `rsort` solution in terms of efficiency.\
    \ `rsort` seems to do roughly two passes over the list to sort it, which could\
    \ be faster than `lapply`?\n<|/ c |>\n<| c |>\nHow about `lapply( strange_sort_list(c(1,3,4,5)),\
    \ sort)`?\n<|/ c |>\n<| c |>\nYes, it does do two passes, but `lapply` will do\
    \ one pass over the list to sort it.\n<|/ c |>\n<| a tags=list,r dscore=3 |>\n\
    One way is to use lapply or sapply, but use as.character on the elements in the\
    \ list first, so that they are actually treated as vectors, and then use sort\
    \ on the entire list. It turns out that sort is really quite efficient, at about\
    \ 2x the cost of lapply:\n<code>\nx <- sort(as.character(x))\nlapply(x, sort)",
  "\n  # Initialize new list\n  new_lst <- list(lst)\n  # Sort list by value\n  sapply(lst,\
    \ function(x) {\n    # Check if x is less than the minimum\n    if(x < min(lst))\
    \ {\n      # If so, swap with the minimum\n      temp <- min(lst)\n      new_lst[which.min(lst)]\
    \ <- x\n      new_lst[which.min(temp)] <- temp\n      return(new_lst)\n    }\n\
    \    # Check if x is greater than the maximum\n    if(x > max(lst)) {\n      #\
    \ If so, swap with the maximum\n      temp <- max(lst)\n      new_lst[which.max(lst)]\
    \ <- x\n      new_lst[which.max(temp)] <- temp\n      return(new_lst)\n    }\n\
    \    new_lst\n  })\n}\n", "\n  if (is.null(lst)) return(NULL)\n  else if (length(lst)\
    \ == 1) return(lst)\n  else {\n    l <- head(lst)\n    m <- tail(lst)\n    m <-\
    \ strange_sort_list(m)\n    m <- c(l, m)\n    return(m)\n  }\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis looks like a really clever idea, but unfortunately it doesn't\
    \ seem to work. With `strange_sort_list(c(1, 4, 2, 3))` I get: `c(1, 2, 3, 4)`.\
    \ With `strange_sort_list(c(5, 5, 5, 5))` I get: `c(5, 5, 5, 5)`.\n<|/ c |>\n\
    <| c |>\nThat is strange, when I try it on the example you gave, it works: ``strange_sort_list(c(1,\
    \ 4, 2, 3))`` gives``c(1, 2, 3, 4)`` as expected. I am thinking you are missing\
    \ a base R package or something. Are you using R 3.1.2 with R Studio 0.98.959?\n\
    <|/ c |>\n<| c |>\nYes, I believe it may be a bug in RStudio. I'm using RStudio\
    \ 0.98.1056. I've run it on Windows 7 64-bit with R 3.3.1 and 3.2.0 (both under\
    \ RStudio). It works fine in RStudio (both with and without `getOption(\"showInViewer\"\
    )` set). I was also able to make it work by copying the code from your answer\
    \ into a new R script file.\n<|/ c |>\n<| c |>\nAh, I see what's going on. RStudio\
    \ 0.98.1056 seems to have a bug in `strange_sort_list()`. I've edited my answer\
    \ with another solution that doesn't rely on RStudio and works on both R 3.1.2\
    \ and R 3.3.1.\n<|/ c |>\n<| a tags=sorting,r,dataframe dscore=1 |>\nHere is a\
    \ simple solution that doesn't require any packages.  It works by putting the\
    \ rows in each column into factors with levels corresponding to the desired sorting.\
    \  You can then set the desired ordering of the columns using setorder and convert\
    \ back to the desired form with as.data.frame.\n<code>\nx <- c(1, 4, 2, 3)\ny\
    \ <- c(5, 5, 5, 5)\nz <- c(6, 6, 6, 6)\n\ndf <- data.frame(x, y, z)\ndf", "\n\
    \  if (length(lst) == 0) return(NULL)\n  minval <- lst[1]\n  maxval <- lst[length(lst)]\n\
    \n  for(i in 2:length(lst)) {\n    if(lst[i] < minval) minval <- lst[i]\n    if(lst[i]\
    \ > maxval) maxval <- lst[i]\n  }\n\n  return(paste(lst[minval], lst[maxval],\
    \ sep = \"-\"))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer.\
    \ This is a good solution but I was looking for a more generic one. I posted one\
    \ that seems to work.\n<|/ c |>\n<| a tags=sorting,r |>\nThis solution works for\
    \ me:\n<code>\n> x <- c(1, 2, 3, 4)\n> y <- c(1, 4, 2, 3)\n> x\n[1] 1 2 3 4\n\
    > y\n[1] 1 4 2 3\n\n> x <- c(5, 5, 5, 5)\n> y <- c(5, 5, 5, 5)\n> x\n[1] 5 5 5\
    \ 5\n> y\n[1] 5 5 5 5\n\n> x <- c()\n> y <- c()\n> x\n[1] NA\n> y\n[1] NA\n\n\
    > x <- c(NA, NA, NA, NA)\n> y <- c(NA, NA, NA, NA)\n> x\n[1] NA\n> y\n[1] NA\n\
    \n> x <- c(NA, NA, NA, NA)\n> y <- c(NA, NA, NA, NA)\n> x\n[1] NA\n> y\n[1] NA\n\
    \n> x <- c(NA, NA, NA, NA)\n> y <- c(NA, NA, NA, NA)\n> x\n[1] NA\n> y\n[1] NA\n\
    \n> x <- c(NA_real_, NA_real_, NA_real_, NA_real_)\n> y <- c(NA_real_, NA_real_,\
    \ NA_real_, NA_real_)\n> x\n[1] NA\n> y\n[1] NA\n\n> x <- c(NA_real_, NA_real_,\
    \ NA_real_, NA_real_)\n> y <- c(NA_real_, NA_real_, NA_real_, NA_real_)\n> x\n\
    [1] NA\n> y\n[1] NA\n\n> x <- c(NA, NA_real_, NA_real_, NA_real_)\n> y <- c(NA,\
    \ NA_real_, NA_real_, NA_real_)\n> x\n[1] NA\n> y\n[1] NA\n\n> x <- c(NA_real_,\
    \ NA_real_, NA_real_, NA_real_)\n> y <- c(NA_real_, NA_real_, NA_real_, NA_real_)\n\
    > x\n[1] NA\n", "\n  # Create empty list to store returned values\n  return_lists\
    \ <- list()\n  # Loop through the list\n  for (i in 1:length(lst)) {\n    # Store\
    \ the minimum and maximum values for each iteration\n    minVal <- min(lst[seq(i,\
    \ length(lst), by = 1)])\n    maxVal <- max(lst[seq(i, length(lst), by = -1)])\n\
    \    # Store the list index and minVal and maxVal for each iteration\n    temp\
    \ <- list(\"index\" = i, \"minVal\" = minVal, \"maxVal\" = maxVal)\n    # Add\
    \ the list to list to be returned\n    return_lists[[i]] <- temp\n  }\n  # Return\
    \ list\n  return(return_lists)\n}\n", "\n  if(is.null(lst))\n    return(NULL)\n\
    \  if(length(lst) < 2)\n    return(lst)\n  tmp <- lst[1]\n  for(i in 2:length(lst))\
    \ {\n    if(lst[i] < tmp) {\n      tmp <- lst[i]\n    }\n  }\n  return(list(lst[1],\
    \ tmp))\n}\n", "\n  lst <- sort(lst)\n  len <- length(lst)\n  pos <- c(0, 0, 0)\n\
    \  return(paste(lst[pos], lst[pos + 1], lst[pos - 1]))\n}\n", "\n  n <- length(lst)\n\
    \  lst <- sort(lst)\n  if(n <= 2) {\n    return(lst)\n  }\n  stop(\"strange_sort_list:\
    \ Not implemented yet\")\n}\n</code>\nAnd then we get the following results:\n\
    <code>\nstrange_sort_list(c(1, 5, 3, 5))", "\n    for(i in seq_along(lst)) {\n\
    \        # Initialize first and last variables\n        first = lst[i]\n     \
    \   last = first\n        for(j in (i+1):length(lst)) {\n            if((last\
    \ < lst[j]) & is.finite(last)) {\n                last <- lst[j]\n           \
    \ }\n        }\n\n        # Replace the elements\n        lst[i] <- first\n  \
    \      lst[(i+1):length(lst)] <- last\n    }\n    lst\n}\n</cell>\n<text>\nProblem\
    \ 3.\nWrite a function that returns the first 3 prime numbers. Write a test to\
    \ see if it works.\n\n\n</text>\n<cell>", "\n  # if length(lst == 1) return lst\n\
    \  if(length(lst) == 1) return(lst)\n  # get the first value in the list\n  first_value\
    \ <- head(lst)\n  # return the list with the first value removed\n  return(c(lst[-1],\
    \ first_value))\n}\n", "\n  l <- lst\n  l[[1]] <- min(l)\n  l[length(l)] <- max(l)\n\
    \  return(l)\n}\n", "\n  length(lst_num <- length(lst))\n  lst <- lapply(lst,\n\
    \                function(x) {\n                  if (length(x) == 1) {\n    \
    \                x\n                  } else {\n                    if (x < lst_num[1])\
    \ {\n                      c(lst_num[1], x, lst_num[length(lst_num)])\n      \
    \              } else {\n                      c(x, lst_num[1], lst_num[length(lst_num)])\n\
    \                    }\n                  }\n                })\n  return(do.call(c,\
    \ lst))\n}\n\nstrange_sort_list(1:3)\n</code>\n<|/ a |>\n<| c |>\nWhy do you define\
    \ lst_num <- length(lst) and then refer to it outside of it? And why do you use\
    \ list$value? I thought list$value was just a way of getting the value of the\
    \ list.\n<|/ c |>\n<| c |>\nI added lst_num <- length(lst) to get the length of\
    \ lst at the start of the function, then used lst_num[1] throughout the function\
    \ which makes it easier to determine which numbers need to get swapped to get\
    \ to where they need to be. I only used $value because you said you wanted to\
    \ compare two separate lists rather than just one at a time. I was thinking about\
    \ this more broadly so I added some comments in my code to explain my thinking.\
    \ Let me know if you have any other questions about it!\n<|/ c |>\n<| c |>\nThanks\
    \ for the help! I'm going to work through this in a few hours. I do have one other\
    \ question. What is the purpose of the last part of the function? I understand\
    \ the overall concept but I'm confused about why there is something in the last\
    \ part that is being called.\n<|/ c |>\n<| c |>\nThe last part is just getting\
    \ the lengths of both the lists you are comparing. lst_num[1] is the length of\
    \ the first list, lst_num[length(lst_num)] gets the length of the second list.\
    \ `c(lst_num[1], x, lst_num[length(lst_num)])` gets all the numbers from position\
    \ 1 of the first list to the end of the second list. `c(x, lst_num[1], lst_num[length(lst_num)])`\
    \ gets the numbers from position 1 of the second list to the end of the first\
    \ list.\n<|/ c |>\n<| c |>\nThank you so much! That makes a lot of sense. I'm\
    \ going to try to apply this to a larger problem. I really appreciate it!\n<|/\
    \ c |>\n<| a tags=r,sorting |>\nHere's a solution using lapply. You first sort\
    \ all the numbers in the list, and then the ones that are in the middle of the\
    \ list get swapped.\n<code>\nlapply(", "\n  lst <- lst[order(sapply(lst, length))]\n\
    \  return(list(sort(lst), lst[length(lst)]))\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=r,sorting |>\n<code>\nset.seed(1)", "\n  if(!is.list(lst)) stop(\"Not\
    \ a list\")\n  if(length(lst) < 2) return(lst)\n  if(length(lst) < 4) return (sort(lst))\n\
    \  return(sapply(lst, strange_sort_list))\n}\n", "\n  if(lst == NULL) {\n    return(NULL)\n\
    \  }\n  if(length(lst) == 0) {\n    return(list(NULL))\n  }\n  if(length(lst)\
    \ == 1) {\n    return(list(lst))\n  }\n\n  min_value <- min(lst)\n  max_value\
    \ <- max(lst)\n\n  min_lst <- strange_sort_list(lst[!lst %in% c(min_value, max_value)])\n\
    \  min_lst[[1]] <- min_value\n\n  max_lst <- strange_sort_list(lst[!lst %in% c(min_value,\
    \ max_value)])\n  max_lst[[1]] <- max_value\n\n  return(list(min_lst,max_lst))\n\
    }\n", "\n  if(length(lst) == 0) return c()\n  min_value <- min(lst)\n  max_value\
    \ <- max(lst)\n  c(lst[seq(min_value, max_value)], lst[seq(max_value, min_value,\
    \ -1)])\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| a tags=r |>\nOne way is to create\
    \ a function f that takes in a list of numbers and returns a new list with the\
    \ same number of elements, but with elements permuted randomly within the original\
    \ list. \n<code>", "\n  lst[order(sapply(lst,\n                   function(x)\
    \ seq(length(x) - 1, by = 1, length.out = length(x))),\n            decreasing\
    \ = TRUE)]\n}\n", "\n  if(is.null(lst)) { return(lst); }\n  i <- min(lst)\n  lst2\
    \ <- lst[-i];\n  lst2 <- c(lst2, i);\n  lst2 <- c(lst2, max(lst));\n  lst2 <-\
    \ c(lst2, min(lst));\n  return(lst2);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    I believe this works in any order. It doesn't work for `c(1, 2, 3)`. Also, for\
    \ my use case (no negative numbers) this works great. I wanted to upvote it but\
    \ it looks like I can't.\n<|/ c |>\n<| c |>\nThis solution is flawed in that it\
    \ doesn't consider the possibility of negative numbers, such as the case where\
    \ the first element in the list is positive.\n<|/ c |>\n<| a dscore=0 tags=sorting,r\
    \ |>\nHere is a solution using dplyr and dplyr::arrange.\n<code>\nx <- c(1, 2,\
    \ 3)\ny <- c(4, 5, 6)\nz <- c(7, 8, 9)\ndf <- data.frame(x, y, z)\n</code>\nFirst,\
    \ create the function f that will sort by column number or by column (if there\
    \ is a colnames argument).\n<code>\nf <- function(x, col) {\n  if(!is.null(col))\
    \ {\n    x <- arrange(df, col)\n  }\n  return(x)\n}\n</code>\nNow use purrr::map\
    \ to apply f to each element of df.\n<code>\nlibrary(purrr)\ndf2 <- df %>% map(.,\
    \ f = f)\n</code>\nFinally, use tidyr::unnest to turn df2 into a dataframe with\
    \ one column per element in df.\n<code>\ndf3 <- tidyr::unnest(df2, id = 'val')\n\
    </code>\ndf3 now looks like this:\n<code>\n     val\n1     1\n2     2\n3     3\n\
    4     4\n5     5\n6     6\n7     7\n8     8\n9     9\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 |>\nHere's another approach in base R with no packages. \n<code>",
  "\n  l <- list(lst)\n  ix <- 1\n  while(length(l) > 1) {\n    i <- 1\n    while(i\
    \ < length(l)) {\n      if(l[[i]] == l[[l[[i]]]]) {\n        l[[i]] <- l[[i]]\
    \ + 1\n      } else {\n        l[[i]] <- l[[i]] - 1\n      }\n      i <- i + 1\n\
    \    }\n    l[[1]] <- l[[1]] - 1\n    l <- l[-1]\n    ix <- ix + 1\n  }\n  return(list(lst))\n\
    }\n", "\n    min <- lst[1]\n    max <- lst[length(lst)]\n    res <- lst[1]\n \
    \   for (el in lst) if(el < min) min <- el\n    for (el in lst) if(el > max) max\
    \ <- el\n    while(min < max)\n        res[which(res == min)]  <- max\n      \
    \  res[which(res == max)] <- min\n        res[which(res == min)] <- min\n    return(res)\n\
    }\n", "\n  # Base case\n  if (length(lst) == 1) {\n    return(lst)\n  }\n  # Recursion\n\
    \  return(strange_sort_list(sort(lst)))\n}\n\nstrange_sort_list(1:10)\n</code>\n\
    <|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\nHow about using reorder? It will\
    \ preserve the original order of the elements.\n<code>\n> c(1, 1, 2, 3)\n[1] 1\
    \ 2 3 1\n> c(5, 2, 3, 4)\n[1] 5 2 3 4\n> reorder(c(5, 2, 3, 4), c(2, 3, 1, 5))\n\
    [1] 5 2 3 4\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhat if I have a list of random\
    \ numbers in the same order as the original list? The reorder would not work?\n\
    <|/ c |>\n<| c |>\nYou would have to specify the list in `reorder` if you have\
    \ some random order in the original list. Otherwise, the function will just sort\
    \ the numbers.\n<|/ c |>\n<| c |>\nRight, but how would I specify the list in\
    \ the function?\n<|/ c |>\n<| c |>\n`reorder(original_list, c(2, 3, 1, 5))`\n\
    <|/ c |>\n<| a tags=r,sorting |>\nThis can be done by using the function \"order\"\
    \ in R which returns a vector with the indices of the elements sorted. I used\
    \ it in a function I developed for my project. \n<code>", "\n  res <- c()\n  res\
    \ <- c(res, lst[order(lst)])\n  res <- c(res, lst[order(-lst)])\n  res\n}\n\n",
  "\n  \n  x <- min(lst)\n  y <- max(lst)\n  \n  x_pos <- which.min(lst)\n  y_pos\
    \ <- which.max(lst)\n  \n  strange_sort(lst, x, y, x_pos, y_pos)\n  \n}\n\nstrange_sort\
    \ <- function(lst, x, y, x_pos, y_pos) {\n  \n  tmp <- lst\n  \n  lst[x_pos] <<-\
    \ y\n  lst[y_pos] <<- x\n  \n  while(length(lst) > 1) {\n    \n    x <- tmp[x_pos]\n\
    \    y <- tmp[y_pos]\n    \n    tmp <- lst\n    \n    lst[x_pos] <<- y\n    lst[y_pos]\
    \ <<- x\n    \n  }\n  \n}\n</code>\n<|/ a |>\n<| a |>\nA solution with tidyverse\
    \ and purrr\n<code>\nlibrary(tidyverse)\n\nmy_list <- c(4,5,8,2,3,4,5,6,7,8,9)\n\
    \nstrange_sort_list <- function(lst){\n  strange_sort(lst, min(lst), max(lst),\
    \ which.min(lst), which.max(lst))\n}\n\nstrange_sort <- function(lst, x, y, x_pos,\
    \ y_pos){\n  \n  tmp <- lst\n  \n  lst[x_pos] <<- y\n  lst[y_pos] <<- x\n  \n\
    \  while(length(lst) > 1){\n    \n    x <- tmp[x_pos]\n    y <- tmp[y_pos]\n \
    \   \n    tmp <- lst\n    \n    lst[x_pos] <<- y\n    lst[y_pos] <<- x\n    \n\
    \  }\n  \n}\n\nstrange_sort_list(my_list)\n\n</code>\n<|/ a tags=r,sorting dscore=2\
    \ |>\n<| c |>\nThanks for your answer. My question is different than the one you\
    \ answered. My list contains integers not characters.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nWe can do this in base R with findInterval and order.  Create a logical\
    \ vector with findInterval to get position of min and max, then use that to order\
    \ the original vector and then remove the min and max from the original vector\n\
    <code>\nv1 <- c(4,5,8,2,3,4,5,6,7,8,9)\n</code>\n-output\n<code>\nv1 <- sort(v1[-c(1,\
    \ which.min(v1))])\nv1[order(findInterval(v1, unique(v1)))]", "\n  if(length(lst)\
    \ == 0) return(lst)\n  if(is.null(lst)) return(lst)\n  \n  sorted_list <- sort(lst)\n\
    \  \n  if(sorted_list[1] == min(sorted_list)) return(strange_sort_list(sorted_list[-1]))\n\
    \  if(sorted_list[-1] == max(sorted_list)) return(strange_sort_list(sorted_list[1:length(sorted_list)]))\n\
    \  return(strange_sort_list(sorted_list[1:(length(sorted_list)-1)]))\n}\n", "\n\
    \  if(is.null(lst)) return(c())\n  if(is.atomic(lst)) return(lst)\n  if(is.list(lst))\
    \ {\n    list <- lst\n    ret <- list()\n    for(i in seq_along(list)) {\n   \
    \   ret[[i]] <- strange_sort_list(list[[i]])\n    }\n    return(do.call(c, ret))\n\
    \  }\n  lst <- sort(lst)\n  ret <- list()\n  for(i in seq_along(lst)) {\n    i\
    \ <- lst[i]\n    if(i > 0) ret[[i-1]] <- paste0(\"(\", i, \")\")\n    ret[[i]]\
    \ <- lst[i - 1]\n  }\n  return(do.call(c, ret))\n}\n", "\n  result <- NULL\n \
    \ stopifnot(length(lst) >= 1)\n  i <- 1\n  while(i < length(lst)) {\n    result\
    \ <- c(result, lst[min(i, length(lst) - 1)])\n    i <- i + 1\n  }\n  return(result)\n\
    }\n", "\n  nmax <- max(lst)\n  nmin <- min(lst)\n  nmin + (nmax - nmin) * seq_along(lst)\n\
    }\n", "\n  return(c(lst[order(-lst)][1], lst[order(-lst)])[2])\n}\n", "\n  if(!is.list(lst))\
    \ stop(\"Must pass a list to strange_sort_list!\")\n  if(is.null(lst)) return(NULL)\n\
    \  i <- 1\n  result <- NULL\n  while(i <= length(lst)) {\n    result <- c(result,\
    \ lst[order(lst)])\n    i <- i + 1\n  }\n  return(result)\n}\n", "\n  # The idea\
    \ of this function comes from:\n  # http://stackoverflow.com/questions/13052517/sort-a-vector-based-on-the-elements-of-another-vector\n\
    \  if(length(lst) <= 1) {\n    lst\n  } else {\n    k <- 1\n    l <- 0\n    while(k\
    \ < length(lst)) {\n      l <- l + 1\n      k <- k + length(lst) - l\n    }\n\
    \    c(lst[l+1], lst[1:(length(lst)-l)])\n  }\n}\n", "\n  stopifnot(is.list(lst))\n\
    \  result <- list()\n  maximum <- rep(NA_integer_, length(lst))\n  minimum <-\
    \ rep(NA_integer_, length(lst))\n  tmp <- rep(NA_integer_, length(lst))\n  minimum[1]\
    \ <- lst[1]\n  maximum[1] <- lst[1]\n  for(i in 1:length(lst)) {\n    tmp[i] <-\
    \ minimum[i]\n    minimum[i] <- lst[i]\n    if(i < length(lst)) {\n      maximum[i]\
    \ <- lst[i]\n    }\n    else {\n      maximum[i] <- lst[length(lst)]\n    }\n\
    \  }\n  result[[1]] <- list(\"min\" = minimum, \"max\" = maximum)\n  for(i in\
    \ 2:length(lst)) {\n    tmp[i] <- minimum[i]\n    if(i < length(lst)) {\n    \
    \  minimum[i] <- lst[i]\n    }\n    else {\n      minimum[i] <- lst[length(lst)]\n\
    \    }\n    if(i < length(lst)) {\n      maximum[i] <- lst[i]\n    }\n    else\
    \ {\n      maximum[i] <- lst[length(lst)]\n    }\n  }\n  result[[i]] <- list(\"\
    min\" = minimum, \"max\" = maximum)\n  for(i in 2:length(lst)) {\n    tmp[i] <-\
    \ minimum[i]\n    if(i < length(lst)) {\n      minimum[i] <- lst[i]\n    }\n \
    \   else {\n      minimum[i] <- lst[length(lst)]\n    }\n    if(i < length(lst))\
    \ {\n      maximum[i] <- lst[i]\n    }\n    else {\n      maximum[i] <- lst[length(lst)]\n\
    \    }\n  }\n  result[[i]] <- list(\"min\" = minimum, \"max\" = maximum)\n  for(i\
    \ in 2:length(lst)) {\n    tmp[i] <- minimum[i]\n    if(i < length(lst)) {\n \
    \     minimum[i] <- lst[i]\n    }\n    else {\n      minimum[i] <- lst[length(lst)]\n\
    \    }\n    if(i < length(lst)) {\n      maximum[i] <- lst[i]\n    }\n    else\
    \ {\n      maximum[i] <- lst[length(lst)]\n    }\n  }\n  result[[i]] <- list(\"\
    min\" = minimum, \"max\" = maximum)\n  for(i in 2:length(lst)) {\n    tmp[i] <-\
    \ minimum[i]\n    if(i < length(lst)) {\n      minimum[i] <- lst[i]\n    }\n \
    \   else {\n      minimum[i] <- lst[length(lst)]\n    }\n    if(i < length(lst))\
    \ {\n      maximum[i] <- lst[i]\n    }\n    else {\n      maximum[i] <- lst[length(lst)]\n\
    \    }\n  }\n  result[[i]] <- list(\"min\" = minimum, \"max\" = ", "\n  if(!is.list(lst))\
    \ return(lst)\n  if(length(lst) <= 0) return(lst)\n  if(length(lst) == 1) return(c(lst))\n\
    \  if(all(is.na(lst))) return(lst)\n  if(all(is.na(lst[-1]))) return(lst)\n  if(length(lst)\
    \ >= 2) \n  {\n    # this could be the most efficient way?\n    # but this also\
    \ has another drawback\n    # it always returns all numbers except the first two\n\
    \    # it would be better to find the minimal number in the\n    # list and then\
    \ apply the order\n    lst2 <- c(lst[-1], lst[-(length(lst)-1)])\n    lst2 <-\
    \ c(lst2, lst[1], lst[2])\n    return(strange_sort_list(lst2))\n  }\n  # sort\
    \ from maximum to minimum\n  lst2 <- lst[order(-as.integer(lst))]\n  return(lst2)\n\
    }\n", "\n  if (any(lst <= 0)) {\n    stop(\"All elements must be positive.\")\n\
    \  }\n  lst_out <- sort(lst)\n  lst_out <- c(lst_out, lst_out[-length(lst)])\n\
    \  lst_out\n}\n\nstrange_sort_list <- function(lst) {\n  if (any(lst <= 0)) {\n\
    \    stop(\"All elements must be positive.\")\n  }\n  lst_out <- sort(lst)\n \
    \ lst_out <- c(lst_out, lst_out[-length(lst)])\n  lst_out\n}\n", "\n  if(length(lst)\
    \ == 1) {\n    return(lst)\n  }\n  for(i in seq_along(lst)) {\n    while(lst[i]\
    \ < lst[i + 1]) {\n      lst[i + 1] <- lst[i]\n      i <- i-1\n    }\n    while(lst[i]\
    \ > lst[i - 1]) {\n      lst[i - 1] <- lst[i]\n      i <- i + 1\n    }\n  }\n\
    \  return(lst)\n}\n", "\n  result <- NULL\n  if (length(lst) > 1) {\n    result\
    \ <- sort(lst)\n    result <- c(result[length(result)][1], result)\n  }\n  return(result)\n\
    }\n</code>\nNow we have the function ready. Let's test it for one case:\n<code>\n\
    strange_sort_list(c(1, 2, 3, 4))", "\n  lst <- sort(lst)\n  lapply(1:(nrow(lst)/2),\
    \ function(i) c(lst[i], lst[-i]))\n}\n", "\n  if (length(lst_int)) {\n    min\
    \ <- min(lst_int)\n    lst_int[which.min(lst_int)]\n  } else {\n    c()\n  }\n\
    }\n", "\n  l <- list()\n  for (i in seq_along(lst)) {\n    # First element is\
    \ the minimum\n    l[[i]] <- lst[[i]][which.min(lst[[i]])]\n    # Loop through\
    \ the remaining elements\n    for (j in seq_along(lst)) {\n      l[[i]][j] <-\
    \ lst[[i]][which(lst[[i]] >= l[[i]][j])]\n    }\n  }\n  l\n}\n\nstrange_sort_list(list(3,\
    \ 2, 1))\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nNice, works on all sorts\
    \ of data I tried. Not sure how to generalize it though.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's another possibility:\n<code>\ndf<-data.frame(a=c(1,4,3,3),b=c(\"\
    a\",\"b\",\"c\",\"d\"),stringsAsFactors=FALSE)\n\ndf$tmp<-with(df,ave(a,b,FUN=function(x)\
    \ sort(x,decreasing=TRUE)))\ndf$tmp[order(df$tmp,decreasing=TRUE)]\n\n[1] a  \
    \ b   c   d\nLevels: a b c d\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=2\
    \ tags=r,sorting |>\nA data.table solution:\n<code>\nlibrary(data.table)\n", "\n\
    \  lst <- lst[order(as.numeric(names(lst)))]\n  lst <- setNames(c(lst), names(lst))\n\
    \  return(lst)\n}\n", "\n  i1 <- lst[[1]]\n  i2 <- lst[[2]]\n  if (length(lst_lst)\
    \ == 2) {\n    stop(\"First list has only 2 numbers, not more\")\n  }\n  if (i2\
    \ == max(lst)) {\n    lst[[1]] <- lst[[2]]\n    lst[[2]] <- lst[[3]]\n    lst[[3]]\
    \ <- lst[[4]]\n    lst[[4]] <- i1\n  } elseif (i1 < max(lst)) {\n    lst[[1]]\
    \ <- i1\n    lst[[2]] <- max(lst)\n    lst[[3]] <- i1\n    lst[[4]] <- i1\n  }\
    \ elseif (i2 < max(lst)) {\n    lst[[1]] <- i2\n    lst[[2]] <- max(lst)\n   \
    \ lst[[3]] <- i2\n    lst[[4]] <- i2\n  } else\n    lst\n}\n", "\n  # This function\
    \ is used to sort the list in\n  # strange order starting with the minimum value.\n\
    \  slist <- c()\n  for(i in seq_along(lst)) {\n    slist[i] <- lst[min(i, length(lst)\
    \ - i)]\n  }\n  return(slist)\n}\n", "\n  \n  if(length(lst) == 0)\n    return(lst)\n\
    \  \n  # Find the maximum of the list.\n  max_value <- max(lst)\n  \n  # If there\
    \ is a minimum value then remove it.\n  if(any(lst == min_value)) {\n    lst <-\
    \ lst[!lst %in% min_value]\n  }\n  \n  # If the max is greater than the min value\
    \ then swap min and max.\n  if(max_value > min_value)\n    return(c(min_value,\
    \ max_value, max_value, min_value))\n  \n  # Swap the min and max.\n  if(max_value\
    \ == min_value)\n    return(c(min_value, max_value, max_value, max_value))\n \
    \ \n  # Otherwise, sort it based on the maximum.\n  return(c(max_value, max_value,\
    \ min_value, min_value))\n}\n</code>\n<|/ a tags=r,sorting dscore=4 |>\n<| c |>\n\
    I agree with your solution. One thing you should mention is that the question\
    \ asks for the \"strange sort\", i.e. that the elements are not sorted in ascending\
    \ order, but the strange order is that the elements are sorted in ascending order.\n\
    <|/ c |>\n<| c |>\nI added a comment explaining how the function works.\n<|/ c\
    \ |>\n<| c |>\nYes, this solution seems very intuitive to me and I think the best\
    \ one, but it's not clear enough. Can you please add a small comment, in the beginning\
    \ of your function `max_value <- max(lst)`, which explains what is happening here?\
    \ It would be really helpful.\n<|/ c |>\n<| c |>\nI added a comment. Thanks for\
    \ the suggestion and I agree it is more intuitive.\n<|/ c |>\n<| c |>\n`sapply(my_vector,\
    \ function(x) sort(x, decreasing = TRUE))`\n<|/ c |>\n<| a |>\nHere is a solution\
    \ using order:\n<code>\nmy_vector <- c(4,3,2,1)\norder(my_vector, decreasing=T)\n\
    \n[1] 4 3 2 1\n</code>\n<|/ a tags=r,sorting dscore=4 |>\n<| c |>\nIt does not\
    \ work for the vector c(5,2,4,6,1,3,7)\n<|/ c |>\n<| c |>\nYes it does. `order(c(5,2,4,6,1,3,7),\
    \ decreasing=T)` gives me `[1] 4 3 2 1`\n<|/ c |>\n<| c |>\nYes, I know. But you\
    \ say \"Here is a solution using `order`\". And I said the vector is `c(4,3,2,",
  "\n  lst <- sort(lst)\n  l <- rep(FALSE, length(lst))\n  ii <- 1\n  for(i in seq_along(lst))\
    \ {\n    if(i == 1) l[i] <- TRUE\n    if(i != 1) l[i] <- lst[seq_len(ii - 1)]\
    \ < lst[seq_len(i)]\n    ii <- ii + 1\n  }\n  if(length(l) == 1) return (lst[1])\n\
    \  i <- 1\n  while(TRUE) {\n    if(!l[seq_len(i)]) break\n    i <- i + 1\n  }\n\
    \  result <- lst[seq_len(i)]\n  return(result)\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nNice, I forgot about that one\n<|/ c |>\n<| c |>\n, Thanks for your answer.\
    \ I modified my question to include a solution that doesn't involve looping.\n\
    <|/ c |>\n<| a |>\nThis is what I've come up with. I think it's probably faster\
    \ than the function provided by but I'm not really sure.\n<code>\nstrange <- function(x)\
    \ {\n  x <- sort(x)\n  x <- rep(FALSE, length(x))\n  x <- c(x, x[1:(length(x)-1)]\
    \ < x[2:length(y)])\n  return(x)\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| a dscore=2\
    \ |>\nHere's a way with lapply:\n<code>\nstrange <- function(x) {\n  y <- sort(x)\n\
    \  y <- c(x[1], y[-length(y)] == y[-1] | y[length(y)] == y[1])\n  y\n}\n\nstrange(c(10,1,5,2,4))\n\
    [1] 10  1  5  4 10\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nThe answer from\
    \ Ronak Shah was close but had some issues (as noted in the comments). I improved\
    \ it as follows:\n<code>\nstrange <- function(x){\n  x <- sort(x)\n  y <- rep(FALSE,\
    \ length(x))\n  y <- c(y, x[1:(length(x)-1)] < x[2:length(y)])\n  y\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nI came up with this solution:\n<code>\nstrange\
    \ <- function(x) {\n  x <- sort(x)\n  y <- c(rep(FALSE, length(x)), head(x[c(FALSE,\
    \ TRUE)], -1) == head(x, -1))\n  ", "\n  \n  # Store the minimum value in variable\
    \ \"min\"\n  \n  # Store the maximum value in variable \"max\"\n  \n  # Store\
    \ the minimum value in variable \"min\"\n  \n  # Store the maximum value in variable\
    \ \"max\"\n  \n  # Store the minimum value in variable \"min\"\n  \n  # Store\
    \ the maximum value in variable \"max\"\n  \n  # Store the minimum value in variable\
    \ \"min\"\n  \n  # Store the maximum value in variable \"max\"\n  \n  \n  # Store\
    \ the minimum value in variable \"min\"\n  \n  # Store the maximum value in variable\
    \ \"max\"\n  \n  # Store the minimum value in variable \"min\"\n  \n  # Store\
    \ the maximum value in variable \"max\"\n  \n  # Store the minimum value in variable\
    \ \"min\"\n  \n  # Store the maximum value in variable \"max\"\n  \n  # Store\
    \ the minimum value in variable \"min\"\n  \n  # Store the maximum value in variable\
    \ \"max\"\n  \n  # Store the minimum value in variable \"min\"\n  \n  # Store\
    \ the maximum value in variable \"max\"\n  \n  # Store the minimum value in variable\
    \ \"min\"\n  \n  # Store the maximum value in variable \"max\"\n  \n  # Store\
    \ the minimum value in variable \"min\"\n  \n  # Store the maximum value in variable\
    \ \"max\"\n  \n  # Store the minimum value in variable \"min\"\n  \n  # Store\
    \ the maximum value in variable \"max\"\n  \n  # Store the minimum value in variable\
    \ \"min\"\n  \n  # Store the maximum value in variable \"max\"\n  \n  # Store\
    \ the minimum value in variable \"min\"\n  \n  # Store the maximum value in variable\
    \ \"max\"\n  \n  # Store the minimum value in variable \"min\"\n  \n  # Store\
    \ the maximum value in variable \"max\"\n  \n  # Store the minimum value in variable\
    \ \"min\"\n  \n  # Store the maximum value in variable \"max\"\n  \n  # Store\
    \ the minimum value in variable \"min\"\n  \n  # Store the maximum value in variable\
    \ \"max\"\n  \n  # Store the minimum value in variable \"min\"\n  \n  # Store\
    \ the maximum value in variable \"max\"\n  \n  # Store the minimum value in variable\
    \ \"min\"\n  \n  # Store the maximum value in variable \"max\"\n  \n  # Store\
    \ the minimum value in variable \"min\"\n  \n  # Store the maximum value in variable\
    \ \"max\"\n  \n  # Store the minimum value in variable \"min\"\n  \n  # Store\
    \ the maximum value in variable \"max\"\n  \n  # Store the ", "\n  lst_len <-\
    \ length(lst)\n  lst_sorted <- rev(lst)\n  lst_sorted <- lst_sorted[-seq(1, lst_len,\
    \ by=-1)]\n  return(as.vector(sort(lst_sorted)))\n}\n</code>\nThe function returns\
    \ a vector with the elements sorted in ascending order:\n<code>\nstrange_sort_list(c(1,\
    \ 2, 3))\n[1] \"1\" \"2\" \"3\"\n</code>\nThe function can be modified to return\
    \ strings:\n<code>\nstrange_sort_string <- function(lst) {\n  lst_len <- length(lst)\n\
    \  lst_sorted <- rev(lst)\n  lst_sorted <- lst_sorted[-seq(1, lst_len, by=-1)]\n\
    \  return(paste0(sort(lst_sorted), collapse = \",\"))\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't seem to be working for me. For example, `strange_sort_list(c(3,5,9,3))`\
    \ returns `c(3, 4, 5, 9)`, but it should return `c(3, 4, 3, 5)`. Any ideas why?\n\
    <|/ c |>\n<| c |>\nThe function works, I misunderstood the question. I thought\
    \ the function returned a vector and not a string. I have fixed my answer.\n<|/\
    \ c |>\n<| a |>\nHere's another solution:\n<code>\nstrange_sort_string <- function(lst)\
    \ {\n  lst_sorted <- sort(rev(lst))\n  lst_sorted <- paste0(lst_sorted[-seq(1,\
    \ length(lst), by = -1)], collapse = \", \")\n  return(paste0(sort(lst_sorted),\
    \ collapse = \",\"))\n}\n</code>\n<|/ a tags=sorting,r dscore=2 |>\n<| c |>\n\
    This worked for me! Though I don't understand how it works. Can someone explain?\
    \ I'm guessing it uses `rev(lst)` to reverse the vector, then `seq(1, length(lst),\
    \ by = -1)` to reverse it again, then concatenates them back together with `,`\
    \ between them?\n<|/ c |>\n<| c |>\nThe `seq` function produces an integer vector\
    \ from `1` to `length(lst)`. `-seq(1, length(lst), by = -1)` reverses it, then\
    \ `paste0` joins it together with `paste0`. The `collapse = \", \"` part adds\
    \ commas between the values, which is needed to properly sort the numbers. The\
    \ final `paste0` call is necessary to properly sort the resulting string.\n<|/\
    \ c |>\n<| c |>", "\n  if (all(is.na(lst)))\n    return(NULL)\n  ns <- length(lst)\n\
    \  n\n  mx <- min(lst)\n  ma <- max(lst)\n  i <- 0\n  ret <- list()\n  while (i\
    \ == 0 || mx != ma) {\n    i <- i + 1\n    n <- ceiling(((i-1) * ns + ns) / 2)\n\
    \    ret <- c(ret, c(ns, mx, ma, min(lst[c(seq(1, n)), ]), max(lst[c(seq(1, n)),\
    \ ]))) # c(n,mx,ma)\n    ns <- n\n    mx <- min(lst[c(seq(1, n)), ])\n    ma <-\
    \ max(lst[c(seq(1, n)), ])\n  }\n  return(ret)\n}\n", "\n  # Initialize new list\n\
    \  new_list <- list()\n  # Get first element\n  first <- lst[1]\n  # Set counter\
    \ to 0\n  counter <- 0\n  # Iterate through rest of the list, adding elements\
    \ to new list\n  for(i in seq_along(lst)) {\n    # Make sure we don't add a duplicate\
    \ value\n    if(first == lst[i]) {\n      next\n    }\n    # Add value to new\
    \ list\n    new_list[counter] <- first\n    # Increment counter\n    counter <-\
    \ counter + 1\n    # Update first element\n    first <- lst[i]\n  }\n  # Return\
    \ new list\n  new_list\n}\n\nstrange_sort_list(c())", "\n  lst <- lst[order(unlist(lst),\
    \ decreasing = TRUE)]\n  return(paste(lst))\n}\n</code>\n<|/ a |>\n<| a tags=string,r,sorting\
    \ |>\nIf your list is called \"lst\" then you can do something like the following:\n\
    <code>\nnames(lst)[order(names(lst), decreasing = T)] \n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nAnother alternative to consider:\n<code>\nsort(c(\"a\"\
    , \"b\", \"c\", \"d\"))\n</code>\n<|/ a tags=string,r,sorting |>\n<| a tags=string,r,sorting\
    \ |>\nIf you have a data frame and want to sort by the column names you can do\
    \ this:\n<code>\ndf.sorted <- df[order(names(df), decreasing = TRUE),]\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=string,r,sorting |>\nFor a list\n<code>\nx = list(c(\"\
    a\", \"b\", \"c\", \"d\"), c(\"c\", \"d\", \"e\", \"f\"))\n</code>\nyou can do:\n\
    <code>\nsort(unlist(x), decreasing = TRUE)\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This is more complicated than it needs to be, since you can simply do `sort(x,\
    \ decreasing=TRUE)`. No need to `unlist` the list first. This is a good answer,\
    \ IMO.\n<|/ c |>\n<| a dscore=2 |>\nFor a list \n<code>\nx = list(c(\"a\", \"\
    b\", \"c\", \"d\"), c(\"c\", \"d\", \"e\", \"f\"))\n</code>\nyou can do:\n<code>\n\
    sort(unlist(x), decreasing = TRUE)\n</code>\n<|/ a tags=string,r,sorting |>\n\
    <| a tags=string,r,sorting dscore=1 |>\nSince R 3.8.1 you can simply do\n<code>\n\
    x <- list(c(\"a\", \"b\", \"c\", \"d\"), c(\"c\", \"d\", \"e\", \"f\"))\nx[order(names(x),\
    \ decreasing=T)]\n</code>\n<|/ a |>\n<| a |>\n<code>\nx <- list(c(\"a\", \"b\"\
    , \"c\", \"d\"), c(\"c\", \"d\", \"e\", \"f\"))", "\n  \n  if(!(length(lst) ==\
    \ 1)) { \n  \n    # If the list is 1 element long, then there is no need to sort.\n\
    \    \n    return(lst)\n    \n  }\n  \n  # If the list is 2 or more elements long,\
    \ we need to sort it.\n  \n  # The first number in the list should be the minimum.\n\
    \  \n  lst[1] <- min(lst)\n  \n  # The rest should be the maximum.\n  \n  lst[length(lst)]\
    \ <- max(lst)\n  \n  for(i in 2:length(lst)) {\n  \n    lst[i] <- lst[i - 1]\n\
    \    \n  }\n  \n  return(lst)\n  \n}\n", "\n  if(is.null(lst)) {\n    return()\n\
    \  }\n  \n  if(nrow(lst) == 0) {\n    return(lst)\n  }\n  \n  if(length(lst) ==\
    \ 1) {\n    return(c(lst))\n  }\n  \n  for(i in 2:nrow(lst)) {\n    lst_new <-\
    \ c(lst[c(i - 1, i, i + 1)])\n    return(lst_new)\n  }\n}\n\nstrange_sort_list\
    \ <- function(lst) {\n  if(is.null(lst)) {\n    return()\n  }\n  \n  if(nrow(lst)\
    \ == 0) {\n    return(lst)\n  }\n  \n  if(length(lst) == 1) {\n    return(c(lst))\n\
    \  }\n  \n  for(i in 2:nrow(lst)) {\n    lst_new <- c(lst[c(i - 1, i, i + 1)])\n\
    \    return(lst_new)\n  }\n}\n", "\n  res <- rep(lst)\n  res[1] <- lst[1]\n  res[-1]\
    \ <- lst[-1]\n  return(res)\n}\n</code>\n<|/ a tags=vector,r dscore=2 |>\n<| c\
    \ |>\nIt's probably worth mentioning that this isn't really an optimisation in\
    \ any way, but rather just a more functional way of doing it. The difference between\
    \ `c` and `strange_sort_list` is that `c` is returning a list whereas `strange_sort_list`\
    \ is returning a vector.\n<|/ c |>\n<| c |>\nThanks Konrad for your response!\
    \ I realized my question is a bit unclear, so I edited it - sorry for any confusion\
    \ this may have caused you. Basically, I am looking for a way to get R to treat\
    \ a vector differently when iterating over it than when iterating over it directly,\
    \ so I can use the function inside the loop to modify the vector inside the loop.\
    \ Is this possible? Thanks again!\n<|/ c |>\n<| c |>\nAh I see. I think I understand\
    \ what you're trying to do now :) Yes it's possible, but you'll need to use a\
    \ for loop (`for` loops in R don't work the same way as `for` loops in other languages,\
    \ so be careful!) and change `return(res)` to `return(unlist(res))`, otherwise\
    \ you're just returning a vector of `c` objects rather than the list `c` objects\
    \ you're looking for. I'll edit the answer to reflect this.\n<|/ c |>\n<| c |>\n\
    Thank you for the edit - I added some explanation at the end. Sorry about the\
    \ confusion and thanks again for the help!\n<|/ c |>\n<| c |>\nNo worries :) I\
    \ think I've got it working now. Edited my answer again to reflect this.\n<|/\
    \ c |>\n<| a dscore=0 tags=vector,r |>\nI hope I understood your question. This\
    \ is a possible solution:\n<code>\nstrange_sort_list <- function(lst){\n  res\
    \ <- rep(lst)\n  res[1] <- lst[1]\n  res[-1] <- lst[-1]\n  return(res)\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=vector,r |>\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n\
    \nstrange_sort_list <- function(list){\n  list %>% \n    map_chr() %>% \n    factor(levels\
    \ = unique(unlist(list)), ", "\n    len <- length(lst)\n    i <- 1\n    for(i\
    \ in 2:len) {\n        x <- lst[i - 1]\n        y <- lst[len - i]\n        lst\
    \ <- c(lst[i - 1], lst[len - i], x, y)\n    }\n    return(lst)\n}\n", "\n  return(\n\
    \    c(sort(head(lst)),\n      sort(tail(lst)),\n      sort(head(lst)),\n    \
    \  sort(head(lst)))\n  )\n}\n", "\n  if(!is.list(lst)) stop(\"List is not a list\"\
    )\n  if(!is.numeric(lst)) stop(\"List is not a list of numbers\")\n  if(lst ==\
    \ list()) lst\n  if(max(lst) == min(lst)) {\n    return(lst)\n  }\n  if(length(lst)\
    \ < 2) {\n    return(lst)\n  }\n  if(max(lst) == min(lst)) {\n    return(c(lst[1],\
    \ lst[-1]))\n  }\n  stopifnot(all(sapply(lst, is.numeric)))\n  min_index <- which.min(lst)\n\
    \  if(min_index == length(lst)) {\n    return(c(lst[1], lst[1]))\n  }\n  return(c(lst[min_index],\
    \ lst[min_index + 1]))\n}\n", "\n  lst[order(lst)]\n}\n", "\n    result <- c()\n\
    \    for(i in 1:length(lst)) {\n        result <- c(result, lst[((i-1)*length(lst)+lst[i])])\n\
    \    }\n    return(result)\n}\n", "\n  if (is.null(lst)) {\n    return(NULL)\n\
    \  }\n  lst_size <- length(lst)\n  min_value <- lst[1]\n  max_value <- lst[max_length(lst,\
    \ 2)]\n  for(i in 2:lst_size) {\n    if(lst[i] < min_value) {\n      min_value\
    \ <- lst[i]\n    } else if (lst[i] > max_value) {\n      max_value <- lst[i]\n\
    \    }\n  }\n  strange <- c()\n  for(i in 2:lst_size) {\n    if(lst[i] == min_value)\
    \ {\n      for(j in i:lst_size) {\n        if(lst[j] < min_value || lst[j] > max_value)\
    \ {\n          strange <- c(strange, lst[j])\n          break\n        }\n   \
    \   }\n    }\n  }\n  return(strange)\n}\n", "\n    l <- list();\n    for(i in\
    \ 1:length(lst)) {\n        m <- min(lst[seq_len(i)]);\n        n <- max(lst[seq_len(i)]);\n\
    \        m <- min(m, n);\n        l <- c(l, list(m));\n        l <- c(l, list(n));\n\
    \    }\n    l\n}\n", "\n  if(length(lst) == 1) {\n    return(lst)\n  }\n  sorted_list\
    \ <- lst[[1]]\n  for(i in 2:length(lst)) {\n    if(lst[[i]] < sorted_list[-1])\
    \ {\n      sorted_list <- c(sorted_list, lst[[i]])\n    }\n  }\n  sorted_list\
    \ <- c(sorted_list, lst[length(lst)])\n  return(sorted_list)\n}\n", "\n  # Get\
    \ the minimum value from first element\n  min <- lst[[1]]\n  # Get the maximum\
    \ value from the remaining elements\n  max <- max(lst)\n  # Get the minimum value\
    \ from the remaining elements\n  min1 <- min(lst)\n  # Get the maximum value from\
    \ the remaining elements\n  max1 <- max(lst)\n  # Check if all the values are\
    \ same\n  if(identical(max, min)) return(c())\n  return(sort(c(min, max, min1,\
    \ max1)))\n}\n\nstrange_sort_list(c(1, 2, 3, 4))", "\n  rev(lst)\n}\n", "\n  new_list\
    \ <- vector(\"list\", length(lst))\n  \n  for (i in seq_along(lst)) {\n    minimum\
    \ <- min(lst[(i):length(lst)])\n    maximum <- max(lst[(i):length(lst)])\n   \
    \ \n    new_list[[i]] <- c(minimum, maximum, lst[(i):length(lst)])\n  }\n  \n\
    \  new_list\n}\n</code>\n<|/ a |>\n<| a tags=r dscore=0 |>\nYou can use the following\
    \ code to get a random permutation of a vector:\n<code>\nrandom_permutation <-\
    \ function(x) {\n  index <- sample(1:length(x), length(x), replace = FALSE)\n\
    \  x[index]\n}\n</code>\n<|/ a |>\n<| c |>\nThe question asks for random permutation\
    \ of an already ordered list. Your code simply gives a random permutation of the\
    \ same list.\n<|/ c |>\n<| c |>\nThank you, I updated my answer accordingly\n\
    <|/ c |>\n<| a dscore=0 tags=r |>\nI think this is what you are looking for, based\
    \ on your comments. \nI used a similar solution I gave in another thread (here:\
    \ How to sort a dataframe in R with one column in increasing order and another\
    \ in decreasing order?) to get the difference of x and y for the data set. \n\
    The function below sorts the data frame by decreasing difference of x and y. This\
    \ creates a new column with a decreasing difference of x and y. Then, I use dplyr::arrange\
    \ to sort the data frame by this new column (decreasing decreasing decreasing...).\n\
    <code>", "\n  # Sort lst\n  return(lst %>% \n        # sort by max first, then\
    \ min next, then max again\n        arrange(max, min) %>% \n        arrange(min,\
    \ max) %>% \n        arrange(min, max))\n}\n</code>\nThe %>% operator is from\
    \ the magrittr package.\n<|/ a tags=sorting,r dscore=2 |>\n<| a dscore=1 |>\n\
    Here's a base R solution:\n<code>", "\n  sorted_lst <- lst[order(rev(lst))]\n\
    \  return(sorted_lst)\n}\n", "\n  if (!is_list(lst)) return(NULL)\n  lst[order(lst)]\n\
    }\n", "\n  lst.sort <- lst\n  return(lst.sort)\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 tags=r,sorting |>\nA solution using data.table. \nThe idea is to\
    \ create a column of 0s and 1s based on whether the number is greater than or\
    \ less than the previous number. \nThen sort by that column\n<code>\nlibrary(data.table)\n\
    set.seed(1)\nx <- sample(1:100,10)\nx\n[1] 44 21 58 24 39 82 81 61 10 41\n\ndt\
    \ <- data.table(x = x)\ndt[, grp := c(0,rep(0,length(x)-1))[x < shift(x, fill\
    \ = 0)]]\ndt\n    x  grp\n 1: 44 0\n 2: 21 0\n 3: 58 0\n 4: 24 1\n 5: 39 1\n 6:\
    \ 82 0\n 7: 81 0\n 8: 61 0\n 9: 10 0\n10: 41 0\ndt[order(grp)]\n    x  grp\n 1:\
    \ 44 0\n 2: 21 0\n 3: 58 0\n 4: 24 1\n 5: 39 1\n 6: 82 0\n 7: 81 0\n 8: 61 0\n\
    \ 9: 10 0\n10: 41 0\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere's a base R approach\
    \ using rle:\n<code>\nfun <- function(x){\n  y <- rle(x)\n  y$values <- y$values\
    \ * c(1,-1)[order(y$lengths)]\n  inverse.rle(y)\n}\n\nfun(sort(c(1,4,2,3,5,6,10,11)))",
  "\n  if(length(lst) == 0) return(lst)\n  i <- 1\n  while(i <= length(lst)){\n  \
    \  i <- i + 1\n    while(i <= length(lst) && lst[i] > lst[i - 1])\n      i <-\
    \ i + 1\n    lst[i - 1] <<- lst[i]\n    lst[i] <<- lst[i - 1]\n  }\n  return(lst)\n\
    }\n", "\n  return(lst[order(-lst)])\n}\n</code>\n<|/ a |>\n<| c |>\nI didn't see\
    \ your answer before posting mine. I see your answer is basically the same mine\
    \ just using `data.table::setorderv`, which I did not know about. It seems pretty\
    \ useful to have such a function available.\n<|/ c |>\n<| c |>\nI did not see\
    \ your answer because I didn't feel like posting another answer on how to order\
    \ the list by an ascending order that started with the minimum value, then maximum\
    \ of the remaining integers, and then minimum and so on. Maybe I didn't explain\
    \ it well enough, but I thought my approach was a bit more concise.\n<|/ c |>\n\
    <| c |>\nMy answer is basically the same mine only using `data.table::setorderv`,\
    \ which I did not know about. It seems pretty useful to have such a function available.\n\
    <|/ c |>\n<| c |>\nI wasn't suggesting that you post your answer instead of mine.\
    \ I was thinking that it could be helpful to others by posting your answer and\
    \ explaining yours. I think it's quite clear what `setorderv` is doing without\
    \ having to go through the explanation I did.\n<|/ c |>\n<| c |>\nI have added\
    \ a sentence explaining `setorderv` a bit. Hope you don't mind.\n<|/ c |>\n<|\
    \ a |>\nHere's my attempt. I've used rle to find runs of identical integers in\
    \ the vector. Then, I simply use order on the run lengths based on the maximum\
    \ length of the runs.\n<code>\nstrange <- function(x) {\n  rx <- rle(x)\n  x[order(-lengths(rx[rx$lengths>1]))]\
    \ #negate because we want increasing lengths\n}\n\nstrange(c(1, 2, 3, 1, 2, 3,\
    \ 3))", "\n  stopifnot(is.vector(lst), is.integer(lst))\n  result <- NULL\n  len\
    \ <- length(lst)\n  for(i in 1:len) {\n    for(j in i:len) {\n      if(lst[j]\
    \ < lst[i]) result <- c(result, lst[j])\n      if(lst[j] > lst[i]) result <- c(result,\
    \ lst[i])\n    }\n  }\n  return(list(first=result[1], last=result[len]))\n}\n\
    </code>\n<code>\nstrange_sort_list(list(1, 2, 3, 4))\n</code>\n<code>\nstrange_sort_list(list(5,\
    \ 5, 5, 5))\n</code>\n<code>\nstrange_sort_list(list())\n</code>\n<|/ a |>\n<|\
    \ c |>\n`strange_sort_list(c(4,3,6,9,7))` returns `c(1,7,6,9,3)` while `strange_sort_list(c(4,3,6,9))`\
    \ returns `c(1,7,6,9)`\n<|/ c |>\n<| c |>\nSorry I didn't check it properly. I\
    \ made a change to fix it.\n<|/ c |>\n<| c |>\nThis one works great! The only\
    \ thing I don't quite understand is why it always sorts the first 4 elements into\
    \ ascending order and then proceeds to sort by comparing the first and last elements.\n\
    <|/ c |>\n<| c |>\nThe inner loop is trying to find where the 4th element should\
    \ go. Once it finds the 4th element, it compares every other element with it until\
    \ it's found. Once it's found, all of the elements are sorted in descending order.\
    \ The outer loop is looping through the remaining elements to find the starting\
    \ point.\n<|/ c |>\n<| a tags=sorting,r,vector,list dscore=0 |>\nYou can make\
    \ use of lapply and sapply to perform the sort on a vector or list. \n<code>\n\
    \ sort_list <- function(lst) {\n     stopifnot(is.vector(lst), is.integer(lst))\n\
    \n     out <- unlist(lapply(lst, function(x) sort(x)))\n\n     sapply(seq_along(out),\
    \ function(i) out[(i+1):length(out)])\n }\n\nsort_list(1:10)", "\n  if(is.null(lst))\
    \ return(lst)\n  nr <- nrow(lst)\n  for(i in 1:nr) {\n    for(j in 1:nr) {\n \
    \     if(i != j && lst[i] > lst[j]) {\n        lst[j] <- lst[i]\n        lst[i]\
    \ <- lst[j]\n      }\n    }\n  }\n  return(lst)\n}\n", "\n  lst <- sort(lst)\n\
    \  out <- rep(\"\", length(lst))\n  for(i in seq_along(lst)) {\n    out <- c(out,\
    \ rev(lst[c(i, length(lst)-i+1)]))\n  }\n  return(as.character(out))\n}\n", "\n\
    \  i <- 0\n  output <- list()\n  while(i < length(lst)) {\n    if(lst[i] > lst[i+1])\n\
    \      output[[length(output) + 1]] <- lst[i]\n    i <- i + 1\n  }\n  if(length(lst\
    \ > i))\n    output[length(output) + 1] <- lst[i]\n  return(output)\n}\n", "\n\
    \  lst <- sort(lst)\n  lst <- c(lst, rev(lst))\n  lst <- c(lst, rev(lst))\n  return(lst)\n\
    }\n", "\n  l <- lengths(lst)\n  m <- min(l)\n  r <- sort(rep(seq_len(m), l))\n\
    \  v <- lst[r]\n  lapply(seq_len(m), function(x) c(v[c(x, length(v)[-x])], v[length(v)[-x]]))\n\
    }\n</code>\n<|/ a tags=functional-programming,r dscore=2 |>\n<| c |>\n`c(1, 4,\
    \ 2, 3)` should be `c(1, 4, 2, 3)`\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out! I fixed the code\n<|/ c |>\n<| c |>\nNice approach, thanks!\n<|/ c |>\n\
    <| c |>\nNice! I didn't think to do that with `seq_len(n)`.\n<|/ c |>\n<| a tags=functional-programming,r\
    \ dscore=2 |>\nWe can use outer and setNames to assign names to each element.\
    \  Then we can paste together each element of each list with \n<code>\nc(outer(seq_along(l1),\
    \ seq_along(l1), `+`), \n  outer(seq_along(l1), seq_along(l1), `-`))\n</code>\n\
    If we need it in order, we may need to change the output\n<code>\nsetNames(c(outer(seq_along(l1),\
    \ seq_along(l1), `+`), \n         outer(seq_along(l1), seq_along(l1), `-`)), \n\
    \         names(l1))\n</code>\ndata\n<code>\nl1 <- list(a= c('a', 'b'), \n   \
    \        b = c('c', 'd'), \n           c = c('e', 'f'), \n           d = c('g',\
    \ 'h'), \n           e = c('i', 'j'), \n           f = c('k', 'l'), \n       \
    \    g = c('m', 'n'), \n           h = c('o', 'p'), \n           i = c('q', 'r'),\
    \ \n           j = c('s', 't'), \n           k = c('u', 'v'), \n           l =\
    \ c('w', 'x'), \n           m = c('y', 'z'))\n</code>\n<|/ a |>\n<| a tags=functional-programming,r\
    \ |>\nHere's an approach that uses purrr::reduce2 to create a matrix of indices,\
    \ then replaces them with the elements of the original list:\n<code>\nlibrary(purrr)\n\
    \nmap2(rep(c(TRUE, FALSE), lengths(lst)), \n     seq(lengths(lst)), ~.x) %>% \n\
    \  reduce2(c(seq_along(lst), seq_along(lst)), ~ .x[1] + .", "\n  new_list <- list();\n\
    \  for(i in seq_along(lst)) {\n    if(i != 0) {\n      min_value <- lst[i];\n\
    \      for(j in seq_along(lst)) {\n        if(j != i) \n          if(lst[j] <\
    \ min_value) {\n            min_value <- lst[j];\n          }\n      }\n     \
    \ new_list[[i]] <- min_value;\n    } else {\n      new_list[[i]] <- lst[i];\n\
    \    }\n  }\n  return(new_list);\n}\n", "\n  if (length(lst) <= 1) {\n    return(lst)\n\
    \  }\n  min_val <- min(lst)\n  max_val <- max(lst)\n  sorted_list <- list()\n\
    \  sorted_list[[1]] <- lst[[1]]\n  sorted_list[[2]] <- lst[[2]]\n  for(i in 3:length(lst))\
    \ {\n    if (lst[i] < min_val) {\n      sorted_list[[i]] <- lst[[i+1]]\n    }\
    \ else {\n      sorted_list[[i]] <- lst[[i]]\n    }\n  }\n  return(sorted_list)\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI didn't want to write this as a comment, since\
    \ I'm not allowed to comment, yet. But I was looking for a way to do this and\
    \ came across a solution which is not in the comments of the original post. Here,\
    \ I put my solution as an answer, but please feel free to delete it if you can.\n\
    <code>\nstrange_sort_list <- function(lst){\n  if(nchar(lst) <=1) return(lst)\n\
    \  sortedlist <- list()\n  sortedlist[[1]] <- lst[1]\n  sortedlist[[2]] <- lst[2]\n\
    \  for(i in seq(3, length(lst))){\n    if(lst[i] < sortedlist[[1]]){\n      sortedlist[[i]]\
    \ <- lst[[i+1]]\n    } else {\n      sortedlist[[i]] <- lst[[i]]\n    }\n  }\n\
    \  return(sortedlist)\n}\n</code>\n<|/ a tags=list,r,sorting dscore=2 |>\n<| a\
    \ dscore=1 |>\n<code>\nstrange_sort_list <- function(lst){\n  if(nchar(lst) <=1)\
    \ return(lst)\n  sortedlist <- list()\n  sortedlist[[1]] <- lst[1]\n  sortedlist[[2]]\
    \ <- lst[2]\n  for(i in seq(3, length(lst))){\n    if(lst[i] < sortedlist[[1]]){\n\
    \      sortedlist[[i]] <- lst[[i+1]]\n    } else {\n      sortedlist[[i]] <- lst[[i]]\n\
    \    }\n  }\n  return(sortedlist)\n}\n</code>\n<|/ a tags=list,r,sorting |>\n\
    <| a tags=list,r,sorting |>\nI think this might be what you're looking for:\n\
    <code>\n> strange_sort_list(c(1, 2, 3, 4))\n[1] 1 4 2 3\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nYes, but what about `strange_sort_list(c())` ?\n<|/ c |>\n<| c\
    \ |>\nstrange_sort_list(c()) returns character(0) as a ", "\n  lst <- unlist(lst)\n\
    \  lst <- rev(lst)\n  lst\n}\n</code>\n<|/ a dscore=1 tags=r |>\n<| a tags=r |>\n\
    Another approach:\n<code>\nset.seed(1)\nnum <- 10\nl <- sort(sample(num, num,\
    \ replace = TRUE))\nstr(l)", "\n  if(lst == NULL || is.null(lst)) {\n    return(NULL)\n\
    \  }\n  lst1 <- lst\n  if(is.list(lst)) {\n    lst1 <- lst[[1]]\n  }\n  for(i\
    \ in seq_along(lst1)) {\n    lst1[[i]] <- lst1[[i]][order(as.numeric(lst1[[i]]))]\n\
    \  }\n  return(c(lst1))\n}\n", "\n  if (is.null(lst)) {\n    return(c())\n  }\n\
    \  result <- c(rep(lst[1], length(lst)-1))\n  result <- c(result, lst[length(lst)])\n\
    \  result <- c(result, lst[-length(lst)])\n  return(result)\n}\n", "\n  if (!is.list(lst))\
    \ stop(\"strange_sort_list() requires a list argument\")\n  nl <- length(lst)\n\
    \  if (nl == 0) return(lst)\n  x <- sort(lst)\n  nx <- length(x)\n  y <- rep(0,\
    \ nx)\n  for (i in seq_len(nx)) {\n    xi <- x[i]\n    y <- c(y, rep(NA, nl -\
    \ length(x)))\n    y[i] <- xi\n  }\n  y[!is.na(y)] <- x\n  return(y)\n}\n</code>\n\
    <|/ a tags=r,function,sorting,list dscore=1 |>\n<| c |>\nI like this approach,\
    \ but I was hoping to avoid creating an explicit function just for the sorting.\n\
    <|/ c |>\n<| c |>\nThanks. I had hoped that there was a simple way (like a function\
    \ or package) that would allow me to sort the list without needing to sort the\
    \ function output.\n<|/ c |>\n<| c |>\nThis is not only simpler, but easier to\
    \ understand and reason about.  It also runs in constant time on inputs that aren't\
    \ sorted.\n<|/ c |>\n<| c |>\nThis is great and I wish I could give +2.  However,\
    \ I hate code that's using an if() statement to break out of a loop.  It's too\
    \ easy to make a typo and you end up with your function running forever.  I suppose\
    \ this may be one of those times where using if() statements is fine (for readability),\
    \ but a for loop is better (for performance).  And if performance is a concern,\
    \ I find that a for loop is still easier to maintain than a while() loop.\n<|/\
    \ c |>\n<| c |>\n: I agree that `if` is generally not good practice. I am more\
    \ worried about code using it when it is actually a conditional statement. Perhaps\
    \ my example was too trivial to notice such a difference.\n<|/ c |>\n<| a tags=r,function,sorting,list\
    \ |>\nThis could be achieved with function reorder():\n<code>\nmylist <- list(1,\
    \ 7, 5, 3, 9, 10, 5, 6, 1)\nmylist2 <- reorder(mylist, 1:length(mylist))\nmylist2",
  "\n  sorted_list <- sort(lst)\n  return(paste0(sorted_list, collapse = \", \"))\
    \ }\n", "\n  ret <- NULL\n  for (i in 1:length(lst)) {\n    ret <- c(ret, c(lst[i],\
    \ lst[length(lst) - i]))\n  }\n  return(ret)\n}\n", "\n  # Sort ascending.\n \
    \ lst <- lst[order(lst)]\n\n  # Sort from minimum to maximum.\n  # Example: c(5,\
    \ 4, 5, 5) --> c(5, 5, 5, 5) --> c(5, 5, 5, 5)\n  # lst <- lst[order(-lst)]\n\
    \  lst <- lst[order(-lst)]\n\n  # Sort from maximum to minimum.\n  # Example:\
    \ c(5, 5, 5, 5) --> c(5, 5, 4, 5) --> c(5, 4, 5, 5)\n  # lst <- lst[order(lst)]\n\
    \  lst <- lst[order(lst)]\n\n  # Sort from minimum to maximum.\n  # Example: c(5,\
    \ 4, 5, 5) --> c(5, 5, 5, 5) --> c(5, 5, 5, 5)\n  # lst <- lst[order(-lst)]\n\
    \  lst <- lst[order(-lst)]\n\n  # Sort from maximum to minimum.\n  # Example:\
    \ c(5, 5, 5, 5) --> c(5, 5, 4, 5) --> c(5, 4, 5, 5)\n  # lst <- lst[order(lst)]\n\
    \  lst <- lst[order(lst)]\n\n  # Sort from minimum to maximum.\n  # Example: c(5,\
    \ 4, 5, 5) --> c(5, 5, 5, 5) --> c(5, 5, 5, 5)\n  # lst <- lst[order(-lst)]\n\
    \  lst <- lst[order(-lst)]\n\n  # Sort from maximum to minimum.\n  # Example:\
    \ c(5, 5, 5, 5) --> c(5, 5, 4, 5) --> c(5, 4, 5, 5)\n  # lst <- lst[order(lst)]\n\
    \  lst <- lst[order(lst)]\n  return(lst)\n}\n", "\n  # Make copies\n  list1 <-\
    \ lst\n  list2 <- lst\n\n  # Find the maximum\n  maximum <- max(list1)\n\n  #\
    \ Find the minimum\n  minimum <- min(list1)\n\n  # Find the index\n  index <-\
    \ list1 == maximum\n\n  # Swap\n  list2[which(index)] <- minimum\n  list2[which(list1\
    \ != minimum)] <- maximum\n\n  # Return\n  list2\n}\n\nstrange_sort_list(c(1,\
    \ 2, 4, 3, 5))\n</cell>\n<text>\nSort by number of vowels\nWrite a function vowel_count\
    \ that returns the number of vowels in a given string.\n\n\n</text>\n<cell>",
  "\n  # If list is empty, return an empty string\n  if(length(lst) == 0) {\n    \"\
    \"\n  } else {\n    # Split the list into two parts:\n    # 1. the minimum integers\n\
    \    # 2. the maximum integers\n    splitted_list <- split(lst, seq(1, length(lst),\
    \ by=1))\n    minimums <- unlist(splitted_list)[1]\n    maximums <- unlist(splitted_list)[length(unlist(splitted_list))]\n\
    \    # Return the result with minimum integers first\n    strange_sort <- rep(minimums,\
    \ length(maximums))\n    strange_sort[maximums+1] <- maximums\n    strange_sort\n\
    \  }\n}\n\nstrange_sort_list(c(1, 2, 3, 4, 5))", "\n  length(lst) %/% 2 <- length(lst)\n\
    \  lst <- lst[order(rev(seq(length(lst), 2, -1)))]\n  if(length(lst) %% 2 == 0)\
    \ return(lst)\n  return(list(lst[-1], lst[-length(lst)]))\n}\n", "\n  # If list\
    \ empty return empty string\n  if (length(lst) == 0) return(\"\")\n\n  # If list\
    \ has only one value, return it\n  if (length(lst) == 1) return(lst[1])\n\n  #\
    \ Find minimum, maximum and other values\n  max_val <- max(lst)\n  min_val <-\
    \ min(lst)\n  other_vals <- lst[!lst %in% c(min_val, max_val)]\n  other_vals <-\
    \ sort(other_vals)\n  other_vals <- c(1, other_vals)\n\n  # Return new list\n\
    \  return(c(max_val, min_val, other_vals))\n}\n", "\n  l <- length(lst)\n  if(l<2)\
    \ return(lst)\n  c(lst[seq(1,l)], \n    lst[seq(l,2*l)],\n    lst[seq(2*l,3*l)],\n\
    \    lst[seq(3*l,4*l)],\n    lst[seq(4*l,5*l)],\n    lst[seq(5*l,6*l)],\n    lst[seq(6*l,7*l)],\n\
    \    lst[seq(7*l,8*l)],\n    lst[seq(8*l,9*l)],\n    lst[seq(9*l,l)]\n  )\n}\n",
  "\n  x <- lst[1]\n  for(i in 2:length(lst)) {\n    y <- lst[i]\n    x <- c(x, y,\
    \ x)\n  }\n  return(x)\n}\n", "\n  if(is.null(lst)) return(NULL)\n  min_list <-\
    \ min(lst)\n  max_list <- max(lst)\n  min_list <- lst[which(lst==min_list)]\n\
    \  max_list <- lst[which(lst==max_list)]\n  c(min_list, sort(max_list, decreasing=TRUE))\n\
    }\n", "\n  lst <- lst[order(decreasing = TRUE)]\n  if (length(lst) == 1) {\n \
    \   lst\n  } else {\n    res <- strange_sort_list(lst[seq_along(lst)])\n    res\
    \ <- c(res, lst)\n    res <- res[order(order(res))]\n    res\n  }\n}\n", "\n \
    \ lst1 <- c()\n  for(i in seq_along(lst)) {\n    if(length(lst) > 0) {\n     \
    \ if(lst[[i]] %in% c(min(lst), max(lst))) {\n        lst <- lst[-i]\n      }\n\
    \      else {\n        lst <- c(lst[[i]], lst)\n      }\n    }\n    else {\n \
    \     lst <- lst[[i]]\n    }\n    lst1 <- c(lst1, lst[[i]])\n  }\n  lst1\n}\n\
    strange_sort_list(list(1, 2, 3))\nstrange_sort_list(list())\nstrange_sort_list(c(1,\
    \ 2, 3, 4))\nstrange_sort_list(c())\nstrange_sort_list(c(5, 5, 5, 5))\nstrange_sort_list(c(NA,\
    \ NA))\n", "\n  # Get min and max from list.\n  min_value <- min(lst)\n  max_value\
    \ <- max(lst)\n  if(length(lst > 0)) {\n    stopifnot(min_value == max_value)\n\
    \  }\n  res <- list()\n  # Sort list by minimum value first.\n  res[[1]] <- min_value\n\
    \  # Move all the other integers one space to the right.\n  for(i in seq_along(lst)[-1])\
    \ {\n    res[[i+1]] <- lst[i]\n  }\n  return(paste(res, collapse = \",\"))\n}\n",
  "\n  sort(unique(lst))\n}\n", "\n  if (is.null(lst))\n    return('')\n  \n  lst.min\
    \ <- min(lst)\n  lst.max <- max(lst)\n  lst.len <- length(lst)\n  \n  return(strange_sort_list(rev(lst))\
    \ + \n          sprintf(\n            'c(%s, %s, %s, %s)',\n            lst.min,\n\
    \            lst[lst.len],\n            lst.max,\n            lst[lst.len - 1])\n\
    \  )\n}\n", "\n  lst_a <- sort(unlist(lst))\n  lst_b <- sort(unlist(lst))\n  lst_c\
    \ <- sort(unlist(lst))\n  lst_a <- paste0(lst_a, lst_b)\n  lst_a <- paste0(lst_a,\
    \ lst_c)\n  return(lst_a)\n}\n", "\n  return(lst <- sort(lst))\n}\n\n", "\n  res\
    \ <- NULL\n  n <- length(lst)\n  while (n) {\n    # first we find minimum\n  \
    \  min <- lst[[1]]\n    i <- 1\n    while (i<=n && lst[[i]] < min) {\n      min\
    \ <- lst[[i]]\n      i <- i + 1\n    }\n    # now we find maximum\n    max <-\
    \ lst[[i-1]]\n    j <- i\n    while (j<=n && lst[j] > max) {\n      max <- lst[j]\n\
    \      j <- j + 1\n    }\n    # and finally we swap min and max\n    lst[[i]]\
    \ <- max\n    lst[[i-1]] <- min\n    n <- n-1\n  }\n  return(lst)\n}\n</code>\n\
    <|/ a |>\n<| a |>\nAn Rcpp version of's answer (which is probably the fastest\
    \ solution possible)\n<code>", "\n  if(is.null(lst) || is.na(lst)) {\n    return(lst)\n\
    \  }\n  n <- length(lst)\n  if(n > 1) {\n    if(length(lst == 1) || (lst == lst[1]))\
    \ {\n      return(lst)\n    }\n    idx <- c(1, n + 1)\n    sorted_idx <- idx[order(idx)]\n\
    \    return(lst[sorted_idx])\n  } else {\n    return(lst)\n  }\n}\n", "\n  temp\
    \ <- NULL\n  for(i in 1:length(lst)) {\n    temp <- c(temp, lst[[i]])\n  }\n \
    \ return(temp)\n}\n</code>\nNow to solve the problem:\n<code>\nstrange_sort_list(c(3,2,1,0))",
  "\n  x <- lst[1]\n  x2 <- lst[2]\n  x3 <- lst[3]\n  x4 <- lst[4]\n  x5 <- lst[5]\n\
    \  x6 <- lst[6]\n  x7 <- lst[7]\n  x8 <- lst[8]\n  x9 <- lst[9]\n  x10 <- lst[10]\n\
    \  x11 <- lst[11]\n  x12 <- lst[12]\n  x13 <- lst[13]\n  x14 <- lst[14]\n  x15\
    \ <- lst[15]\n  x16 <- lst[16]\n  x17 <- lst[17]\n  x18 <- lst[18]\n  x19 <- lst[19]\n\
    \  x20 <- lst[20]\n  x21 <- lst[21]\n  x22 <- lst[22]\n  x23 <- lst[23]\n  x24\
    \ <- lst[24]\n  x25 <- lst[25]\n  x26 <- lst[26]\n  x27 <- lst[27]\n  x28 <- lst[28]\n\
    \  x29 <- lst[29]\n  x30 <- lst[30]\n  x31 <- lst[31]\n  x32 <- lst[32]\n  x33\
    \ <- lst[33]\n  x34 <- lst[34]\n  x35 <- lst[35]\n  x36 <- lst[36]\n  x37 <- lst[37]\n\
    \  x38 <- lst[38]\n  x39 <- lst[39]\n  x40 <- lst[40]\n  x41 <- lst[41]\n  x42\
    \ <- lst[42]\n  x43 <- lst[43]\n  x44 <- lst[44]\n  x45 <- lst[45]\n  x46 <- lst[46]\n\
    \  x47 <- lst[47]\n  x48 <- lst[48]\n  x49 <- lst[49]\n  x50 <- lst[50]\n  x51\
    \ <- lst[51]\n  x52 <- lst[52]\n  x53 <- lst[53]\n  x54 <- lst[54]\n  x55 <- lst[55]\n\
    \  x56 <", "\n  sapply(\n    seq_along(lst), function(x) {\n      lst[[x]] <-\
    \ decreasing(lst[[x]])\n      lst[[x]][seq_along(lst[[x]])] <- lst[[x]]\n    \
    \  unlist(lst[[x]])\n    }\n  )\n}\n</code>\nAnd here is a recursive version that\
    \ returns a list rather than a string:\n<code>\nstrange_sort_list <- function(lst)\
    \ {\n  sapply(\n    seq_along(lst), function(x) {\n      if(x == 1) return(lst[[x]])\n\
    \      lst[[x]] <- decreasing(lst[[x]])\n      return(strange_sort_list(lst[[x]]))\n\
    \    }\n  )\n}\n</code>\n<|/ a dscore=2 tags=r |>\n<| c |>\nThe `unlist` call\
    \ at the end is unnecessary, so I removed it. And I didn't really need the `return(...)`,\
    \ but it is useful in general. I would just use that `sapply` line instead of\
    \ my `for` loop, but I thought I'd keep it similar.\n<|/ c |>\n<| c |>\nOh that's\
    \ great! That `return(...)` does something I didn't know it did, thank you so\
    \ much!\n<|/ c |>\n<| a |>\nThis can be done in several different ways but here\
    \ are some for comparison. \n<code>", "\n    result <- lst[[1]]\n    for(i in\
    \ 2:length(lst)) {\n        if(lst[[i]] < result[1]) {\n            result <-\
    \ c(lst[[i]], result)\n        } else {\n            result <- c(result, lst[[i]])\n\
    \        }\n    }\n    return(result)\n}\n", "\n  if(!is.list(lst)) return(lst)\n\
    \  if(length(lst == 0)) return(lst)\n  if(is.list(lst[[1]])) {\n    lst[[1]] <-\
    \ strange_sort_list(lst[[1]])\n  }\n  sapply(lst,function(x) sort(x))\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThat's interesting. Can you elaborate on how your\
    \ function is different from what `sort` does internally? If you're able to show\
    \ that it would be great.\n<|/ c |>\n<| c |>\nThe main difference between my and\
    \ your function are the `sapply`s. In your function, you sort the whole vector\
    \ at once, while sort sorts the individual elements of the vector. For example,\
    \ `sort(c(5, 5))` would give you `[1] 5 5 5` while `strange_sort_list(5)` gives\
    \ `[1] 5`. Also, you don't need to have `return` statements in your functions.\
    \ In your function, if the `strange_sort_list` function doesn't get called, the\
    \ function just returns. In the `sort` function, you still need to have `return`\
    \ statements in the `sort` function.\n<|/ c |>\n<| c |>\nI don't think you're\
    \ quite understanding the point of `sapply`. What it does is apply a function\
    \ to all the elements of a list. In the case of my function, `strange_sort_list(5)`\
    \ gives you `[1] 5`. `sapply` loops over each element of the list `lst` and applies\
    \ the function `strange_sort_list` to it, which would give `[1]  5  5 5`. All\
    \ this does is give us `[1] 5 5 5 5`\n<|/ c |>\n<| c |>\nI think we're in agreement\
    \ here. The point of `sapply` is to apply a function to each element of a list.\
    \ Your solution doesn't do this. Your solution also doesn't work for `strange_sort_list(c(5,5,5,5))`\
    \ because `sapply` loops over the elements of the list and `sort(c(5,5,5,5))`\
    \ gives us `[1] 5 5 5 5`.\n<|/ c |>\n<| c |>\nThe issue is that `sapply` is really\
    \ just a `for` loop in disguise. In my solution, `strange_sort_list(5)` gets transformed\
    \ to `strange_sort_list(5)`, which is `[1]  5  5 5`. This means that `sapply`\
    \ would need to loop over each element of the list `lst` and apply `strange_sort_list`\
    \ to it, which would give us a `[1] 5 5 5 5`. Since ", "\n  lst_len <- length(lst)\n\
    \  if(lst_len == 0){\n    return(list(NA))\n  }\n\n  sorted_list <- c(lst)\n \
    \ \n  for(i in seq_along(lst)){\n    temp <- sorted_list[i - 1]\n    for(i in\
    \ seq_along(sorted_list)){\n      if(sorted_list[i] > temp){\n        sorted_list[i\
    \ - 1] <- sorted_list[i]\n        sorted_list[i] <- temp\n      }\n    }\n  }\n\
    \  sorted_list\n}\n", "\n  len <- length(lst)\n  result <- c()\n  temp <- lst[1]\n\
    \  for (i in 2:len) {\n    if(lst[i - 1] > lst[i]) {\n      temp <- lst[i]\n \
    \   } else {\n      temp <- lst[i - 1]\n    }\n    result <- c(result, temp)\n\
    \  }\n  result\n}\n", "\n  x <- min(lst)\n  y <- max(lst)\n  z <- min(c(lst[x],\
    \ lst[y]))\n  strange <- c(lst[x], lst[y], z, lst[z])\n  return(strange)\n}\n\
    </code>\n<|/ a tags=list,r,sorting dscore=1 |>\n<| a tags=list,r,sorting dscore=1\
    \ |>\nA solution using Reduce:\n<code>\nsort.list = function(L){\n    Reduce('c',\
    \ lapply(L, `[`, 3:1))\n}\n</code>\n<|/ a |>\n<| c |>\n`Reduce` is definitely\
    \ the right way to go, but you might want to explain how it works...\n<|/ c |>\n\
    <| c |>\n`Reduce` calls `FUN` on each element of the list `L`, passing each element\
    \ of `L` as an argument to `FUN`. `FUN` returns an object of type `character(0)`\
    \ in this case, as each element of the list `L` is not a vector (but a list, in\
    \ R terminology) and is not passed to `Reduce`. In short, `Reduce('c', c(L[[1]],\
    \ L[[2]], L[[3]], L[[4]]))`. `Reduce` applies `c` to each element of the list\
    \ `L`.\n<|/ c |>\n<| a |>\nUsing lapply and sort:\n<code>\nsort.list = function(x)\
    \ {\n  lapply(x, sort)\n}\n</code>\n<|/ a tags=list,r,sorting dscore=0 |>\n<|\
    \ c |>\nI guess you misread the question: OP is looking for sorting with three\
    \ conditions: (1) minimum first, then maximum (2) maximum first, then minimum\
    \ (3) minimum last.\n<|/ c |>\n<| c |>\nYour answer doesn't match what the OP\
    \ is looking for: `sort` does not take into account the OP asking for the opposite\
    \ of `sort`.\n<|/ c |>\n<| c |>\nThe OP asks for the opposite of `sort`. `sort`\
    \ sorts the list in increasing order, while he wants decreasing order.\n<|/ c\
    \ |>\n<| c |>\nI do believe that he is referring to the `decreasing = TRUE` argument,\
    \ which is not available in `sort`\n<|/ c |>\n<| c |>\nWell, OP edited the question,\
    \ I think he meant `decreasing = FALSE`.\n<|/ c |>\n<| a tags=list,r,sorting |>\n\
    I wanted to sort a list with more than one condition and then use an ifelse statement\
    \ to condition"]
stop_tokens:
- "\n#"
- "\n```"
